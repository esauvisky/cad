{"custom_id": "task-0", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: affine.scad\n//   Matrix math and affine transformation matrices.\n// Includes:\n//   include <BOSL2/std.scad>\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Affine2d 3x3 Transformation Matrices\n\n\n// Function: affine2d_identity()\n// Synopsis: Returns a 2D (3x3) identity transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms\n// See Also: affine3d_identity(), ident(), IDENT\n// Usage:\n//   mat = affine2d_identify();\n// Description:\n//   Create a 3x3 affine2d identity matrix.\n// Example:\n//   mat = affine2d_identity();\n//   // Returns:\n//   //   [\n//   //     [1, 0, 0],\n//   //     [0, 1, 0],\n//   //     [0, 0, 1]\n//   //   ]\nfunction affine2d_identity() = ident(3);\n\n\n// Function: affine2d_translate()\n// Synopsis: Returns a 2D (3x3) translation transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Translation\n// See Also: affine3d_translate(), move(), translate(), left(), right(), fwd(), back(), down(), up()\n// Usage:\n//   mat = affine2d_translate(v);\n// Description:\n//   Returns the 3x3 affine2d matrix to perform a 2D translation.\n// Arguments:\n//   v = 2D Offset to translate by.  [X,Y]\n// Example:\n//   mat = affine2d_translate([30,40]);\n//   // Returns:\n//   //   [\n//   //     [1, 0, 30],\n//   //     [0, 1, 40],\n//   //     [0, 0,  1]\n//   //   ]\nfunction affine2d_translate(v=[0,0]) =\n    assert(is_vector(v),2)\n    [\n        [1, 0, v.x],\n        [0, 1, v.y],\n        [0 ,0,   1]\n    ];\n\n\n// Function: affine2d_scale()\n// Synopsis: Returns a 2D (3x3) scaling transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Scaling\n// See Also: affine3d_scale(), scale(), xscale(), yscale(), zscale(), affine3d_scale()\n// Usage:\n//   mat = affine2d_scale(v);\n// Description:\n//   Returns the 3x3 affine2d matrix to perform a 2D scaling transformation.\n// Arguments:\n//   v = 2D vector of scaling factors.  [X,Y]\n// Example:\n//   mat = affine2d_scale([3,4]);\n//   // Returns:\n//   //   [\n//   //     [3, 0, 0],\n//   //     [0, 4, 0],\n//   //     [0, 0, 1]\n//   //   ]\nfunction affine2d_scale(v=[1,1]) =\n    assert(is_vector(v,2))\n    [\n        [v.x,   0, 0],\n        [  0, v.y, 0],\n        [  0,   0, 1]\n    ];\n\n\n// Function: affine2d_zrot()\n// Synopsis: Returns a 2D (3x3) rotation transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Rotation\n// See Also: rot(), xrot(), yrot(), zrot(), affine3d_zrot()\n// Usage:\n//   mat = affine2d_zrot(ang);\n// Description:\n//   Returns the 3x3 affine2d matrix to perform a rotation of a 2D vector around the Z axis.\n// Arguments:\n//   ang = Number of degrees to rotate.\n// Example:\n//   mat = affine2d_zrot(90);\n//   // Returns:\n//   //   [\n//   //     [0,-1, 0],\n//   //     [1, 0, 0],\n//   //     [0, 0, 1]\n//   //   ]\nfunction affine2d_zrot(ang=0) =\n    assert(is_finite(ang))\n    [\n        [cos(ang), -sin(ang), 0],\n        [sin(ang),  cos(ang), 0],\n        [       0,         0, 1]\n    ];\n\n\n// Function: affine2d_mirror()\n// Synopsis: Returns a 2D (3x3) reflection transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Reflection, Mirroring\n// See Also: mirror(), xflip(), yflip(), zflip(), affine3d_mirror()\n// Usage:\n//   mat = affine2d_mirror(v);\n// Description:\n//   Returns the 3x3 affine2d matrix to perform a reflection of a 2D vector across the line given by its normal vector.\n// Arguments:\n//   v = The normal vector of the line to reflect across.\n// Example:\n//   mat = affine2d_mirror([0,1]);\n//   // Returns:\n//   //   [\n//   //     [ 1, 0, 0],\n//   //     [ 0,-1, 0],\n//   //     [ 0, 0, 1]\n//   //   ]\n// Example:\n//   mat = affine2d_mirror([1,0]);\n//   // Returns:\n//   //   [\n//   //     [-1, 0, 0],\n//   //     [ 0, 1, 0],\n//   //     [ 0, 0, 1]\n//   //   ]\n// Example:\n//   mat = affine2d_mirror([1,1]);\n//   // Returns approximately:\n//   //   [\n//   //     [ 0,-1, 0],\n//   //     [-1, 0, 0],\n//   //     [ 0, 0, 1]\n//   //   ]\nfunction affine2d_mirror(v) =\n    assert(is_vector(v,2))\n    let(v=unit(point2d(v)), a=v.x, b=v.y)\n    [\n        [1-2*a*a, 0-2*a*b, 0],\n        [0-2*a*b, 1-2*b*b, 0],\n        [      0,       0, 1]\n    ];\n\n\n// Function: affine2d_skew()\n// Synopsis: Returns a 2D (3x3) skewing transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Skewing\n// See Also: skew(), affine3d_skew()\n// Usage:\n//   mat = affine2d_skew(xa);\n//   mat = affine2d_skew(ya=);\n//   mat = affine2d_skew(xa, ya);\n// Description:\n//   Returns the 3x3 affine2d matrix to skew a 2D vector along the XY plane.\n// Arguments:\n//   xa = Skew angle, in degrees, in the direction of the X axis. Default: 0\n//   ya = Skew angle, in degrees, in the direction of the Y axis. Default: 0\n// Example:\n//   mat = affine2d_skew(xa=45,ya=-45);\n//   // Returns approximately:\n//   //   [\n//   //     [ 1, 1, 0],\n//   //     [-1, 1, 0],\n//   //     [ 0, 0, 1]\n//   //   ]\nfunction affine2d_skew(xa=0, ya=0) =\n    assert(is_finite(xa))\n    assert(is_finite(ya))\n    [\n        [1,       tan(xa), 0],\n        [tan(ya), 1,       0],\n        [0,       0,       1]\n    ];\n\n\n\n// Section: Affine3d 4x4 Transformation Matrices\n\n\n// Function: affine3d_identity()\n// Synopsis: Returns a 3D (4x4) identity transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms\n// See Also: affine2d_identity(), ident(), IDENT\n// Usage:\n//   mat = affine3d_identity();\n// Description:\n//   Create a 4x4 affine3d identity matrix.\n// Example:\n//   mat = affine2d_identity();\n//   // Returns:\n//   //   [\n//   //     [1, 0, 0, 0],\n//   //     [0, 1, 0, 0],\n//   //     [0, 0, 1, 0],\n//   //     [0, 0, 0, 1]\n//   //   ]\nfunction affine3d_identity() = ident(4);\n\n\n// Function: affine3d_translate()\n// Synopsis: Returns a 3D (4x4) translation transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Translation\n// See Also: move(), translate(), left(), right(), fwd(), back(), down(), up(), affine2d_translate()\n// Usage:\n//   mat = affine3d_translate(v);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a 3D translation.\n// Arguments:\n//   v = 3D offset to translate by.  [X,Y,Z]\n// Example:\n//   mat = affine2d_translate([30,40,50]);\n//   // Returns:\n//   //   [\n//   //     [1, 0, 0, 30],\n//   //     [0, 1, 0, 40],\n//   //     [0, 0, 1, 50]\n//   //     [0, 0, 0,  1]\n//   //   ]\nfunction affine3d_translate(v=[0,0,0]) =\n    assert(is_list(v))\n    let( v = [for (i=[0:2]) default(v[i],0)] )\n    [\n        [1, 0, 0, v.x],\n        [0, 1, 0, v.y],\n        [0, 0, 1, v.z],\n        [0 ,0, 0,   1]\n    ];\n\n\n// Function: affine3d_scale()\n// Synopsis: Returns a 3D (4x4) scaling transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Scaling\n// See Also: scale(), affine2d_scale()\n// Usage:\n//   mat = affine3d_scale(v);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a 3D scaling transformation.\n// Arguments:\n//   v = 3D vector of scaling factors.  [X,Y,Z]\n// Example:\n//   mat = affine3d_scale([3,4,5]);\n//   // Returns:\n//   //   [\n//   //     [3, 0, 0, 0],\n//   //     [0, 4, 0, 0],\n//   //     [0, 0, 5, 0],\n//   //     [0, 0, 0, 1]\n//   //   ]\nfunction affine3d_scale(v=[1,1,1]) =\n    assert(is_list(v))\n    let( v = [for (i=[0:2]) default(v[i],1)] )\n    [\n        [v.x,   0,   0, 0],\n        [  0, v.y,   0, 0],\n        [  0,   0, v.z, 0],\n        [  0,   0,   0, 1]\n    ];\n\n\n// Function: affine3d_xrot()\n// Synopsis: Returns a 3D (4x4) X-axis rotation transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Rotation\n// See Also: rot(), xrot(), yrot(), zrot(), affine2d_zrot()\n// Usage:\n//   mat = affine3d_xrot(ang);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a rotation of a 3D vector around the X axis.\n// Arguments:\n//   ang = number of degrees to rotate.\n// Example:\n//   mat = affine3d_xrot(90);\n//   // Returns:\n//   //   [\n//   //     [1, 0, 0, 0],\n//   //     [0, 0,-1, 0],\n//   //     [0, 1, 0, 0],\n//   //     [0, 0, 0, 1]\n//   //   ]\nfunction affine3d_xrot(ang=0) =\n    assert(is_finite(ang))\n    [\n        [1,        0,         0,   0],\n        [0, cos(ang), -sin(ang),   0],\n        [0, sin(ang),  cos(ang),   0],\n        [0,        0,         0,   1]\n    ];\n\n\n// Function: affine3d_yrot()\n// Synopsis: Returns a 3D (4x4) Y-axis rotation transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Rotation\n// See Also: rot(), xrot(), yrot(), zrot(), affine2d_zrot()\n// Usage:\n//   mat = affine3d_yrot(ang);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a rotation of a 3D vector around the Y axis.\n// Arguments:\n//   ang = Number of degrees to rotate.\n// Example:\n//   mat = affine3d_yrot(90);\n//   // Returns:\n//   //   [\n//   //     [ 0, 0, 1, 0],\n//   //     [ 0, 1, 0, 0],\n//   //     [-1, 0, 0, 0],\n//   //     [ 0, 0, 0, 1]\n//   //   ]\nfunction affine3d_yrot(ang=0) =\n    assert(is_finite(ang))\n    [\n        [ cos(ang), 0, sin(ang),   0],\n        [        0, 1,        0,   0],\n        [-sin(ang), 0, cos(ang),   0],\n        [        0, 0,        0,   1]\n    ];\n\n\n// Function: affine3d_zrot()\n// Synopsis: Returns a 3D (4x4) Z-axis rotation transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Rotation\n// See Also: rot(), xrot(), yrot(), zrot(), affine2d_zrot()\n// Usage:\n//   mat = affine3d_zrot(ang);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a rotation of a 3D vector around the Z axis.\n// Arguments:\n//   ang = number of degrees to rotate.\n// Example:\n//   mat = affine3d_zrot(90);\n//   // Returns:\n//   //   [\n//   //     [ 0,-1, 0, 0],\n//   //     [ 1, 0, 0, 0],\n//   //     [ 0, 0, 1, 0],\n//   //     [ 0, 0, 0, 1]\n//   //   ]\nfunction affine3d_zrot(ang=0) =\n    assert(is_finite(ang))\n    [\n        [cos(ang), -sin(ang), 0, 0],\n        [sin(ang),  cos(ang), 0, 0],\n        [       0,         0, 1, 0],\n        [       0,         0, 0, 1]\n    ];\n\n\n// Function: affine3d_rot_by_axis()\n// Synopsis: Returns a 3D (4x4) arbitrary-axis rotation transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Rotation\n// See Also: rot(), xrot(), yrot(), zrot(), affine2d_zrot()\n// Usage:\n//   mat = affine3d_rot_by_axis(u, ang);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a rotation of a 3D vector around an axis.\n// Arguments:\n//   u = 3D axis vector to rotate around.\n//   ang = number of degrees to rotate.\n// Example:\n//   mat = affine3d_rot_by_axis([1,1,1], 120);\n//   // Returns approx:\n//   //   [\n//   //     [ 0, 0, 1, 0],\n//   //     [ 1, 0, 0, 0],\n//   //     [ 0, 1, 0, 0],\n//   //     [ 0, 0, 0, 1]\n//   //   ]\nfunction affine3d_rot_by_axis(u=UP, ang=0) =\n    assert(is_finite(ang))\n    assert(is_vector(u,3))\n    approx(ang,0)? affine3d_identity() :\n    let(\n        u = unit(u),\n        c = cos(ang),\n        c2 = 1-c,\n        s = sin(ang)\n    ) [\n        [u.x*u.x*c2+c    , u.x*u.y*c2-u.z*s, u.x*u.z*c2+u.y*s, 0],\n        [u.y*u.x*c2+u.z*s, u.y*u.y*c2+c    , u.y*u.z*c2-u.x*s, 0],\n        [u.z*u.x*c2-u.y*s, u.z*u.y*c2+u.x*s, u.z*u.z*c2+c    , 0],\n        [               0,                0,                0, 1]\n    ];\n\n\n// Function: affine3d_rot_from_to()\n// Synopsis: Returns a 3D (4x4) tilt rotation transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Rotation\n// See Also: rot(), xrot(), yrot(), zrot(), affine2d_zrot()\n// Usage:\n//   mat = affine3d_rot_from_to(from, to);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a rotation of a 3D vector from one vector direction to another.\n// Arguments:\n//   from = 3D axis vector to rotate from.\n//   to = 3D axis vector to rotate to.\n// Example:\n//   mat = affine3d_rot_from_to(UP, RIGHT);\n//   // Returns:\n//   //   [\n//   //     [ 0, 0, 1, 0],\n//   //     [ 0, 1, 0, 0],\n//   //     [-1, 0, 0, 0],\n//   //     [ 0, 0, 0, 1]\n//   //   ]\nfunction affine3d_rot_from_to(from, to) =\n    assert(is_vector(from))\n    assert(is_vector(to))\n    assert(len(from)==len(to))\n    let(\n        from = unit(point3d(from)),\n        to = unit(point3d(to))\n    ) approx(from,to)? affine3d_identity() :\n    from.z==0 && to.z==0 ?  affine3d_zrot(v_theta(point2d(to)) - v_theta(point2d(from)))\n    :\n    let(\n        u = vector_axis(from,to),\n        ang = vector_angle(from,to),\n        c = cos(ang),\n        c2 = 1-c,\n        s = sin(ang)\n    ) [\n        [u.x*u.x*c2+c    , u.x*u.y*c2-u.z*s, u.x*u.z*c2+u.y*s, 0],\n        [u.y*u.x*c2+u.z*s, u.y*u.y*c2+c    , u.y*u.z*c2-u.x*s, 0],\n        [u.z*u.x*c2-u.y*s, u.z*u.y*c2+u.x*s, u.z*u.z*c2+c    , 0],\n        [               0,                0,                0, 1]\n    ];\n\n\n// Function: affine3d_mirror()\n// Synopsis: Returns a 3D (4x4) reflection transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Reflection, Mirroring\n// See Also: mirror(), xflip(), yflip(), zflip(), affine2d_mirror()\n// Usage:\n//   mat = affine3d_mirror(v);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a reflection of a 3D vector across the plane given by its normal vector.\n// Arguments:\n//   v = The normal vector of the plane to reflect across.\n// Example:\n//   mat = affine3d_mirror([1,0,0]);\n//   // Returns:\n//   //   [\n//   //     [-1, 0, 0, 0],\n//   //     [ 0, 1, 0, 0],\n//   //     [ 0, 0, 1, 0],\n//   //     [ 0, 0, 0, 1]\n//   //   ]\n// Example:\n//   mat = affine3d_mirror([0,1,0]);\n//   // Returns:\n//   //   [\n//   //     [ 1, 0, 0, 0],\n//   //     [ 0,-1, 0, 0],\n//   //     [ 0, 0, 1, 0],\n//   //     [ 0, 0, 0, 1]\n//   //   ]\nfunction affine3d_mirror(v) =\n    assert(is_vector(v))\n    let(\n        v=unit(point3d(v)),\n        a=v.x, b=v.y, c=v.z\n    ) [\n        [1-2*a*a,  -2*a*b,  -2*a*c, 0],\n        [ -2*b*a, 1-2*b*b,  -2*b*c, 0],\n        [ -2*c*a,  -2*c*b, 1-2*c*c, 0],\n        [      0,       0,       0, 1]\n    ];\n\n\n// Function: affine3d_skew()\n// Synopsis: Returns a 3D (4x4) skewing transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Skewing\n// See Also: skew(), affine3d_skew_xy(), affine3d_skew_xz(), affine3d_skew_yz(), affine2d_skew()\n// Usage:\n//   mat = affine3d_skew([sxy=], [sxz=], [syx=], [syz=], [szx=], [szy=]);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a skew transformation.\n// Arguments:\n//   sxy = Skew factor multiplier for skewing along the X axis as you get farther from the Y axis.  Default: 0\n//   sxz = Skew factor multiplier for skewing along the X axis as you get farther from the Z axis.  Default: 0\n//   syx = Skew factor multiplier for skewing along the Y axis as you get farther from the X axis.  Default: 0\n//   syz = Skew factor multiplier for skewing along the Y axis as you get farther from the Z axis.  Default: 0\n//   szx = Skew factor multiplier for skewing along the Z axis as you get farther from the X axis.  Default: 0\n//   szy = Skew factor multiplier for skewing along the Z axis as you get farther from the Y axis.  Default: 0\n// Example:\n//   mat = affine3d_skew(sxy=2,szx=3);\n//   // Returns:\n//   //   [\n//   //     [ 1, 2, 0, 0],\n//   //     [ 0, 1, 0, 0],\n//   //     [ 0, 0, 1, 0],\n//   //     [ 3, 0, 0, 1]\n//   //   ]\nfunction affine3d_skew(sxy=0, sxz=0, syx=0, syz=0, szx=0, szy=0) = [\n    [  1, sxy, sxz, 0],\n    [syx,   1, syz, 0],\n    [szx, szy,   1, 0],\n    [  0,   0,   0, 1]\n];\n\n\n// Function: affine3d_skew_xy()\n// Synopsis: Returns a 3D (4x4) XY-plane skewing transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Skewing\n// See Also: skew(), affine3d_skew(), affine3d_skew_xz(), affine3d_skew_yz(), affine2d_skew()\n// Usage:\n//   mat = affine3d_skew_xy(xa);\n//   mat = affine3d_skew_xy(ya=);\n//   mat = affine3d_skew_xy(xa, ya);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a skew transformation along the XY plane.\n// Arguments:\n//   xa = Skew angle, in degrees, in the direction of the X axis.  Default: 0\n//   ya = Skew angle, in degrees, in the direction of the Y axis.  Default: 0\n// Example:\n//   mat = affine3d_skew_xy(xa=45,ya=-45);\n//   // Returns:\n//   //   [\n//   //     [ 1, 0, 1, 0],\n//   //     [ 0, 1,-1, 0],\n//   //     [ 0, 0, 1, 0],\n//   //     [ 0, 0, 0, 1]\n//   //   ]\nfunction affine3d_skew_xy(xa=0, ya=0) =\n    assert(is_finite(xa))\n    assert(is_finite(ya))\n    [\n        [      1, tan(xa), 0, 0],\n        [tan(ya),       1, 0, 0],\n        [      0,       0, 1, 0],\n        [      0,       0, 0, 1]\n    ];\n\n\n// Function: affine3d_skew_xz()\n// Synopsis: Returns a 3D (4x4) XZ-plane skewing transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Skewing\n// See Also: skew(), affine3d_skew(), affine3d_skew_xy(), affine3d_skew_yz(), affine2d_skew()\n// Usage:\n//   mat = affine3d_skew_xz(xa);\n//   mat = affine3d_skew_xz(za=);\n//   mat = affine3d_skew_xz(xa, za);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a skew transformation along the XZ plane.\n// Arguments:\n//   xa = Skew angle, in degrees, in the direction of the X axis.  Default: 0\n//   za = Skew angle, in degrees, in the direction of the Z axis.  Default: 0\n// Example:\n//   mat = affine3d_skew_xz(xa=45,za=-45);\n//   // Returns:\n//   //   [\n//   //     [ 1, 1, 0, 0],\n//   //     [ 0, 1, 0, 0],\n//   //     [ 0,-1, 1, 0],\n//   //     [ 0, 0, 0, 1]\n//   //   ]\nfunction affine3d_skew_xz(xa=0, za=0) =\n    assert(is_finite(xa))\n    assert(is_finite(za))\n    [\n        [      1, 0, tan(xa), 0],\n        [      0, 1,       0, 0],\n        [tan(za), 0,       1, 0],\n        [      0, 0,       0, 1]\n    ];\n\n\n// Function: affine3d_skew_yz()\n// Synopsis: Returns a 3D (4x4) YZ-plane skewing transformation matrix.\n// SynTags: Mat\n// Topics: Affine, Matrices, Transforms, Skewing\n// See Also: skew(), affine3d_skew(), affine3d_skew_xy(), affine3d_skew_xz(), affine2d_skew()\n// Usage:\n//   mat = affine3d_skew_yz(ya);\n//   mat = affine3d_skew_yz(za=);\n//   mat = affine3d_skew_yz(ya, za);\n// Description:\n//   Returns the 4x4 affine3d matrix to perform a skew transformation along the YZ plane.\n// Arguments:\n//   ya = Skew angle, in degrees, in the direction of the Y axis.  Default: 0\n//   za = Skew angle, in degrees, in the direction of the Z axis.  Default: 0\n// Example:\n//   mat = affine3d_skew_yz(ya=45,za=-45);\n//   // Returns:\n//   //   [\n//   //     [ 1, 0, 0, 0],\n//   //     [ 1, 1, 0, 0],\n//   //     [-1, 0, 1, 0],\n//   //     [ 0, 0, 0, 1]\n//   //   ]\nfunction affine3d_skew_yz(ya=0, za=0) =\n    assert(is_finite(ya))\n    assert(is_finite(za))\n    [\n        [1,       0,       0, 0],\n        [0,       1, tan(ya), 0],\n        [0, tan(za),       1, 0],\n        [0,       0,       0, 1]\n    ];\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-1", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: attachments.scad\n//   The modules in this file allows you to attach one object to another by making one object the child of another object.\n//   You can place the child object in relation to its parent object and control the position and orientation\n//   relative to the parent.  The modifiers allow you to treat children in ways different from simple union, such\n//   as differencing them from the parent, or changing their color.  Attachment only works when the parent and child\n//   are both written to support attachment.  Also included in this file  are the tools to make your own \"attachable\" objects.\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: Positioning objects on or relative to other objects.  Making your own objects support attachment.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Default values for attachment code.\n$tags=undef;      // for backward compatibility\n$tag = \"\";\n$tag_prefix = \"\";\n$overlap = 0;\n$color = \"default\";\n$save_color = undef;         // Saved color to revert back for children\n\n$anchor_override = undef;\n$attach_to = undef;\n$attach_anchor = [CENTER, CENTER, UP, 0];\n$attach_norot = false;\n\n$parent_anchor = BOTTOM;\n$parent_spin = 0;\n$parent_orient = UP;\n\n$parent_size = undef;\n$parent_geom = undef;\n\n$tags_shown = \"ALL\";\n$tags_hidden = [];\n\n_ANCHOR_TYPES = [\"intersect\",\"hull\"];\n\n\n// Section: Terminology and Shortcuts\n//   This library adds the concept of anchoring, spin and orientation to the `cube()`, `cylinder()`\n//   and `sphere()` builtins, as well as to most of the shapes provided by this library itself.\n//   - An anchor is a place on an object which you can align the object to, or attach other objects\n//     to using `attach()` or `position()`. An anchor has a position, a direction, and a spin.\n//     The direction and spin are used to orient other objects to match when using `attach()`.\n//   - Spin is a simple rotation around the Z axis.\n//   - Orientation is rotating an object so that its top is pointed towards a given vector.\n//   .\n//   An object will first be translated to its anchor position, then spun, then oriented.\n//   For a detailed step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n//   .\n//   For describing directions, faces, edges, and corners the library provides a set of shortcuts\n//   all based on combinations of unit direction vectors.  You can use these for anchoring and orienting\n//   attachable objects.  You can also them to specify edge sets for rounding or chamfering cuboids,\n//   or for placing edge, face and corner masks.\n// Subsection: Anchor\n//   Anchoring is specified with the `anchor` argument in most shape modules.  Specifying `anchor`\n//   when creating an object will translate the object so that the anchor point is at the origin\n//   (0,0,0).  Anchoring always occurs before spin and orientation are applied.\n//   .\n//   An anchor can be referred to in one of two ways; as a directional vector, or as a named anchor string.\n//   .\n//   When given as a vector, it points, in a general way, towards the face, edge, or corner of the\n//   object that you want the anchor for, relative to the center of the object.  You can simply\n//   specify a vector like `[0,0,1]` to anchor an object at the Z+ end, but you can also use\n//   directional constants with names like `TOP`, `BOTTOM`, `LEFT`, `RIGHT` and `BACK` that you can add together\n//   to specify anchor points.  See [specifying directions](attachments.scad#subsection-specifying-directions)\n//   below for the full list of pre-defined directional constants.\n//   .\n//   For example:\n//   - `[0,0,1]` is the same as `TOP` and refers to the center of the top face.\n//   - `[-1,0,1]` is the same as `TOP+LEFT`, and refers to the center of the top-left edge.\n//   - `[1,1,-1]` is the same as `BOTTOM+BACK+RIGHT`, and refers to the bottom-back-right corner.\n//   .\n//   When the object is cubical or rectangular in shape the anchors must have zero or one values\n//   for their components and they refer to the face centers, edge centers, or corners of the object.\n//   The direction of a face anchor will be perpendicular to the face, pointing outward.  The direction of a edge anchor\n//   will be the average of the anchor directions of the two faces the edge is between.  The direction\n//   of a corner anchor will be the average of the anchor directions of the three faces the corner is\n//   on.\n//   .\n//   When the object is cylindrical, conical, or spherical in nature, the anchors will be located\n//   around the surface of the cylinder, cone, or sphere, relative to the center.\n//   You can generally use an arbitrary vector to get an anchor positioned anywhere on the curved\n//   surface of such an object, and the anchor direction will be the surface normal at the anchor location.\n//   However, for anchor component pointing toward the flat face should be either -1, 1, or 0, and\n//   anchors that point diagonally toward one of the flat faces will select a point on the edge.\n//   .\n//   For objects in two dimensions, the natural expectation is for TOP and BOTTOM to refer to the Y direction\n//   of the shape.  To support this, if you give an anchor in 2D that has anchor.y=0 then the Z component\n//   will be mapped to the Y direction.  This  means you can use TOP and BOTTOM for anchors of 2D objects.\n//   But remember that TOP and BOTTOM are three dimensional vectors and this is a special interpretation\n//   for 2d anchoring.\n//   .\n//   Some more complex objects, like screws and stepper motors, have named anchors to refer to places\n//   on the object that are not at one of the standard faces, edges or corners.  For example, stepper\n//   motors have anchors for `\"screw1\"`, `\"screw2\"`, etc. to refer to the various screwholes on the\n//   stepper motor shape.  The names, positions, directions, and spins of these anchors are\n//   specific to the object, and are documented when they exist.\n// Subsection: Spin\n//   Spin is specified with the `spin` argument in most shape modules.  Specifying a scalar `spin`\n//   when creating an object will rotate the object counter-clockwise around the Z axis by the given\n//   number of degrees.  If given as a 3D vector, the object will be rotated around each of the X, Y, Z\n//   axes by the number of degrees in each component of the vector.  Spin is always applied after\n//   anchoring, and before orientation.  Since spin is applied after anchoring it is not what\n//   you might think of intuitively as spinning the shape.  To do that, apply `zrot()` to the shape before anchoring.\n// Subsection: Orient\n//   Orientation is specified with the `orient` argument in most shape modules.  Specifying `orient`\n//   when creating an object will rotate the object such that the top of the object will be pointed\n//   at the vector direction given in the `orient` argument.  Orientation is always applied after\n//   anchoring and spin.  The constants `UP`, `DOWN`, `FRONT`, `BACK`, `LEFT`, and `RIGHT` can be\n//   added together to form the directional vector for this.  ie: `LEFT+BACK`\n// Subsection: Specifying Directions\n//   You can use direction vectors to specify anchors for objects or to specify edges, faces, and\n//   corners of cubes.  You can simply specify these direction vectors numerically, but another\n//   option is to use named constants for direction vectors.  These constants define unit vectors\n//   for the six axis directions as shown below.\n// Figure(3D,Big,VPD=6): Named constants for direction vectors.  Some directions have more than one name.\n//   $fn=12;\n//   stroke([[0,0,0],RIGHT], endcap2=\"arrow2\", width=.05);\n//   color(\"black\")right(.05)up(.05)move(RIGHT) text3d(\"RIGHT\",size=.1,h=.01,anchor=LEFT,orient=FRONT);\n//   stroke([[0,0,0],LEFT], endcap2=\"arrow2\", width=.05);\n//   color(\"black\")left(.05)up(.05)move(LEFT) text3d(\"LEFT\",size=.1,h=.01,anchor=RIGHT,orient=FRONT);\n//   stroke([[0,0,0],FRONT], endcap2=\"arrow2\", width=.05);\n//   color(\"black\")\n//   left(.1){\n//   up(.12)move(FRONT) text3d(\"FRONT\",size=.1,h=.01,anchor=RIGHT,orient=FRONT);\n//   move(FRONT) text3d(\"FWD\",size=.1,h=.01,anchor=RIGHT,orient=FRONT);\n//   down(.12)move(FRONT) text3d(\"FORWARD\",size=.1,h=.01,anchor=RIGHT,orient=FRONT);\n//   }\n//   stroke([[0,0,0],BACK], endcap2=\"arrow2\", width=.05);\n//   right(.05)\n//   color(\"black\")move(BACK) text3d(\"BACK\",size=.1,h=.01,anchor=LEFT,orient=FRONT);\n//   stroke([[0,0,0],DOWN], endcap2=\"arrow2\", width=.05);\n//   color(\"black\")\n//   right(.1){\n//   up(.12)move(BOT) text3d(\"DOWN\",size=.1,h=.01,anchor=LEFT,orient=FRONT);\n//   move(BOT) text3d(\"BOTTOM\",size=.1,h=.01,anchor=LEFT,orient=FRONT);\n//   down(.12)move(BOT) text3d(\"BOT\",size=.1,h=.01,anchor=LEFT,orient=FRONT);\n//   }\n//   stroke([[0,0,0],TOP], endcap2=\"arrow2\", width=.05);\n//   color(\"black\")left(.05){\n//   up(.12)move(TOP) text3d(\"TOP\",size=.1,h=.01,anchor=RIGHT,orient=FRONT);\n//   move(TOP) text3d(\"UP\",size=.1,h=.01,anchor=RIGHT,orient=FRONT);\n//   }\n// Figure(2D,Big): Named constants for direction vectors in 2D.  For anchors the TOP and BOTTOM directions are collapsed into 2D as shown here, but do not try to use TOP or BOTTOM as 2D directions in other situations.\n//   $fn=12;\n//   stroke(path2d([[0,0,0],RIGHT]), endcap2=\"arrow2\", width=.05);\n//   color(\"black\")fwd(.22)left(.05)move(RIGHT) text(\"RIGHT\",size=.1,anchor=RIGHT);\n//   stroke(path2d([[0,0,0],LEFT]), endcap2=\"arrow2\", width=.05);\n//   color(\"black\")right(.05)fwd(.22)move(LEFT) text(\"LEFT\",size=.1,anchor=LEFT);\n//   stroke(path2d([[0,0,0],FRONT]), endcap2=\"arrow2\", width=.05);\n//   color(\"black\")\n//   fwd(.2)\n//   right(.15)\n//   color(\"black\")move(BACK) { text(\"BACK\",size=.1,anchor=LEFT); back(.14) text(\"(TOP)\", size=.1, anchor=LEFT);}\n//   color(\"black\")\n//   left(.15)back(.2+.14)move(FRONT){\n//   back(.14) text(\"FRONT\",size=.1,anchor=RIGHT);\n//       text(\"FWD\",size=.1,anchor=RIGHT);\n//   fwd(.14) text(\"FORWARD\",size=.1,anchor=RIGHT);\n//   fwd(.28) text(\"(BOTTOM)\",size=.1,anchor=RIGHT);\n//   fwd(.14*3) text(\"(BOT)\",size=.1,anchor=RIGHT);\n//   }\n//   stroke(path2d([[0,0,0],BACK]), endcap2=\"arrow2\", width=.05);\n// Subsection: Specifying Faces\n//   Modules operating on faces accept a list of faces to describe the faces to operate on.  Each\n//   face is given by a vector that points to that face.  Attachments of cuboid objects onto their faces also\n//   work by choosing an attachment face with a single vector in the same manner.\n// Figure(3D,Big,NoScales,VPD=275): The six faces of the cube.  Some have faces have more than one name.\n//   ydistribute(50) {\n//      xdistribute(35){\n//        _show_cube_faces([BACK], botlabel=[\"BACK\"]);\n//        _show_cube_faces([UP],botlabel=[\"TOP\",\"UP\"]);\n//        _show_cube_faces([RIGHT],botlabel=[\"RIGHT\"]);\n//      }\n//      xdistribute(35){\n//        _show_cube_faces([FRONT],toplabel=[\"FRONT\",\"FWD\", \"FORWARD\"]);\n//        _show_cube_faces([DOWN],toplabel=[\"BOTTOM\",\"BOT\",\"DOWN\"]);\n//        _show_cube_faces([LEFT],toplabel=[\"LEFT\"]);\n//      }\n//   }\n// Subsection: Specifying Edges\n//   Modules operating on edges use two arguments to describe the edge set they will use: The `edges` argument\n//   is a list of edge set descriptors to include in the edge set, and the `except` argument is a list of\n//   edge set descriptors to remove from the edge set.\n//   The default value for `edges` is `\"ALL\"`, the set of all edges.\n//   The default value for `except` is the    empty set, meaning no edges are removed.\n//   If either argument is just a single edge set\n//   descriptor it can be passed directly rather than in a singleton list.\n//   Each edge set descriptor must be one of:\n//   - A vector pointing towards an edge, indicating that single edge.\n//   - A vector pointing towards a face, indicating all edges surrounding that face.\n//   - A vector pointing towards a corner, indicating all edges touching that corner.\n//   - The string `\"X\"`, indicating all X axis aligned edges.\n//   - The string `\"Y\"`, indicating all Y axis aligned edges.\n//   - The string `\"Z\"`, indicating all Z axis aligned edges.\n//   - The string `\"ALL\"`, indicating all edges.\n//   - The string `\"NONE\"`, indicating no edges at all.\n//   - A 3x4 array, where each entry corresponds to one of the 12 edges and is set to 1 if that edge is included and 0 if the edge is not.  The edge ordering is:\n//       ```\n//       [\n//           [Y-Z-, Y+Z-, Y-Z+, Y+Z+],\n//           [X-Z-, X+Z-, X-Z+, X+Z+],\n//           [X-Y-, X+Y-, X-Y+, X+Y+]\n//       ]\n//       ```\n//   .\n//   You can specify edge descriptors directly by giving a vector, or you can use sums of the\n//   named direction vectors described above.  Below we show all of the edge sets you can\n//   describe with sums of the direction vectors, and then we show some examples of combining\n//   edge set descriptors.\n// Figure(3D,Big,VPD=300,NoScales): Vectors pointing toward an edge select that single edge\n//   ydistribute(50) {\n//       xdistribute(30) {\n//           _show_edges(edges=BOT+RIGHT);\n//           _show_edges(edges=BOT+BACK);\n//           _show_edges(edges=BOT+LEFT);\n//           _show_edges(edges=BOT+FRONT);\n//       }\n//       xdistribute(30) {\n//           _show_edges(edges=FWD+RIGHT);\n//           _show_edges(edges=BACK+RIGHT);\n//           _show_edges(edges=BACK+LEFT);\n//           _show_edges(edges=FWD+LEFT);\n//       }\n//       xdistribute(30) {\n//           _show_edges(edges=TOP+RIGHT);\n//           _show_edges(edges=TOP+BACK);\n//           _show_edges(edges=TOP+LEFT);\n//           _show_edges(edges=TOP+FRONT);\n//       }\n//   }\n// Figure(3D,Med,VPD=205,NoScales): Vectors pointing toward a face select all edges surrounding that face.\n//   ydistribute(50) {\n//       xdistribute(30) {\n//           _show_edges(edges=LEFT);\n//           _show_edges(edges=FRONT);\n//           _show_edges(edges=RIGHT);\n//       }\n//       xdistribute(30) {\n//           _show_edges(edges=TOP);\n//           _show_edges(edges=BACK);\n//           _show_edges(edges=BOTTOM);\n//       }\n//   }\n// Figure(3D,Big,VPD=300,NoScales): Vectors pointing toward a corner select all edges surrounding that corner.\n//   ydistribute(50) {\n//       xdistribute(30) {\n//           _show_edges(edges=FRONT+LEFT+TOP);\n//           _show_edges(edges=FRONT+RIGHT+TOP);\n//           _show_edges(edges=FRONT+LEFT+BOT);\n//           _show_edges(edges=FRONT+RIGHT+BOT);\n//       }\n//       xdistribute(30) {\n//           _show_edges(edges=TOP+LEFT+BACK);\n//           _show_edges(edges=TOP+RIGHT+BACK);\n//           _show_edges(edges=BOT+LEFT+BACK);\n//           _show_edges(edges=BOT+RIGHT+BACK);\n//       }\n//   }\n// Figure(3D,Med,VPD=205,NoScales): Named Edge Sets\n//   ydistribute(50) {\n//       xdistribute(30) {\n//           _show_edges(edges=\"X\");\n//           _show_edges(edges=\"Y\");\n//           _show_edges(edges=\"Z\");\n//       }\n//       xdistribute(30) {\n//           _show_edges(edges=\"ALL\");\n//           _show_edges(edges=\"NONE\");\n//       }\n//   }\n// Figure(3D,Big,VPD=310,NoScales):  Next are some examples showing how you can combine edge descriptors to obtain different edge sets.    You can specify the top front edge with a numerical vector or by combining the named direction vectors.  If you combine them as a list you get all the edges around the front and top faces.  Adding `except` removes an edge.\n//   xdistribute(43){\n//     _show_edges(_edges([0,-1,1]),toplabel=[\"edges=[0,-1,1]\"]);\n//     _show_edges(_edges(TOP+FRONT),toplabel=[\"edges=TOP+FRONT\"]);\n//     _show_edges(_edges([TOP,FRONT]),toplabel=[\"edges=[TOP,FRONT]\"]);\n//     _show_edges(_edges([TOP,FRONT],TOP+FRONT),toplabel=[\"edges=[TOP,FRONT]\",\"except=TOP+FRONT\"]);\n//   }\n// Figure(3D,Big,VPD=310,NoScales): Using `except=BACK` removes the four edges surrounding the back face if they are present in the edge set.  In the first example only one edge needs to be removed.  In the second example we remove two of the Z-aligned edges.  The third example removes all four back edges from the default edge set of all edges.  You can explicitly give `edges=\"ALL\"` but it is not necessary, since this is the default.  In the fourth example, the edge set of Y-aligned edges contains no back edges, so the `except` parameter has no effect.\n//   xdistribute(43){\n//     _show_edges(_edges(BOT,BACK), toplabel=[\"edges=BOT\",\"except=BACK\"]);\n//     _show_edges(_edges(\"Z\",BACK), toplabel=[\"edges=\\\"Z\\\"\", \"except=BACK\"]);\n//     _show_edges(_edges(\"ALL\",BACK), toplabel=[\"(edges=\\\"ALL\\\")\", \"except=BACK\"]);\n//     _show_edges(_edges(\"Y\",BACK), toplabel=[\"edges=\\\"Y\\\"\",\"except=BACK\"]);\n//   }\n// Figure(3D,Big,NoScales,VPD=310): On the left `except` is a list to remove two edges.  In the center we show a corner edge set defined by a numerical vector, and at the right we remove that same corner edge set with named direction vectors.\n//   xdistribute(52){\n//    _show_edges(_edges(\"ALL\",[FRONT+RIGHT,FRONT+LEFT]),\n//               toplabel=[\"except=[FRONT+RIGHT,\",\"       FRONT+LEFT]\"]);\n//    _show_edges(_edges([1,-1,1]),toplabel=[\"edges=[1,-1,1]\"]);\n//    _show_edges(_edges([TOP,BOT], TOP+RIGHT+FRONT),toplabel=[\"edges=[TOP,BOT]\",\"except=TOP+RIGHT+FRONT\"]);\n//   }\n// Subsection: Specifying Corners\n//   Modules operating on corners use two arguments to describe the corner set they will use: The `corners` argument\n//   is a list of corner set descriptors to include in the corner set, and the `except` argument is a list of\n//   corner set descriptors to remove from the corner set.\n//   The default value for `corners` is `\"ALL\"`, the set of all corners.\n//   The default value for `except` is the   empty set, meaning no corners are removed.\n//   If either argument is just a single corner set\n//   descriptor it can be passed directly rather than in a singleton list.\n//   Each corner set descriptor must be one of:\n//   - A vector pointing towards a corner, indicating that corner.\n//   - A vector pointing towards an edge indicating both corners at the ends of that edge.\n//   - A vector pointing towards a face, indicating all the corners of that face.\n//   - The string `\"ALL\"`, indicating all corners.\n//   - The string `\"NONE\"`, indicating no corners at all.\n//   - A length 8 vector where each entry corresponds to a corner and is 1 if the corner is included and 0 if it is excluded.  The corner ordering is\n//       ```\n//       [X-Y-Z-, X+Y-Z-, X-Y+Z-, X+Y+Z-, X-Y-Z+, X+Y-Z+, X-Y+Z+, X+Y+Z+]\n//       ```\n//   .\n//   You can specify corner descriptors directly by giving a vector, or you can use sums of the\n//   named direction vectors described above.  Below we show all of the corner sets you can\n//   describe with sums of the direction vectors and then we show some examples of combining\n//   corner set descriptors.\n// Figure(3D,Big,NoScales,VPD=300): Vectors pointing toward a corner select that corner.\n//   ydistribute(55) {\n//       xdistribute(35) {\n//           _show_corners(corners=FRONT+LEFT+TOP);\n//           _show_corners(corners=FRONT+RIGHT+TOP);\n//           _show_corners(corners=FRONT+LEFT+BOT);\n//           _show_corners(corners=FRONT+RIGHT+BOT);\n//       }\n//       xdistribute(35) {\n//           _show_corners(corners=TOP+LEFT+BACK);\n//           _show_corners(corners=TOP+RIGHT+BACK);\n//           _show_corners(corners=BOT+LEFT+BACK);\n//           _show_corners(corners=BOT+RIGHT+BACK);\n//       }\n//   }\n// Figure(3D,Big,NoScales,VPD=340): Vectors pointing toward an edge select the corners and the ends of the edge.\n//   ydistribute(55) {\n//       xdistribute(35) {\n//           _show_corners(corners=BOT+RIGHT);\n//           _show_corners(corners=BOT+BACK);\n//           _show_corners(corners=BOT+LEFT);\n//           _show_corners(corners=BOT+FRONT);\n//       }\n//       xdistribute(35) {\n//           _show_corners(corners=FWD+RIGHT);\n//           _show_corners(corners=BACK+RIGHT);\n//           _show_corners(corners=BACK+LEFT);\n//           _show_corners(corners=FWD+LEFT);\n//       }\n//       xdistribute(35) {\n//           _show_corners(corners=TOP+RIGHT);\n//           _show_corners(corners=TOP+BACK);\n//           _show_corners(corners=TOP+LEFT);\n//           _show_corners(corners=TOP+FRONT);\n//       }\n//   }\n// Figure(3D,Med,NoScales,VPD=225): Vectors pointing toward a face select the corners of the face.\n//   ydistribute(55) {\n//       xdistribute(35) {\n//           _show_corners(corners=LEFT);\n//           _show_corners(corners=FRONT);\n//           _show_corners(corners=RIGHT);\n//       }\n//       xdistribute(35) {\n//           _show_corners(corners=TOP);\n//           _show_corners(corners=BACK);\n//           _show_corners(corners=BOTTOM);\n//       }\n//   }\n// Figure(3D,Med,NoScales,VPD=200): Corners by name\n//   xdistribute(35) {\n//       _show_corners(corners=\"ALL\");\n//       _show_corners(corners=\"NONE\");\n//   }\n// Figure(3D,Big,NoScales,VPD=300):     Next are some examples showing how you can combine corner descriptors to obtain different corner sets.   You can specify corner sets numerically or by adding together named directions.  The third example shows a list of two corner specifications, giving all the corners on the front face or the right face.\n//   xdistribute(52){\n//     _show_corners(_corners([1,-1,-1]),toplabel=[\"corners=[1,-1,-1]\"]);\n//     _show_corners(_corners(BOT+RIGHT+FRONT),toplabel=[\"corners=BOT+RIGHT+FRONT\"]);\n//     _show_corners(_corners([FRONT,RIGHT]), toplabel=[\"corners=[FRONT,RIGHT]\"]);\n//   }\n// Figure(3D,Big,NoScales,VPD=300): Corners for one edge, two edges, and all the edges except the two on one edge.  Note that since the default is all edges, you only need to give the except argument in this case:\n//    xdistribute(52){\n//      _show_corners(_corners(FRONT+TOP), toplabel=[\"corners=FRONT+TOP\"]);\n//       _show_corners(_corners([FRONT+TOP,BOT+BACK]), toplabel=[\"corners=[FRONT+TOP,\",\"        BOT+BACK]\"]);\n//       _show_corners(_corners(\"ALL\",FRONT+TOP), toplabel=[\"(corners=\\\"ALL\\\")\",\"except=FRONT+TOP\"]);\n//    }\n// Figure(3D,Med,NoScales,VPD=240): The first example shows a single corner removed from the top corners using a numerical vector.  The second one shows removing a set of two corner descriptors from the implied set of all corners.\n//    xdistribute(58){\n//       _show_corners(_corners(TOP,[1,1,1]), toplabel=[\"corners=TOP\",\"except=[1,1,1]\"]);\n//       _show_corners(_corners(\"ALL\",[FRONT+RIGHT+TOP,FRONT+LEFT+BOT]),\n//                    toplabel=[\"except=[FRONT+RIGHT+TOP,\",\"       FRONT+LEFT+BOT]\"]);\n//    }\n// Subsection: Anchoring of Non-Rectangular Objects and Anchor Type (atype)\n//   We focused above on rectangular objects that have well-defined faces and edges aligned with the coordinate axes.\n//   Things get difficult when the objects are curved, or even when their edges are not neatly aligned with the coordinate axes.\n//   In these cases, the library may provide multiple different anchoring schemes, called the anchor types.  When a module supports\n//   multiple anchor types, use the `atype=` parameter to select the anchor type you need.\n// .\n//   First consider the case of a simple rectangle whose corners have been rounded.  Where should the anchors lie?\n//   The default anchor type puts them in the same location as the anchors of an unrounded rectangle, which means that for\n//   positive rounding radii, they are not even located on the perimeter of the object.\n// Figure(2D,Med,NoAxes): Default \"box\" atype anchors for a rounded {{rect()}}\n//   rect([100,50], rounding=[10,0,0,-20],chamfer=[0,10,-20,0]) show_anchors();\n// Continues:\n//   This choice enables you to position the box, or attach things to it, without regard to its rounding or chamfers.  If you need to\n//   anchor onto the roundovers or chamfers then you can use the \"perim\" anchor type:\n// Figure(2D,Med,NoAxes): The \"perim\" atype for a rounded and chamfered {{rect()}}\n//   rect([100,50], rounding=[10,0,0,-20],chamfer=[0,10,-20,0],atype=\"perim\") show_anchors();\n// Continues:\n//   With this anchor type, the anchors are located on the perimeter.  For positive roundings they point in the standard anchor direction;\n//   for negative roundings they are parallel to the base.  As noted above, for circles, cylinders, and spheres, the anchor point is\n//   determined by choosing the point where the anchor vector intersects the shape.  On a circle, this results in an anchor whose direction\n//   matches the user provided anchor vector.  But on an ellipse, something else happens:\n// Figure(2D,Med,NoAxes): Anchors on an ellipse.  The red arrow shows a TOP+RIGHT anchor direction. \n//   ellipse([70,30]) show_anchors();\n//   stroke([[0,0],[45,45]], color=\"red\",endcap2=\"arrow2\");\n// Continues:\n//   For a TOP+RIGHT anchor direction, the surface normal at the intersection point does not match the anchor direction,\n//   so the direction of the anchor shown in blue does not match the direction specified, in red.\n//   Anchors computed this way have anchor type \"intersect\".  When a shape is concave, intersection anchors can produce\n//   a result buried inside the shape's concavity.  Consider the RIGHT anchor of this supershape example:\n// Figure(2D,Med,NoAxes): A supershape with \"intersect\" anchor type:\n//   supershape(n=150,r=75, m1=4, n1=4.0,n2=16, n3=1.5, a=0.9, b=9,atype=\"intersect\") show_anchors();\n// Continues:\n//   A different anchor type called \"hull\" finds anchors that are on the convex hull of the shape.  \n// Figure(2D,Med,NoAxes): A supershape with \"hull\" anchor type:\n//   supershape(n=150,r=55, m1=4, n1=4.0,n2=16, n3=1.5, a=0.9, b=9,atype=\"hull\") show_anchors();\n// Continues:\n//   Hull anchoring works by creating the line (or plane in 3D) that is normal to the specified anchor direction, and\n//   finding the point farthest from the center that intersects that line (or plane).\n// Figure(2D,Med,NoAxes): Finding the RIGHT and BACK+LEFT \"hull\" anchors\n//   supershape(n=128,r=55, m1=4, n1=4.0,n2=16, n3=1.5, a=0.9, b=9,atype=\"hull\") {\n//     position(RIGHT) color_this(\"red\")rect([1,90],anchor=LEFT);\n//     attach(RIGHT)anchor_arrow2d(13);\n//     attach(BACK+LEFT) {\n//        anchor_arrow2d(13);\n//        color_this(\"red\")rect([30,1]);\n//        }\n//     }\n// Continues:\n//   In the example the RIGHT anchor is found when the normal line (shown in red) is tangent to the shape at two points.\n//   The anchor is then taken to be the midpoint.  The BACK+LEFT anchor occurs with a single tangent point, and the\n//   anchor point is located at the tangent point.  For circles intersection is done to the exact circle, but for other\n//   shapes these calculations are done on the point lists that defines the shape, so if you change the number of points\n//   in the list, the precise location of the anchors can change.  You can also get surprising results if your point list is badly chosen.\n// Figure(2D,Med,NoAxes): Circle anchor in blue.  The red anchor is computed to a point list of a circle with 17 segments.  \n//   circle(r=31,$fn=128) attach(TOP)anchor_arrow2d(15);\n//   region(circle(r=33,$fn=17)) {color(\"red\")attach(TOP)anchor_arrow2d(13);}\n// Continues:\n//   The figure shows a large horizontal offset due to a poor choice of sampling for the circular shape when using the \"hull\" anchor type.\n//   The determination of \"hull\" or \"intersect\" anchors may depend on the location of the centerpoint used in the computation.\n//   Some of the modules allow you to change the centerpoint using a `cp=` argument.  If you need to change the centerpoint for\n//   a module that does not provide this option, you can use the generic {{region()}} module, which will let you specify a centerpoint.\n//   The default center point is the centroid, specified by \"centroid\".  You can also choose \"mean\", which gives the mean of all\n//   the data points, or \"bbox\", which gives the centerpoint of the bounding box for the data.  Your last option for centerpoint is to\n//   choose an arbitrary point that meets your needs.\n// Figure(2D,Med,NoAxes): The centerpoint for \"intersect\" anchors is located at the red dot\n//   region(supershape(n=128,r=55, m1=4, n1=4.0,n2=16, n3=1.5, a=0.9, b=9),atype=\"intersect\",cp=[0,30]) show_anchors();\n//   color(\"red\")back(30)circle(r=2,$fn=16);\n// Continues:\n//   Note that all the anchors for an object have to be determined based on one anchor type and relative to the same centerpoint.\n//   The supported anchor types for each module appear in the \"Anchor Types\" section of its entry.  \n\n\n\n\n\n// Section: Attachment Positioning\n\n// Module: position()\n// Synopsis: Attaches children to a parent object at an anchor point.\n// SynTags: Trans\n// Topics: Attachments\n// See Also: attachable(), attach(), orient()\n// Usage:\n//   PARENT() position(at) CHILDREN;\n// Description:\n//   Attaches children to a parent object at an anchor point.  For a step-by-step explanation\n//   of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   at = The vector, or name of the parent anchor point to attach to.\n// Side Effects:\n//   `$attach_anchor` for each `from=` anchor given, this is set to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.\n//   `$attach_to` is set to `undef`.\n//   `$attach_norot` is set to `true`.\n// Example:\n//   spheroid(d=20) {\n//       position(TOP) cyl(l=10, d1=10, d2=5, anchor=BOTTOM);\n//       position(RIGHT) cyl(l=10, d1=10, d2=5, anchor=BOTTOM);\n//       position(FRONT) cyl(l=10, d1=10, d2=5, anchor=BOTTOM);\n//   }\nmodule position(at,from)\n{\n    if (is_def(from)){\n      echo(\"'from' argument of position() has changed to 'at' and will be removed in a future version\");\n    }\n    dummy0=assert(num_defined([at,from])==1, \"Cannot give both `at` argument and the deprectated `from` argument to position()\");\n    at = first_defined([at,from]);\n    req_children($children);\n    dummy1=assert($parent_geom != undef, \"No object to position relative to.\");\n    anchors = (is_vector(at)||is_string(at))? [at] : at;\n    two_d = _attach_geom_2d($parent_geom);\n    for (anchr = anchors) {\n        anch = _find_anchor(anchr, $parent_geom);\n        $attach_to = undef;\n        $attach_anchor = anch;\n        $attach_norot = true;\n        translate(anch[1]) children();\n    }\n}\n\n\n\n// Module: orient()\n// Synopsis: Orients children's tops in the directon of the specified anchor.\n// SynTags: Trans\n// Topics: Attachments\n// See Also: attachable(), attach(), position()\n// Usage:\n//   PARENT() orient(anchor, [spin]) CHILDREN;\n// Description:\n//   Orients children such that their top is tilted in the direction of the specified parent anchor point. \n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   anchor = The anchor on the parent which you want to match the orientation of.\n//   spin = The spin to add to the children.  (Overrides anchor spin.)\n// Side Effects:\n//   `$attach_to` is set to `undef`.\n//   `$attach_norot` is set to `true`.\n// Example: When orienting to an anchor, the spin of the anchor may cause confusion:\n//   prismoid([50,50],[30,30],h=40) {\n//       position(TOP+RIGHT)\n//           orient(RIGHT)\n//               prismoid([30,30],[0,5],h=20,anchor=BOT+LEFT);\n//   }\n// Example: You can override anchor spin with `spin=`.\n//   prismoid([50,50],[30,30],h=40) {\n//       position(TOP+RIGHT)\n//           orient(RIGHT,spin=0)\n//               prismoid([30,30],[0,5],h=20,anchor=BOT+LEFT);\n//   }\n// Example: Or you can anchor the child from the back\n//   prismoid([50,50],[30,30],h=40) {\n//       position(TOP+RIGHT)\n//           orient(RIGHT)\n//               prismoid([30,30],[0,5],h=20,anchor=BOT+BACK);\n//   }\nmodule orient(anchor, spin) {\n    req_children($children);\n    check=\n      assert($parent_geom != undef, \"No parent to orient from!\")\n      assert(is_string(anchor) || is_vector(anchor));\n    anch = _find_anchor(anchor, $parent_geom);\n    two_d = _attach_geom_2d($parent_geom);\n    fromvec = two_d? BACK : UP;\n    spin = default(spin, anch[3]);\n    dummy=assert(is_finite(spin));\n\n    $attach_to = undef;\n    $attach_norot = true;\n    if (two_d)\n        rot(spin)rot(from=fromvec, to=anch[2]) children();\n    else\n        rot(spin, from=fromvec, to=anch[2]) children();\n}\n\n\n\n// Module: align()\n// Synopsis: Position and orient children with alignment to parent edges.\n// SynTags: Trans\n// Topics: Attachments\n// See Also: attachable(), attach(), position(), orient()\n// Usage:\n//   PARENT() align(anchor, [orient], [spin], [inside=]) CHILDREN;\n// Description:\n//   Positions children to the specified anchor(s) on the parent and anchors the\n//   children so that they are aligned with the edge(s) of the parent at those parent anchors.\n//   You can specify a parent anchor point in `orient` and in this case, the top of the child\n//   is tilted in the direction of that anchor.\n//   This means you can easily place children so they are aligned flush with edges of the parent.\n//   In contrast, with {{position()}} you will have to work out the correct anchor for the children\n//   which is not always obvious.  It also enables you to place several children that have different\n//   anchors, which would otherwise require several {{position()}} calls.  The inside argument\n//   causes the object to appear inside the parent for use with {{diff()}}.  \n//   .\n//   When you use `align()`, the `orient=` and `anchor=` arguments to the child objects are overriden,\n//   so they do not have any effect.  The `spin=` argument to the child still applies. \n// Arguments:\n//   anchor = parent anchor or list of parent anchors for positioning children\n//   orient = parent anchor to give direction for orienting the children.  Default: UP\n//   spin = spin in degrees for rotating the children.  Default: Derived from orient anchor\n//   ---\n//   inside = if true, place object inside the parent instead of outside.  Default: false\n// Side Effects:\n//   `$attach_anchor` for each anchor given, this is set to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.\n//   `$attach_to` is set to `undef`.\n//   `$attach_norot` is set to `true`.\n//   `$anchor_override` is set to the anchor required for proper positioning of the child.  \n//   if inside is true then set default tag to \"remove\"\n// Example: Child would require anchor of RIGHT+FRONT+BOT if placed with {{position()}}. \n//   cuboid([50,40,15])\n//     align(RIGHT+FRONT+TOP)\n//       color(\"lightblue\")prismoid([10,5],[7,4],height=4);\n// Example: Child requires a different anchor for each position, so explicit specification of the anchor for children is impossible in this case, without using two separate commands.\n//   cuboid([50,40,15])\n//     align([RIGHT+TOP,LEFT+TOP])\n//       color(\"lightblue\")prismoid([10,5],[7,4],height=4);\n// Example: If you try to spin your child, the spin happens after the alignment anchor, so the child will not be flush:\n//   cuboid([50,40,15])\n//     align([RIGHT+TOP])\n//       color(\"lightblue\")\n//          prismoid([10,5],[7,4],height=4,spin=90);\n// Example: You can instead spin the attached children using the spin parameter to `align()`.  In this example, the required anchor is BOT+FWD, which is less obvious.\n//   cuboid([50,40,15])\n//     align(RIGHT+TOP,spin=90)\n//       color(\"lightblue\")prismoid([10,5],[7,4],height=4);\n// Example: Here the child is oriented to the RIGHT, so it appears flush with the top.  In this case you don't have to figure out that the required child anchor is BOT+BACK.  \n//   cuboid([50,40,15])\n//     align(RIGHT+TOP,RIGHT)\n//       color(\"lightblue\")prismoid([10,5],[7,4],height=4);\n// Example: If you change the orientation the child still appears aligned flush in its changed orientation:\n//   cuboid([50,40,15])\n//     align(RIGHT+TOP,DOWN)\n//       color(\"lightblue\")prismoid([10,5],[7,4],height=4);\n// Example: Objects on the right already have nonzero spin by default, so setting spin=0 changes the spin:\n//   prismoid(50,30,25){\n//     align(RIGHT+TOP,RIGHT,spin=0)\n//       color(\"lightblue\")prismoid([10,5],[7,4],height=4);\n//     align(RIGHT+BOT,RIGHT)\n//       color(\"green\")prismoid([10,5],[7,4],height=4);\n//   }\n// Example: Setting inside=true enables us to subtract the child from the parent with {{diff()}.  The \"remove\" tag is automatically applied when you set `inside=true`.  \n//   diff()\n//     cuboid([40,30,10])\n//       move(.1*[0,-1,1])\n//         align(FRONT+TOP,inside=true)\n//           prismoid([10,5],[7,5],height=4);\nmodule align(anchor,orient=UP,spin,inside=false)\n{\n    req_children($children);\n    dummy1=assert($parent_geom != undef, \"No object to align to.\")\n           assert(is_string(orient) || is_vector(orient),\"Bad orient value\");\n    position_anchors = (is_vector(anchor)||is_string(anchor))? [anchor] : anchor;\n    two_d = _attach_geom_2d($parent_geom);\n    fromvec = two_d? BACK : UP;\n\n    orient_anch = _find_anchor(orient, $parent_geom);\n    spin = default(spin, orient_anch[3]);\n    dummy2=assert(is_finite(spin));\n    \n    $attach_to = undef;\n    $attach_norot = true;\n\n    factor = inside?1:-1;\n    \n    for (thisanch = position_anchors) {\n        pos_anch = _find_anchor(thisanch, $parent_geom);\n        init_anch = two_d ? rot(from=orient_anch[2], to=fromvec, p=zrot(-spin,pos_anch[0]))\n                          : rot(spin, from=fromvec, to=orient_anch[2], reverse=true, p=pos_anch[0]);\n        quant_anch = [for(v=init_anch) sign(round(v))];\n        $anchor_override = two_d && quant_anch.y!=0 ? [quant_anch.x,factor*quant_anch.y]\n                         : !two_d && quant_anch.z!=0 ? [quant_anch.x,quant_anch.y, factor*quant_anch.z]\n                         : factor*quant_anch;\n        $attach_anchor = pos_anch;\n        translate(pos_anch[1]) {\n            if (two_d)\n                rot(spin)rot(from=fromvec, to=orient_anch[2])\n                  default_tag(\"remove\",inside) children();\n            else\n                rot(spin, from=fromvec, to=orient_anch[2])\n                  default_tag(\"remove\",inside) children();                  \n        }\n    }\n}\n\n\n\n\n\n// Module: attach()\n// Synopsis: Attaches children to a parent object at an anchor point and orientation.\n// SynTags: Trans\n// Topics: Attachments\n// See Also: attachable(), position(), face_profile(), edge_profile(), corner_profile()\n// Usage:\n//   PARENT() attach(from, [overlap=], [norot=]) CHILDREN;\n//   PARENT() attach(from, to, [overlap=], [norot=]) CHILDREN;\n// Description:\n//   Attaches children to a parent object at an anchor point and orientation.  Attached objects will\n//   be overlapped into the parent object by a little bit, as specified by the `$overlap`\n//   value (0 by default), or by the overriding `overlap=` argument.  This is to prevent OpenSCAD\n//   from making non-manifold objects.  You can define `$overlap=` as an argument in a parent\n//   module to set the default for all attachments to it.  For a step-by-step explanation of\n//   attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   from = The vector, or name of the parent anchor point to attach to.\n//   to = Optional name of the child anchor point.  If given, orients the child such that the named anchors align together rotationally.\n//   ---\n//   overlap = Amount to sink child into the parent.  Equivalent to `down(X)` after the attach.  This defaults to the value in `$overlap`, which is `0` by default.\n//   norot = If true, don't rotate children when attaching to the anchor point.  Only translate to the anchor point.\n// Side Effects:\n//   `$idx` is set to the index number of each anchor if a list of anchors is given.  Otherwise is set to `0`.\n//   `$attach_anchor` for each `from=` anchor given, this is set to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.\n//   `$attach_to` is set to the value of the `to=` argument, if given.  Otherwise, `undef`\n//   `$attach_norot` is set to the value of the `norot=` argument.\n// Example:\n//   spheroid(d=20) {\n//       attach(TOP) down(1.5) cyl(l=11.5, d1=10, d2=5, anchor=BOTTOM);\n//       attach(RIGHT, BOTTOM) down(1.5) cyl(l=11.5, d1=10, d2=5);\n//       attach(FRONT, BOTTOM, overlap=1.5) cyl(l=11.5, d1=10, d2=5);\n//   }\nmodule attach(from, to, overlap, norot=false)\n{\n    req_children($children);\n    assert($parent_geom != undef, \"No object to attach to!\");\n    overlap = (overlap!=undef)? overlap : $overlap;\n    anchors = (is_vector(from)||is_string(from))? [from] : from;\n    for ($idx = idx(anchors)) {\n        anchr = anchors[$idx];\n        anch = _find_anchor(anchr, $parent_geom);\n        two_d = _attach_geom_2d($parent_geom);\n        $attach_to = to;\n        $attach_anchor = anch;\n        $attach_norot = norot;\n        olap = two_d? [0,-overlap,0] : [0,0,-overlap];\n        if (norot || (norm(anch[2]-UP)<1e-9 && anch[3]==0)) {\n            translate(anch[1]) translate(olap) children();\n        } else {\n            fromvec = two_d? BACK : UP;\n            translate(anch[1]) rot(anch[3],from=fromvec,to=anch[2]) translate(olap) children();\n        }\n    }\n}\n\n// Section: Tagging\n\n// Module: tag()\n// Synopsis: Assigns a tag to an object\n// Topics: Attachments\n// See Also: force_tag(), recolor(), hide(), show_only(), diff(), intersect()\n// Usage:\n//   PARENT() tag(tag) CHILDREN;\n// Description:\n//   Assigns the specified tag to all of the children. Note that if you want\n//   to apply a tag to non-tag-aware objects you need to use {{force_tag()}} instead.\n//   This works by setting the `$tag` variable, but it provides extra error checking and\n//   handling of scopes.  You may set `$tag` directly yourself, but this is not recommended.\n//   .\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   tag = tag string, which must not contain any spaces.\n// Side Effects:\n//   Sets `$tag` to the tag you specify, possibly with a scope prefix.\n// Example(3D):  Applies the tag to both cuboids instead of having to repeat `$tag=\"remove\"` for each one.\n//   diff(\"remove\")\n//     cuboid(10){\n//       position(TOP) cuboid(3);\n//       tag(\"remove\")\n//       {\n//         position(FRONT) cuboid(3);\n//         position(RIGHT) cuboid(3);\n//       }\n//     }\nmodule tag(tag)\n{\n    req_children($children);\n    check=\n      assert(is_string(tag),\"tag must be a string\")\n      assert(undef==str_find(tag,\" \"),str(\"Tag string \\\"\",tag,\"\\\" contains a space, which is not allowed\"));\n    $tag = str($tag_prefix,tag);\n    children();\n}\n\n\n// Module: force_tag()\n// Synopsis: Assigns a tag to a non-attachable object.\n// Topics: Attachments\n// See Also: tag(), recolor(), hide(), show_only(), diff(), intersect()\n// Usage:\n//   PARENT() force_tag([tag]) CHILDREN;\n// Description:\n//   You use this module when you want to make a non-attachable or non-BOSL2 module respect tags.\n//   It applies to its children the tag specified (or the tag currently in force if you don't specify a tag),\n//   making a final determination about whether to show or hide the children.\n//   This means that tagging in children's children will be ignored.\n//   This module is specifically provided for operating on children that are not tag aware such as modules\n//   that don't use {{attachable()}} or built in modules such as\n//   - `polygon()`\n//   - `projection()`\n//   - `polyhedron()`  (or use [`vnf_polyhedron()`](vnf.scad#vnf_polyhedron))\n//   - `linear_extrude()`  (or use [`linear_sweep()`](regions.scad#linear_sweep))\n//   - `rotate_extrude()`\n//   - `surface()`\n//   - `import()`\n//   - `difference()`\n//   - `intersection()`\n//   - `hull()`\n//   .\n//   When you use tag-based modules like {{diff()}} with a non-attachable module, the result may be puzzling.\n//   Any time a test occurs for display of child() that test will succeed.  This means that when diff() checks\n//   to see if it should show a module it will show it, and when diff() checks to see if it should subtract the module\n//   it will subtract it.  The result will be a hole, possibly with zero-thickness edges or faces.  In order to\n//   get the correct behavior, every non-attachable module needs an invocation of force_tag, even ones\n//   that are not tagged.\n//   .\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   tag = tag string, which must not contain any spaces\n// Side Effects:\n//   Sets `$tag` to the tag you specify, possibly with a scope prefix.\n// Example(2D): This example produces the full square without subtracting the \"remove\" item.  When you use non-attachable modules with tags, results are unpredictable.\n//   diff()\n//   {\n//     polygon(square(10));\n//     move(-[.01,.01])polygon(square(5),$tag=\"remove\");\n//   }\n// Example(2D): Adding force_tag() fixes the model.  Note you need to add it to *every* non-attachable module, even the untagged ones, as shown here.\n//   diff()\n//   {\n//     force_tag()\n//       polygon(square(10));\n//     force_tag(\"remove\")\n//       move(-[.01,.01])polygon(square(5));\n//   }\nmodule force_tag(tag)\n{\n    req_children($children);\n    check1=assert(is_undef(tag) || is_string(tag),\"tag must be a string\");\n    $tag = str($tag_prefix,default(tag,$tag));\n    assert(undef==str_find($tag,\" \"),str(\"Tag string \\\"\",$tag,\"\\\" contains a space, which is not allowed\"));\n    if(_is_shown())\n      show_all()\n        children();\n}\n\n\n\n// Module: default_tag()\n// Synopsis: Sets a default tag for all children.\n// Topics: Attachments\n// See Also: force_tag(), recolor(), hide(), show_only(), diff(), intersect()\n// Usage:\n//   PARENT() default_tag(tag) CHILDREN;\n// Description:\n//   Sets a default tag for all of the children.  This is intended to be used to set a tag for a whole module\n//   that is then used outside the module, such as setting the tag to \"remove\" for easy operation with {{diff()}}.\n//   The default_tag() module sets the `$tag` variable only if it is not already\n//   set so you can have a module set a default tag of \"remove\" but that tag can be overridden by a {{tag()}}\n//   in force from a parent.  If you use {{tag()}} it will override any previously\n//   specified tag from a parent, which can be very confusing to a user trying to change the tag on a module.\n//   The `do_tag` parameter allows you to apply a default tag conditionally without having to repeat the children.  \n//   .\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   tag = tag string, which must not contain any spaces.\n//   do_tag = if false do not set the tag.  \n// Side Effects:\n//   Sets `$tag` to the tag you specify, possibly with a scope prefix.\n// Example(3D):  The module thing() is defined with {{tag()}} and the user applied tag of \"keep_it\" is ignored, leaving the user puzzled.\n//   module thing() { tag(\"remove\") cuboid(10);}\n//   diff()\n//     cuboid(20){\n//       position(TOP) thing();\n//       position(RIGHT) tag(\"keep_it\") thing();\n//   }\n// Example(3D):  Using default_tag() fixes this problem: the user applied tag does not get overridden by the tag hidden in the module definition.\n//   module thing() { default_tag(\"remove\") cuboid(10);}\n//   diff()\n//     cuboid(20){\n//       position(TOP) thing();\n//       position(RIGHT) tag(\"keep_it\") thing();\n//   }\nmodule default_tag(tag,do_tag=true)\n{\n    if ($tag==\"\" && do_tag) tag(tag) children();\n    else children();\n}\n\n\n// Module: tag_scope()\n// Synopsis: Creates a new tag scope.\n// See Also: tag(), force_tag(), default_tag()\n// Topics: Attachments\n// Usage:\n//   tag_scope([scope]) CHILDREN;\n// Description:\n//   Creates a tag scope with locally altered tag names to avoid tag name conflict with other code.\n//   This is necessary when writing modules because the module's caller might happen to use the same tags.\n//   Note that if you directly set the `$tag` variable then tag scoping will not work correctly.\n// Side Effects:\n//   `$tag_prefix` is set to the value of `scope=` if given, otherwise is set to a random string.\n// Example: In this example the ring module uses \"remove\" tags which will conflict with use of the same tags by the parent.\n//   module ring(r,h,w=1,anchor,spin,orient)\n//   {\n//     tag_scope(\"ringscope\")\n//       attachable(anchor,spin,orient,r=r,h=h){\n//         diff()\n//           cyl(r=r,h=h)\n//             tag(\"remove\") cyl(r=r-w,h=h+1);\n//         children();\n//       }\n//   }\n//   // Calling the module using \"remove\" tags\n//   // will conflict with internal tag use in\n//   // the ring module.\n//   $fn=32;\n//   diff(){\n//       ring(10,7,w=4);\n//       tag(\"remove\")ring(8,8);\n//       tag(\"remove\")diff(\"rem\"){\n//          ring(9.5,8,w=1);\n//          tag(\"rem\")ring(9.5,8,w=.3);\n//       }\n//     }\nmodule tag_scope(scope){\n  req_children($children);\n  scope = is_undef(scope) ? rand_str(20) : scope;\n  assert(is_string(scope), \"scope must be a string\");\n  assert(undef==str_find(scope,\" \"),str(\"Scope string \\\"\",scope,\"\\\" contains a space, which is not allowed\"));\n  $tag_prefix=scope;\n  children();\n}\n\n\n// Section: Attachment Modifiers\n\n// Module: diff()\n// Synopsis: Performs a differencing operation using tags rather than hierarchy to control what happens.\n// Topics: Attachments\n// See Also: tag(), force_tag(), recolor(), show_only(), hide(), tag_diff(), intersect(), tag_intersect()\n// Usage:\n//   diff([remove], [keep]) PARENT() CHILDREN;\n// Description:\n//   Performs a differencing operation using tags to control what happens.  This is specifically intended to\n//   address the situation where you want differences between a parent and child object, something\n//   that is impossible with the native difference() module.\n//   The children to diff are grouped into three categories, regardless of nesting level.\n//   The `remove` argument is a space delimited list of tags specifying objects to\n//   subtract.  The `keep` argument is a similar list of tags giving objects to be kept.\n//   Objects not matching either the `remove` or `keep` lists form the third category of base objects.\n//   To produce its output, diff() forms the union of all the base objects and then\n//   subtracts all the objects with tags in `remove`.  Finally it adds in objects listed in `keep`.\n//   Attachable objects should be tagged using {{tag()}}\n//   and non-attachable objects with {{force_tag()}}.\n//   .\n//   Remember when using tagged operations with that the operations don't happen in hierarchical order, since\n//   the point of tags is to break the hierarchy.  If you tag an object with a keep tag, nothing will be\n//   subtracted from it, no matter where it appears because kept objects are unioned in at the end.\n//   If you want a child of an object tagged with a remove tag to stay in the model it may be\n//   better to give it a tag that is not a remove tag or a keep tag.  Such an object *will* be subject to\n//   subtractions from other remove-tagged objects.\n//   .\n//   Note that `diff()` invokes its children three times.\n//   .\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   remove = String containing space delimited set of tag names of children to difference away.  Default: `\"remove\"`\n//   keep = String containing space delimited set of tag names of children to keep; that is, to union into the model after differencing is completed.  Default: `\"keep\"`\n// Example: Diffing using default tags\n//   diff()\n//   cuboid(50) {\n//       tag(\"remove\") attach(TOP) sphere(d=40);\n//       tag(\"keep\") attach(CTR) cylinder(h=40, d=10);\n//   }\n// Example: The \"hole\" items are subtracted from everything else.  The other tags can be anything you find convenient.\n//   diff(\"hole\")\n//     tag(\"body\")sphere(d=100) {\n//       tag(\"pole\") zcyl(d=55, h=100);  // attach() not needed for center-to-center.\n//       tag(\"hole\") {\n//          xcyl(d=55, h=101);\n//          ycyl(d=55, h=101);\n//       }\n//       tag(\"axle\")zcyl(d=15, h=140);\n//     }\n// Example:\n//   diff(keep=\"axle\")\n//   sphere(d=100) {\n//       tag(\"axle\")xcyl(d=40, l=120);\n//       tag(\"remove\")cuboid([40,120,100]);\n//   }\n// Example: Masking\n//   diff()\n//   cube([80,90,100], center=true) {\n//       edge_mask(FWD)\n//           rounding_edge_mask(l=max($parent_size)*1.01, r=25);\n//   }\n// Example: Here we subtract the parent object from the child.  Because tags propagate to children we need to clear the \"remove\" tag from the child.\n//  diff()\n//     tag(\"remove\")cuboid(10)\n//       tag(\"\")position(RIGHT+BACK)cyl(r=8,h=9);\n// Example(3D,VPR=[104,0,200], VPT=[-0.9,3.03, -0.74], VPD=19,NoAxes,NoScales): A pipe module that subtracts its interior when you call it using diff().  Normally if you union two pipes together, you'll get interfering walls at the intersection, but not here:\n//   $fn=16;\n//   // This module must be called by subtracting with \"diff\"\n//   module pipe(length, od, id) {\n//       // Strip the tag the user is using to subtract\n//       tag(\"\")cylinder(h=length, d=od, center=true);\n//       // Leave the tag alone here, so this one is removed\n//       cylinder(h=length+.02, d=id, center=true);\n//   }\n//   // Draw some intersecting pipes\n//   diff(){\n//     tag(\"remove\"){\n//       pipe(length=5, od=2, id=1.9);\n//       zrot(10)xrot(75)\n//         pipe(length=5, od=2, id=1.9);\n//     }\n//     // The orange bar has its center removed\n//     color(\"orange\") down(1) xcyl(h=8, d=1);\n//     // \"keep\" preserves the interior of the blue bar intact\n//     tag(\"keep\") recolor(\"blue\") up(1) xcyl(h=8, d=1);\n//   }\n//   // Objects outside the diff don't have pipe interiors removed\n//   color(\"purple\") down(2.2) ycyl(h=8, d=0.3);\n// Example(3D,NoScales,NoAxes): Nested diff() calls work as expected, but be careful of reusing tag names, even hidden in submodules.\n//   $fn=32;\n//   diff(\"rem1\")\n//   cyl(r=10,h=10){\n//     diff(\"rem2\",$tag=\"rem1\"){\n//       cyl(r=8,h=11);\n//       tag(\"rem2\")diff(\"rem3\"){\n//           cyl(r=6,h=12);\n//           tag(\"rem3\")cyl(r=4,h=13);\n//           }\n//       }\n//   }\n// Example: This example shows deep nesting, where all the differences cross levels.  Unlike the preceding example, each cylinder is positioned relative to its parent.  Note that it suffices to use two remove tags, alternating between them at each level.\n//   $fn=32;\n//   diff(\"remA\")\n//     cyl(r=9, h=6)\n//       tag(\"remA\")diff(\"remB\")\n//         left(.2)position(RIGHT)cyl(r=8,h=7,anchor=RIGHT)\n//           tag(\"remB\")diff(\"remA\")\n//            left(.2)position(LEFT)cyl(r=7,h=7,anchor=LEFT)\n//              tag(\"remA\")diff(\"remB\")\n//                left(.2)position(LEFT)cyl(r=6,h=8,anchor=LEFT)\n//                  tag(\"remB\")diff(\"remA\")\n//                    right(.2)position(RIGHT)cyl(r=5,h=9,anchor=RIGHT)\n//                      tag(\"remA\")diff(\"remB\")\n//                        right(.2)position(RIGHT)cyl(r=4,h=10,anchor=RIGHT)\n//                          tag(\"remB\")left(.2)position(LEFT)cyl(r=3,h=11,anchor=LEFT);\n// Example(3D,NoAxes,NoScales): When working with Non-Attachables like rotate_extrude() you must apply {{force_tag()}} to every non-attachable object.\n//   back_half()\n//     diff(\"remove\")\n//       cuboid(40) {\n//         attach(TOP)\n//           recolor(\"lightgreen\")\n//             cyl(l=10,d=30);\n//         position(TOP+RIGHT)\n//           force_tag(\"remove\")\n//             xrot(90)\n//               rotate_extrude()\n//                 right(20)\n//                   circle(5);\n//       }\n// Example: Here is another example where two children are intersected using the native intersection operator, and then tagged with {{force_tag()}}.  Note that because the children are at the same level, you don't need to use a tagged operator for their intersection.\n//  $fn=32;\n//  diff()\n//    cuboid(10){\n//      force_tag(\"remove\")intersection()\n//        {\n//          position(RIGHT) cyl(r=7,h=15);\n//          position(LEFT) cyl(r=7,h=15);\n//        }\n//      tag(\"keep\")cyl(r=1,h=9);\n//    }\n// Example: In this example the children that are subtracted are each at different nesting levels, with a kept object in between.\n//   $fn=32;\n//   diff()\n//     cuboid(10){\n//       tag(\"remove\")cyl(r=4,h=11)\n//         tag(\"keep\")cyl(r=3,h=17)\n//           tag(\"remove\")position(RIGHT)cyl(r=2,h=18);\n//     }\n// Example: Combining tag operators can be tricky.  Here the `diff()` operation keeps two tags, \"fullkeep\" and \"keep\".  Then {{intersect()}} intersects the \"keep\" tagged item with everything else, but keeps the \"fullkeep\" object.\n//   $fn=32;\n//   intersect(\"keep\",\"fullkeep\")\n//     diff(keep=\"fullkeep keep\")\n//       cuboid(10){\n//         tag(\"remove\")cyl(r=4,h=11);\n//         tag(\"keep\") position(RIGHT)cyl(r=8,h=12);\n//         tag(\"fullkeep\")cyl(r=1,h=12);\n//     }\n// Example: In this complex example we form an intersection, subtract an object, and keep some objects.  Note that for the small cylinders on either side, marking them as \"keep\" or removing their tag gives the same effect.  This is because without a tag they become part of the intersection and the result ends up the same.  For the two cylinders at the back, however, the result is different.  With \"keep\" the cylinder on the left appears whole, but without it, the cylinder at the back right is subject to intersection.\n//   $fn=64;\n//   diff()\n//     intersect(keep=\"remove keep\")\n//       cuboid(10,$thing=\"cube\"){\n//         tag(\"intersect\"){\n//           position(RIGHT) cyl(r=5.5,h=15)\n//              tag(\"\")cyl(r=2,h=10);\n//           position(LEFT) cyl(r=5.54,h=15)\n//              tag(\"keep\")cyl(r=2,h=10);\n//         }\n//         // Untagged it is in the intersection\n//         tag(\"\") position(BACK+RIGHT)\n//           cyl(r=2,h=10,anchor=CTR);\n//         // With keep the full cylinder appears\n//         tag(\"keep\") position(BACK+LEFT)\n//           cyl(r=2,h=10,anchor=CTR);\n//         tag(\"remove\") cyl(r=3,h=15);\n//       }\nmodule diff(remove=\"remove\", keep=\"keep\")\n{\n    req_children($children);\n    assert(is_string(remove),\"remove must be a string of tags\");\n    assert(is_string(keep),\"keep must be a string of tags\");\n    if (_is_shown())\n    {\n        difference() {\n            hide(str(remove,\" \",keep)) children();\n            show_only(remove) children();\n        }\n    }\n    show_int(keep)children();\n}\n\n\n// Module: tag_diff()\n// Synopsis: Performs a {{diff()}} and then sets a tag on the result.\n// Topics: Attachments\n// See Also: tag(), force_tag(), recolor(), show_only(), hide(), diff(), intersect(), tag_intersect()\n// Usage:\n//   tag_diff(tag, [remove], [keep]) PARENT() CHILDREN;\n// Description:\n//   Perform a differencing operation in the manner of {{diff()}} using tags to control what happens,\n//   and then tag the resulting difference object with the specified tag.  This forces the specified\n//   tag to be resolved at the level of the difference operation.  In most cases, this is not necessary,\n//   but if you have kept objects and want to operate on this difference object as a whole object using\n//   more tag operations, you will probably not get the results you want if you simply use {{tag()}}.\n//   .\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   tag = Tag string to apply to this difference object\n//   remove = String containing space delimited set of tag names of children to difference away.  Default: `\"remove\"`\n//   keep = String containing space delimited set of tag names of children to keep; that is, to union into the model after differencing is completed.  Default: `\"keep\"`\n// Side Effects:\n//   Sets `$tag` to the tag you specify, possibly with a scope prefix.\n// Example: In this example we have a difference with a kept object that is then subtracted from a cube, but we don't want the kept object to appear in the final output, so this result is wrong:\n//   diff(\"rem\"){\n//     cuboid([20,10,30],anchor=FRONT);\n//     tag(\"rem\")diff(\"remove\",\"keep\"){\n//       cuboid([10,10,20]);\n//       tag(\"remove\")cuboid([11,11,5]);\n//       tag(\"keep\")cuboid([2,2,20]);\n//     }\n//   }\n// Example: Using tag_diff corrects the problem:\n//   diff(\"rem\"){\n//     cuboid([20,10,30],anchor=FRONT);\n//       tag_diff(\"rem\",\"remove\",\"keep\"){\n//         cuboid([10,10,20]);\n//         tag(\"remove\")cuboid([11,11,5]);\n//         tag(\"keep\")cuboid([2,2,20]);\n//       }\n//   }\n// Example: This concentric cylinder example uses \"keep\" and produces the wrong result.  The kept cylinder gets kept in the final output instead of subtracted.  This happens even when we make sure to change the `keep` argument at the top level {{diff()}} call.\n//   diff(\"rem\",\"nothing\")\n//     cyl(r=8,h=6)\n//       tag(\"rem\")diff()\n//         cyl(r=7,h=7)\n//           tag(\"remove\")cyl(r=6,h=8)\n//           tag(\"keep\")cyl(r=5,h=9);\n// Example: Changing to tag_diff() causes the kept cylinder to be subtracted, producing the desired result:\n//   diff(\"rem\")\n//     cyl(r=8,h=6)\n//       tag_diff(\"rem\")\n//         cyl(r=7,h=7)\n//           tag(\"remove\")cyl(r=6,h=8)\n//           tag(\"keep\")cyl(r=5,h=9);\nmodule tag_diff(tag,remove=\"remove\", keep=\"keep\")\n{\n    req_children($children);\n    assert(is_string(remove),\"remove must be a string of tags\");\n    assert(is_string(keep),\"keep must be a string of tags\");\n    assert(is_string(tag),\"tag must be a string\");\n    assert(undef==str_find(tag,\" \"),str(\"Tag string \\\"\",tag,\"\\\" contains a space, which is not allowed\"));\n    $tag=str($tag_prefix,tag);\n    if (_is_shown())\n      show_all(){\n         difference() {\n            hide(str(remove,\" \",keep)) children();\n            show_only(remove) children();\n         }\n         show_only(keep)children();\n      }\n}\n\n\n// Module: intersect()\n// Synopsis: Perform an intersection operation on children using tags rather than hierarchy to control what happens.\n// Topics: Attachments\n// See Also: tag(), force_tag(), recolor(), show_only(), hide(), diff(), tag_diff(), tag_intersect()\n// Usage:\n//   intersect([intersect], [keep]) PARENT() CHILDREN;\n// Description:\n//   Performs an intersection operation on its children, using tags to\n//   determine what happens.  This is specifically intended to address\n//   the situation where you want intersections involving a parent and\n//   child object, something that is impossible with the native\n//   intersection() module.  This module treats the children in three\n//   groups: objects matching the tags listed in `intersect`, objects\n//   matching tags listed in `keep`, and the remaining objects that\n//   don't match any of the listed tags.  The intersection is computed\n//   between the union of the `intersect` tagged objects and union of the objects that don't\n//   match any of the listed tags.  Finally the objects listed in `keep` are\n//   unioned with the result.  Attachable objects should be tagged using {{tag()}}\n//   and non-attachable objects with {{force_tag()}}.\n//   .\n//   Note that `intersect()` invokes its children three times.\n//   .\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   intersect = String containing space delimited set of tag names of children to intersect.  Default: \"intersect\"\n//   keep = String containing space delimited set of tag names of children to keep whole.  Default: \"keep\"\n// Example:\n//   intersect(\"mask\", keep=\"axle\")\n//     sphere(d=100) {\n//         tag(\"mask\")cuboid([40,100,100]);\n//         tag(\"axle\")xcyl(d=40, l=100);\n//     }\n// Example: Combining tag operators can be tricky.  Here the {{diff()}} operation keeps two tags, \"fullkeep\" and \"keep\".  Then `intersect()` intersects the \"keep\" tagged item with everything else, but keeps the \"fullkeep\" object.\n//   $fn=32;\n//   intersect(\"keep\",\"fullkeep\")\n//     diff(keep=\"fullkeep keep\")\n//       cuboid(10){\n//         tag(\"remove\")cyl(r=4,h=11);\n//         tag(\"keep\") position(RIGHT)cyl(r=8,h=12);\n//         tag(\"fullkeep\")cyl(r=1,h=12);\n//     }\n// Example: In this complex example we form an intersection, subtract an object, and keep some objects.  Note that for the small cylinders on either side, marking them as \"keep\" or removing their tag gives the same effect.  This is because without a tag they become part of the intersection and the result ends up the same.  For the two cylinders at the back, however, the result is different.  With \"keep\" the cylinder on the left appears whole, but without it, the cylinder at the back right is subject to intersection.\n//   $fn=64;\n//   diff()\n//     intersect(keep=\"remove keep\")\n//       cuboid(10,$thing=\"cube\"){\n//         tag(\"intersect\"){\n//           position(RIGHT) cyl(r=5.5,h=15)\n//              tag(\"\")cyl(r=2,h=10);\n//           position(LEFT) cyl(r=5.54,h=15)\n//              tag(\"keep\")cyl(r=2,h=10);\n//         }\n//         // Untagged it is in the intersection\n//         tag(\"\") position(BACK+RIGHT)\n//           cyl(r=2,h=10,anchor=CTR);\n//         // With keep the full cylinder appears\n//         tag(\"keep\") position(BACK+LEFT)\n//           cyl(r=2,h=10,anchor=CTR);\n//         tag(\"remove\") cyl(r=3,h=15);\n//       }\nmodule intersect(intersect=\"intersect\",keep=\"keep\")\n{\n   assert(is_string(intersect),\"intersect must be a string of tags\");\n   assert(is_string(keep),\"keep must be a string of tags\");\n   intersection(){\n      show_only(intersect) children();\n      hide(str(intersect,\" \",keep)) children();\n   }\n   show_int(keep) children();\n}\n\n\n// Module: tag_intersect()\n// Synopsis: Performs an {{intersect()}} and then tags the result.\n// Topics: Attachments\n// See Also: tag(), force_tag(), recolor(), show_only(), hide(), diff(), tag_diff(), intersect()\n// Usage:\n//   tag_intersect(tag, [intersect], [keep]) PARENT() CHILDREN;\n// Description:\n//   Perform an intersection operation in the manner of {{intersect()}} using tags to control what happens,\n//   and then tag the resulting difference object with the specified tag.  This forces the specified\n//   tag to be resolved at the level of the intersect operation.  In most cases, this is not necessary,\n//   but if you have kept objects and want to operate on this difference object as a whole object using\n//   more tag operations, you will probably not get the results you want if you simply use {{tag()}}.\n//   .\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   tag = Tag to set for the intersection\n//   intersect = String containing space delimited set of tag names of children to intersect.  Default: \"intersect\"\n//   keep = String containing space delimited set of tag names of children to keep whole.  Default: \"keep\"\n// Side Effects:\n//   Sets `$tag` to the tag you specify, possibly with a scope prefix.\n// Example:  Without `tag_intersect()` the kept object is not included in the difference.\n//   $fn=32;\n//   diff()\n//     cuboid([20,15,9])\n//     tag(\"remove\")intersect()\n//       cuboid(10){\n//         tag(\"intersect\")position(RIGHT) cyl(r=7,h=10);\n//         tag(\"keep\")position(LEFT)cyl(r=4,h=10);\n//       }\n// Example: Using tag_intersect corrects the problem.\n//   $fn=32;\n//   diff()\n//     cuboid([20,15,9])\n//     tag_intersect(\"remove\")\n//       cuboid(10){\n//         tag(\"intersect\")position(RIGHT) cyl(r=7,h=10);\n//         tag(\"keep\")position(LEFT)cyl(r=4,h=10);\n//       }\nmodule tag_intersect(tag,intersect=\"intersect\",keep=\"keep\")\n{\n   assert(is_string(intersect),\"intersect must be a string of tags\");\n   assert(is_string(keep),\"keep must be a string of tags\");\n   assert(is_string(tag),\"tag must be a string\");\n   assert(undef==str_find(tag,\" \"),str(\"Tag string \\\"\",tag,\"\\\" contains a space, which is not allowed\"));\n   $tag=str($tag_prefix,tag);\n   if (_is_shown())\n     show_all(){\n       intersection(){\n          show_only(intersect) children();\n          hide(str(intersect,\" \",keep)) children();\n       }\n       show_only(keep) children();\n   }\n}\n\n\n// Module: conv_hull()\n// Synopsis:  Performs a hull operation on the children using tags to determine what happens.\n// Topics: Attachments, Hulling\n// See Also: tag(), recolor(), show_only(), hide(), diff(), intersect(), hull()\n// Usage:\n//   conv_hull([keep]) CHILDREN;\n// Description:\n//   Performs a hull operation on the children using tags to determine what happens.  The items\n//   not tagged with the `keep` tags are combined into a convex hull, and the children tagged with the keep tags\n//   are unioned with the result.\n//   .\n//   Note that `conv_hull()` invokes its children twice.  \n//   .\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   keep = String containing space delimited set of tag names of children to keep out of the hull.  Default: \"keep\"\n// Example:\n//   conv_hull(\"keep\")\n//      sphere(d=100, $fn=64) {\n//        cuboid([40,90,90]);\n//        tag(\"keep\")xcyl(d=40, l=120);\n//      }\n// Example: difference combined with hull where all objects are relative to each other.\n//   $fn=32;\n//   diff()\n//     conv_hull(\"remove\")\n//       cuboid(10)\n//         position(RIGHT+BACK)cyl(r=4,h=10)\n//           tag(\"remove\")cyl(r=2,h=12);\nmodule conv_hull(keep=\"keep\")\n{\n    req_children($children);\n    assert(is_string(keep),\"keep must be a string of tags\");\n    if (_is_shown())\n        hull() hide(keep) children();\n    show_int(keep) children();\n}\n\n\n// Module: tag_conv_hull()\n// Synopsis: Performs a {{conv_hull()}} and then sets a tag on the result.\n// Topics: Attachments\n// See Also: tag(), recolor(), show_only(), hide(), diff(), intersect()\n// Usage:\n//   tag_conv_hull(tag, [keep]) CHILDREN;\n// Description:\n//   Perform a convex hull operation in the manner of {{conv_hull()}} using tags to control what happens,\n//   and then tag the resulting hull object with the specified tag.  This forces the specified\n//   tag to be resolved at the level of the hull operation.  In most cases, this is not necessary,\n//   but if you have kept objects and want to operate on the hull object as a whole object using\n//   more tag operations, you will probably not get the results you want if you simply use {{tag()}}.\n//   .\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   keep = String containing space delimited set of tag names of children to keep out of the hull.  Default: \"keep\"\n// Side Effects:\n//   Sets `$tag` to the tag you specify, possibly with a scope prefix.\n// Example: With a regular tag, the kept object is not handled as desired:\n//   diff(){\n//      cuboid([30,30,9])\n//        tag(\"remove\")conv_hull(\"remove\")\n//          cuboid(10,anchor=LEFT+FRONT){\n//            position(RIGHT+BACK)cyl(r=4,h=10);\n//            tag(\"keep\")position(FRONT+LEFT)cyl(r=4,h=10);\n//          }\n//   }\n// Example: Using `tag_conv_hull()` fixes the problem:\n//   diff(){\n//      cuboid([30,30,9])\n//        tag_conv_hull(\"remove\")\n//          cuboid(10,anchor=LEFT+FRONT){\n//            position(RIGHT+BACK)cyl(r=4,h=10);\n//            tag(\"keep\")position(FRONT+LEFT)cyl(r=4,h=10);\n//          }\n//   }\nmodule tag_conv_hull(tag,keep=\"keep\")\n{\n    req_children($children);\n    assert(is_string(keep),\"keep must be a string of tags\");\n    assert(is_string(tag),\"tag must be a string\");\n    assert(undef==str_find(tag,\" \"),str(\"Tag string \\\"\",tag,\"\\\" contains a space, which is not allowed\"));\n    $tag=str($tag_prefix,tag);\n    if (_is_shown())\n      show_all(){\n        hull() hide(keep) children();\n        show_only(keep) children();\n      }\n}\n\n\n// Module: hide()\n// Synopsis: Hides attachable children with the given tags.\n// Topics: Attachments\n// See Also: tag(), recolor(), show_only(), show_all(), show_int(), diff(), intersect()\n// Usage:\n//   hide(tags) CHILDREN;\n// Description:\n//   Hides all attachable children with the given tags, which you supply as a space separated string. Previously hidden objects remain hidden, so hiding is cumulative, unlike `show_only()`.\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Side Effects:\n//   Sets `$tags_hidden` to include the tags you specify.\n// Example:  Hides part of the model.\n//   hide(\"A\")\n//     tag(\"main\") cube(50, anchor=CENTER, $tag=\"Main\") {\n//       tag(\"A\")attach(LEFT, BOTTOM) cylinder(d=30, h=30);\n//       tag(\"B\")attach(RIGHT, BOTTOM) cylinder(d=30, h=30);\n//     }\n// Example: Use an invisible parent to position children.  Note that children must be retagged because they inherit the parent tag.\n//   $fn=16;\n//   hide(\"hidden\")\n//     tag(\"hidden\")cuboid(10)\n//       tag(\"visible\") {\n//         position(RIGHT) cyl(r=1,h=12);\n//         position(LEFT) cyl(r=1,h=12);\n//       }\nmodule hide(tags)\n{\n    req_children($children);\n    dummy=assert(is_string(tags), \"tags must be a string\");\n    taglist = [for(s=str_split(tags,\" \",keep_nulls=false)) str($tag_prefix,s)];\n    $tags_hidden = concat($tags_hidden,taglist);\n    children();\n}\n\n\n// Module: show_only()\n// Synopsis: Show only the children with the listed tags.\n// See Also: tag(), recolor(), show_all(), show_int(), diff(), intersect()\n// Topics: Attachments\n// Usage:\n//   show_only(tags) CHILDREN;\n// Description:\n//   Show only the children with the listed tags, which you sply as a space separated string.  Only unhidden objects will be shown, so if an object is hidden either before or after the `show_only()` call then it will remain hidden.  This overrides any previous `show_only()` calls.  Unlike `hide()`, calls to `show_only()` are not cumulative.\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Side Effects:\n//   Sets `$tags_shown` to the tag you specify.\n// Example:  Display the attachments but not the parent\n//   show_only(\"visible\")\n//     cube(50, anchor=CENTER)\n//       tag(\"visible\"){\n//         attach(LEFT, BOTTOM) cylinder(d=30, h=30);\n//         attach(RIGHT, BOTTOM) cylinder(d=30, h=30);\n//       }\nmodule show_only(tags)\n{\n    req_children($children);\n    dummy=assert(is_string(tags), str(\"tags must be a string\",tags));\n    taglist = [for(s=str_split(tags,\" \",keep_nulls=false)) str($tag_prefix,s)];\n    $tags_shown = taglist;\n    children();\n}\n\n// Module: show_all()\n// Synopsis: Shows all children and clears tags.\n// See Also: tag(), recolor(), show_only(), show_int(), diff(), intersect()\n// Topics: Attachments\n// Usage;\n//   show_all() CHILDREN;\n// Description:\n//   Shows all children.  Clears the list of hidden tags and shown tags so that all child objects will be\n//   fully displayed.\n// Side Effects:\n//   Sets `$tags_shown=\"ALL\"`\n//   Sets `$tags_hidden=[]`\nmodule show_all()\n{\n   req_children($children);\n   $tags_shown=\"ALL\";\n   $tags_hidden=[];\n   children();\n}\n\n\n// Module: show_int()\n// Synopsis: Shows children with the listed tags which were already shown in the parent context.\n// See Also: tag(), recolor(), show_only(), show_all(), show_int(), diff(), intersect()\n// Topics: Attachments\n// Usage:\n//   show_int(tags) CHILDREN;\n// Description:\n//   Show only the children with the listed tags which were already shown in the parent context.\n//   This intersects the current show list with the list of tags you provide.\n// Arguments:\n//   tags = list of tags to show\n// Side Effects:\n//   Sets `$tags_shown`\nmodule show_int(tags)\n{\n    req_children($children);\n    dummy=assert(is_string(tags), str(\"tags must be a string\",tags));\n    taglist = [for(s=str_split(tags,\" \",keep_nulls=false)) str($tag_prefix,s)];\n    $tags_shown = $tags_shown == \"ALL\" ? taglist : set_intersection($tags_shown,taglist);\n    children();\n}\n\n\n// Section: Mask Attachment\n\n\n// Module: face_mask()\n// Synopsis: Ataches a 3d mask shape to the given faces of the parent.\n// SynTags: Trans\n// Topics: Attachments, Masking\n// See Also: attachable(), position(), attach(), edge_mask(), corner_mask(), face_profile(), edge_profile(), corner_profile()\n// Usage:\n//   PARENT() face_mask(faces) CHILDREN;\n// Description:\n//   Takes a 3D mask shape, and attaches it to the given faces, with the appropriate orientation to be\n//   differenced away.  The mask shape should be vertically oriented (Z-aligned) with the bottom half\n//   (Z-) shaped to be diffed away from the face of parent attachable shape.  If no tag is set then\n//   `face_mask()` sets the tag for children to \"remove\" so that it will work with the default {{diff()}} tag.\n//   For details on specifying the faces to mask see [Specifying Faces](attachments.scad#subsection-specifying-faces).\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   edges = Faces to mask.  See  [Specifying Faces](attachments.scad#subsection-specifying-faces) for information on specifying faces.  Default: All faces\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n//   `$idx` is set to the index number of each face in the list of faces given.\n//   `$attach_anchor` is set for each face given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.\n// Example:\n//   diff()\n//   cylinder(r=30, h=60)\n//       face_mask(TOP) {\n//           rounding_cylinder_mask(r=30,rounding=5);\n//           cuboid([5,61,10]);\n//       }\n// Example: Using `$idx`\n//   diff()\n//   cylinder(r=30, h=60)\n//       face_mask([TOP, BOT])\n//           zrot(45*$idx) zrot_copies([0,90]) cuboid([5,61,10]);\nmodule face_mask(faces=[LEFT,RIGHT,FRONT,BACK,BOT,TOP]) {\n    req_children($children);\n    faces = is_vector(faces)? [faces] : faces;\n    assert(all([for (face=faces) is_vector(face) && sum([for (x=face) x!=0? 1 : 0])==1]), \"Vector in faces doesn't point at a face.\");\n    assert($parent_geom != undef, \"No object to attach to!\");\n    attach(faces) {\n       default_tag(\"remove\") children();\n    }\n}\n\n\n// Module: edge_mask()\n// Synopsis: Attaches a 3D mask shape to the given edges of the parent.\n// SynTags: Trans\n// Topics: Attachments, Masking\n// See Also: attachable(), position(), attach(), face_mask(), corner_mask(), face_profile(), edge_profile(), corner_profile()\n// Usage:\n//   PARENT() edge_mask([edges], [except]) CHILDREN;\n// Description:\n//   Takes a 3D mask shape, and attaches it to the given edges, with the appropriate orientation to be\n//   differenced away.  The mask shape should be vertically oriented (Z-aligned) with the back-right\n//   quadrant (X+Y+) shaped to be diffed away from the edge of parent attachable shape.  If no tag is set\n//   then `edge_mask` sets the tag for children to \"remove\" so that it will work with the default {{diff()}} tag.\n//   For details on specifying the edges to mask see [Specifying Edges](attachments.scad#subsection-specifying-edges).\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Figure: A Typical Edge Rounding Mask\n//   module roundit(l,r) difference() {\n//       translate([-1,-1,-l/2])\n//           cube([r+1,r+1,l]);\n//       translate([r,r])\n//           cylinder(h=l+1,r=r,center=true, $fn=quantup(segs(r),4));\n//   }\n//   roundit(l=30,r=10);\n// Arguments:\n//   edges = Edges to mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: All edges.\n//   except = Edges to explicitly NOT mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: No edges.\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n//   `$idx` is set to the index number of each edge.\n//   `$attach_anchor` is set for each edge given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.\n//   `$parent_size` is set to the size of the parent object.\n// Example:\n//   diff()\n//   cube([50,60,70],center=true)\n//       edge_mask([TOP,\"Z\"],except=[BACK,TOP+LEFT])\n//           rounding_edge_mask(l=71,r=10);\nmodule edge_mask(edges=EDGES_ALL, except=[]) {\n    req_children($children);\n    assert($parent_geom != undef, \"No object to attach to!\");\n    edges = _edges(edges, except=except);\n    vecs = [\n        for (i = [0:3], axis=[0:2])\n        if (edges[axis][i]>0)\n        EDGE_OFFSETS[axis][i]\n    ];\n    for ($idx = idx(vecs)) {\n        vec = vecs[$idx];\n        vcount = (vec.x?1:0) + (vec.y?1:0) + (vec.z?1:0);\n        dummy=assert(vcount == 2, \"Not an edge vector!\");\n        anch = _find_anchor(vec, $parent_geom);\n        $attach_to = undef;\n        $attach_anchor = anch;\n        $attach_norot = true;\n        rotang =\n            vec.z<0? [90,0,180+v_theta(vec)] :\n            vec.z==0 && sign(vec.x)==sign(vec.y)? 135+v_theta(vec) :\n            vec.z==0 && sign(vec.x)!=sign(vec.y)? [0,180,45+v_theta(vec)] :\n            [-90,0,180+v_theta(vec)];\n        translate(anch[1]) rot(rotang)\n           default_tag(\"remove\") children();\n    }\n}\n\n\n// Module: corner_mask()\n// Synopsis: Attaches a 3d mask shape to the given corners of the parent.\n// SynTags: Trans\n// Topics: Attachments, Masking\n// See Also: attachable(), position(), attach(), face_mask(), edge_mask(), face_profile(), edge_profile(), corner_profile()\n// Usage:\n//   PARENT() corner_mask([corners], [except]) CHILDREN;\n// Description:\n//   Takes a 3D mask shape, and attaches it to the specified corners, with the appropriate orientation to\n//   be differenced away.  The 3D corner mask shape should be designed to mask away the X+Y+Z+ octant.  If no tag is set\n//   then `corner_mask` sets the tag for children to \"remove\" so that it will work with the default {{diff()}} tag.\n//   See [Specifying Corners](attachments.scad#subsection-specifying-corners) for information on how to specify corner sets.\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   corners = Corners to mask.  See [Specifying Corners](attachments.scad#subsection-specifying-corners).  Default: All corners.\n//   except = Corners to explicitly NOT mask.  See [Specifying Corners](attachments.scad#subsection-specifying-corners).  Default: No corners.\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n//   `$idx` is set to the index number of each corner.\n//   `$attach_anchor` is set for each corner given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.\n// Example:\n//   diff()\n//   cube(100, center=true)\n//       corner_mask([TOP,FRONT],LEFT+FRONT+TOP)\n//           difference() {\n//               translate(-0.01*[1,1,1]) cube(20);\n//               translate([20,20,20]) sphere(r=20);\n//           }\nmodule corner_mask(corners=CORNERS_ALL, except=[]) {\n    req_children($children);\n    assert($parent_geom != undef, \"No object to attach to!\");\n    corners = _corners(corners, except=except);\n    vecs = [for (i = [0:7]) if (corners[i]>0) CORNER_OFFSETS[i]];\n    for ($idx = idx(vecs)) {\n        vec = vecs[$idx];\n        vcount = (vec.x?1:0) + (vec.y?1:0) + (vec.z?1:0);\n        dummy=assert(vcount == 3, \"Not an edge vector!\");\n        anch = _find_anchor(vec, $parent_geom);\n        $attach_to = undef;\n        $attach_anchor = anch;\n        $attach_norot = true;\n        rotang = vec.z<0?\n            [  0,0,180+v_theta(vec)-45] :\n            [180,0,-90+v_theta(vec)-45];\n        translate(anch[1]) rot(rotang)\n            default_tag(\"remove\") children();\n    }\n}\n\n\n// Module: face_profile()\n// Synopsis: Extrudes a 2D edge profile into a mask for all edges and corners of the given faces on the parent.\n// SynTags: Geom\n// Topics: Attachments, Masking\n// See Also: attachable(), position(), attach(), edge_profile(), corner_profile(), face_mask(), edge_mask(), corner_mask()\n// Usage:\n//   PARENT() face_profile(faces, r|d=, [convexity=]) CHILDREN;\n// Description:\n//   Given a 2D edge profile, extrudes it into a mask for all edges and corners bounding each given face. If no tag is set\n//   then `face_profile` sets the tag for children to \"remove\" so that it will work with the default {{diff()}} tag.\n//   See  [Specifying Faces](attachments.scad#subsection-specifying-faces) for information on specifying faces.\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   faces = Faces to mask edges and corners of.\n//   r = Radius of corner mask.\n//   ---\n//   d = Diameter of corner mask.\n//   excess = Excess length to extrude the profile to make edge masks.  Default: 0.01\n//   convexity = Max number of times a line could intersect the perimeter of the mask shape.  Default: 10\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n//   `$idx` is set to the index number of each face.\n//   `$attach_anchor` is set for each edge or corner given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.\n//   `$profile_type` is set to `\"edge\"` or `\"corner\"`, depending on what is being masked.\n// Example:\n//   diff()\n//   cube([50,60,70],center=true)\n//       face_profile(TOP,r=10)\n//           mask2d_roundover(r=10);\nmodule face_profile(faces=[], r, d, excess=0.01, convexity=10) {\n    req_children($children);\n    faces = is_vector(faces)? [faces] : faces;\n    assert(all([for (face=faces) is_vector(face) && sum([for (x=face) x!=0? 1 : 0])==1]), \"Vector in faces doesn't point at a face.\");\n    r = get_radius(r=r, d=d, dflt=undef);\n    assert(is_num(r) && r>=0);\n    edge_profile(faces, excess=excess) children();\n    corner_profile(faces, convexity=convexity, r=r) children();\n}\n\n\n// Module: edge_profile()\n// Synopsis: Extrudes a 2d edge profile into a mask on the given edges of the parent.\n// SynTags: Geom\n// Topics: Attachments, Masking\n// See Also: attachable(), position(), attach(), face_profile(), edge_profile_asym(), corner_profile(), edge_mask(), face_mask(), corner_mask()\n// Usage:\n//   PARENT() edge_profile([edges], [except], [convexity]) CHILDREN;\n// Description:\n//   Takes a 2D mask shape and attaches it to the selected edges, with the appropriate orientation and\n//   extruded length to be `diff()`ed away, to give the edge a matching profile.  If no tag is set\n//   then `edge_profile` sets the tag for children to \"remove\" so that it will work with the default {{diff()}} tag.\n//   For details on specifying the edges to mask see [Specifying Edges](attachments.scad#subsection-specifying-edges).\n//   For a step-by-step\n//   explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   edges = Edges to mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: All edges.\n//   except = Edges to explicitly NOT mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: No edges.\n//   excess = Excess length to extrude the profile to make edge masks.  Default: 0.01\n//   convexity = Max number of times a line could intersect the perimeter of the mask shape.  Default: 10\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n//   `$idx` is set to the index number of each edge.\n//   `$attach_anchor` is set for each edge given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.\n//   `$profile_type` is set to `\"edge\"`.\n//   `$edge_angle` is set to the inner angle of the current edge.\n// Example:\n//   diff()\n//   cube([50,60,70],center=true)\n//       edge_profile([TOP,\"Z\"],except=[BACK,TOP+LEFT])\n//           mask2d_roundover(r=10, inset=2);\n// Example: Using $edge_angle on a Conoid\n//   diff()\n//   cyl(d1=50, d2=30, l=40, anchor=BOT) {\n//       edge_profile([TOP,BOT], excess=10, convexity=6) {\n//           mask2d_roundover(r=8, inset=1, excess=1, mask_angle=$edge_angle);\n//       }\n//   }\n// Example: Using $edge_angle on a Prismoid\n//   diff()\n//   prismoid([60,50],[30,20],h=40,shift=[-25,15]) {\n//       edge_profile(excess=10, convexity=20) {\n//           mask2d_roundover(r=5,inset=1,mask_angle=$edge_angle);\n//       }\n//   }\n\nmodule edge_profile(edges=EDGES_ALL, except=[], excess=0.01, convexity=10) {\n    req_children($children);\n    check1 = assert($parent_geom != undef, \"No object to attach to!\");\n    conoid = $parent_geom[0] == \"conoid\";\n    edges = !conoid? _edges(edges, except=except) :\n        edges==EDGES_ALL? [TOP,BOT] :\n        assert(all([for (e=edges) in_list(e,[TOP,BOT])]), \"Invalid conoid edge spec.\")\n        edges;\n    vecs = conoid\n      ? [for (e=edges) e+FWD]\n      : [\n            for (i = [0:3], axis=[0:2])\n            if (edges[axis][i]>0)\n            EDGE_OFFSETS[axis][i]\n        ];\n    all_vecs_are_edges = all([for (vec = vecs) sum(v_abs(vec))==2]);\n    check2 = assert(all_vecs_are_edges, \"All vectors must be edges.\");\n    default_tag(\"remove\")\n    for ($idx = idx(vecs)) {\n        vec = vecs[$idx];\n        anch = _find_anchor(vec, $parent_geom);\n        path_angs_T = _attach_geom_edge_path($parent_geom, vec);\n        path = path_angs_T[0];\n        vecs = path_angs_T[1];\n        post_T = path_angs_T[2];\n        $attach_to = undef;\n        $attach_anchor = anch;\n        $attach_norot = true;\n        $profile_type = \"edge\";\n        multmatrix(post_T) {\n            for (i = idx(path,e=-2)) {\n                pt1 = select(path,i);\n                pt2 = select(path,i+1);\n                cp = (pt1 + pt2) / 2;\n                v1 = vecs[i][0];\n                v2 = vecs[i][1];\n                $edge_angle = 180 - vector_angle(v1,v2);\n                if (!approx(pt1,pt2)) {\n                    seglen = norm(pt2-pt1) + 2 * excess;\n                    move(cp) {\n                        frame_map(x=-v2, z=unit(pt2-pt1)) {\n                            linear_extrude(height=seglen, center=true, convexity=convexity)\n                                mirror([-1,1]) children();\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n// Module: edge_profile_asym()\n// Synopsis: Extrudes an asymmetric 2D profile into a mask on the given edges and corners of the parent.\n// SynTags: Geom\n// Topics: Attachments, Masking\n// See Also: attachable(), position(), attach(), face_profile(), edge_profile(), corner_profile(), edge_mask(), face_mask(), corner_mask()\n// Usage:\n//   PARENT() edge_profile([edges], [except=], [convexity=], [flip=], [corner_type=]) CHILDREN;\n// Description:\n//   Takes an asymmetric 2D mask shape and attaches it to the selected edges and corners, with the appropriate\n//   orientation and extruded length to be `diff()`ed away, to give the edges and corners a matching profile.\n//   If no tag is set then `edge_profile_asym()` sets the tag for children to \"remove\" so that it will work\n//   with the default {{diff()}} tag.  For details on specifying the edges to mask see [Specifying Edges](attachments.scad#subsection-specifying-edges).\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n//   .\n//   The asymmetric profiles are joined consistently at the corners.  This is impossible if all three edges at a corner use the profile, hence\n//   this situation is not permitted.  The profile orientation can be inverted using the `flip=true` parameter.\n//   .\n//   The standard profiles are located in the first quadrant and have positive X values.  If you provide a profile located in the second quadrant,\n//   where the X values are negative, then it will produce a fillet.  You can flip any of the standard profiles using {{xflip()}}.  \n//   Fillets are always asymmetric because at a given edge, they can blend in two different directions, so even for symmetric profiles,\n//   the asymmetric logic is required.  You can set the `corner_type` parameter to select rounded, chamfered or sharp corners.\n//   However, when the corners are inside (concave) corners, you must provide the size of the profile ([width,height]), because the\n//   this information is required to produce the correct corner and cannot be obtain from the profile itself, which is a child object.  \n// Arguments:\n//   edges = Edges to mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: All edges.\n//   except = Edges to explicitly NOT mask.  See [Specifying Edges](attachments.scad#subsection-specifying-edges).  Default: No edges.\n//   excess = Excess length to extrude the profile to make edge masks.  Default: 0.01\n//   convexity = Max number of times a line could intersect the perimeter of the mask shape.  Default: 10\n//   flip = If true, reverses the orientation of any external profile parts at each edge.  Default false\n//   corner_type = Specifies how exterior corners should be formed.  Must be one of `\"none\"`, `\"chamfer\"`, `\"round\"`, or `\"sharp\"`.  Default: `\"none\"`\n//   size = If given the width and height of the 2D profile, will enable rounding and chamfering of internal corners when given a negative profile.\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n//   `$idx` is set to the index number of each edge.\n//   `$attach_anchor` is set for each edge given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.\n//   `$profile_type` is set to `\"edge\"`.\n// Example:\n//   ogee = [\n//       \"xstep\",1,  \"ystep\",1,  // Starting shoulder.\n//       \"fillet\",5, \"round\",5,  // S-curve.\n//       \"ystep\",1,  \"xstep\",1   // Ending shoulder.\n//   ];\n//   diff()\n//   cuboid(50) {\n//       edge_profile_asym(FRONT)\n//          mask2d_ogee(ogee);\n//   }\n// Example: Flipped\n//   ogee = [\n//       \"xstep\",1,  \"ystep\",1,  // Starting shoulder.\n//       \"fillet\",5, \"round\",5,  // S-curve.\n//       \"ystep\",1,  \"xstep\",1   // Ending shoulder.\n//   ];\n//   diff()\n//   cuboid(50) {\n//       edge_profile_asym(FRONT, flip=true)\n//          mask2d_ogee(ogee);\n//   }\n// Example: Negative Chamfering\n//   cuboid(50) {\n//       edge_profile_asym(FWD, flip=false)\n//           xflip() mask2d_chamfer(10);\n//       edge_profile_asym(BACK, flip=true, corner_type=\"sharp\")\n//           xflip() mask2d_chamfer(10);\n//   }\n// Example: Negative Roundings\n//   cuboid(50) {\n//       edge_profile_asym(FWD, flip=false)\n//           xflip() mask2d_roundover(10);\n//       edge_profile_asym(BACK, flip=true, corner_type=\"round\")\n//           xflip() mask2d_roundover(10);\n//   }\n// Example: Cornerless\n//   cuboid(50) {\n//       edge_profile_asym(\n//           \"ALL\", except=[TOP+FWD+RIGHT, BOT+BACK+LEFT]\n//        ) xflip() mask2d_roundover(10);\n//   }\n// Example: More complicated edge sets\n//   cuboid(50) {\n//       edge_profile_asym(\n//           [FWD,BACK,BOT+RIGHT], except=[FWD+RIGHT,BOT+BACK],\n//           corner_type=\"round\"\n//        ) xflip() mask2d_roundover(10);\n//   }\n// Example: Mixing it up a bit.\n//   diff()\n//   cuboid(60) {\n//       tag(\"keep\") edge_profile_asym(LEFT, flip=true, corner_type=\"chamfer\")\n//           xflip() mask2d_chamfer(10);\n//       edge_profile_asym(RIGHT)\n//           mask2d_roundover(10);\n//   }\n// Example: Chamfering internal corners.\n//   cuboid(40) {\n//       edge_profile_asym(\n//           [FWD+DOWN,FWD+LEFT],\n//           corner_type=\"chamfer\", size=[10,10]/sqrt(2)\n//        ) xflip() mask2d_chamfer(10);\n//   }\n// Example: Rounding internal corners.\n//   cuboid(40) {\n//       edge_profile_asym(\n//           [FWD+DOWN,FWD+LEFT],\n//           corner_type=\"round\", size=[10,10]\n//        ) xflip() mask2d_roundover(10);\n//   }\n\nmodule edge_profile_asym(\n    edges=EDGES_ALL, except=[],\n    excess=0.01, convexity=10,\n    flip=false, corner_type=\"none\",\n    size=[0,0]\n) {\n    function _corner_orientation(pos,pvec) =\n        let(\n            j = [for (i=[0:2]) if (pvec[i]) i][0],\n            T = (pos.x>0? xflip() : ident(4)) *\n                (pos.y>0? yflip() : ident(4)) *\n                (pos.z>0? zflip() : ident(4)) *\n                rot(-120*(2-j), v=[1,1,1])\n        ) T;\n\n    function _default_edge_orientation(edge) =\n        edge.z < 0? [[-edge.x,-edge.y,0], UP] :\n        edge.z > 0? [[-edge.x,-edge.y,0], DOWN] :\n        edge.y < 0? [[-edge.x,0,0], BACK] :\n        [[-edge.x,0,0], FWD] ;\n\n    function _edge_transition_needs_flip(from,to) =\n        let(\n            flip_edges = [\n                [BOT+FWD, [FWD+LEFT, FWD+RIGHT]],\n                [BOT+BACK, [BACK+LEFT, BACK+RIGHT]],\n                [BOT+LEFT, []],\n                [BOT+RIGHT, []],\n                [TOP+FWD, [FWD+LEFT, FWD+RIGHT]],\n                [TOP+BACK, [BACK+LEFT, BACK+RIGHT]],\n                [TOP+LEFT, []],\n                [TOP+RIGHT, []],\n                [FWD+LEFT, [TOP+FWD, BOT+FWD]],\n                [FWD+RIGHT, [TOP+FWD, BOT+FWD]],\n                [BACK+LEFT, [TOP+BACK, BOT+BACK]],\n                [BACK+RIGHT, [TOP+BACK, BOT+BACK]],\n            ],\n            i = search([from], flip_edges, num_returns_per_match=1)[0],\n            check = assert(i!=[], \"Bad edge vector.\")\n        ) in_list(to,flip_edges[i][1]);\n\n    function _edge_corner_numbers(vec) =\n        let(\n            v2 = [for (i=idx(vec)) vec[i]? (vec[i]+1)/2*pow(2,i) : 0],\n            off = v2.x + v2.y + v2.z,\n            xs = [0, if (!vec.x) 1],\n            ys = [0, if (!vec.y) 2],\n            zs = [0, if (!vec.z) 4]\n        ) [for (x=xs, y=ys, z=zs) x+y+z + off];\n\n    function _gather_contiguous_edges(edge_corners) =\n        let(\n            no_tri_corners = all([for(cn = [0:7]) len([for (ec=edge_corners) if(in_list(cn,ec[1])) 1])<3]),\n            check = assert(no_tri_corners, \"Cannot have three edges that meet at the same corner.\")\n        )\n        _gather_contiguous_edges_r(\n            [for (i=idx(edge_corners)) if(i) edge_corners[i]],\n            edge_corners[0][1],\n            [edge_corners[0][0]], []);\n\n    function _gather_contiguous_edges_r(edge_corners, ecns, curr, out) =\n        len(edge_corners)==0? [each out, curr] :\n        let(\n            i1 = [\n                for (i = idx(edge_corners))\n                if (in_list(ecns[0], edge_corners[i][1]))\n                i\n            ],\n            i2 = [\n                for (i = idx(edge_corners))\n                if (in_list(ecns[1], edge_corners[i][1]))\n                i\n            ]\n        ) !i1 && !i2? _gather_contiguous_edges_r(\n            [for (i=idx(edge_corners)) if(i) edge_corners[i]],\n            edge_corners[0][1],\n            [edge_corners[0][0]],\n            [each out, curr]\n        ) : let(\n            nu_curr = [\n                if (i1) edge_corners[i1[0]][0],\n                each curr,\n                if (i2) edge_corners[i2[0]][0],\n            ],\n            nu_ecns = [\n                if (!i1) ecns[0] else [\n                    for (ecn = edge_corners[i1[0]][1])\n                    if (ecn != ecns[0]) ecn\n                ][0],\n                if (!i2) ecns[1] else [\n                    for (ecn = edge_corners[i2[0]][1])\n                    if (ecn != ecns[1]) ecn\n                ][0],\n            ],\n            rem = [\n                for (i = idx(edge_corners))\n                if (i != i1[0] && i != i2[0])\n                edge_corners[i]\n            ]\n        )\n        _gather_contiguous_edges_r(rem, nu_ecns, nu_curr, out);\n\n    function _edge_transition_inversions(edge_string) =\n        let(\n            // boolean cumulative sum\n            bcs = function(list, i=0, inv=false, out=[])\n                    i>=len(list)? out :\n                    let( nu_inv = list[i]? !inv : inv )\n                    bcs(list, i+1, nu_inv, [each out, nu_inv]),\n            inverts = bcs([\n                false,\n                for(i = idx(edge_string)) if (i)\n                    _edge_transition_needs_flip(\n                        edge_string[i-1],\n                        edge_string[i]\n                    )\n            ]),\n            boti = [for(i = idx(edge_string)) if (edge_string[i].z<0) i],\n            topi = [for(i = idx(edge_string)) if (edge_string[i].z>0) i],\n            lfti = [for(i = idx(edge_string)) if (edge_string[i].x<0) i],\n            rgti = [for(i = idx(edge_string)) if (edge_string[i].x>0) i],\n            idx = [for (m = [boti, topi, lfti, rgti]) if(m) m[0]][0],\n            rinverts = inverts[idx] == false? inverts : [for (x = inverts) !x]\n        ) rinverts;\n\n    function _is_closed_edge_loop(edge_string) =\n        let(\n            e1 = edge_string[0],\n            e2 = last(edge_string)\n        )\n        len([for (i=[0:2]) if (abs(e1[i])==1 && e1[i]==e2[i]) 1]) == 1 &&\n        len([for (i=[0:2]) if (e1[i]==0 && abs(e2[i])==1) 1]) == 1 &&\n        len([for (i=[0:2]) if (e2[i]==0 && abs(e1[i])==1) 1]) == 1;\n\n    function _edge_pair_perp_vec(e1,e2) =\n        [for (i=[0:2]) if (abs(e1[i])==1 && e1[i]==e2[i]) -e1[i] else 0];\n\n    req_children($children);\n    check1 = assert($parent_geom != undef, \"No object to attach to!\")\n        assert(in_list(corner_type, [\"none\", \"round\", \"chamfer\", \"sharp\"]))\n        assert(is_bool(flip));\n    edges = _edges(edges, except=except);\n    vecs = [\n        for (i = [0:3], axis=[0:2])\n        if (edges[axis][i]>0)\n        EDGE_OFFSETS[axis][i]\n    ];\n    all_vecs_are_edges = all([for (vec = vecs) sum(v_abs(vec))==2]);\n    check2 = assert(all_vecs_are_edges, \"All vectors must be edges.\");\n    edge_corners = [for (vec = vecs) [vec, _edge_corner_numbers(vec)]];\n    edge_strings = _gather_contiguous_edges(edge_corners);\n    default_tag(\"remove\")\n    for (edge_string = edge_strings) {\n        inverts = _edge_transition_inversions(edge_string);\n        flipverts = [for (x = inverts) flip? !x : x];\n        vecpairs = [\n            for (i = idx(edge_string))\n            let (p = _default_edge_orientation(edge_string[i]))\n            flipverts[i]? [p.y,p.x] : p\n        ];\n        is_loop = _is_closed_edge_loop(edge_string);\n        for (i = idx(edge_string)) {\n            if (corner_type!=\"none\" && (i || is_loop)) {\n                e1 = select(edge_string,i-1);\n                e2 = select(edge_string,i);\n                vp1 = select(vecpairs,i-1);\n                vp2 = select(vecpairs,i);\n                pvec = _edge_pair_perp_vec(e1,e2);\n                pos = [for (i=[0:2]) e1[i]? e1[i] : e2[i]];\n                mirT = _corner_orientation(pos, pvec);\n                $attach_to = undef;\n                $attach_anchor = _find_anchor(pos, $parent_geom);\n                $attach_norot = true;\n                $profile_type = \"corner\";\n                position(pos) {\n                    multmatrix(mirT) {\n                        if (vp1.x == vp2.x && size.y > 0) {\n                            zflip() {\n                                if (corner_type==\"chamfer\") {\n                                    fn = $fn;\n                                    move([size.y,size.y]) {\n                                        rotate_extrude(angle=90, $fn=4)\n                                            left_half(planar=true, $fn=fn)\n                                                zrot(-90) fwd(size.y) children();\n                                    }\n                                    linear_extrude(height=size.x) {\n                                        mask2d_roundover(size.y, inset=0.01, $fn=4);\n                                    }\n                                } else if (corner_type==\"round\") {\n                                    move([size.y,size.y]) {\n                                        rotate_extrude(angle=90)\n                                            left_half(planar=true)\n                                                zrot(-90) fwd(size.y) children();\n                                    }\n                                    linear_extrude(height=size.x) {\n                                        mask2d_roundover(size.y, inset=0.01);\n                                    }\n                                }\n                            }\n                        } else if (vp1.y == vp2.y) {\n                            if (corner_type==\"chamfer\") {\n                                fn = $fn;\n                                rotate_extrude(angle=90, $fn=4)\n                                    right_half(planar=true, $fn=fn)\n                                        children();\n                                rotate_extrude(angle=90, $fn=4)\n                                    left_half(planar=true, $fn=fn)\n                                        children();\n                            } else if (corner_type==\"round\") {\n                                rotate_extrude(angle=90)\n                                    right_half(planar=true)\n                                        children();\n                                rotate_extrude(angle=90)\n                                    left_half(planar=true)\n                                        children();\n                            } else { //corner_type == \"sharp\"\n                                intersection() {\n                                    rot([90,0, 0]) linear_extrude(height=100,center=true,convexity=convexity) children();\n                                    rot([90,0,90]) linear_extrude(height=100,center=true,convexity=convexity) children();\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (i = idx(edge_string)) {\n            $attach_to = undef;\n            $attach_anchor = _find_anchor(edge_string[i], $parent_geom);\n            $attach_norot = true;\n            $profile_type = \"edge\";\n            edge_profile(edge_string[i], excess=excess, convexity=convexity) {\n                if (flipverts[i]) {\n                    mirror([-1,1]) children();\n                } else {\n                    children();\n                }\n            }\n        }\n    }\n}\n\n\n\n// Module: corner_profile()\n// Synopsis: Rotationally extrudes a 2d edge profile into corner mask on the given corners of the parent.\n// SynTags: Geom\n// Topics: Attachments, Masking\n// See Also: attachable(), position(), attach(), face_profile(), edge_profile(), corner_mask(), face_mask(), edge_mask()\n// Usage:\n//   PARENT() corner_profile([corners], [except], [r=|d=], [convexity=]) CHILDREN;\n// Description:\n//   Takes a 2D mask shape, rotationally extrudes and converts it into a corner mask, and attaches it\n//   to the selected corners with the appropriate orientation. If no tag is set then `corner_profile()`\n//   sets the tag for children to \"remove\" so that it will work with the default {{diff()}} tag.\n//   See [Specifying Corners](attachments.scad#subsection-specifying-corners) for information on how to specify corner sets.\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   corners = Corners to mask.  See [Specifying Corners](attachments.scad#subsection-specifying-corners).  Default: All corners.\n//   except = Corners to explicitly NOT mask.  See [Specifying Corners](attachments.scad#subsection-specifying-corners).  Default: No corners.\n//   ---\n//   r = Radius of corner mask.\n//   d = Diameter of corner mask.\n//   convexity = Max number of times a line could intersect the perimeter of the mask shape.  Default: 10\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n//   `$idx` is set to the index number of each corner.\n//   `$attach_anchor` is set for each corner given, to the `[ANCHOR, POSITION, ORIENT, SPIN]` information for that anchor.\n//   `$profile_type` is set to `\"corner\"`.\n// Example:\n//   diff()\n//   cuboid([50,60,70],rounding=10,edges=\"Z\",anchor=CENTER) {\n//       corner_profile(TOP,r=10)\n//           mask2d_teardrop(r=10, angle=40);\n//   }\nmodule corner_profile(corners=CORNERS_ALL, except=[], r, d, convexity=10) {\n    check1 = assert($parent_geom != undef, \"No object to attach to!\");\n    r = max(0.01, get_radius(r=r, d=d, dflt=undef));\n    check2 = assert(is_num(r), \"Bad r/d argument.\");\n    corners = _corners(corners, except=except);\n    vecs = [for (i = [0:7]) if (corners[i]>0) CORNER_OFFSETS[i]];\n    all_vecs_are_corners = all([for (vec = vecs) sum(v_abs(vec))==3]);\n    check3 = assert(all_vecs_are_corners, \"All vectors must be corners.\");\n    for ($idx = idx(vecs)) {\n        vec = vecs[$idx];\n        anch = _find_anchor(vec, $parent_geom);\n        $attach_to = undef;\n        $attach_anchor = anch;\n        $attach_norot = true;\n        $profile_type = \"corner\";\n        rotang = vec.z<0?\n            [  0,0,180+v_theta(vec)-45] :\n            [180,0,-90+v_theta(vec)-45];\n        default_tag(\"remove\"){\n            translate(anch[1]) {\n                rot(rotang) {\n                    down(0.01) {\n                        linear_extrude(height=r+0.01, center=false) {\n                            difference() {\n                                translate(-[0.01,0.01]) square(r);\n                                translate([r,r]) circle(r=r*0.999);\n                            }\n                        }\n                    }\n                    translate([r,r]) zrot(180) {\n                        rotate_extrude(angle=90, convexity=convexity) {\n                            right(r) xflip() {\n                                children();\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n// Section: Making your objects attachable\n\n\n// Module: attachable()\n// Synopsis: Manages the anchoring, spin, orientation, and attachments for an object.\n// Topics: Attachments\n// See Also: reorient()\n// Usage: Square/Trapezoid Geometry\n//   attachable(anchor, spin, two_d=true, size=, [size2=], [shift=], [override=], ...) {OBJECT; children();}\n// Usage: Circle/Oval Geometry\n//   attachable(anchor, spin, two_d=true, r=|d=, ...) {OBJECT; children();}\n// Usage: 2D Path/Polygon Geometry\n//   attachable(anchor, spin, two_d=true, path=, [extent=], ...) {OBJECT; children();}\n// Usage: 2D Region Geometry\n//   attachable(anchor, spin, two_d=true, region=, [extent=], ...) {OBJECT; children();}\n// Usage: Cubical/Prismoidal Geometry\n//   attachable(anchor, spin, [orient], size=, [size2=], [shift=], [override=],  ...) {OBJECT; children();}\n// Usage: Cylindrical Geometry\n//   attachable(anchor, spin, [orient], r=|d=, l=, [axis=], ...) {OBJECT; children();}\n// Usage: Conical Geometry\n//   attachable(anchor, spin, [orient], r1=|d1=, r2=|d2=, l=, [axis=], ...) {OBJECT; children();}\n// Usage: Spheroid/Ovoid Geometry\n//   attachable(anchor, spin, [orient], r=|d=, ...) {OBJECT; children();}\n// Usage: Extruded Path/Polygon Geometry\n//   attachable(anchor, spin, path=, l=|h=, [extent=], ...) {OBJECT; children();}\n// Usage: Extruded Region Geometry\n//   attachable(anchor, spin, region=, l=|h=, [extent=], ...) {OBJECT; children();}\n// Usage: VNF Geometry\n//   attachable(anchor, spin, [orient], vnf=, [extent=], ...) {OBJECT; children();}\n// Usage: Pre-Specified Geometry\n//   attachable(anchor, spin, [orient], geom=) {OBJECT; children();}\n//\n// Description:\n//   Manages the anchoring, spin, orientation, and attachments for OBJECT, located in a 3D volume or 2D area.\n//   A managed 3D volume is assumed to be vertically (Z-axis) oriented, and centered.\n//   A managed 2D area is just assumed to be centered.  The shape to be managed is given\n//   as the first child to this module, and the second child should be given as `children()`.\n//   For example, to manage a conical shape:\n//   ```openscad\n//   attachable(anchor, spin, orient, r1=r1, r2=r2, l=h) {\n//       cyl(r1=r1, r2=r2, l=h);\n//       children();\n//   }\n//   ```\n//   .\n//   If this is *not* run as a child of `attach()` with the `to` argument\n//   given, then the following transformations are performed in order:\n//   * Translates so the `anchor` point is at the origin (0,0,0).\n//   * Rotates around the Z axis by `spin` degrees counter-clockwise.\n//   * Rotates so the top of the part points towards the vector `orient`.\n//   .\n//   If this is called as a child of `attach(from,to)`, then the info\n//   for the anchor points referred to by `from` and `to` are fetched,\n//   which will include position, direction, and spin.  With that info,\n//   the following transformations are performed:\n//   * Translates this part so it's anchor position matches the parent's anchor position.\n//   * Rotates this part so it's anchor direction vector exactly opposes the parent's anchor direction vector.\n//   * Rotates this part so it's anchor spin matches the parent's anchor spin.\n//   .\n//   This module is also responsible for handing coloring of objects with {{recolor()}} and {{color_this()}}, and\n//   it is responsible for processing tags and determining whether the object should\n//   display or not in the current context.  The determination to display the attachable object\n//   usually occurs in this module, which means that an object which does not display (e.g. a \"remove\" tagged object\n//   inside {{diff()}} cannot have internal {{tag()}} calls that change its tags and cause submodel\n//   portions to display: the entire object simply does not run.  If you want the attachable object internal tags to be respected,\n//   you can set `use_child_tags=true` which delays the determination to display objects to the children.\n//   For this to work correctly, all of the children must be attachables.\n//   .\n//   Application of {{recolor()}} and {{color_this()}} also happens in this module and normally it applies to the\n//   entire attachable object, so coloring commands that you give in the first child to `attachable()` have no effect.\n//   Generally it makes sense that if a user specifies a color for an attachable object, the entire object is displayed\n//   in that color, but if you want to retain control of color for sub-parts of an attachable object, you can use\n//   the `use_child_color=true` option, which delays the assignment of colors to the child level.  For this to work\n//   correctly, all of the sub-parts of your attachable object must be attachables.  Also note that this option could\n//   be confusing to users who don't understand why color commands are not working on the object.  \n//   .\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n//\n// Arguments:\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   ---\n//   size = If given as a 3D vector, contains the XY size of the bottom of the cuboidal/prismoidal volume, and the Z height.  If given as a 2D vector, contains the front X width of the rectangular/trapezoidal shape, and the Y length.\n//   size2 = If given as a 2D vector, contains the XY size of the top of the prismoidal volume.  If given as a number, contains the back width of the trapezoidal shape.\n//   shift = If given as a 2D vector, shifts the top of the prismoidal or conical shape by the given amount.  If given as a number, shifts the back of the trapezoidal shape right by that amount.  Default: No shift.\n//   r = Radius of the cylindrical/conical volume.  Can be a scalar, or a list of sizes per axis.\n//   d = Diameter of the cylindrical/conical volume.  Can be a scalar, or a list of sizes per axis.\n//   r1 = Radius of the bottom of the conical volume.  Can be a scalar, or a list of sizes per axis.\n//   r2 = Radius of the top of the conical volume.  Can be a scalar, or a list of sizes per axis.\n//   d1 = Diameter of the bottom of the conical volume.  Can be a scalar, a list of sizes per axis.\n//   d2 = Diameter of the top of the conical volume.  Can be a scalar, a list of sizes per axis.\n//   l/h = Length of the cylindrical, conical, or extruded path volume along axis.\n//   vnf = The [VNF](vnf.scad) of the volume.\n//   path = The path to generate a polygon from.\n//   region = The region to generate a shape from.\n//   extent = If true, calculate anchors by extents, rather than intersection, for VNFs and paths.  Default: true.\n//   cp = If given, specifies the centerpoint of the volume.  Default: `[0,0,0]`\n//   offset = If given, offsets the perimeter of the volume around the centerpoint.\n//   anchors = If given as a list of anchor points, allows named anchor points.\n//   two_d = If true, the attachable shape is 2D.  If false, 3D.  Default: false (3D)\n//   axis = The vector pointing along the axis of a geometry.  Default: UP\n//   override = Function that takes an anchor and for 3d returns a triple `[position, direction, spin]` or for 2d returns a pair `[position,direction]` to use for that anchor to override the normal one.  You can also supply a lookup table that is a list of `[anchor, [position, direction, spin]]` entries.  If the direction/position/spin that is returned is undef then the default will be used.  This option applies only to the \"trapezoid\" and \"prismoid\" geometry types.  \n//   geom = If given, uses the pre-defined (via {{attach_geom()}} geometry.\n//   use_child_tags = if true then delay the decision to display or not display this object to the children.  Default: false\n//\n// Side Effects:\n//   `$parent_anchor` is set to the parent object's `anchor` value.\n//   `$parent_spin` is set to the parent object's `spin` value.\n//   `$parent_orient` is set to the parent object's `orient` value.\n//   `$parent_geom` is set to the parent object's `geom` value.\n//   `$parent_size` is set to the parent object's cubical `[X,Y,Z]` volume size.\n//   `$color` is used to set the color of the object\n//   `$save_color` is used to revert color to the parent's color\n//\n// Example(NORENDER): Cubical Shape\n//   attachable(anchor, spin, orient, size=size) {\n//       cube(size, center=true);\n//       children();\n//   }\n//\n// Example(NORENDER): Prismoidal Shape\n//   attachable(\n//       anchor, spin, orient,\n//       size=point3d(botsize,h),\n//       size2=topsize,\n//       shift=shift\n//   ) {\n//       prismoid(botsize, topsize, h=h, shift=shift);\n//       children();\n//   }\n//\n// Example(NORENDER): Cylindrical Shape, Z-Axis Aligned\n//   attachable(anchor, spin, orient, r=r, l=h) {\n//       cyl(r=r, l=h);\n//       children();\n//   }\n//\n// Example(NORENDER): Cylindrical Shape, Y-Axis Aligned\n//   attachable(anchor, spin, orient, r=r, l=h, axis=BACK) {\n//       cyl(r=r, l=h);\n//       children();\n//   }\n//\n// Example(NORENDER): Cylindrical Shape, X-Axis Aligned\n//   attachable(anchor, spin, orient, r=r, l=h, axis=RIGHT) {\n//       cyl(r=r, l=h);\n//       children();\n//   }\n//\n// Example(NORENDER): Conical Shape, Z-Axis Aligned\n//   attachable(anchor, spin, orient, r1=r1, r2=r2, l=h) {\n//       cyl(r1=r1, r2=r2, l=h);\n//       children();\n//   }\n//\n// Example(NORENDER): Conical Shape, Y-Axis Aligned\n//   attachable(anchor, spin, orient, r1=r1, r2=r2, l=h, axis=BACK) {\n//       cyl(r1=r1, r2=r2, l=h);\n//       children();\n//   }\n//\n// Example(NORENDER): Conical Shape, X-Axis Aligned\n//   attachable(anchor, spin, orient, r1=r1, r2=r2, l=h, axis=RIGHT) {\n//       cyl(r1=r1, r2=r2, l=h);\n//       children();\n//   }\n//\n// Example(NORENDER): Spherical Shape\n//   attachable(anchor, spin, orient, r=r) {\n//       sphere(r=r);\n//       children();\n//   }\n//\n// Example(NORENDER): Extruded Polygon Shape, by Extents\n//   attachable(anchor, spin, orient, path=path, l=length) {\n//       linear_extrude(height=length, center=true)\n//           polygon(path);\n//       children();\n//   }\n//\n// Example(NORENDER): Extruded Polygon Shape, by Intersection\n//   attachable(anchor, spin, orient, path=path, l=length, extent=false) {\n//       linear_extrude(height=length, center=true)\n//           polygon(path);\n//       children();\n//   }\n//\n// Example(NORENDER): Arbitrary VNF Shape, by Extents\n//   attachable(anchor, spin, orient, vnf=vnf) {\n//       vnf_polyhedron(vnf);\n//       children();\n//   }\n//\n// Example(NORENDER): Arbitrary VNF Shape, by Intersection\n//   attachable(anchor, spin, orient, vnf=vnf, extent=false) {\n//       vnf_polyhedron(vnf);\n//       children();\n//   }\n//\n// Example(NORENDER): 2D Rectangular Shape\n//   attachable(anchor, spin, orient, two_d=true, size=size) {\n//       square(size, center=true);\n//       children();\n//   }\n//\n// Example(NORENDER): 2D Trapezoidal Shape\n//   attachable(\n//       anchor, spin, orient,\n//       two_d=true,\n//       size=[x1,y],\n//       size2=x2,\n//       shift=shift\n//   ) {\n//       trapezoid(w1=x1, w2=x2, h=y, shift=shift);\n//       children();\n//   }\n//\n// Example(NORENDER): 2D Circular Shape\n//   attachable(anchor, spin, orient, two_d=true, r=r) {\n//       circle(r=r);\n//       children();\n//   }\n//\n// Example(NORENDER): Arbitrary 2D Polygon Shape, by Extents\n//   attachable(anchor, spin, orient, two_d=true, path=path) {\n//       polygon(path);\n//       children();\n//   }\n//\n// Example(NORENDER): Arbitrary 2D Polygon Shape, by Intersection\n//   attachable(anchor, spin, orient, two_d=true, path=path, extent=false) {\n//       polygon(path);\n//       children();\n//   }\n//\n// Example(NORENDER): Using Pre-defined Geometry\n//   geom = atype==\"perim\"? attach_geom(two_d=true, path=path, extent=false) :\n//       atype==\"extents\"? attach_geom(two_d=true, path=path, extent=true) :\n//       atype==\"circle\"? attach_geom(two_d=true, r=r) :\n//       assert(false, \"Bad atype\");\n//   attachable(anchor, spin, orient, geom=geom) {\n//       polygon(path);\n//       children();\n//   }\n//\n// Example: An object can be designed to attach as negative space using {{diff()}}, but if you want an object to include both positive and negative space then you run into trouble because tags inside the `attachable()` are ignored.  One solution is to call attachable() twice.  This example shows how two calls to  attachable can create an object with positive and negative space.  Note, however, that children in the negative space are differenced away: the highlighted little cube does not survive into the final model.\n//   module thing(anchor,spin,orient) {\n//      tag(\"remove\") attachable(size=[15,15,15],anchor=anchor,spin=spin,orient=orient){\n//        cuboid([10,10,16]);\n//        union(){}   // dummy children\n//      }\n//      attachable(size=[15,15,15], anchor=anchor, spin=spin, orient=orient){\n//        cuboid([15,15,15]);\n//        children();\n//      }\n//   }\n//   diff()\n//     cube([19,10,19])\n//       attach([FRONT],overlap=-4)\n//         thing(anchor=TOP)\n//           # attach(TOP) cuboid(2,anchor=TOP);\n// Example: Here is an example where the \"keep\" tag allows children to appear in the negative space.  That tag is also needed for this module to produce the desired output.  As above, the tag must be applied outside the attachable() call.\n//   module thing(anchor = CENTER, spin = 0, orient = UP) {\n//      tag(\"remove\") attachable(anchor, spin, orient, d1=0,d2=95,h=33) {\n//          cylinder(h = 33.1, d1 = 0, d2 = 95, anchor=CENTER);\n//          union(){}  // dummy children\n//      }\n//      tag(\"keep\") attachable(anchor, spin, orient,d1=0,d2=95,h=33) {\n//            cylinder(h = 33, d = 10,anchor=CENTER);\n//            children();\n//        }\n//    }\n//    diff()\n//      cube(100)\n//        attach([FRONT,TOP],overlap=-4)\n//          thing(anchor=TOP)\n//            tube(ir=12,h=10);\n// Example: A different way to achieve similar effects to the above to examples is to use the `use_child_tags` parameter.  This parameter allows you to use just one call to attachable.  The second example above can also be rewritten like this. \n//   module thing(anchor,spin,orient) {\n//      attachable(size=[15,15,15],anchor=anchor,spin=spin,orient=orient,use_child_tags=true){\n//        union(){\n//          cuboid([15,15,15]);\n//          tag(\"remove\")cuboid([10,10,16]);\n//        }\n//        children();\n//      }\n//   }\n//   diff()\n//     cube([19,10,19])\n//       attach([FRONT],overlap=-4)\n//         thing(anchor=TOP);\n// Example: An advantage of using `use_child_tags` is that it can work on nested constructions.  Here the child cylinder is aligned relative to its parent and removed from the calling parent object.\n//   $fn=64;\n//   module thing(anchor=BOT){\n//     attachable(anchor = anchor,d=9,h=6,use_child_tags=true){\n//       cyl(d = 9, h = 6) \n//         tag(\"remove\") \n//            align(RIGHT+TOP,inside=true) \n//                 left(1)up(1)cyl(l=11, d=3);\n//       children();\n//     }\n//   }\n//   back_half()\n//     diff()\n//       cuboid(10)\n//         position(TOP)thing(anchor=BOT);\n// Example(3D,NoAxes): Here an attachable module uses {{recolor()}} to change the color of a sub-part, producing the result shown on the left.  But if the caller applies color to the attachable, then both the green and yellow are changed, as shown on the right.  \n//   module thing(anchor=CENTER) {\n//       attachable(anchor,size=[10,10,10]) {\n//           cuboid(10)\n//             position(TOP) recolor(\"green\")\n//               cuboid(5,anchor=BOT);\n//           children();\n//       }\n//   }\n//   move([-15,-15])\n//   thing()\n//     attach(RIGHT,BOT)\n//       recolor(\"blue\") cyl(d=5,h=5);\n//   recolor(\"pink\") thing()\n//     attach(RIGHT,BOT)\n//       recolor(\"blue\") cyl(d=5,h=5);\n// Example(3D,NoAxes): Using the `use_child_color=true` option enables the green color to persist, even when the user specifies a color.\n//   module thing(anchor=CENTER) {\n//       attachable(anchor,size=[10,10,10],use_child_color=true) {\n//           cuboid(10)\n//             position(TOP) recolor(\"green\")\n//               cuboid(5,anchor=BOT);\n//           children();\n//       }\n//   }\n//   recolor(\"pink\") thing()\n//     attach(RIGHT,BOT)\n//       recolor(\"blue\") cyl(d=5,h=5);\n\nmodule attachable(\n    anchor, spin, orient,\n    size, size2, shift,\n    r,r1,r2, d,d1,d2, l,h,\n    vnf, path, region,\n    extent=true,\n    cp=[0,0,0],\n    offset=[0,0,0],\n    anchors=[],\n    two_d=false,\n    axis=UP,override,\n    geom,\n    use_child_tags=false, use_child_color=false\n) { \n    dummy1 =\n        assert($children==2, \"attachable() expects exactly two children; the shape to manage, and the union of all attachment candidates.\")\n        assert(is_undef(anchor) || is_vector(anchor) || is_string(anchor), str(\"Got: \",anchor))\n        assert(is_undef(spin)   || is_vector(spin,3) || is_num(spin), str(\"Got: \",spin))\n        assert(is_undef(orient) || is_vector(orient,3), str(\"Got: \",orient));\n    anchor = first_defined([$anchor_override, anchor, CENTER]);\n    spin =   default(spin,   0);\n    orient = is_def($anchor_override)? UP : default(orient, UP);\n    region = !is_undef(region)? region :\n        !is_undef(path)? [path] :\n        undef;\n    geom = is_def(geom)? geom :\n        attach_geom(\n            size=size, size2=size2, shift=shift,\n            r=r, r1=r1, r2=r2, h=h,\n            d=d, d1=d1, d2=d2, l=l,\n            vnf=vnf, region=region, extent=extent,\n            cp=cp, offset=offset, anchors=anchors,\n            two_d=two_d, axis=axis, override=override\n        );\n    m = _attach_transform(anchor,spin,orient,geom);\n    multmatrix(m) {\n        $parent_anchor = anchor;\n        $parent_spin   = spin;\n        $parent_orient = orient;\n        $parent_geom   = geom;\n        $parent_size   = _attach_geom_size(geom);\n        $attach_to   = undef;\n        $anchor_override=undef;\n        if (use_child_tags || _is_shown()){\n           if (!use_child_color)\n            _color($color) children(0);\n           else\n               children(0);\n        }\n        if (is_def($save_color)) {\n            $color=$save_color;\n            $save_color=undef;\n            children(1);\n        }\n        else children(1);\n    }\n}\n\n// Function: reorient()\n// Synopsis: Calculates the transformation matrix needed to reorient an object.\n// SynTags: Trans, Path, VNF\n// Topics: Attachments\n// See Also: reorient(), attachable()\n// Usage: Square/Trapezoid Geometry\n//   mat = reorient(anchor, spin, [orient], two_d=true, size=, [size2=], [shift=], ...);\n//   pts = reorient(anchor, spin, [orient], two_d=true, size=, [size2=], [shift=], p=, ...);\n// Usage: Circle/Oval Geometry\n//   mat = reorient(anchor, spin, [orient], two_d=true, r=|d=, ...);\n//   pts = reorient(anchor, spin, [orient], two_d=true, r=|d=, p=, ...);\n// Usage: 2D Path/Polygon Geometry\n//   mat = reorient(anchor, spin, [orient], two_d=true, path=, [extent=], ...);\n//   pts = reorient(anchor, spin, [orient], two_d=true, path=, [extent=], p=, ...);\n// Usage: 2D Region/Polygon Geometry\n//   mat = reorient(anchor, spin, [orient], two_d=true, region=, [extent=], ...);\n//   pts = reorient(anchor, spin, [orient], two_d=true, region=, [extent=], p=, ...);\n// Usage: Cubical/Prismoidal Geometry\n//   mat = reorient(anchor, spin, [orient], size=, [size2=], [shift=], ...);\n//   vnf = reorient(anchor, spin, [orient], size=, [size2=], [shift=], p=, ...);\n// Usage: Cylindrical Geometry\n//   mat = reorient(anchor, spin, [orient], r=|d=, l=, [axis=], ...);\n//   vnf = reorient(anchor, spin, [orient], r=|d=, l=, [axis=], p=, ...);\n// Usage: Conical Geometry\n//   mat = reorient(anchor, spin, [orient], r1=|d1=, r2=|d2=, l=, [axis=], ...);\n//   vnf = reorient(anchor, spin, [orient], r1=|d1=, r2=|d2=, l=, [axis=], p=, ...);\n// Usage: Spheroid/Ovoid Geometry\n//   mat = reorient(anchor, spin, [orient], r|d=, ...);\n//   vnf = reorient(anchor, spin, [orient], r|d=, p=, ...);\n// Usage: Extruded Path/Polygon Geometry\n//   mat = reorient(anchor, spin, [orient], path=, l=|h=, [extent=], ...);\n//   vnf = reorient(anchor, spin, [orient], path=, l=|h=, [extent=], p=, ...);\n// Usage: Extruded Region Geometry\n//   mat = reorient(anchor, spin, [orient], region=, l=|h=, [extent=], ...);\n//   vnf = reorient(anchor, spin, [orient], region=, l=|h=, [extent=], p=, ...);\n// Usage: VNF Geometry\n//   mat = reorient(anchor, spin, [orient], vnf, [extent], ...);\n//   vnf = reorient(anchor, spin, [orient], vnf, [extent], p=, ...);\n//\n// Description:\n//   Given anchor, spin, orient, and general geometry info for a managed volume, this calculates\n//   the transformation matrix needed to be applied to the contents of that volume.  A managed 3D\n//   volume is assumed to be vertically (Z-axis) oriented, and centered.  A managed 2D area is just\n//   assumed to be centered.\n//   .\n//   If `p` is not given, then the transformation matrix will be returned.\n//   If `p` contains a VNF, a new VNF will be returned with the vertices transformed by the matrix.\n//   If `p` contains a path, a new path will be returned with the vertices transformed by the matrix.\n//   If `p` contains a point, a new point will be returned, transformed by the matrix.\n//   .\n//   If `$attach_to` is not defined, then the following transformations are performed in order:\n//   * Translates so the `anchor` point is at the origin (0,0,0).\n//   * Rotates around the Z axis by `spin` degrees counter-clockwise.\n//   * Rotates so the top of the part points towards the vector `orient`.\n//   .\n//   If `$attach_to` is defined, as a consequence of `attach(from,to)`, then\n//   the following transformations are performed in order:\n//   * Translates this part so it's anchor position matches the parent's anchor position.\n//   * Rotates this part so it's anchor direction vector exactly opposes the parent's anchor direction vector.\n//   * Rotates this part so it's anchor spin matches the parent's anchor spin.\n//   .\n//   For a step-by-step explanation of attachments, see the [Attachments Tutorial](Tutorial-Attachments).\n//\n// Arguments:\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   ---\n//   size = If given as a 3D vector, contains the XY size of the bottom of the cuboidal/prismoidal volume, and the Z height.  If given as a 2D vector, contains the front X width of the rectangular/trapezoidal shape, and the Y length.\n//   size2 = If given as a 2D vector, contains the XY size of the top of the prismoidal volume.  If given as a number, contains the back width of the trapezoidal shape.\n//   shift = If given as a 2D vector, shifts the top of the prismoidal or conical shape by the given amount.  If given as a number, shifts the back of the trapezoidal shape right by that amount.  Default: No shift.\n//   r = Radius of the cylindrical/conical volume.  Can be a scalar, or a list of sizes per axis.\n//   d = Diameter of the cylindrical/conical volume.  Can be a scalar, or a list of sizes per axis.\n//   r1 = Radius of the bottom of the conical volume.  Can be a scalar, or a list of sizes per axis.\n//   r2 = Radius of the top of the conical volume.  Can be a scalar, or a list of sizes per axis.\n//   d1 = Diameter of the bottom of the conical volume.  Can be a scalar, a list of sizes per axis.\n//   d2 = Diameter of the top of the conical volume.  Can be a scalar, a list of sizes per axis.\n//   l/h = Length of the cylindrical, conical, or extruded path volume along axis.\n//   vnf = The [VNF](vnf.scad) of the volume.\n//   path = The path to generate a polygon from.\n//   region = The region to generate a shape from.\n//   extent = If true, calculate anchors by extents, rather than intersection.  Default: false.\n//   cp = If given, specifies the centerpoint of the volume.  Default: `[0,0,0]`\n//   offset = If given, offsets the perimeter of the volume around the centerpoint.\n//   anchors = If given as a list of anchor points, allows named anchor points.\n//   two_d = If true, the attachable shape is 2D.  If false, 3D.  Default: false (3D)\n//   axis = The vector pointing along the axis of a geometry.  Default: UP\n//   p = The VNF, path, or point to transform.\nfunction reorient(\n    anchor, spin, orient,\n    size, size2, shift,\n    r,r1,r2, d,d1,d2, l,h,\n    vnf, path, region,\n    extent=true,\n    offset=[0,0,0],\n    cp=[0,0,0],\n    anchors=[],\n    two_d=false,\n    axis=UP, override, \n    geom,\n    p=undef\n) =\n    assert(is_undef(anchor) || is_vector(anchor) || is_string(anchor), str(\"Got: \",anchor))\n    assert(is_undef(spin)   || is_vector(spin,3) || is_num(spin), str(\"Got: \",spin))\n    assert(is_undef(orient) || is_vector(orient,3), str(\"Got: \",orient))\n    let(\n        anchor = default(anchor, CENTER),\n        spin =   default(spin,   0),\n        orient = default(orient, UP),\n        region = !is_undef(region)? region :\n            !is_undef(path)? [path] :\n            undef,\n        geom = is_def(geom)? geom :\n            attach_geom(\n                size=size, size2=size2, shift=shift,\n                r=r, r1=r1, r2=r2, h=h,\n                d=d, d1=d1, d2=d2, l=l,\n                vnf=vnf, region=region, extent=extent,\n                cp=cp, offset=offset, anchors=anchors,\n                two_d=two_d, axis=axis, override=override\n            ),\n        $attach_to = undef\n    ) _attach_transform(anchor,spin,orient,geom,p);\n\n\n// Function: named_anchor()\n// Synopsis: Creates an anchor data structure.\n// Topics: Attachments\n// See Also: reorient(), attachable()\n// Usage:\n//   a = named_anchor(name, pos, [orient], [spin]);\n// Description:\n//   Creates an anchor data structure.  For a step-by-step explanation of attachments,\n//   see the [Attachments Tutorial](Tutorial-Attachments).\n// Arguments:\n//   name = The string name of the anchor.  Lowercase.  Words separated by single dashes.  No spaces.\n//   pos = The [X,Y,Z] position of the anchor.\n//   orient = A vector pointing in the direction parts should project from the anchor position.  Default: UP\n//   spin = If needed, the angle to rotate the part around the direction vector.  Default: 0\nfunction named_anchor(name, pos, orient=UP, spin=0) = [name, pos, orient, spin];\n\n\n// Function: attach_geom()\n// Synopsis: Returns the internal geometry description of an attachable object.\n// Topics: Attachments\n// See Also: reorient(), attachable()\n// Usage: Null/Point Geometry\n//   geom = attach_geom(...);\n// Usage: Square/Trapezoid Geometry\n//   geom = attach_geom(two_d=true, size=, [size2=], [shift=], ...);\n// Usage: Circle/Oval Geometry\n//   geom = attach_geom(two_d=true, r=|d=, ...);\n// Usage: 2D Path/Polygon/Region Geometry\n//   geom = attach_geom(two_d=true, region=, [extent=], ...);\n// Usage: Cubical/Prismoidal Geometry\n//   geom = attach_geom(size=, [size2=], [shift=], ...);\n// Usage: Cylindrical Geometry\n//   geom = attach_geom(r=|d=, l=|h=, [axis=], ...);\n// Usage: Conical Geometry\n//   geom = attach_geom(r1|d1=, r2=|d2=, l=, [axis=], ...);\n// Usage: Spheroid/Ovoid Geometry\n//   geom = attach_geom(r=|d=, ...);\n// Usage: Extruded 2D Path/Polygon/Region Geometry\n//   geom = attach_geom(region=, l=|h=, [extent=], [shift=], [scale=], [twist=], ...);\n// Usage: VNF Geometry\n//   geom = attach_geom(vnf=, [extent=], ...);\n//\n// Description:\n//   Given arguments that describe the geometry of an attachable object, returns the internal geometry description.\n//   This will probably not not ever need to be called by the end user.\n//\n// Arguments:\n//   ---\n//   size = If given as a 3D vector, contains the XY size of the bottom of the cuboidal/prismoidal volume, and the Z height.  If given as a 2D vector, contains the front X width of the rectangular/trapezoidal shape, and the Y length.\n//   size2 = If given as a 2D vector, contains the XY size of the top of the prismoidal volume.  If given as a number, contains the back width of the trapezoidal shape.\n//   shift = If given as a 2D vector, shifts the top of the prismoidal or conical shape by the given amount.  If given as a number, shifts the back of the trapezoidal shape right by that amount.  Default: No shift.\n//   scale = If given as number or a 2D vector, scales the top of the shape, relative to the bottom.  Default: `[1,1]`\n//   twist = If given as number, rotates the top of the shape by the given number of degrees clockwise, relative to the bottom.  Default: `0`\n//   r = Radius of the cylindrical/conical volume.  Can be a scalar, or a list of sizes per axis.\n//   d = Diameter of the cylindrical/conical volume.  Can be a scalar, or a list of sizes per axis.\n//   r1 = Radius of the bottom of the conical volume.  Can be a scalar, or a list of sizes per axis.\n//   r2 = Radius of the top of the conical volume.  Can be a scalar, or a list of sizes per axis.\n//   d1 = Diameter of the bottom of the conical volume.  Can be a scalar, a list of sizes per axis.\n//   d2 = Diameter of the top of the conical volume.  Can be a scalar, a list of sizes per axis.\n//   l/h = Length of the cylindrical, conical or extruded region volume along axis.\n//   vnf = The [VNF](vnf.scad) of the volume.\n//   region = The region to generate a shape from.\n//   extent = If true, calculate anchors by extents, rather than intersection.  Default: true.\n//   cp = If given, specifies the centerpoint of the volume.  Default: `[0,0,0]`\n//   offset = If given, offsets the perimeter of the volume around the centerpoint.\n//   anchors = If given as a list of anchor points, allows named anchor points.\n//   two_d = If true, the attachable shape is 2D.  If false, 3D.  Default: false (3D)\n//   axis = The vector pointing along the axis of a geometry.  Default: UP\n//   override = Function that takes an anchor and returns a pair `[position,direction]` to use for that anchor to override the normal one.  You can also supply a lookup table that is a list of `[anchor, [position, direction]]` entries.  If the direction/position that is returned is undef then the default will be used.\n//\n// Example(NORENDER): Null/Point Shape\n//   geom = attach_geom();\n//\n// Example(NORENDER): Cubical Shape\n//   geom = attach_geom(size=size);\n//\n// Example(NORENDER): Prismoidal Shape\n//   geom = attach_geom(\n//       size=point3d(botsize,h),\n//       size2=topsize, shift=shift\n//   );\n//\n// Example(NORENDER): Cylindrical Shape, Z-Axis Aligned\n//   geom = attach_geom(r=r, h=h);\n//\n// Example(NORENDER): Cylindrical Shape, Y-Axis Aligned\n//   geom = attach_geom(r=r, h=h, axis=BACK);\n//\n// Example(NORENDER): Cylindrical Shape, X-Axis Aligned\n//   geom = attach_geom(r=r, h=h, axis=RIGHT);\n//\n// Example(NORENDER): Conical Shape, Z-Axis Aligned\n//   geom = attach_geom(r1=r1, r2=r2, h=h);\n//\n// Example(NORENDER): Conical Shape, Y-Axis Aligned\n//   geom = attach_geom(r1=r1, r2=r2, h=h, axis=BACK);\n//\n// Example(NORENDER): Conical Shape, X-Axis Aligned\n//   geom = attach_geom(r1=r1, r2=r2, h=h, axis=RIGHT);\n//\n// Example(NORENDER): Spherical Shape\n//   geom = attach_geom(r=r);\n//\n// Example(NORENDER): Ovoid Shape\n//   geom = attach_geom(r=[r_x, r_y, r_z]);\n//\n// Example(NORENDER): Arbitrary VNF Shape, Anchored by Extents\n//   geom = attach_geom(vnf=vnf);\n//\n// Example(NORENDER): Arbitrary VNF Shape, Anchored by Intersection\n//   geom = attach_geom(vnf=vnf, extent=false);\n//\n// Example(NORENDER): 2D Rectangular Shape\n//   geom = attach_geom(two_d=true, size=size);\n//\n// Example(NORENDER): 2D Trapezoidal Shape\n//   geom = attach_geom(two_d=true, size=[x1,y], size2=x2, shift=shift, override=override);\n//\n// Example(NORENDER): 2D Circular Shape\n//   geom = attach_geom(two_d=true, r=r);\n//\n// Example(NORENDER): 2D Oval Shape\n//   geom = attach_geom(two_d=true, r=[r_x, r_y]);\n//\n// Example(NORENDER): Arbitrary 2D Region Shape, Anchored by Extents\n//   geom = attach_geom(two_d=true, region=region);\n//\n// Example(NORENDER): Arbitrary 2D Region Shape, Anchored by Intersection\n//   geom = attach_geom(two_d=true, region=region, extent=false);\n//\n// Example(NORENDER): Extruded Region, Anchored by Extents\n//   geom = attach_geom(region=region, l=height);\n//\n// Example(NORENDER): Extruded Region, Anchored by Intersection\n//   geom = attach_geom(region=region, l=length, extent=false);\n//\n\nfunction _local_struct_val(struct, key)=\n    assert(is_def(key),\"key is missing\")\n    let(ind = search([key],struct)[0])\n    ind == [] ? undef : struct[ind][1];\n\n\nfunction attach_geom(\n    size, size2,\n    shift, scale, twist,\n    r,r1,r2, d,d1,d2, l,h,\n    vnf, region,\n    extent=true,\n    cp=[0,0,0],\n    offset=[0,0,0],\n    anchors=[],\n    two_d=false,\n    axis=UP, override\n) =\n    assert(is_bool(extent))\n    assert(is_vector(cp) || is_string(cp))\n    assert(is_vector(offset))\n    assert(is_list(anchors))\n    assert(is_bool(two_d))\n    assert(is_vector(axis))\n    !is_undef(size)? (\n        let(\n            over_f = is_undef(override) ? function(anchor) [undef,undef,undef]\n                   : is_func(override) ? override\n                   : function(anchor) _local_struct_val(override,anchor)\n        )\n        two_d? (\n            let(\n                size2 = default(size2, size.x),\n                shift = default(shift, 0)\n            )\n            assert(is_vector(size,2))\n            assert(is_num(size2))\n            assert(is_num(shift))\n            [\"trapezoid\", point2d(size), size2, shift, over_f, cp, offset, anchors]\n        ) : (\n            let(\n                size2 = default(size2, point2d(size)),\n                shift = default(shift, [0,0])\n            )\n            assert(is_vector(size,3))\n            assert(is_vector(size2,2))\n            assert(is_vector(shift,2))\n            [\"prismoid\", size, size2, shift, axis, over_f, cp, offset, anchors]\n        )\n    ) : !is_undef(vnf)? (\n        assert(is_vnf(vnf))\n        assert(two_d == false)\n        extent? [\"vnf_extent\", vnf, cp, offset, anchors] :\n        [\"vnf_isect\", vnf, cp, offset, anchors]\n    ) : !is_undef(region)? (\n        assert(is_region(region),2)\n        let( l = default(l, h) )\n        two_d==true\n          ? assert(is_undef(l))\n            extent==true\n              ? [\"rgn_extent\", region, cp, offset, anchors]\n              : [\"rgn_isect\",  region, cp, offset, anchors]\n          : assert(is_finite(l))\n            let(\n                shift = default(shift, [0,0]),\n                scale = is_num(scale)? [scale,scale] : default(scale, [1,1]),\n                twist = default(twist, 0)\n            )\n            assert(is_vector(shift,2))\n            assert(is_vector(scale,2))\n            assert(is_num(twist))\n            extent==true\n              ? [\"extrusion_extent\", region, l, twist, scale, shift, cp, offset, anchors]\n              : [\"extrusion_isect\",  region, l, twist, scale, shift, cp, offset, anchors]\n    ) :\n    let(\n        r1 = get_radius(r1=r1,d1=d1,r=r,d=d,dflt=undef)\n    )\n    !is_undef(r1)? (\n        let( l = default(l, h) )\n        !is_undef(l)? (\n            let(\n                shift = default(shift, [0,0]),\n                r2 = get_radius(r1=r2,d1=d2,r=r,d=d,dflt=undef)\n            )\n            assert(is_num(r1) || is_vector(r1,2))\n            assert(is_num(r2) || is_vector(r2,2))\n            assert(is_num(l))\n            assert(is_vector(shift,2))\n            [\"conoid\", r1, r2, l, shift, axis, cp, offset, anchors]\n        ) : (\n            two_d? (\n                assert(is_num(r1) || is_vector(r1,2))\n                [\"ellipse\", r1, cp, offset, anchors]\n            ) : (\n                assert(is_num(r1) || is_vector(r1,3))\n                [\"spheroid\", r1, cp, offset, anchors]\n            )\n        )\n    ) :\n    [\"point\", cp, offset, anchors];\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//\n// Attachment internal functions\n\n\n/// Internal Function: _attach_geom_2d()\n/// Topics: Attachments\n/// See Also: reorient(), attachable()\n/// Usage:\n///   bool = _attach_geom_2d(geom);\n/// Description:\n///   Returns true if the given attachment geometry description is for a 2D shape.\nfunction _attach_geom_2d(geom) =\n    let( type = geom[0] )\n    type == \"trapezoid\" || type == \"ellipse\" ||\n    type == \"rgn_isect\" || type == \"rgn_extent\";\n\n\n/// Internal Function: _attach_geom_size()\n/// Usage:\n///   bounds = _attach_geom_size(geom);\n/// Topics: Attachments\n/// See Also: reorient(), attachable()\n/// Description:\n///   Returns the `[X,Y,Z]` bounding size for the given attachment geometry description.\nfunction _attach_geom_size(geom) =\n    let( type = geom[0] )\n    type == \"point\"? [0,0,0] :\n    type == \"prismoid\"? ( //size, size2, shift, axis\n        let(\n            size=geom[1], size2=geom[2], shift=point2d(geom[3]),\n            maxx = max(size.x,size2.x),\n            maxy = max(size.y,size2.y),\n            z = size.z\n        ) [maxx, maxy, z]\n    ) : type == \"conoid\"? ( //r1, r2, l, shift\n        let(\n            r1=geom[1], r2=geom[2], l=geom[3],\n            shift=point2d(geom[4]), axis=point3d(geom[5]),\n            rx1 = default(r1[0],r1),\n            ry1 = default(r1[1],r1),\n            rx2 = default(r2[0],r2),\n            ry2 = default(r2[1],r2),\n            maxxr = max(rx1,rx2),\n            maxyr = max(ry1,ry2)\n        )\n        approx(axis,UP)? [2*maxxr,2*maxyr,l] :\n        approx(axis,RIGHT)? [l,2*maxyr,2*maxxr] :\n        approx(axis,BACK)? [2*maxxr,l,2*maxyr] :\n        [2*maxxr, 2*maxyr, l]\n    ) : type == \"spheroid\"? ( //r\n        let( r=geom[1] )\n        is_num(r)? [2,2,2]*r : v_mul([2,2,2],point3d(r))\n    ) : type == \"vnf_extent\" || type==\"vnf_isect\"? ( //vnf\n        let(\n            vnf = geom[1]\n        ) vnf==EMPTY_VNF? [0,0,0] :\n        let(\n            mm = pointlist_bounds(geom[1][0]),\n            delt = mm[1]-mm[0]\n        ) delt\n    ) : type == \"extrusion_isect\" || type == \"extrusion_extent\"? ( //path, l\n        let(\n            mm = pointlist_bounds(flatten(geom[1])),\n            delt = mm[1]-mm[0]\n        ) [delt.x, delt.y, geom[2]]\n    ) : type == \"trapezoid\"? ( //size, size2\n        let(\n            size=geom[1], size2=geom[2], shift=geom[3],\n            maxx = max(size.x,size2+abs(shift))\n        ) [maxx, size.y]\n    ) : type == \"ellipse\"? ( //r\n        let( r=geom[1] )\n        is_num(r)? [2,2]*r : v_mul([2,2],point2d(r))\n    ) : type == \"rgn_isect\" || type == \"rgn_extent\"? ( //path\n        let(\n            mm = pointlist_bounds(flatten(geom[1])),\n            delt = mm[1]-mm[0]\n        ) [delt.x, delt.y]\n    ) :\n    assert(false, \"Unknown attachment geometry type.\");\n\n\n\n/// Internal Function: _attach_geom_edge_path()\n/// Usage:\n///   angle = _attach_geom_edge_path(geom, edge);\n/// Topics: Attachments\n/// See Also: reorient(), attachable()\n/// Description:\n///   Returns the path and post-transform matrix of the indicated edge.\n///   If the edge is invalid for the geometry, returns `undef`.\nfunction _attach_geom_edge_path(geom, edge) =\n    assert(is_vector(edge),str(\"Invalid edge: edge=\",edge))\n    let(\n        type = geom[0],\n        cp = _get_cp(geom),\n        offset_raw = select(geom,-2),\n        offset = [for (i=[0:2]) edge[i]==0? 0 : offset_raw[i]],  // prevents bad centering.\n        edge = point3d(edge)\n    )\n    type == \"prismoid\"? ( //size, size2, shift, axis\n        let(all_comps_good = [for (c=edge) if (c!=sign(c)) 1]==[])\n        assert(all_comps_good, \"All components of an edge for a cuboid/prismoid must be -1, 0, or 1\")\n        let(edge_good = len([for (c=edge) if(c) 1])==2)\n        assert(edge_good, \"Invalid edge.\")\n        let(\n            size = geom[1],\n            size2 = geom[2],\n            shift = point2d(geom[3]),\n            axis = point3d(geom[4]),\n            edge = rot(from=axis, to=UP, p=edge),\n            offset = rot(from=axis, to=UP, p=offset),\n            h = size.z,\n            cpos = function(vec) let(\n                        u = (vec.z + 1) / 2,\n                        siz = lerp(point2d(size), size2, u) / 2,\n                        z = vec.z * h / 2,\n                        pos = point3d(v_mul(siz, point2d(vec)) + shift * u, z)\n                    ) pos,\n            ep1 = cpos([for (c=edge) c? c : -1]),\n            ep2 = cpos([for (c=edge) c? c :  1]),\n            cp = (ep1 + ep2) / 2,\n            axy = point2d(edge),\n            bot = point3d(v_mul(point2d(size )/2, axy), -h/2),\n            top = point3d(v_mul(point2d(size2)/2, axy) + shift, h/2),\n            xang = atan2(h,(top-bot).x),\n            yang = atan2(h,(top-bot).y),\n            vecs = [\n                if (edge.x) yrot(90-xang, p=sign(axy.x)*RIGHT),\n                if (edge.y) xrot(yang-90, p=sign(axy.y)*BACK),\n                if (edge.z) [0,0,sign(edge.z)]\n            ], \n            segvec = cross(unit(vecs[1]), unit(vecs[0])),\n            seglen = norm(ep2 - ep1),\n            path = [\n                cp - segvec * seglen/2,\n                cp + segvec * seglen/2\n            ],\n            m = rot(from=UP,to=axis) * move(offset)\n        ) [path, [vecs], m]\n    ) : type == \"conoid\"? ( //r1, r2, l, shift, axis\n        assert(edge.z && edge.z == sign(edge.z), \"The Z component of an edge for a cylinder/cone must be -1 or 1\")\n        let(\n            rr1 = geom[1],\n            rr2 = geom[2],\n            l = geom[3],\n            shift = point2d(geom[4]),\n            axis = point3d(geom[5]),\n            r1 = is_num(rr1)? [rr1,rr1] : point2d(rr1),\n            r2 = is_num(rr2)? [rr2,rr2] : point2d(rr2),\n            edge = rot(from=axis, to=UP, p=edge),\n            offset = rot(from=axis, to=UP, p=offset),\n            maxr = max([each r1, each r2]),\n            sides = segs(maxr),\n            top = path3d(move(shift, p=ellipse(r=r2, $fn=sides)), l/2),\n            bot = path3d(ellipse(r=r1, $fn=sides), -l/2),\n            path = edge.z < 0 ? bot : top,\n            path2 = edge.z < 0 ? top : bot,\n            zed = edge.z<0? [0,0,-l/2] : point3d(shift,l/2),\n            vecs = [\n                for (i = idx(top)) let(\n                    pt1 = (path[i] + select(path,i+1)) /2,\n                    pt2 = (path2[i] + select(path2,i+1)) /2,\n                    v1 = unit(zed - pt1),\n                    v2 = unit(pt2 - pt1),\n                    v3 = unit(cross(v1,v2)),\n                    v4 = cross(v3,v2),\n                    v5 = cross(v1,v3)\n                ) [v4, v5]\n            ],\n            m = rot(from=UP,to=axis) * move(offset)\n        ) edge.z>0\n          ? [reverse(list_wrap(path)), reverse(vecs), m]\n          : [list_wrap(path), vecs, m]\n    ) : undef;\n\n\n/// Internal Function: _attach_transform()\n/// Usage: To Get a Transformation Matrix\n///   mat = _attach_transform(anchor, spin, orient, geom);\n/// Usage: To Transform Points, Paths, Patches, or VNFs\n///   new_p = _attach_transform(anchor, spin, orient, geom, p);\n/// Topics: Attachments\n/// See Also: reorient(), attachable()\n/// Description:\n///   Returns the affine3d transformation matrix needed to `anchor`, `spin`, and `orient`\n///   the given geometry `geom` shape into position.\n/// Arguments:\n///   anchor = Anchor point to translate to the origin `[0,0,0]`.  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n///   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n///   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n///   geom = The geometry description of the shape.\n///   p = If given as a VNF, path, or point, applies the affine3d transformation matrix to it and returns the result.\nfunction _attach_transform(anchor, spin, orient, geom, p) =\n    assert(is_undef(anchor) || is_vector(anchor) || is_string(anchor), str(\"Got: \",anchor))\n    assert(is_undef(spin)   || is_vector(spin,3) || is_num(spin), str(\"Got: \",spin))\n    assert(is_undef(orient) || is_vector(orient,3), str(\"Got: \",orient))\n    let(\n        anchor = default(anchor, CENTER),\n        \n        spin   = default(spin,   0),\n        orient = default(orient, UP),\n        two_d = _attach_geom_2d(geom),\n        m = ($attach_to != undef)? (\n            let(\n                anch = _find_anchor($attach_to, geom),\n                pos = anch[1]\n            ) two_d? (\n                assert(two_d && is_num(spin))\n                affine3d_zrot(spin) *\n                rot(to=FWD, from=point3d(anch[2])) *\n                affine3d_translate(point3d(-pos))\n            ) : (\n                assert(is_num(spin) || is_vector(spin,3))\n                let(\n                    ang = vector_angle(anch[2], DOWN),\n                    axis = vector_axis(anch[2], DOWN),\n                    ang2 = (anch[2]==UP || anch[2]==DOWN)? 0 : 180-anch[3],\n                    axis2 = rot(p=axis,[0,0,ang2])\n                )\n                affine3d_rot_by_axis(axis2,ang) * (\n                    is_num(spin)? affine3d_zrot(ang2+spin) : (\n                        affine3d_zrot(spin.z) *\n                        affine3d_yrot(spin.y) *\n                        affine3d_xrot(spin.x) *\n                        affine3d_zrot(ang2)\n                    )\n                ) * affine3d_translate(point3d(-pos))\n            )\n        ) : (\n            let(\n                pos = _find_anchor(anchor, geom)[1]\n            ) two_d? (\n                assert(two_d && is_num(spin))\n                affine3d_zrot(spin) *\n                affine3d_translate(point3d(-pos))\n            ) : (\n                assert(is_num(spin) || is_vector(spin,3))\n                let(\n                    axis = vector_axis(UP,orient),\n                    ang = vector_angle(UP,orient)\n                )\n                affine3d_rot_by_axis(axis,ang) * (\n                    is_num(spin)? affine3d_zrot(spin) : (\n                        affine3d_zrot(spin.z) *\n                        affine3d_yrot(spin.y) *\n                        affine3d_xrot(spin.x)\n                    )\n                ) * affine3d_translate(point3d(-pos))\n            )\n        )\n    ) is_undef(p)? m :\n    is_vnf(p)? [(p==EMPTY_VNF? p : apply(m, p[0])), p[1]] :\n    apply(m, p);\n\n\nfunction _get_cp(geom) =\n    let(cp=select(geom,-3))\n    is_vector(cp) ? cp\n  : let(\n        type = in_list(geom[0],[\"vnf_extent\",\"vnf_isect\"]) ? \"vnf\"\n             : in_list(geom[0],[\"rgn_extent\",\"rgn_isect\"]) ? \"path\"\n             : in_list(geom[0],[\"extrusion_extent\",\"extrusion_isect\"]) ? \"xpath\"\n             : \"other\"\n    )\n    assert(type!=\"other\", \"Invalid cp value\")\n    cp==\"centroid\" ? (\n       type==\"vnf\" && (len(geom[1][0])==0 || len(geom[1][1])==0) ? [0,0,0] :\n       [each centroid(geom[1]), if (type==\"xpath\") 0]\n    )\n  : let(points = type==\"vnf\"?geom[1][0]:flatten(force_region(geom[1])))\n    cp==\"mean\" ? [each mean(points), if (type==\"xpath\") 0]\n  : cp==\"box\" ?[each  mean(pointlist_bounds(points)), if (type==\"xpath\") 0]\n  : assert(false,\"Invalid cp specification\");\n\n\nfunction _get_cp(geom) =\n    let(cp=select(geom,-3))\n    is_vector(cp) ? cp\n  : let(\n        is_vnf = in_list(geom[0],[\"vnf_extent\",\"vnf_isect\"])\n    )\n    cp == \"centroid\" ? (\n       is_vnf && len(geom[1][1])==0\n          ? [0,0,0]\n          : centroid(geom[1])\n    )\n  : let(points = is_vnf?geom[1][0]:flatten(force_region(geom[1])))\n    cp==\"mean\" ? mean(points)\n  : cp==\"box\" ? mean(pointlist_bounds(points))\n  : assert(false,\"Invalid cp specification\");\n\n\n\nfunction _force_anchor_2d(anchor) =\n  assert(anchor.y==0 || anchor.z==0, \"Anchor for a 2D shape cannot be fully 3D.  It must have either Y or Z component equal to zero.\")\n  anchor.y==0 ? [anchor.x,anchor.z] : point2d(anchor);\n\n\n/// Internal Function: _find_anchor()\n/// Usage:\n///   anchorinfo = _find_anchor(anchor, geom);\n/// Topics: Attachments\n/// See Also: reorient(), attachable()\n/// Description:\n///   Calculates the anchor data for the given `anchor` vector or name, in the given attachment\n///   geometry.  Returns `[ANCHOR, POS, VEC, ANG]` where `ANCHOR` is the requested anchorname\n///   or vector, `POS` is the anchor position, `VEC` is the direction vector of the anchor, and\n///   `ANG` is the angle to align with around the rotation axis of th anchor direction vector.\n/// Arguments:\n///   anchor = Vector or named anchor string.\n///   geom = The geometry description of the shape.\nfunction _find_anchor(anchor, geom) =\n    is_string(anchor)? (\n          anchor==\"origin\"? [anchor, CENTER, UP, 0]\n        : let(\n              anchors = last(geom),\n              found = search([anchor], anchors, num_returns_per_match=1)[0]\n          )\n          assert(found!=[], str(\"Unknown anchor: \",anchor))\n          anchors[found]\n    ) :\n    let(\n        cp = _get_cp(geom),\n        offset_raw = select(geom,-2),\n        offset = [for (i=[0:2]) anchor[i]==0? 0 : offset_raw[i]],  // prevents bad centering.\n        type = geom[0]\n    )\n    assert(is_vector(anchor),str(\"Invalid anchor: anchor=\",anchor))\n    let(\n        anchor = point3d(anchor),\n        oang = (\n            approx(point2d(anchor), [0,0])? 0 :\n            atan2(anchor.y, anchor.x)+90\n        )\n    )\n    type == \"prismoid\"? ( //size, size2, shift, axis\n        let(all_comps_good = [for (c=anchor) if (c!=sign(c)) 1]==[])\n        assert(all_comps_good, \"All components of an anchor for a cuboid/prismoid must be -1, 0, or 1\")\n        let(\n            size=geom[1], size2=geom[2],\n            shift=point2d(geom[3]), axis=point3d(geom[4]),\n            override = geom[5](anchor)\n        )\n        let(\n            size = [for (c = size) max(0,c)],\n            size2 = [for (c = size2) max(0,c)],\n            anch = rot(from=axis, to=UP, p=anchor),\n            offset = rot(from=axis, to=UP, p=offset),\n            h = size.z,\n            u = (anch.z + 1) / 2,  // u is one of 0, 0.5, or 1\n            axy = point2d(anch),\n            bot = point3d(v_mul(point2d(size )/2, axy), -h/2),\n            top = point3d(v_mul(point2d(size2)/2, axy) + shift, h/2),\n            pos = point3d(cp) + lerp(bot,top,u) + offset,\n            vecs = anchor==CENTER? [UP]\n              : [\n                    if (anch.x!=0) unit(rot(from=UP, to=[(top-bot).x,0,max(0.01,h)], p=[axy.x,0,0]), UP),\n                    if (anch.y!=0) unit(rot(from=UP, to=[0,(top-bot).y,max(0.01,h)], p=[0,axy.y,0]), UP),\n                    if (anch.z!=0) unit([0,0,anch.z],UP)\n                ],\n            vec2 = anchor==CENTER? UP\n              : len(vecs)==1? unit(vecs[0],UP)\n              : len(vecs)==2? vector_bisect(vecs[0],vecs[1])\n              : let(\n                    v1 = vector_bisect(vecs[0],vecs[2]),\n                    v2 = vector_bisect(vecs[1],vecs[2]),\n                    p1 = plane_from_normal(yrot(90,p=v1)),\n                    p2 = plane_from_normal(xrot(-90,p=v2)),\n                    line = plane_intersection(p1,p2),\n                    v3 = unit(line[1]-line[0],UP) * anch.z\n                )\n                unit(v3,UP),\n            vec = default(override[1],rot(from=UP, to=axis, p=vec2)),\n            pos2 = default(override[0],rot(from=UP, to=axis, p=pos))\n        ) [anchor, pos2, vec, default(override[2],oang)]\n    ) : type == \"conoid\"? ( //r1, r2, l, shift\n        assert(anchor.z == sign(anchor.z), \"The Z component of an anchor for a cylinder/cone must be -1, 0, or 1\")\n        let(\n            rr1=geom[1], rr2=geom[2], l=geom[3],\n            shift=point2d(geom[4]), axis=point3d(geom[5]),\n            r1 = is_num(rr1)? [rr1,rr1] : point2d(rr1),\n            r2 = is_num(rr2)? [rr2,rr2] : point2d(rr2),\n            anch = rot(from=axis, to=UP, p=anchor),\n            offset = rot(from=axis, to=UP, p=offset),\n            u = (anch.z+1)/2,\n            axy = unit(point2d(anch),[0,0]),\n            bot = point3d(v_mul(r1,axy), -l/2),\n            top = point3d(v_mul(r2,axy)+shift, l/2),\n            pos = point3d(cp) + lerp(bot,top,u) + offset,\n            sidevec = rot(from=UP, to=top==bot?UP:top-bot, p=point3d(axy)),\n            vvec = anch==CENTER? UP : unit([0,0,anch.z],UP),\n            vec = anch==CENTER? CENTER :\n                approx(axy,[0,0])? unit(anch,UP) :\n                approx(anch.z,0)? sidevec :\n                unit((sidevec+vvec)/2,UP),\n            pos2 = rot(from=UP, to=axis, p=pos),\n            vec2 = anch==CENTER? UP : rot(from=UP, to=axis, p=vec)\n        ) [anchor, pos2, vec2, oang]\n    ) : type == \"point\"? (\n        let(\n            anchor = unit(point3d(anchor),CENTER),\n            pos = point3d(cp) + point3d(offset),\n            vec = unit(anchor,UP)\n        ) [anchor, pos, vec, oang]\n    ) : type == \"spheroid\"? ( //r\n        let(\n            rr = geom[1],\n            r = is_num(rr)? [rr,rr,rr] : point3d(rr),\n            anchor = unit(point3d(anchor),CENTER),\n            pos = point3d(cp) + v_mul(r,anchor) + point3d(offset),\n            vec = unit(v_mul(r,anchor),UP)\n        ) [anchor, pos, vec, oang]\n    ) : type == \"vnf_isect\"? ( //vnf\n        let( vnf=geom[1] )\n        approx(anchor,CTR)? [anchor, cp, UP, 0] :      // CENTER anchors anchor on cp, \"origin\" anchors on [0,0]\n        vnf==EMPTY_VNF? [anchor, [0,0,0], unit(anchor), 0] :\n        let(\n            eps = 1/2048,\n            points = vnf[0],\n            faces = vnf[1],\n            rpts = apply(rot(from=anchor, to=RIGHT) * move(-cp), points),\n            hits = [\n                for (face = faces)\n                    let(\n                        verts = select(rpts, face),\n                        ys = column(verts,1),\n                        zs = column(verts,2)\n                    )\n                    if (max(ys) >= -eps && max(zs) >= -eps &&\n                        min(ys) <=  eps &&  min(zs) <=  eps)\n                        let(\n                            poly = select(points, face),\n                            isect = polygon_line_intersection(poly, [cp,cp+anchor], eps=eps),\n                            ptlist = is_undef(isect) ? [] :\n                                     is_vector(isect) ? [isect]\n                                                      : flatten(isect),   // parallel to a face\n                            n = len(ptlist)>0 ? polygon_normal(poly) : undef\n                        )\n                        for(pt=ptlist) [anchor * (pt-cp), n, pt]\n            ]\n        )\n        assert(len(hits)>0, \"Anchor vector does not intersect with the shape.  Attachment failed.\")\n        let(\n            furthest = max_index(column(hits,0)),\n            dist = hits[furthest][0],\n            pos = hits[furthest][2],\n            hitnorms = [for (hit = hits) if (approx(hit[0],dist,eps=eps)) hit[1]],\n            unorms = [\n                      for (i = idx(hitnorms))\n                          let(\n                              thisnorm = hitnorms[i],\n                              isdup = [\n                                       for (j = [i+1:1:len(hitnorms)-1])\n                                           if (approx(thisnorm, hitnorms[j])) 1\n                                      ] != []\n                          )\n                          if (!isdup) thisnorm\n                     ],\n            n = unit(sum(unorms)),\n            oang = approx(point2d(n), [0,0])? 0 : atan2(n.y, n.x) + 90\n        )\n        [anchor, pos, n, oang]\n    ) : type == \"vnf_extent\"? ( //vnf\n        let( vnf=geom[1] )\n        approx(anchor,CTR)? [anchor, cp, UP, 0] :      // CENTER anchors anchor on cp, \"origin\" anchors on [0,0]\n        vnf==EMPTY_VNF? [anchor, [0,0,0], unit(anchor,UP), 0] :\n        let(\n            rpts = apply(rot(from=anchor, to=RIGHT) * move(point3d(-cp)), vnf[0]),\n            maxx = max(column(rpts,0)),\n            idxs = [for (i = idx(rpts)) if (approx(rpts[i].x, maxx)) i],\n            avep = sum(select(rpts,idxs))/len(idxs),\n            mpt = approx(point2d(anchor),[0,0])? [maxx,0,0] : avep,\n            pos = point3d(cp) + rot(from=RIGHT, to=anchor, p=mpt)\n        ) [anchor, pos, anchor, oang]\n    ) : type == \"trapezoid\"? ( //size, size2, shift, override\n        let(all_comps_good = [for (c=anchor) if (c!=sign(c)) 1]==[])\n        assert(all_comps_good, \"All components of an anchor for a rectangle/trapezoid must be -1, 0, or 1\")\n        let(\n            anchor=_force_anchor_2d(anchor),\n            size=geom[1], size2=geom[2], shift=geom[3],\n            u = (anchor.y+1)/2,  // 0<=u<=1\n            frpt = [size.x/2*anchor.x, -size.y/2],\n            bkpt = [size2/2*anchor.x+shift, size.y/2],\n            override = geom[4](anchor),\n            pos = override[0] != undef? override[0] :\n                point2d(cp) + lerp(frpt, bkpt, u) + point2d(offset),\n            svec = approx(bkpt,frpt)? [anchor.x,0,0] :\n                point3d(line_normal(bkpt,frpt)*anchor.x),\n            vec = is_def(override[1]) ? override[1]\n                : anchor.y == 0? ( anchor.x == 0? BACK : svec )\n                : anchor.x == 0? [0,anchor.y,0]\n                : unit((svec + [0,anchor.y,0]) / 2, [0,anchor.y,0])\n        ) [anchor, pos, vec, 0]\n    ) : type == \"ellipse\"? ( //r\n        let(\n            anchor = unit(_force_anchor_2d(anchor),[0,0]),\n            r = force_list(geom[1],2),\n            pos = approx(anchor.x,0)\n                ? [0,sign(anchor.y)*r.y]\n                : let(\n                       m = anchor.y/anchor.x,\n                       px = approx(min(r),0)? 0 :\n                           sign(anchor.x) * sqrt(1/(1/sqr(r.x) + m*m/sqr(r.y)))\n                  )\n                  [px,m*px],\n            vec = approx(min(r),0)? (approx(norm(anchor),0)? BACK : anchor) :\n                unit([r.y/r.x*pos.x, r.x/r.y*pos.y],BACK)\n        ) [anchor, point2d(cp+offset)+pos, vec, 0]\n    ) : type == \"rgn_isect\"? ( //region\n        let(\n            anchor = _force_anchor_2d(anchor),\n            rgn = force_region(move(-point2d(cp), p=geom[1]))\n        )\n        approx(anchor,[0,0])? [anchor, cp, BACK, 0] :     // CENTER anchors anchor on cp, \"origin\" anchors on [0,0]\n        let(\n            isects = [\n                for (path=rgn, t=triplet(path,true)) let(\n                    seg1 = [t[0],t[1]],\n                    seg2 = [t[1],t[2]],\n                    isect = line_intersection([[0,0],anchor], seg1, RAY, SEGMENT),\n                    n = is_undef(isect)? [0,1] :\n                        !approx(isect, t[1])? line_normal(seg1) :\n                        unit((line_normal(seg1)+line_normal(seg2))/2,[0,1]),\n                    n2 = vector_angle(anchor,n)>90? -n : n\n                )\n                if(!is_undef(isect) && !approx(isect,t[0])) [norm(isect), isect, n2]\n            ]\n        )\n        assert(len(isects)>0, \"Anchor vector does not intersect with the shape.  Attachment failed.\")\n        let(\n            maxidx = max_index(column(isects,0)),\n            isect = isects[maxidx],\n            pos = point2d(cp) + isect[1],\n            vec = unit(isect[2],[0,1])\n        ) [anchor, pos, vec, 0]\n    ) : type == \"rgn_extent\"? ( //region\n        let( anchor = _force_anchor_2d(anchor) )\n        approx(anchor,[0,0])? [anchor, cp, BACK, 0] :   // CENTER anchors anchor on cp, \"origin\" anchors on [0,0]\n        let(\n            rgn = force_region(geom[1]),\n            rpts = rot(from=anchor, to=RIGHT, p=flatten(rgn)),\n            maxx = max(column(rpts,0)),\n            ys = [for (pt=rpts) if (approx(pt.x, maxx)) pt.y],\n            midy = (min(ys)+max(ys))/2,\n            pos = rot(from=RIGHT, to=anchor, p=[maxx,midy])\n        ) [anchor, pos, unit(anchor,BACK), 0]\n    ) : type==\"extrusion_extent\" || type==\"extrusion_isect\" ? (  // extruded region\n        assert(in_list(anchor.z,[-1,0,1]), \"The Z component of an anchor for an extruded 2D shape must be -1, 0, or 1.\")\n        let(\n            anchor_xy = point2d(anchor),\n            rgn = geom[1],\n            L = geom[2],\n            twist = geom[3],\n            scale = geom[4],\n            shift = geom[5],\n            u = (anchor.z + 1) / 2,\n            shmat = move(lerp([0,0], shift, u)),\n            scmat = scale(lerp([1,1], scale, u)),\n            twmat = zrot(lerp(0, -twist, u)),\n            mat = shmat * scmat * twmat\n        )\n        approx(anchor_xy,[0,0]) ? [anchor, apply(mat, point3d(cp,anchor.z*L/2)), unit(anchor, UP), oang] :\n        let(\n            newrgn = apply(mat, rgn),\n            newgeom = attach_geom(two_d=true, region=newrgn, extent=type==\"extrusion_extent\", cp=cp),\n            topmat = anchor.z!=0 ? []\n                   : move(shift)*scale(scale)*zrot(-twist),\n            topgeom = anchor.z!=0? []\n                    : attach_geom(two_d=true, region=apply(topmat,rgn), extent=type==\"extrusion_extent\", cp=cp),\n            top2d =  anchor.z!=0? []\n                  : _find_anchor(anchor_xy, topgeom),\n            result2d = _find_anchor(anchor_xy, newgeom),\n            pos = point3d(result2d[1], anchor.z*L/2),\n            vec = anchor.z==0? rot(from=UP,to=point3d(top2d[1],L/2)-point3d(result2d[1]),p=point3d(result2d[2]))\n                : unit(point3d(result2d[2], anchor.z),UP),\n            oang = atan2(vec.y,vec.x) + 90\n        )\n        [anchor, pos, vec, oang]\n    ) :\n    assert(false, \"Unknown attachment geometry type.\");\n\n\n/// Internal Function: _is_shown()\n/// Usage:\n///   bool = _is_shown();\n/// Topics: Attachments\n/// See Also: reorient(), attachable()\n/// Description:\n///   Returns true if objects should currently be shown based on the tag settings.\nfunction _is_shown() =\n    assert(is_list($tags_shown) || $tags_shown==\"ALL\")\n    assert(is_list($tags_hidden))\n    let(\n        dummy=is_undef($tags) ? 0 : echo(\"Use tag() instead of $tags for specifying an object's tag.\"),\n        $tag = default($tag,$tags)\n    )\n    assert(is_string($tag), str(\"Tag value (\",$tag,\") is not a string\"))\n    assert(undef==str_find($tag,\" \"),str(\"Tag string \\\"\",$tag,\"\\\" contains a space, which is not allowed\"))\n    let(\n        shown  = $tags_shown==\"ALL\" || in_list($tag,$tags_shown),\n        hidden = in_list($tag, $tags_hidden)\n    )\n    shown && !hidden;\n\n\n// Section: Visualizing Anchors\n\n/// Internal Function: _standard_anchors()\n/// Usage:\n///   anchs = _standard_anchors([two_d]);\n/// Description:\n///   Return the vectors for all standard anchors.\n/// Arguments:\n///   two_d = If true, returns only the anchors where the Z component is 0.  Default: false\nfunction _standard_anchors(two_d=false) = [\n    for (\n        zv = [\n            if (!two_d) TOP,\n            CENTER,\n            if (!two_d) BOTTOM\n        ],\n        yv = [FRONT, CENTER, BACK],\n        xv = [LEFT, CENTER, RIGHT]\n    ) xv+yv+zv\n];\n\n\n\n// Module: show_anchors()\n// Synopsis: Shows anchors for the parent object.\n// SynTags: Geom\n// Topics: Attachments\n// See Also: expose_anchors(), anchor_arrow(), anchor_arrow2d(), frame_ref()\n// Usage:\n//   PARENT() show_anchors([s], [std=], [custom=]);\n// Description:\n//   Show all standard anchors for the parent object.\n// Arguments:\n//   s = Length of anchor arrows.\n//   ---\n//   std = If true show standard anchors.  Default: true\n//   custom = If true show named anchors.  Default: true\n// Example(FlatSpin,VPD=333):\n//   cube(50, center=true) show_anchors();\nmodule show_anchors(s=10, std=true, custom=true) {\n    check = assert($parent_geom != undef);\n    two_d = _attach_geom_2d($parent_geom);\n    if (std) {\n        for (anchor=_standard_anchors(two_d=two_d)) {\n            if(two_d) {\n                attach(anchor) anchor_arrow2d(s);\n            } else {\n                attach(anchor) anchor_arrow(s);\n            }\n        }\n    }\n    if (custom) {\n        for (anchor=last($parent_geom)) {\n            attach(anchor[0]) {\n                if(two_d) {\n                    anchor_arrow2d(s, color=\"cyan\");\n                } else {\n                    anchor_arrow(s, color=\"cyan\");\n                }\n                color(\"black\")\n                tag(\"anchor-arrow\") {\n                    xrot(two_d? 0 : 90) {\n                        back(s/3) {\n                            yrot_copies(n=2)\n                            up(two_d? 0.51 : s/30) {\n                                linear_extrude(height=0.01, convexity=12, center=true) {\n                                    text(text=anchor[0], size=s/4, halign=\"center\", valign=\"center\", font=\"Helvetica\", $fn=36);\n                                }\n                            }\n                        }\n                    }\n                }\n                color([1, 1, 1, 1])\n                tag(\"anchor-arrow\") {\n                    xrot(two_d? 0 : 90) {\n                        back(s/3) {\n                             cube([s/4.5*len(anchor[0]), s/3, 0.01], center=true);\n                        }\n                   }\n                }\n            }\n        }\n    }\n    children();\n}\n\n\n// Module: anchor_arrow()\n// Synopsis: Shows a 3d anchor orientation arrow.\n// SynTags: Geom\n// Topics: Attachments\n// See Also: anchor_arrow2d(), show_anchors(), expose_anchors(), frame_ref(), generic_airplane()\n// Usage:\n//   anchor_arrow([s], [color], [flag], [anchor=], [orient=], [spin=]) [ATTACHMENTS];\n// Description:\n//   Show an anchor orientation arrow.  By default, tagged with the name \"anchor-arrow\".\n// Arguments:\n//   s = Length of the arrows.  Default: `10`\n//   color = Color of the arrow.  Default: `[0.333, 0.333, 1]`\n//   flag = If true, draw the orientation flag on the arrowhead.  Default: true\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   anchor_arrow(s=20);\nmodule anchor_arrow(s=10, color=[0.333,0.333,1], flag=true, $tag=\"anchor-arrow\", $fn=12, anchor=BOT, spin=0, orient=UP) {\n    attachable(anchor,spin,orient, r=s/6, l=s) {\n        down(s/2)\n        recolor(\"gray\") spheroid(d=s/6) {\n            attach(CENTER,BOT) recolor(color) cyl(h=s*2/3, d=s/15) {\n                attach(TOP,BOT) cyl(h=s/3, d1=s/5, d2=0) {\n                    if(flag) {\n                        position(BOT)\n                            recolor([1,0.5,0.5])\n                                cuboid([s/100, s/6, s/4], anchor=FRONT+BOT);\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n\n// Module: anchor_arrow2d()\n// Synopsis: Shows a 2d anchor orientation arrow.\n// SynTags: Geom\n// Topics: Attachments\n// See Also: anchor_arrow(), show_anchors(), expose_anchors(), frame_ref()\n// Usage:\n//   anchor_arrow2d([s], [color]);\n// Description:\n//   Show an anchor orientation arrow.\n// Arguments:\n//   s = Length of the arrows.\n//   color = Color of the arrow.\n// Example:\n//   anchor_arrow2d(s=20);\nmodule anchor_arrow2d(s=15, color=[0.333,0.333,1], $tag=\"anchor-arrow\") {\n    color(color) stroke([[0,0],[0,s]], width=s/10, endcap1=\"butt\", endcap2=\"arrow2\");\n}\n\n\n\n// Module: expose_anchors()\n// Synopsis: Used to show a transparent object with solid color anchor arrows.\n// Topics: Attachments\n// See Also: anchor_arrow2d(), show_anchors(), show_anchors(), frame_ref()\n// Usage:\n//   expose_anchors(opacity) {child1() show_anchors(); child2() show_anchors(); ...}\n// Description:\n//   Used in combination with show_anchors() to display an object in transparent gray with its anchors in solid color.\n//   Children will appear transparent and any anchor arrows drawn with will appear in solid color.\n// Arguments:\n//   opacity = The opacity of the children.  0.0 is invisible, 1.0 is opaque.  Default: 0.2\n// Example(FlatSpin,VPD=333):\n//   expose_anchors() cube(50, center=true) show_anchors();\nmodule expose_anchors(opacity=0.2) {\n    show_only(\"anchor-arrow\")\n        children();\n    hide(\"anchor-arrow\")\n        color(is_undef($color) || $color==\"default\" ? [0,0,0] :\n              is_string($color) ? $color\n                                : point3d($color),\n              opacity)\n            children();\n}\n\n\n\n// Module: show_transform_list()\n// Synopsis: Shows a list of transforms and how they connect.\n// SynTags: Geom\n// Topics: Attachments\n// See Also: generic_airplane(), anchor_arrow(), show_anchors(), expose_anchors(), frame_ref()\n// Usage:\n//   show_transform_list(tlist, [s]);\n//   show_transform_list(tlist) {CHILDREN};\n// Description:\n//   Given a list of transformation matrices, shows the position and orientation of each one.\n//   A line is drawn from each transform position to the next one, and an orientation indicator is\n//   shown at each position.  If a child is passed, that child will be used as the orientation indicator.\n//   By default, a {{generic_airplane()}} is used as the orientation indicator.\n// Arguments:\n//   s = Length of the {{generic_airplane()}}.  Default: 5\n// Example:\n//   tlist = [\n//       zrot(90),\n//       zrot(90) * fwd(30) * zrot(30),\n//       zrot(90) * fwd(30) * zrot(30) *\n//           fwd(35) * xrot(-30),\n//       zrot(90) * fwd(30) * zrot(30) *\n//           fwd(35) * xrot(-30) * fwd(40) * yrot(15),\n//   ];\n//   show_transform_list(tlist, s=20);\n// Example:\n//   tlist = [\n//       zrot(90),\n//       zrot(90) * fwd(30) * zrot(30),\n//       zrot(90) * fwd(30) * zrot(30) *\n//           fwd(35) * xrot(-30),\n//       zrot(90) * fwd(30) * zrot(30) *\n//           fwd(35) * xrot(-30) * fwd(40) * yrot(15),\n//   ];\n//   show_transform_list(tlist) frame_ref();\nmodule show_transform_list(tlist, s=5) {\n    path = [for (m = tlist) apply(m, [0,0,0])];\n    stroke(path, width=s*0.03);\n    for (m = tlist) {\n        multmatrix(m) {\n            if ($children>0) children();\n            else generic_airplane(s=s);\n        }\n    }\n}\n\n\n// Module: generic_airplane()\n// Synopsis: Shows a generic airplane shape, useful for viewing orientations.\n// SynTags: Geom\n// Topics: Attachments\n// See Also: anchor_arrow(), show_anchors(), expose_anchors(), frame_ref()\n// Usage:\n//   generic_airplane([s]);\n// Description:\n//   Creates a generic airplane shape.  This can be useful for viewing the orientation of 3D transforms.\n// Arguments:\n//   s = Length of the airplane.  Default: 5\n// Example:\n//   generic_airplane(s=20);\nmodule generic_airplane(s=5) {\n    $fn = max(segs(0.05*s), 12);\n    color(\"#ddd\")\n    fwd(s*0.05)\n    ycyl(l=0.7*s, d=0.1*s) {\n        attach(FWD) top_half(s=s) zscale(2) sphere(d=0.1*s);\n        attach(BACK,FWD) ycyl(l=0.2*s, d1=0.1*s, d2=0.05*s) {\n            yrot_copies([-90,0,90])\n                prismoid(s*[0.01,0.2], s*[0.01,0.05],\n                    h=0.2*s, shift=s*[0,0.15], anchor=BOT);\n        }\n        yrot_copies([-90,90])\n            prismoid(s*[0.01,0.2], s*[0.01,0.05],\n                h=0.5*s, shift=s*[0,0.15], anchor=BOT);\n    }\n    color(\"#777\") zcopies(0.1*s) sphere(d=0.02*s);\n    back(0.09*s) {\n        color(\"#f00\") right(0.46*s) sphere(d=0.04*s);\n        color(\"#0f0\") left(0.46*s) sphere(d=0.04*s);\n    }\n}\n\n\n\n// Module: frame_ref()\n// Synopsis: Shows axis orientation arrows.\n// SynTags: Geom\n// Topics: Attachments\n// See Also: anchor_arrow(), anchor_arrow2d(), show_anchors(), expose_anchors()\n// Usage:\n//   frame_ref(s, opacity);\n// Description:\n//   Displays X,Y,Z axis arrows in red, green, and blue respectively.\n// Arguments:\n//   s = Length of the arrows.\n//   opacity = The opacity of the arrows.  0.0 is invisible, 1.0 is opaque.  Default: 1.0\n// Examples:\n//   frame_ref(25);\n//   frame_ref(30, opacity=0.5);\nmodule frame_ref(s=15, opacity=1) {\n    cube(0.01, center=true) {\n        attach([1,0,0]) anchor_arrow(s=s, flag=false, color=[1.0, 0.3, 0.3, opacity]);\n        attach([0,1,0]) anchor_arrow(s=s, flag=false, color=[0.3, 1.0, 0.3, opacity]);\n        attach([0,0,1]) anchor_arrow(s=s, flag=false, color=[0.3, 0.3, 1.0, opacity]);\n        children();\n    }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n///\n/// Code after this is internal code for managing edge and corner sets and for displaying\n/// edge and corners in the docs\n///\n\nmodule _edges_text3d(txt,size=3) {\n    if (is_list(txt)) {\n        for (i=idx(txt)) {\n            down((i-len(txt)/2+0.5)*size*1.5) {\n                _edges_text3d(txt[i], size=size);\n            }\n        }\n    } else {\n        xrot(90) color(\"#000\")\n        linear_extrude(height=0.1) {\n            text(text=txt, size=size, halign=\"center\", valign=\"center\");\n        }\n    }\n}\n\n\nfunction _edges_vec_txt(x) = is_string(x)? str(\"\\\"\", x, \"\\\"\") :\n    assert(is_string(x) || is_vector(x,3), str(x))\n    let(\n        lst = concat(\n            x.z>0? [\"TOP\"]   : x.z<0? [\"BOT\"]  : [],\n            x.y>0? [\"BACK\"]  : x.y<0? [\"FWD\"]  : [],\n            x.x>0? [\"RIGHT\"] : x.x<0? [\"LEFT\"] : []\n        ),\n        out = [\n           for (i = idx(lst))\n           i>0? str(\"+\",lst[i]) : lst[i]\n        ]\n    ) out;\n\n\nfunction _edges_text(edges) =\n    is_string(edges) ? [str(\"\\\"\",edges,\"\\\"\")] :\n    edges==EDGES_NONE ? [\"EDGES_NONE\"] :\n    edges==EDGES_ALL ? [\"EDGES_ALL\"] :\n    _is_edge_array(edges) ? [\"\"] :\n    is_vector(edges,3) ? _edges_vec_txt(edges) :\n    is_list(edges) ? let(\n        lst = [for (x=edges) each _edges_text(x)],\n        out = [\n            for (i=idx(lst))\n            str(\n                (i==0? \"[\" : \"\"),\n                lst[i],\n                (i<len(lst)-1? \",\" : \"\"),\n                (i==len(lst)-1? \"]\" : \"\")\n            )\n        ]\n    ) out :\n    [\"\"];\n\n\n\n/// Internal Constant: EDGES_NONE\n/// Topics: Edges\n/// See Also: EDGES_ALL, edges()\n/// Description:\n///   The set of no edges.\n/// Figure(3D):\n///   _show_edges(edges=\"NONE\");\nEDGES_NONE = [[0,0,0,0], [0,0,0,0], [0,0,0,0]];\n\n\n/// Internal Constant: EDGES_ALL\n/// Topics: Edges\n/// See Also: EDGES_NONE, edges()\n/// Description:\n///   The set of all edges.\n/// Figure(3D):\n///   _show_edges(edges=\"ALL\");\nEDGES_ALL = [[1,1,1,1], [1,1,1,1], [1,1,1,1]];\n\n\n/// Internal Constant: EDGES_OFFSETS\n/// Topics: Edges\n/// See Also: EDGES_NONE, EDGES_ALL, edges()\n/// Description:\n///   The vectors pointing to the center of each edge of a unit sized cube.\n///   Each item in an edge array will have a corresponding vector in this array.\nEDGE_OFFSETS = [\n    [\n        [ 0,-1,-1],\n        [ 0, 1,-1],\n        [ 0,-1, 1],\n        [ 0, 1, 1]\n    ], [\n        [-1, 0,-1],\n        [ 1, 0,-1],\n        [-1, 0, 1],\n        [ 1, 0, 1]\n    ], [\n        [-1,-1, 0],\n        [ 1,-1, 0],\n        [-1, 1, 0],\n        [ 1, 1, 0]\n    ]\n];\n\n\n\n/// Internal Function: _is_edge_array()\n/// Topics: Edges, Type Checking\n/// Usage:\n///   bool = _is_edge_array(x);\n/// Description:\n///   Returns true if the given value has the form of an edge array.\n/// Arguments:\n///   x = The item to check the type of.\n/// See Also: edges(), EDGES_NONE, EDGES_ALL\nfunction _is_edge_array(x) = is_list(x) && is_vector(x[0]) && len(x)==3 && len(x[0])==4;\n\n\nfunction _edge_set(v) =\n    _is_edge_array(v)? v : [\n    for (ax=[0:2]) [\n        for (b=[-1,1], a=[-1,1]) let(\n            v2=[[0,a,b],[a,0,b],[a,b,0]][ax]\n        ) (\n            is_string(v)? (\n                v==\"X\"? (ax==0) :   // Return all X axis aligned edges.\n                v==\"Y\"? (ax==1) :   // Return all Y axis aligned edges.\n                v==\"Z\"? (ax==2) :   // Return all Z axis aligned edges.\n                v==\"ALL\"? true :    // Return all edges.\n                v==\"NONE\"? false :  // Return no edges.\n                let(valid_values = [\"X\", \"Y\", \"Z\", \"ALL\", \"NONE\"])\n                assert(\n                    in_list(v, valid_values),\n                    str(v, \" must be a vector, edge array, or one of \", valid_values)\n                ) v\n            ) :\n            let(nonz = sum(v_abs(v)))\n            nonz==2? (v==v2) :  // Edge: return matching edge.\n            let(\n                matches = num_true([\n                    for (i=[0:2]) v[i] && (v[i]==v2[i])\n                ])\n            )\n            nonz==1? (matches==1) :  // Face: return surrounding edges.\n            (matches==2)             // Corner: return touching edges.\n        )? 1 : 0\n    ]\n];\n\n\n/// Internal Function: _normalize_edges()\n/// Topics: Edges\n/// Usage:\n///   edges = _normalize_edges(v);\n/// Description:\n///   Normalizes all values in an edge array to be `1`, if it was originally greater than `0`,\n///   or `0`, if it was originally less than or equal to `0`.\n/// See Also:  edges(), EDGES_NONE, EDGES_ALL\nfunction _normalize_edges(v) = [for (ax=v) [for (edge=ax) edge>0? 1 : 0]];\n\n\n\n\n/// Internal Function: _edges()\n/// Topics: Edges\n/// Usage:\n///   edgs = _edges(v);\n///   edgs = _edges(v, except);\n///\n/// Description:\n///   Takes a list of edge set descriptors, and returns a normalized edges array\n///   that represents all those given edges.\n/// Arguments:\n///   v = The edge set to include.\n///   except = The edge set to specifically exclude, even if they are in `v`.\n///\n/// See Also:  EDGES_NONE, EDGES_ALL\n///\nfunction _edges(v, except=[]) =\n    v==[] ? EDGES_NONE :\n    (is_string(v) || is_vector(v) || _is_edge_array(v))? _edges([v], except=except) :\n    (is_string(except) || is_vector(except) || _is_edge_array(except))? _edges(v, except=[except]) :\n    except==[]? _normalize_edges(sum([for (x=v) _edge_set(x)])) :\n    _normalize_edges(\n        _normalize_edges(sum([for (x=v) _edge_set(x)])) -\n        sum([for (x=except) _edge_set(x)])\n    );\n\n\n/// Internal Module: _show_edges()\n/// Topics: Edges, Debugging\n/// Usage:\n///   _show_edges(edges, [size=], [text=], [txtsize=]);\n/// Description:\n///   Draws a semi-transparent cube with the given edges highlighted in red.\n/// Arguments:\n///   edges = The edges to highlight.\n///   size = The scalar size of the cube.\n///   text = The text to show on the front of the cube.\n///   txtsize = The size of the text.\n/// See Also: _edges(), EDGES_NONE, EDGES_ALL\n/// Example:\n///   _show_edges(size=30, edges=[\"X\",\"Y\"]);\nmodule _show_edges(edges=\"ALL\", size=20, text, txtsize=3,toplabel) {\n    edge_set = _edges(edges);\n    text = !is_undef(text) ? text : _edges_text(edges);\n    color(\"red\") {\n        for (axis=[0:2], i=[0:3]) {\n            if (edge_set[axis][i] > 0) {\n                translate(EDGE_OFFSETS[axis][i]*size/2) {\n                    if (axis==0) xcyl(h=size, d=2);\n                    if (axis==1) ycyl(h=size, d=2);\n                    if (axis==2) zcyl(h=size, d=2);\n                }\n            }\n        }\n    }\n    fwd(size/2) _edges_text3d(text, size=txtsize);\n    color(\"yellow\",0.7) cuboid(size=size);\n    vpr = [55,0,25];\n    color(\"black\")\n    if (is_def(toplabel))\n      for(h=idx(toplabel)) up(21+6*h)rot(vpr) text3d(select(toplabel,-h-1),size=3.3,h=0.1,orient=UP,anchor=FRONT);\n}\n\n\n\n\n/// Internal Constant: CORNERS_NONE\n/// Topics: Corners\n/// Description:\n///   The set of no corners.\n/// Figure(3D):\n///   _show_corners(corners=\"NONE\");\n/// See Also: CORNERS_ALL, corners()\nCORNERS_NONE = [0,0,0,0,0,0,0,0];  // No corners.\n\n\n/// Internal Constant: CORNERS_ALL\n/// Topics: Corners\n/// Description:\n///   The set of all corners.\n/// Figure(3D):\n///   _show_corners(corners=\"ALL\");\n/// See Also: CORNERS_NONE, _corners()\nCORNERS_ALL = [1,1,1,1,1,1,1,1];\n\n\n/// Internal Constant: CORNER_OFFSETS\n/// Topics: Corners\n/// Description:\n///   The vectors pointing to each corner of a unit sized cube.\n///   Each item in a corner array will have a corresponding vector in this array.\n/// See Also: CORNERS_NONE, CORNERS_ALL, _corners()\nCORNER_OFFSETS = [\n    [-1,-1,-1], [ 1,-1,-1], [-1, 1,-1], [ 1, 1,-1],\n    [-1,-1, 1], [ 1,-1, 1], [-1, 1, 1], [ 1, 1, 1]\n];\n\n\n\n\n/// Internal Function: _is_corner_array()\n/// Topics: Corners, Type Checking\n/// Usage:\n///   bool = _is_corner_array(x)\n/// Description:\n///   Returns true if the given value has the form of a corner array.\n/// See Also: CORNERS_NONE, CORNERS_ALL, _corners()\nfunction _is_corner_array(x) = is_vector(x) && len(x)==8 && all([for (xx=x) xx==1||xx==0]);\n\n\n/// Internal Function: _normalize_corners()\n/// Topics: Corners\n/// Usage:\n///   corns = _normalize_corners(v);\n/// Description:\n///   Normalizes all values in a corner array to be `1`, if it was originally greater than `0`,\n///   or `0`, if it was originally less than or equal to `0`.\n/// See Also: CORNERS_NONE, CORNERS_ALL, _corners()\nfunction _normalize_corners(v) = [for (x=v) x>0? 1 : 0];\n\n\nfunction _corner_set(v) =\n    _is_corner_array(v)? v : [\n    for (i=[0:7]) let(\n        v2 = CORNER_OFFSETS[i]\n    ) (\n        is_string(v)? (\n            v==\"ALL\"? true :    // Return all corners.\n            v==\"NONE\"? false :  // Return no corners.\n            let(valid_values = [\"ALL\", \"NONE\"])\n            assert(\n                in_list(v, valid_values),\n                str(v, \" must be a vector, corner array, or one of \", valid_values)\n            ) v\n        ) :\n        all([for (i=[0:2]) !v[i] || (v[i]==v2[i])])\n    )? 1 : 0\n];\n\n\n/// Function: _corners()\n/// Topics: Corners\n/// Usage:\n///   corns = _corners(v);\n///   corns = _corners(v, except);\n/// Description:\n///   Takes a list of corner set descriptors, and returns a normalized corners array\n///   that represents all those given corners.  If the `except` argument is given\n///   a list of corner set descriptors, then all those corners will be removed\n///   from the returned corners array.  If either argument only has a single corner\n///   set descriptor, you do not have to pass it in a list.\nfunction _corners(v, except=[]) =\n    v==[] ? CORNERS_NONE :\n    (is_string(v) || is_vector(v) || _is_corner_array(v))? _corners([v], except=except) :\n    (is_string(except) || is_vector(except) || _is_corner_array(except))? _corners(v, except=[except]) :\n    except==[]? _normalize_corners(sum([for (x=v) _corner_set(x)])) :\n    let(\n        a = _normalize_corners(sum([for (x=v) _corner_set(x)])),\n        b = _normalize_corners(sum([for (x=except) _corner_set(x)]))\n    ) _normalize_corners(a - b);\n\n\n/// Internal Function: _corner_edges()\n/// Topics: Corners\n/// Description:\n///   Returns [XCOUNT,YCOUNT,ZCOUNT] where each is the count of edges aligned with that\n///   axis that are in the edge set and touch the given corner.\n/// Arguments:\n///   edges = Standard edges array.\n///   v = Vector pointing to the corner to count edge intersections at.\n/// See Also: CORNERS_NONE, CORNERS_ALL, _corners()\nfunction _corner_edges(edges, v) =\n    let(u = (v+[1,1,1])/2) [edges[0][u.y+u.z*2], edges[1][u.x+u.z*2], edges[2][u.x+u.y*2]];\n\n\n/// InternalFunction: _corner_edge_count()\n/// Topics: Corners\n/// Description:\n///   Counts how many given edges intersect at a specific corner.\n/// Arguments:\n///   edges = Standard edges array.\n///   v = Vector pointing to the corner to count edge intersections at.\n/// See Also: CORNERS_NONE, CORNERS_ALL, _corners()\nfunction _corner_edge_count(edges, v) =\n    let(u = (v+[1,1,1])/2) edges[0][u.y+u.z*2] + edges[1][u.x+u.z*2] + edges[2][u.x+u.y*2];\n\n\nfunction _corners_text(corners) =\n    is_string(corners) ? [str(\"\\\"\",corners,\"\\\"\")] :\n    corners==CORNERS_NONE ? [\"CORNERS_NONE\"] :\n    corners==CORNERS_ALL ? [\"CORNERS_ALL\"] :\n    _is_corner_array(corners) ? [\"\"] :\n    is_vector(corners,3) ? _edges_vec_txt(corners) :\n    is_list(corners) ? let(\n        lst = [for (x=corners) each _corners_text(x)],\n        out = [\n            for (i=idx(lst))\n            str(\n                (i==0? \"[\" : \"\"),\n                lst[i],\n                (i<len(lst)-1? \",\" : \"\"),\n                (i==len(lst)-1? \"]\" : \"\")\n            )\n        ]\n    ) out :\n    [\"\"];\n\n\n/// Internal Module: _show_corners()\n/// Topics: Corners, Debugging\n/// Usage:\n///   _show_corners(corners, [size=], [text=], [txtsize=]);\n/// Description:\n///   Draws a semi-transparent cube with the given corners highlighted in red.\n/// Arguments:\n///   corners = The corners to highlight.\n///   size = The scalar size of the cube.\n///   text = If given, overrides the text to be shown on the front of the cube.\n///   txtsize = The size of the text.\n/// See Also: CORNERS_NONE, CORNERS_ALL, corners()\n/// Example:\n///   _show_corners(corners=FWD+RIGHT, size=30);\nmodule _show_corners(corners=\"ALL\", size=20, text, txtsize=3,toplabel) {\n    corner_set = _corners(corners);\n    text = !is_undef(text) ? text : _corners_text(corners);\n    for (i=[0:7]) if (corner_set[i]>0)\n        translate(CORNER_OFFSETS[i]*size/2)\n            color(\"red\") sphere(d=2, $fn=16);\n    fwd(size/2) _edges_text3d(text, size=txtsize);\n    color(\"yellow\",0.7) cuboid(size=size);\n    vpr = [55,0,25];\n    color(\"black\")\n    if (is_def(toplabel))\n      for(h=idx(toplabel)) up(21+6*h)rot(vpr) text3d(select(toplabel,-h-1),size=3.3,h=.1,orient=UP,anchor=FRONT);\n}\n\nmodule _show_cube_faces(faces, size=20, toplabel,botlabel) {\n   color(\"red\")\n     for(f=faces){\n          move(f*size/2) rot(from=UP,to=f)\n             cuboid([size,size,.1]);\n     }\n   vpr = [55,0,25];\n   color(\"black\"){\n   if (is_def(toplabel))\n     for(h=idx(toplabel)) up(21+6*h)rot(vpr) text3d(select(toplabel,-h-1),size=3.3,h=.1,orient=UP,anchor=FRONT);\n   if (is_def(botlabel))\n     for(h=idx(botlabel)) down(26+6*h)rot(vpr) text3d(botlabel[h],size=3.3,h=.1,orient=UP,anchor=FRONT);\n   }\n   color(\"yellow\",0.7) cuboid(size=size);\n}\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-2", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: ball_bearings.scad\n//   Models for standard ball bearing cartridges.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/ball_bearings.scad>\n// FileGroup: Parts\n// FileSummary: Models for standard ball bearing cartridges.\n//////////////////////////////////////////////////////////////////////\n\n\n\n// Section: Ball Bearing Models\n\n// Module: ball_bearing()\n// Synopsis: Creates a standardized ball bearing assembly.\n// SynTags: Geom\n// Topics: Parts, Bearings\n// See Also: linear_bearing(), lmXuu_bearing(), lmXuu_housing()\n// Description:\n//   Creates a model of a ball bearing assembly.\n// Arguments:\n//   trade_size = String name of a standard ball bearing trade size.  ie: \"608\", \"6902ZZ\", or \"R8\"\n//   id = Inner diameter of ball bearing assembly.\n//   od = Outer diameter of ball bearing assembly.\n//   width = Width of ball bearing assembly.\n//   shield = Does the ball bearing assembly have a shield.\n//   flange = Does the ball bearing assembly have a flange.\n//   fd = Diameter of the flange (only used if `flange=true`).\n//   fw = Width of the flange (only used if `flange=true`).\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   ball_bearing(\"608\", $fn=72);\n// Example:\n//   ball_bearing(\"608ZZ\", $fn=72);\n// Example:\n//   ball_bearing(\"R8\", $fn=72);\n// Example:\n//   ball_bearing(id=12,od=32,width=10,shield=false, $fn=72);\n// Example:\n//   ball_bearing(\"MF105ZZ\", $fn=72);\n// Example:\n//   ball_bearing(\"F688ZZ\", $fn=72);\n// Example:\n//   ball_bearing(id=12,od=24,width=6,shield=true, flange=true, fd=26.5, fw=1.5, $fn=72);\nmodule ball_bearing(trade_size, id, od, width, shield=true, flange=false, fd, fw, anchor=CTR, spin=0, orient=UP) {\n    info = is_undef(trade_size)? [id, od, width, shield, flange, fd, fw] :\n        ball_bearing_info(trade_size);\n    check = assert(all_defined(select(info, 0,4)), \"Bad Input\");\n    if(flange){\n        assert(!is_undef(fd), \"If flange is set you must specify it's diameter\");\n        assert(!is_undef(fw), \"If flange is set you must specify it's width\");\n    }\n    id = info[0];\n    od = info[1];\n    width = info[2];\n    shield = info[3];\n    flange = info[4];\n    fd = info[5];\n    fw = info[6];\n    mid_d = (id+od)/2;\n    wall = (od-id)/2/3;\n    color(\"silver\")\n    attachable(anchor,spin,orient, d=od, l=width) {\n        if (shield) {\n            tube(id=id, wall=wall, h=width);\n            tube(od=od, wall=wall, h=width);\n            tube(id=id+0.1, od=od-0.1, h=(wall*2+width)/2);\n            if (flange){\n                translate([0,0,-width/2+fw/2])tube(id=od, od=fd, h=fw);\n            }\n        } else {\n            ball_cnt = floor(PI*mid_d*0.95 / (wall*2));\n            difference() {\n                union() {\n                    tube(id=id, wall=wall, h=width);\n                    tube(od=od, wall=wall, h=width);\n                }\n                torus(r_maj=mid_d/2, r_min=wall);\n            }\n            for (i=[0:1:ball_cnt-1]) {\n                zrot(i*360/ball_cnt) right(mid_d/2) sphere(d=wall*2);\n            }\n            if (flange){\n                translate([0,0,-width/2+fw/2])tube(id=od, od=fd, h=fw);\n            }\n        }\n\n\n        children();\n    }\n}\n\n\n\n// Section: Ball Bearing Info\n\n\n// Function: ball_bearing_info()\n// Synopsis: Returns size info for a standardized ball bearing assembly.\n// Topics: Parts, Bearings\n// See Also: ball_bearing(), linear_bearing(), lmXuu_info()\n// Description:\n//   Get dimensional info for a standard metric ball bearing cartridge.\n//   Returns `[SHAFT_DIAM, OUTER_DIAM, WIDTH, SHIELDED, FLANGED, FLANGE_DIAM, FLANGE_WIDTH]` for the cylindrical cartridge.\n// Arguments:\n//   size = Inner diameter of lmXuu bearing, in mm.\nfunction ball_bearing_info(trade_size) =\n    assert(is_string(trade_size))\n    let(\n        IN = 25.4,\n        data = [\n            // trade_size, ID,     OD,      width,  shielded, flanged, fd, fw \n            [      \"R2\",  1/8*IN,  3/8*IN,  5/32*IN, false,   false,   0,  0 ],\n            [      \"R3\", 3/16*IN,  1/2*IN,  5/32*IN, false,   false,   0,  0 ],\n            [      \"R4\",  1/4*IN,  5/8*IN, 0.196*IN, false,   false,   0,  0 ],\n            [      \"R6\",  3/8*IN,  7/8*IN,  7/32*IN, false,   false,   0,  0 ],\n            [      \"R8\",  1/2*IN,  9/8*IN,   1/4*IN, false,   false,   0,  0 ],\n            [     \"R10\",  5/8*IN, 11/8*IN,  9/32*IN, false,   false,   0,  0 ],\n            [     \"R12\",  3/4*IN, 13/8*IN,  5/16*IN, false,   false,   0,  0 ],\n            [     \"R14\",  7/8*IN, 15/8*IN,   3/8*IN, false,   false,   0,  0 ],\n            [     \"R16\",  8/8*IN, 16/8*IN,   3/8*IN, false,   false,   0,  0 ],\n            [     \"R18\",  9/8*IN, 17/8*IN,   3/8*IN, false,   false,   0,  0 ],\n            [     \"R20\", 10/8*IN, 18/8*IN,   3/8*IN, false,   false,   0,  0 ],\n            [     \"R22\", 11/8*IN, 20/8*IN,  7/16*IN, false,   false,   0,  0 ],\n            [     \"R24\", 12/8*IN, 21/8*IN,  7/16*IN, false,   false,   0,  0 ],\n\n            [    \"R2ZZ\",  1/8*IN,  3/8*IN,  5/32*IN, true,    false,   0,  0  ],\n            [    \"R3ZZ\", 3/16*IN,  1/2*IN,  5/32*IN, true,    false,   0,  0  ],\n            [    \"R4ZZ\",  1/4*IN,  5/8*IN, 0.196*IN, true,    false,   0,  0  ],\n            [    \"R6ZZ\",  3/8*IN,  7/8*IN,  7/32*IN, true,    false,   0,  0  ],\n            [    \"R8ZZ\",  1/2*IN,  9/8*IN,   1/4*IN, true,    false,   0,  0  ],\n            [   \"R10ZZ\",  5/8*IN, 11/8*IN,  9/32*IN, true,    false,   0,  0  ],\n            [   \"R12ZZ\",  3/4*IN, 13/8*IN,  5/16*IN, true,    false,   0,  0  ],\n            [   \"R14ZZ\",  7/8*IN, 15/8*IN,   3/8*IN, true,    false,   0,  0  ],\n            [   \"R16ZZ\",  8/8*IN, 16/8*IN,   3/8*IN, true,    false,   0,  0  ],\n            [   \"R18ZZ\",  9/8*IN, 17/8*IN,   3/8*IN, true,    false,   0,  0  ],\n            [   \"R20ZZ\", 10/8*IN, 18/8*IN,   3/8*IN, true,    false,   0,  0  ],\n            [   \"R22ZZ\", 11/8*IN, 20/8*IN,  7/16*IN, true,    false,   0,  0  ],\n            [   \"R24ZZ\", 12/8*IN, 21/8*IN,  7/16*IN, true,    false,   0,  0  ],\n\n            [     \"608\",   8,  22,   7, false, false, 0, 0 ],\n            [     \"629\",   9,  26,   8, false, false, 0, 0 ],\n            [     \"635\",   5,  19,   6, false, false, 0, 0 ],\n            [    \"6000\",  10,  26,   8, false, false, 0, 0 ],\n            [    \"6001\",  12,  28,   8, false, false, 0, 0 ],\n            [    \"6002\",  15,  32,   9, false, false, 0, 0 ],\n            [    \"6003\",  17,  35,  10, false, false, 0, 0 ],\n            [    \"6007\",  35,  62,  14, false, false, 0, 0 ],\n            [    \"6200\",  10,  30,   9, false, false, 0, 0 ],\n            [    \"6201\",  12,  32,  10, false, false, 0, 0 ],\n            [    \"6202\",  15,  35,  11, false, false, 0, 0 ],\n            [    \"6203\",  17,  40,  12, false, false, 0, 0 ],\n            [    \"6204\",  20,  47,  14, false, false, 0, 0 ],\n            [    \"6205\",  25,  52,  15, false, false, 0, 0 ],\n            [    \"6206\",  30,  62,  16, false, false, 0, 0 ],\n            [    \"6207\",  35,  72,  17, false, false, 0, 0 ],\n            [    \"6208\",  40,  80,  18, false, false, 0, 0 ],\n            [    \"6209\",  45,  85,  19, false, false, 0, 0 ],\n            [    \"6210\",  50,  90,  20, false, false, 0, 0 ],\n            [    \"6211\",  55, 100,  21, false, false, 0, 0 ],\n            [    \"6212\",  60, 110,  22, false, false, 0, 0 ],\n            [    \"6301\",  12,  37,  12, false, false, 0, 0 ],\n            [    \"6302\",  15,  42,  13, false, false, 0, 0 ],\n            [    \"6303\",  17,  47,  14, false, false, 0, 0 ],\n            [    \"6304\",  20,  52,  15, false, false, 0, 0 ],\n            [    \"6305\",  25,  62,  17, false, false, 0, 0 ],\n            [    \"6306\",  30,  72,  19, false, false, 0, 0 ],\n            [    \"6307\",  35,  80,  21, false, false, 0, 0 ],\n            [    \"6308\",  40,  90,  23, false, false, 0, 0 ],\n            [    \"6309\",  45, 100,  25, false, false, 0, 0 ],\n            [    \"6310\",  50, 110,  27, false, false, 0, 0 ],\n            [    \"6311\",  55, 120,  29, false, false, 0, 0 ],\n            [    \"6312\",  60, 130,  31, false, false, 0, 0 ],\n            [    \"6403\",  17,  62,  17, false, false, 0, 0 ],\n            [    \"6800\",  10,  19,   5, false, false, 0, 0 ],\n            [    \"6801\",  12,  21,   5, false, false, 0, 0 ],\n            [    \"6802\",  15,  24,   5, false, false, 0, 0 ],\n            [    \"6803\",  17,  26,   5, false, false, 0, 0 ],\n            [    \"6804\",  20,  32,   7, false, false, 0, 0 ],\n            [    \"6805\",  25,  37,   7, false, false, 0, 0 ],\n            [    \"6806\",  30,  42,   7, false, false, 0, 0 ],\n            [    \"6900\",  10,  22,   6, false, false, 0, 0 ],\n            [    \"6901\",  12,  24,   6, false, false, 0, 0 ],\n            [    \"6902\",  15,  28,   7, false, false, 0, 0 ],\n            [    \"6903\",  17,  30,   7, false, false, 0, 0 ],\n            [    \"6904\",  20,  37,   9, false, false, 0, 0 ],\n            [    \"6905\",  25,  42,   9, false, false, 0, 0 ],\n            [    \"6906\",  30,  47,   9, false, false, 0, 0 ],\n            [    \"6907\",  35,  55,  10, false, false, 0, 0 ],\n            [    \"6908\",  40,  62,  12, false, false, 0, 0 ],\n            [   \"16002\",  15,  22,   8, false, false, 0, 0 ],\n            [   \"16004\",  20,  42,   8, false, false, 0, 0 ],\n            [   \"16005\",  25,  47,   8, false, false, 0, 0 ],\n            [   \"16100\",  10,  28,   8, false, false, 0, 0 ],\n            [   \"16101\",  12,  30,   8, false, false, 0, 0 ],\n\n            [   \"608ZZ\",   8,  22,   7, true, false, 0, 0 ],\n            [   \"629ZZ\",   9,  26,   8, true, false, 0, 0 ],\n            [   \"635ZZ\",   5,  19,   6, true, false, 0, 0 ],\n            [  \"6000ZZ\",  10,  26,   8, true, false, 0, 0 ],\n            [  \"6001ZZ\",  12,  28,   8, true, false, 0, 0 ],\n            [  \"6002ZZ\",  15,  32,   9, true, false, 0, 0 ],\n            [  \"6003ZZ\",  17,  35,  10, true, false, 0, 0 ],\n            [  \"6007ZZ\",  35,  62,  14, true, false, 0, 0 ],\n            [  \"6200ZZ\",  10,  30,   9, true, false, 0, 0 ],\n            [  \"6201ZZ\",  12,  32,  10, true, false, 0, 0 ],\n            [  \"6202ZZ\",  15,  35,  11, true, false, 0, 0 ],\n            [  \"6203ZZ\",  17,  40,  12, true, false, 0, 0 ],\n            [  \"6204ZZ\",  20,  47,  14, true, false, 0, 0 ],\n            [  \"6205ZZ\",  25,  52,  15, true, false, 0, 0 ],\n            [  \"6206ZZ\",  30,  62,  16, true, false, 0, 0 ],\n            [  \"6207ZZ\",  35,  72,  17, true, false, 0, 0 ],\n            [  \"6208ZZ\",  40,  80,  18, true, false, 0, 0 ],\n            [  \"6209ZZ\",  45,  85,  19, true, false, 0, 0 ],\n            [  \"6210ZZ\",  50,  90,  20, true, false, 0, 0 ],\n            [  \"6211ZZ\",  55, 100,  21, true, false, 0, 0 ],\n            [  \"6212ZZ\",  60, 110,  22, true, false, 0, 0 ],\n            [  \"6301ZZ\",  12,  37,  12, true, false, 0, 0 ],\n            [  \"6302ZZ\",  15,  42,  13, true, false, 0, 0 ],\n            [  \"6303ZZ\",  17,  47,  14, true, false, 0, 0 ],\n            [  \"6304ZZ\",  20,  52,  15, true, false, 0, 0 ],\n            [  \"6305ZZ\",  25,  62,  17, true, false, 0, 0 ],\n            [  \"6306ZZ\",  30,  72,  19, true, false, 0, 0 ],\n            [  \"6307ZZ\",  35,  80,  21, true, false, 0, 0 ],\n            [  \"6308ZZ\",  40,  90,  23, true, false, 0, 0 ],\n            [  \"6309ZZ\",  45, 100,  25, true, false, 0, 0 ],\n            [  \"6310ZZ\",  50, 110,  27, true, false, 0, 0 ],\n            [  \"6311ZZ\",  55, 120,  29, true, false, 0, 0 ],\n            [  \"6312ZZ\",  60, 130,  31, true, false, 0, 0 ],\n            [  \"6403ZZ\",  17,  62,  17, true, false, 0, 0 ],\n            [  \"6800ZZ\",  10,  19,   5, true, false, 0, 0 ],\n            [  \"6801ZZ\",  12,  21,   5, true, false, 0, 0 ],\n            [  \"6802ZZ\",  15,  24,   5, true, false, 0, 0 ],\n            [  \"6803ZZ\",  17,  26,   5, true, false, 0, 0 ],\n            [  \"6804ZZ\",  20,  32,   7, true, false, 0, 0 ],\n            [  \"6805ZZ\",  25,  37,   7, true, false, 0, 0 ],\n            [  \"6806ZZ\",  30,  42,   7, true, false, 0, 0 ],\n            [  \"6900ZZ\",  10,  22,   6, true, false, 0, 0 ],\n            [  \"6901ZZ\",  12,  24,   6, true, false, 0, 0 ],\n            [  \"6902ZZ\",  15,  28,   7, true, false, 0, 0 ],\n            [  \"6903ZZ\",  17,  30,   7, true, false, 0, 0 ],\n            [  \"6904ZZ\",  20,  37,   9, true, false, 0, 0 ],\n            [  \"6905ZZ\",  25,  42,   9, true, false, 0, 0 ],\n            [  \"6906ZZ\",  30,  47,   9, true, false, 0, 0 ],\n            [  \"6907ZZ\",  35,  55,  10, true, false, 0, 0 ],\n            [  \"6908ZZ\",  40,  62,  12, true, false, 0, 0 ],\n            [ \"16002ZZ\",  15,  22,   8, true, false, 0, 0 ],\n            [ \"16004ZZ\",  20,  42,   8, true, false, 0, 0 ],\n            [ \"16005ZZ\",  25,  47,   8, true, false, 0, 0 ],\n            [ \"16100ZZ\",  10,  28,   8, true, false, 0, 0 ],\n            [ \"16101ZZ\",  12,  30,   8, true, false, 0, 0 ],\n\n            [  \"MF52ZZ\",   2,   5,   2, true,  true,   6.2,  0.6 ],\n            [  \"MF63ZZ\",   3,   6, 2.5, true,  true,   7.2,  0.6 ],\n            [  \"MF74ZZ\",   4,   7, 2.5, true,  true,   8.2,  0.6 ],\n            [  \"MF83ZZ\",   3,   8, 2.5, true,  true,   9.2,  0.6 ],\n            [  \"MF85ZZ\",   5,   8, 2.5, true,  true,   9.2,  0.6 ],\n            [  \"MF95ZZ\",   5,   9, 2.5, true,  true,  10.2,  0.6 ],\n            [ \"MF105ZZ\",   5,  10,   3, true,  true,  11.2,  0.6 ],\n            [ \"MF117ZZ\",   7,  11, 2.5, true,  true,  12.2,  0.6 ],\n            [ \"MF128ZZ\",   8,  12, 3.5, true,  true,  13.6,  0.8 ],\n            [ \"MF148ZZ\",   8,  14, 3.5, true,  true,  15.6,  0.8 ],\n            [ \"F6700ZZ\",  10,  15,   4, true,  true,  16.8,  0.8 ],\n            [ \"F6701ZZ\",  12,  18,   4, true,  true,  19.8,  0.8 ],\n            [ \"F6800ZZ\",  10,  19,   5, true,  true,  21.1,  1.1 ],\n            [ \"F6801ZZ\",  12,  21,   5, true,  true,  23.1,  1.1 ],\n            [ \"F6802ZZ\",  15,  24,   5, true,  true,  26.1,  1.1 ],\n            [ \"F6803ZZ\",  17,  26,   5, true,  true,  28.1,  1.1 ],\n            [ \"F6804ZZ\",  20,  32,   7, true,  true,    35,  1.5 ],\n            [ \"F6805ZZ\",  25,  37,   7, true,  true,  40.2,  1.5 ],\n            [ \"F6900ZZ\",  10,  22,   6, true,  true,  24.5,  1.5 ],\n            [ \"F6901ZZ\",  12,  24,   6, true,  true,  26.5,  1.5 ],\n            \n            [  \"F683ZZ\",   3,   7,   3, false, true,   8.1,  0.6 ],\n            [  \"F684ZZ\",   4,   9,   4, false, true,  10.3,  0.6 ],\n            [  \"F685ZZ\",   5,  11,   5, false, true,  12.5,  1   ],\n            [  \"F686ZZ\",   6,  13,   5, false, true,    15,  1   ],\n            [  \"F687ZZ\",   7,  14,   5, false, true,    16,  1   ],\n            [  \"F688ZZ\",   8,  16,   5, false, true,    18,  1   ],\n            [  \"F689ZZ\",   9,  17,   5, false, true,    19,  1   ],\n            [ \"F6900ZZ\",  10,  22,   6, false, true,    25,  1.5 ],\n            [ \"F6901ZZ\",  12,  24,   6, false, true,  26.5,  1.5 ],\n            [ \"F6902ZZ\",  15,  28,   7, false, true,  31.5,  1.5 ],\n            [ \"F6903ZZ\",  17,  30,   7, false, true,  33.5,  1.5 ],\n            [ \"F6904ZZ\",  20,  37,   9, false, true,  40.5,  1.5 ],\n            [ \"F6905ZZ\",  25,  42,   9, false, true,  45.5,  1.5 ],\n            [ \"F6000ZZ\",  10,  26,   8, false, true,  28.5,  1.5 ],\n            [ \"F6001ZZ\",  12,  28,   8, false, true,  30.5,  1.5 ],\n            [ \"F6001ZZ\",  15,  32,   9, false, true,  34.5,  1.5 ],\n            [ \"F6003ZZ\",  17,  35,  10, false, true,  37.5,  1.5 ],\n            [ \"F6004ZZ\",  20,  42,  12, false, true,  44.5,  1.5 ],\n            [ \"F6005ZZ\",  25,  47,  12, false, true,  49.5,  1.5 ],\n            [ \"F6006ZZ\",  30,  55,  13, false, true,  57.5,  1.5 ],\n        ],\n        found = search([trade_size], data, 1)[0]\n    )\n    assert(found!=[], str(\"Unsupported ball bearing trade size: \", trade_size))\n    select(data[found], 1, -1);\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-3", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: beziers.scad\n//   Bezier curves and surfaces are way to represent smooth curves and smoothly curving\n//   surfaces with a set of control points.  The curve or surface is defined by\n//   the control points, but usually only passes through the first and last control point (the endpoints).\n//   This file provides some\n//   aids to constructing the control points, and highly optimized functions for\n//   computing the Bezier curves and surfaces given by the control points, \n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/beziers.scad>\n// FileGroup: Advanced Modeling\n// FileSummary: Bezier curves and surfaces.\n//////////////////////////////////////////////////////////////////////\n\n// Terminology:\n//   Path = A series of points joined by straight line segements.\n//   Bezier Curve = A polynomial curve defined by a list of control points.  The curve starts at the first control point and ends at the last one.  The other control points define the shape of the curve and they are often *NOT* on the curve\n//   Control Point = A point that influences the shape of the Bezier curve.\n//   Degree = The degree of the polynomial used to make the bezier curve.  A bezier curve of degree N will have N+1 control points.  Most beziers are cubic (degree 3).  The higher the degree, the more the curve can wiggle.  \n//   Bezier Parameter = A parameter, usually `u` below, that ranges from 0 to 1 to trace out the bezier curve.  When `u=0` you get the first control point and when `u=1` you get the last control point. Intermediate points are traced out *non-uniformly*.  \n//   Bezier Path = A list of bezier control points corresponding to a series of Bezier curves that connect together, end to end.  Because they connect, the endpoints are shared between control points and are not repeated, so a degree 3 bezier path representing two bezier curves will have seven entries to represent two sets of four control points.    **NOTE:** A \"bezier path\" is *NOT* a standard path\n//   Bezier Patch = A two-dimensional arrangement of Bezier control points that generate a bounded curved Bezier surface.  A Bezier patch is a (N+1) by (M+1) grid of control points, which defines surface with four edges (in the non-degenerate case). \n//   Bezier Surface = A surface defined by a list of one or more bezier patches.\n//   Spline Steps = The number of straight-line segments used to approximate a Bezier curve.  The more spline steps, the better the approximation to the curve, but the slower it will be to generate.  This plays a role analogous to `$fn` for circles.  Usually defaults to 16.\n\n\n// Section: Bezier Curves\n\n// Function: bezier_points()\n// Synopsis: Computes one or more specified points along a bezier curve.\n// SynTags: Path\n// Topics: Bezier Curves\n// See Also: bezier_curve(), bezier_curvature(), bezier_tangent(), bezier_derivative(), bezier_points()\n// Usage:\n//   pt = bezier_points(bezier, u);\n//   ptlist = bezier_points(bezier, RANGE);\n//   ptlist = bezier_points(bezier, LIST);\n// Description:\n//   Computes points on a bezier curve with control points specified by `bezier` at parameter values\n//   specified by `u`, which can be a scalar or a list.  The value `u=0` gives the first endpoint; `u=1` gives the final endpoint,\n//   and intermediate values of `u` fill in the curve in a non-uniform fashion.  This function uses an optimized method which\n//   is best when `u` is a long list and the bezier degree is 10 or less.  The degree of the bezier\n//   curve is `len(bezier)-1`.\n// Arguments:\n//   bezier = The list of endpoints and control points for this bezier curve.\n//   u = Parameter values for evaluating the curve, given as a single value, a list or a range.  \n// Example(2D): Quadratic (Degree 2) Bezier.\n//   bez = [[0,0], [30,30], [80,0]];\n//   debug_bezier(bez, N=len(bez)-1);\n//   translate(bezier_points(bez, 0.3)) color(\"red\") sphere(1);\n// Example(2D): Cubic (Degree 3) Bezier\n//   bez = [[0,0], [5,35], [60,-25], [80,0]];\n//   debug_bezier(bez, N=len(bez)-1);\n//   translate(bezier_points(bez, 0.4)) color(\"red\") sphere(1);\n// Example(2D): Degree 4 Bezier.\n//   bez = [[0,0], [5,15], [40,20], [60,-15], [80,0]];\n//   debug_bezier(bez, N=len(bez)-1);\n//   translate(bezier_points(bez, 0.8)) color(\"red\") sphere(1);\n// Example(2D): Giving a List of `u`\n//   bez = [[0,0], [5,35], [60,-25], [80,0]];\n//   debug_bezier(bez, N=len(bez)-1);\n//   pts = bezier_points(bez, [0, 0.2, 0.3, 0.7, 0.8, 1]);\n//   rainbow(pts) move($item) sphere(1.5, $fn=12);\n// Example(2D): Giving a Range of `u`\n//   bez = [[0,0], [5,35], [60,-25], [80,0]];\n//   debug_bezier(bez, N=len(bez)-1);\n//   pts = bezier_points(bez, [0:0.2:1]);\n//   rainbow(pts) move($item) sphere(1.5, $fn=12);\n\n// Ugly but speed optimized code for computing bezier curves using the matrix representation\n// See https://pomax.github.io/bezierinfo/#matrix for explanation.\n//\n// All of the loop unrolling makes and the use of the matrix lookup table make a big difference\n// in the speed of execution.  For orders 10 and below this code is 10-20 times faster than\n// the recursive code using the de Casteljau method depending on the bezier order and the\n// number of points evaluated in one call (more points is faster).  For orders 11 and above without the\n// lookup table or hard coded powers list the code is about twice as fast as the recursive method.\n// Note that everything I tried to simplify or tidy this code made is slower, sometimes a lot slower.\nfunction bezier_points(curve, u) =\n    is_num(u) ? bezier_points(curve,[u])[0] :\n    let(\n        N = len(curve)-1,\n        M = _bezier_matrix(N)*curve\n    )\n    N==0 ? [for(uval=u)[1]*M] :\n    N==1 ? [for(uval=u)[1, uval]*M] :\n    N==2 ? [for(uval=u)[1, uval, uval^2]*M] :\n    N==3 ? [for(uval=u)[1, uval, uval^2, uval^3]*M] :          \n    N==4 ? [for(uval=u)[1, uval, uval^2, uval^3, uval^4]*M] :\n    N==5 ? [for(uval=u)[1, uval, uval^2, uval^3, uval^4, uval^5]*M] :\n    N==6 ? [for(uval=u)[1, uval, uval^2, uval^3, uval^4, uval^5,uval^6]*M] :\n    N==7 ? [for(uval=u)[1, uval, uval^2, uval^3, uval^4, uval^5,uval^6, uval^7]*M] :\n    N==8 ? [for(uval=u)[1, uval, uval^2, uval^3, uval^4, uval^5,uval^6, uval^7, uval^8]*M] :\n    N==9 ? [for(uval=u)[1, uval, uval^2, uval^3, uval^4, uval^5,uval^6, uval^7, uval^8, uval^9]*M] :\n    N==10? [for(uval=u)[1, uval, uval^2, uval^3, uval^4, uval^5,uval^6, uval^7, uval^8, uval^9, uval^10]*M] :\n    /* N>=11 */  [for(uval=u)[for (i=[0:1:N]) uval^i]*M];\n\n\n// Not public.\nfunction _signed_pascals_triangle(N,tri=[[-1]]) =\n    len(tri)==N+1 ? tri :\n    let(last=tri[len(tri)-1])\n    _signed_pascals_triangle(N,concat(tri,[[-1, for(i=[0:1:len(tri)-2]) (i%2==1?-1:1)*(abs(last[i])+abs(last[i+1])),len(last)%2==0? -1:1]]));\n\n\n// Not public.\nfunction _compute_bezier_matrix(N) =\n    let(tri = _signed_pascals_triangle(N))\n    [for(i=[0:N]) concat(tri[N][i]*tri[i], repeat(0,N-i))];\n\n\n// The bezier matrix, which is related to Pascal's triangle, enables nonrecursive computation\n// of bezier points.  This method is much faster than the recursive de Casteljau method\n// in OpenScad, but we have to precompute the matrices to reap the full benefit.\n\n// Not public.\n_bezier_matrix_table = [\n    [[1]],\n    [[ 1, 0],\n     [-1, 1]],\n    [[1, 0, 0],\n     [-2, 2, 0],\n     [1, -2, 1]],\n    [[ 1, 0, 0, 0],\n     [-3, 3, 0, 0],\n     [ 3,-6, 3, 0],\n     [-1, 3,-3, 1]],\n    [[ 1,  0,  0, 0, 0],\n     [-4,  4,  0, 0, 0],\n     [ 6,-12,  6, 0, 0],\n     [-4, 12,-12, 4, 0],\n     [ 1, -4,  6,-4, 1]],\n    [[  1,  0, 0,   0, 0, 0],\n     [ -5,  5, 0,   0, 0, 0],\n     [ 10,-20, 10,  0, 0, 0],\n     [-10, 30,-30, 10, 0, 0],\n     [  5,-20, 30,-20, 5, 0],\n     [ -1,  5,-10, 10,-5, 1]],\n    [[  1,  0,  0,  0,  0, 0, 0],\n     [ -6,  6,  0,  0,  0, 0, 0],\n     [ 15,-30, 15,  0,  0, 0, 0],\n     [-20, 60,-60, 20,  0, 0, 0],\n     [ 15,-60, 90,-60, 15, 0, 0],\n     [ -6, 30,-60, 60,-30, 6, 0],\n     [  1, -6, 15,-20, 15,-6, 1]],\n    [[  1,   0,   0,   0,  0,   0, 0, 0],\n     [ -7,   7,   0,   0,  0,   0, 0, 0],\n     [ 21, -42,  21,   0,  0,   0, 0, 0],\n     [-35, 105,-105,  35,  0,   0, 0, 0],\n     [ 35,-140, 210,-140,  35,  0, 0, 0],\n     [-21, 105,-210, 210,-105, 21, 0, 0],\n     [  7, -42, 105,-140, 105,-42, 7, 0],\n     [ -1,   7, -21,  35, -35, 21,-7, 1]],\n    [[  1,   0,   0,   0,   0,   0,  0, 0, 0],\n     [ -8,   8,   0,   0,   0,   0,  0, 0, 0],\n     [ 28, -56,  28,   0,   0,   0,  0, 0, 0],\n     [-56, 168,-168,  56,   0,   0,  0, 0, 0],\n     [ 70,-280, 420,-280,  70,   0,  0, 0, 0],\n     [-56, 280,-560, 560,-280,  56,  0, 0, 0],\n     [ 28,-168, 420,-560, 420,-168, 28, 0, 0],\n     [ -8,  56,-168, 280,-280, 168,-56, 8, 0],\n     [  1,  -8,  28, -56,  70, -56, 28,-8, 1]],\n    [[1, 0, 0, 0, 0, 0, 0,  0, 0, 0], [-9, 9, 0, 0, 0, 0, 0, 0, 0, 0], [36, -72, 36, 0, 0, 0, 0, 0, 0, 0], [-84, 252, -252, 84, 0, 0, 0, 0, 0, 0],\n     [126, -504, 756, -504, 126, 0, 0, 0, 0, 0], [-126, 630, -1260, 1260, -630, 126, 0, 0, 0, 0], [84, -504, 1260, -1680, 1260, -504, 84, 0, 0, 0],\n     [-36, 252, -756, 1260, -1260, 756, -252, 36, 0, 0], [9, -72, 252, -504, 630, -504, 252, -72, 9, 0], [-1, 9, -36, 84, -126, 126, -84, 36, -9, 1]],\n    [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0], [45, -90, 45, 0, 0, 0, 0, 0, 0, 0, 0], [-120, 360, -360, 120, 0, 0, 0, 0, 0, 0, 0],\n     [210, -840, 1260, -840, 210, 0, 0, 0, 0, 0, 0], [-252, 1260, -2520, 2520, -1260, 252, 0, 0, 0, 0, 0],\n     [210, -1260, 3150, -4200, 3150, -1260, 210, 0, 0, 0, 0], [-120, 840, -2520, 4200, -4200, 2520, -840, 120, 0, 0, 0],\n     [45, -360, 1260, -2520, 3150, -2520, 1260, -360, 45, 0, 0], [-10, 90, -360, 840, -1260, 1260, -840, 360, -90, 10, 0],\n     [1, -10, 45, -120, 210, -252, 210, -120, 45, -10, 1]]\n];\n\n\n// Not public.\nfunction _bezier_matrix(N) =\n    N>10 ? _compute_bezier_matrix(N) :\n    _bezier_matrix_table[N];\n\n\n// Function: bezier_curve()\n// Synopsis: Computes a specified number of points on a bezier curve.\n// SynTags: Path\n// Topics: Bezier Curves\n// See Also: bezier_curve(), bezier_curvature(), bezier_tangent(), bezier_derivative(), bezier_points()\n// Usage:\n//   path = bezier_curve(bezier, [splinesteps], [endpoint]);\n// Description:\n//   Takes a list of bezier control points and generates splinesteps segments (splinesteps+1 points)\n//   along the bezier curve they define.\n//   Points start at the first control point and are sampled uniformly along the bezier parameter.\n//   The endpoints of the output will be *exactly* equal to the first and last bezier control points\n//   when endpoint is true.  If endpoint is false the sampling stops one step before the final point\n//   of the bezier curve, but you still get the same number of (more tightly spaced) points.  \n//   The distance between the points will *not* be equidistant.  \n//   The degree of the bezier curve is one less than the number of points in `curve`.\n// Arguments:\n//   bezier = The list of control points that define the Bezier curve. \n//   splinesteps = The number of segments to create on the bezier curve.  Default: 16\n//   endpoint = if false then exclude the endpoint.  Default: True\n// Example(2D): Quadratic (Degree 2) Bezier.\n//   bez = [[0,0], [30,30], [80,0]];\n//   move_copies(bezier_curve(bez, 8)) sphere(r=1.5, $fn=12);\n//   debug_bezier(bez, N=len(bez)-1);\n// Example(2D): Cubic (Degree 3) Bezier\n//   bez = [[0,0], [5,35], [60,-25], [80,0]];\n//   move_copies(bezier_curve(bez, 8)) sphere(r=1.5, $fn=12);\n//   debug_bezier(bez, N=len(bez)-1);\n// Example(2D): Degree 4 Bezier.\n//   bez = [[0,0], [5,15], [40,20], [60,-15], [80,0]];\n//   move_copies(bezier_curve(bez, 8)) sphere(r=1.5, $fn=12);\n//   debug_bezier(bez, N=len(bez)-1);\nfunction bezier_curve(bezier,splinesteps=16,endpoint=true) =\n    bezier_points(bezier, lerpn(0,1,splinesteps+1,endpoint));\n\n\n// Function: bezier_derivative()\n// Synopsis: Evaluates the derivative of the bezier curve at the given point or points.\n// Topics: Bezier Curves\n// See Also: bezier_curvature(), bezier_tangent(), bezier_points()\n// Usage:\n//   deriv = bezier_derivative(bezier, u, [order]);\n//   derivs = bezier_derivative(bezier, LIST, [order]);\n//   derivs = bezier_derivative(bezier, RANGE, [order]);\n// Description:\n//   Evaluates the derivative of the bezier curve at the given parameter value or values, `u`.  The `order` gives the order of the derivative. \n//   The degree of the bezier curve is one less than the number of points in `bezier`.\n// Arguments:\n//   bezier = The list of control points that define the Bezier curve. \n//   u = Parameter values for evaluating the curve, given as a single value, a list or a range.\n//   order = The order of the derivative to return.  Default: 1 (for the first derivative)\nfunction bezier_derivative(bezier, u, order=1) =\n    assert(is_int(order) && order>=0)\n    order==0? bezier_points(bezier, u) : let(\n        N = len(bezier) - 1,\n        dpts = N * deltas(bezier)\n    ) order==1? bezier_points(dpts, u) :\n    bezier_derivative(dpts, u, order-1);\n\n\n\n// Function: bezier_tangent()\n// Synopsis: Calculates unit tangent vectors along the bezier curve at one or more given positions.\n// Topics: Bezier Curves\n// See Also: bezier_curvature(), bezier_derivative(), bezier_points()\n// Usage:\n//   tanvec = bezier_tangent(bezier, u);\n//   tanvecs = bezier_tangent(bezier, LIST);\n//   tanvecs = bezier_tangent(bezier, RANGE);\n// Description:\n//   Returns the unit tangent vector at the given parameter values on a bezier curve with control points `bezier`.\n// Arguments:\n//   bezier = The list of control points that define the Bezier curve. \n//   u = Parameter values for evaluating the curve, given as a single value, a list or a range.\nfunction bezier_tangent(bezier, u) =\n    let(\n        res = bezier_derivative(bezier, u)\n    ) is_vector(res)? unit(res) :\n    [for (v=res) unit(v)];\n\n\n\n// Function: bezier_curvature()\n// Synopsis: Returns the curvature at one or more given positions along a bezier curve.\n// Topics: Bezier Curves\n// See Also: bezier_tangent(), bezier_derivative(), bezier_points()\n// Usage:\n//   crv = bezier_curvature(curve, u);\n//   crvlist = bezier_curvature(curve, LIST);\n//   crvlist = bezier_curvature(curve, RANGE);\n// Description:\n//   Returns the curvature value for the given parameters `u` on the bezier curve with control points `bezier`. \n//   The curvature is the inverse of the radius of the tangent circle at the given point.\n//   Thus, the tighter the curve, the larger the curvature value.  Curvature will be 0 for\n//   a position with no curvature, since 1/0 is not a number.\n// Arguments:\n//   bezier = The list of control points that define the Bezier curve.\n//   u = Parameter values for evaluating the curve, given as a single value, a list or a range.\nfunction bezier_curvature(bezier, u) =\n    is_num(u) ? bezier_curvature(bezier,[u])[0] :\n    let(\n        d1 = bezier_derivative(bezier, u, 1),\n        d2 = bezier_derivative(bezier, u, 2)\n    ) [\n        for(i=idx(d1))\n        sqrt(\n            sqr(norm(d1[i])*norm(d2[i])) -\n            sqr(d1[i]*d2[i])\n        ) / pow(norm(d1[i]),3)\n    ];\n\n\n\n// Function: bezier_closest_point()\n// Synopsis: Finds the closest position on a bezier curve to a given point.\n// Topics: Bezier Curves\n// See Also: bezier_points()\n// Usage:\n//   u = bezier_closest_point(bezier, pt, [max_err]);\n// Description:\n//   Finds the closest part of the given bezier curve to point `pt`.\n//   The degree of the curve, N, is one less than the number of points in `curve`.\n//   Returns `u` for the closest position on the bezier curve to the given point `pt`.\n// Arguments:\n//   bezier = The list of control points that define the Bezier curve. \n//   pt = The point to find the closest curve point to.\n//   max_err = The maximum allowed error when approximating the closest approach.\n// Example(2D):\n//   pt = [40,15];\n//   bez = [[0,0], [20,40], [60,-25], [80,0]];\n//   u = bezier_closest_point(bez, pt);\n//   debug_bezier(bez, N=len(bez)-1);\n//   color(\"red\") translate(pt) sphere(r=1);\n//   color(\"blue\") translate(bezier_points(bez,u)) sphere(r=1);\nfunction bezier_closest_point(bezier, pt, max_err=0.01, u=0, end_u=1) =\n    let(\n        steps = len(bezier)*3,\n        uvals = [u, for (i=[0:1:steps]) (end_u-u)*(i/steps)+u, end_u],\n        path = bezier_points(bezier,uvals),\n        minima_ranges = [\n            for (i = [1:1:len(uvals)-2]) let(\n                d1 = norm(path[i-1]-pt),\n                d2 = norm(path[i  ]-pt),\n                d3 = norm(path[i+1]-pt)\n            ) if (d2<=d1 && d2<=d3) [uvals[i-1],uvals[i+1]]\n        ]\n    ) len(minima_ranges)>1? (\n        let(\n            min_us = [\n                for (minima = minima_ranges)\n                    bezier_closest_point(bezier, pt, max_err=max_err, u=minima.x, end_u=minima.y)\n            ],\n            dists = [for (v=min_us) norm(bezier_points(bezier,v)-pt)],\n            min_i = min_index(dists)\n        ) min_us[min_i]\n    ) : let(\n        minima = minima_ranges[0],\n        pp = bezier_points(bezier, minima),\n        err = norm(pp[1]-pp[0])\n    ) err<max_err? mean(minima) :\n    bezier_closest_point(bezier, pt, max_err=max_err, u=minima[0], end_u=minima[1]);\n\n\n// Function: bezier_length()\n// Synopsis: Approximate the length of part of a bezier curve.\n// Topics: Bezier Curves\n// See Also: bezier_points()\n// Usage:\n//   pathlen = bezier_length(bezier, [start_u], [end_u], [max_deflect]);\n// Description:\n//   Approximates the length of the portion of the bezier curve between start_u and end_u.\n// Arguments:\n//   bezier = The list of control points that define the Bezier curve. \n//   start_u = The Bezier parameter to start measuring measuring from.  Between 0 and 1.\n//   end_u = The Bezier parameter to end measuring at.  Between 0 and 1.  Greater than start_u.\n//   max_deflect = The largest amount of deflection from the true curve to allow for approximation.\n// Example:\n//   bez = [[0,0], [5,35], [60,-25], [80,0]];\n//   echo(bezier_length(bez));\nfunction bezier_length(bezier, start_u=0, end_u=1, max_deflect=0.01) =\n    let(\n        segs = len(bezier) * 2,\n        uvals = lerpn(start_u, end_u, segs+1),\n        path = bezier_points(bezier,uvals),\n        defl = max([\n            for (i=idx(path,e=-3)) let(\n                mp = (path[i] + path[i+2]) / 2\n            ) norm(path[i+1] - mp)\n        ]),\n        mid_u = lerp(start_u, end_u, 0.5)\n    )\n    defl <= max_deflect? path_length(path) :\n    sum([\n        for (i=[0:1:segs-1]) let(\n            su = lerp(start_u, end_u, i/segs),\n            eu = lerp(start_u, end_u, (i+1)/segs)\n        ) bezier_length(bezier, su, eu, max_deflect)\n    ]);\n\n\n\n// Function: bezier_line_intersection()\n// Synopsis: Calculates where a bezier curve intersects a line.\n// Topics: Bezier Curves, Geometry, Intersection\n// See Also: bezier_points(), bezier_length(), bezier_closest_point()\n// Usage: \n//   u = bezier_line_intersection(bezier, line);\n// Description:\n//   Finds the intersection points of the 2D Bezier curve with control points `bezier` and the given line, specified as a pair of points.  \n//   Returns the intersection as a list of `u` values for the Bezier.  \n// Arguments:\n//   bezier = The list of control points that define a 2D Bezier curve. \n//   line = a list of two distinct 2d points defining a line\nfunction bezier_line_intersection(bezier, line) =\n    assert(is_path(bezier,2), \"The input \u00b4bezier\u00b4 must be a 2d bezier\")\n    assert(_valid_line(line,2), \"The input `line` is not a valid 2d line\")\n    let( \n        a = _bezier_matrix(len(bezier)-1)*bezier, // bezier algebraic coeffs. \n        n = [-line[1].y+line[0].y, line[1].x-line[0].x], // line normal\n        q = [for(i=[len(a)-1:-1:1]) a[i]*n, (a[0]-line[0])*n] // bezier SDF to line\n    )\n    [for(u=real_roots(q)) if (u>=0 && u<=1) u];\n\n\n\n\n// Section: Bezier Path Functions\n//   To contruct more complicated curves you can connect a sequence of Bezier curves end to end.  \n//   A Bezier path is a flattened list of control points that, along with the degree, represents such a sequence of bezier curves where all of the curves have the same degree.\n//   A Bezier path looks like a regular path, since it is just a list of points, but it is not a regular path.  Use {{bezpath_curve()}} to convert a Bezier path to a regular path.\n//   We interpret a degree N Bezier path as groups of N+1 control points that\n//   share endpoints, so they overlap by one point.  So if you have an order 3 bezier path `[p0,p1,p2,p3,p4,p5,p6]` then the first\n//   Bezier curve control point set is `[p0,p1,p2,p3]` and the second one is `[p3,p4,p5,p6]`.  The endpoint, `p3`, is shared between the control point sets.\n//   The Bezier degree, which must be known to interpret the Bezier path, defaults to 3. \n\n\n// Function: bezpath_points()\n// Synopsis: Computes one or more specified points along a bezier path.\n// SynTags: Path\n// Topics: Bezier Paths\n// See Also: bezier_points(), bezier_curve()\n// Usage:\n//   pt = bezpath_points(bezpath, curveind, u, [N]);\n//   ptlist = bezpath_points(bezpath, curveind, LIST, [N]);\n//   path = bezpath_points(bezpath, curveind, RANGE, [N]);\n// Description:\n//   Extracts from the Bezier path `bezpath` the control points for the Bezier curve whose index is `curveind` and\n//   computes the point or points on the corresponding Bezier curve specified by `u`.  If `curveind` is zero you\n//   get the first curve.  The number of curves is `(len(bezpath)-1)/N` so the maximum index is that number minus one.  \n// Arguments:\n//   bezpath = A Bezier path path to approximate.\n//   curveind = Curve number along the path.  \n//   u = Parameter values for evaluating the curve, given as a single value, a list or a range.\n//   N = The degree of the Bezier path curves.  Default: 3\nfunction bezpath_points(bezpath, curveind, u, N=3) =\n    bezier_points(select(bezpath,curveind*N,(curveind+1)*N), u);\n\n\n// Function: bezpath_curve()\n// Synopsis: Converts bezier path into a path of points. \n// SynTags: Path\n// Topics: Bezier Paths\n// See Also: bezier_points(), bezier_curve(), bezpath_points()\n// Usage:\n//   path = bezpath_curve(bezpath, [splinesteps], [N], [endpoint])\n// Description:\n//   Computes a number of uniformly distributed points along a bezier path.\n// Arguments:\n//   bezpath = A bezier path to approximate.\n//   splinesteps = Number of straight lines to split each bezier curve into. default=16\n//   N = The degree of the bezier curves.  Cubic beziers have N=3.  Default: 3\n//   endpoint = If true, include the very last point of the bezier path.  Default: true\n// Example(2D):\n//   bez = [\n//       [0,0], [-5,30],\n//       [20,60], [50,50], [110,30],\n//       [60,25], [70,0], [80,-25],\n//       [80,-50], [50,-50]\n//   ];\n//   path = bezpath_curve(bez);\n//   stroke(path,dots=true,dots_color=\"red\");\nfunction bezpath_curve(bezpath, splinesteps=16, N=3, endpoint=true) =\n    assert(is_path(bezpath))\n    assert(is_int(N))\n    assert(is_int(splinesteps) && splinesteps>0)\n    assert(len(bezpath)%N == 1, str(\"A degree \",N,\" bezier path should have a multiple of \",N,\" points in it, plus 1.\"))\n    let(\n        segs = (len(bezpath)-1) / N,\n        step = 1 / splinesteps\n    ) [\n        for (seg = [0:1:segs-1])\n            each bezier_points(select(bezpath, seg*N, (seg+1)*N), [0:step:1-step/2]),\n        if (endpoint) last(bezpath)\n    ];\n\n\n// Function: bezpath_closest_point()\n// Synopsis: Finds the closest point on a bezier path to a given point.\n// Topics: Bezier Paths\n// See Also: bezpath_points(), bezpath_curve(), bezier_points(), bezier_curve(), bezier_closest_point()\n// Usage:\n//   res = bezpath_closest_point(bezpath, pt, [N], [max_err]);\n// Description:\n//   Finds an approximation to the closest part of the given bezier path to point `pt`.\n//   Returns [segnum, u] for the closest position on the bezier path to the given point `pt`.\n// Arguments:\n//   bezpath = A bezier path to approximate.\n//   pt = The point to find the closest curve point to.\n//   N = The degree of the bezier curves.  Cubic beziers have N=3.  Default: 3\n//   max_err = The maximum allowed error when approximating the closest approach.\n// Example(2D):\n//   pt = [100,0];\n//   bez = [[0,0], [20,40], [60,-25], [80,0],\n//          [100,25], [140,25], [160,0]];\n//   pos = bezpath_closest_point(bez, pt);\n//   xy = bezpath_points(bez,pos[0],pos[1]);\n//   debug_bezier(bez, N=3);\n//   color(\"red\") translate(pt) sphere(r=1);\n//   color(\"blue\") translate(xy) sphere(r=1);\nfunction bezpath_closest_point(bezpath, pt, N=3, max_err=0.01, seg=0, min_seg=undef, min_u=undef, min_dist=undef) =\n    assert(is_vector(pt))\n    assert(is_int(N))\n    assert(is_num(max_err))\n    assert(len(bezpath)%N == 1, str(\"A degree \",N,\" bezier path shound have a multiple of \",N,\" points in it, plus 1.\"))\n    let(curve = select(bezpath,seg*N,(seg+1)*N))\n    (seg*N+1 >= len(bezpath))? (\n        let(curve = select(bezpath, min_seg*N, (min_seg+1)*N))\n        [min_seg, bezier_closest_point(curve, pt, max_err=max_err)]\n    ) : (\n        let(\n            curve = select(bezpath,seg*N,(seg+1)*N),\n            u = bezier_closest_point(curve, pt, max_err=0.05),\n            dist = norm(bezier_points(curve, u)-pt),\n            mseg = (min_dist==undef || dist<min_dist)? seg : min_seg,\n            mdist = (min_dist==undef || dist<min_dist)? dist : min_dist,\n            mu = (min_dist==undef || dist<min_dist)? u : min_u\n        )\n        bezpath_closest_point(bezpath, pt, N, max_err, seg+1, mseg, mu, mdist)\n    );\n\n\n\n// Function: bezpath_length()\n// Synopsis: Approximate the length of a bezier path.\n// Topics: Bezier Paths\n// See Also: bezier_points(), bezier_curve(), bezier_length()\n// Usage:\n//   plen = bezpath_length(path, [N], [max_deflect]);\n// Description:\n//   Approximates the length of the bezier path.\n// Arguments:\n//   path = A bezier path to approximate.\n//   N = The degree of the bezier curves.  Cubic beziers have N=3.  Default: 3\n//   max_deflect = The largest amount of deflection from the true curve to allow for approximation.\nfunction bezpath_length(bezpath, N=3, max_deflect=0.001) =\n    assert(is_int(N))\n    assert(is_num(max_deflect))\n    assert(len(bezpath)%N == 1, str(\"A degree \",N,\" bezier path shound have a multiple of \",N,\" points in it, plus 1.\"))\n    sum([\n        for (seg=[0:1:(len(bezpath)-1)/N-1]) (\n            bezier_length(\n                select(bezpath, seg*N, (seg+1)*N),\n                max_deflect=max_deflect\n            )\n        )\n    ]);\n\n\n\n// Function: path_to_bezpath()\n// Synopsis: Generates a bezier path that passes through all points in a given linear path.\n// SynTags: Path\n// Topics: Bezier Paths, Rounding\n// See Also: path_tangents()\n// Usage:\n//   bezpath = path_to_bezpath(path, [closed], [tangents], [uniform], [size=]|[relsize=]);\n// Description:\n//   Given a 2d or 3d input path and optional list of tangent vectors, computes a cubic (degree 3) bezier\n//   path that passes through every point on the input path and matches the tangent vectors.  If you do\n//   not supply the tangent it will be computed using `path_tangents()`.  If the path is closed specify this\n//   by setting `closed=true`.  The size or relsize parameter determines how far the curve can deviate from\n//   the input path.  In the case where the curve has a single hump, the size specifies the exact distance\n//   between the specified path and the bezier.  If you give relsize then it is relative to the segment\n//   length (e.g. 0.05 means 5% of the segment length).  In 2d when the bezier curve makes an S-curve\n//   the size parameter specifies the sum of the deviations of the two peaks of the curve.  In 3-space\n//   the bezier curve may have three extrema: two maxima and one minimum.  In this case the size specifies\n//   the sum of the maxima minus the minimum.  If you do not supply the tangents then they are computed\n//   using `path_tangents()` with `uniform=false` by default.  Tangents computed on non-uniform data tend\n//   to display overshoots.  See `smooth_path()` for examples.\n// Arguments:\n//   path = 2D or 3D point list or 1-region that the curve must pass through\n//   closed = true if the curve is closed .  Default: false\n//   tangents = tangents constraining curve direction at each point\n//   uniform = set to true to compute tangents with uniform=true.  Default: false\n//   ---\n//   size = absolute size specification for the curve, a number or vector\n//   relsize = relative size specification for the curve, a number or vector.  Default: 0.1. \nfunction path_to_bezpath(path, closed, tangents, uniform=false, size, relsize) =\n    is_1region(path) ? path_to_bezpath(path[0], default(closed,true), tangents, uniform, size, relsize) :\n    let(closed=default(closed,false))\n    assert(is_bool(closed))\n    assert(is_bool(uniform))\n    assert(num_defined([size,relsize])<=1, \"Can't define both size and relsize\")\n    assert(is_path(path,[2,3]),\"Input path is not a valid 2d or 3d path\")\n    assert(is_undef(tangents) || is_path(tangents,[2,3]),\"Tangents must be a 2d or 3d path\")\n    assert(is_undef(tangents) || len(path)==len(tangents), \"Input tangents must be the same length as the input path\")\n    let(\n        curvesize = first_defined([size,relsize,0.1]),\n        relative = is_undef(size),\n        lastpt = len(path) - (closed?0:1)\n    )\n    assert(is_num(curvesize) || len(curvesize)==lastpt, str(\"Size or relsize must have length \",lastpt))\n    let(\n        sizevect = is_num(curvesize) ? repeat(curvesize, lastpt) : curvesize,\n        tangents = is_def(tangents) ? [for(t=tangents) let(n=norm(t)) assert(!approx(n,0),\"Zero tangent vector\") t/n] :\n                                      path_tangents(path, uniform=uniform, closed=closed)\n    )\n    assert(min(sizevect)>0, \"Size and relsize must be greater than zero\")\n    [\n        for(i=[0:1:lastpt-1])\n            let(\n                first = path[i],\n                second = select(path,i+1),\n                seglength = norm(second-first),\n                dummy = assert(seglength>0, str(\"Path segment has zero length from index \",i,\" to \",i+1)),\n                segdir = (second-first)/seglength,\n                tangent1 = tangents[i],\n                tangent2 = -select(tangents,i+1),                        // Need this to point backwards, in direction of the curve\n                parallel = abs(tangent1*segdir) + abs(tangent2*segdir), // Total component of tangents parallel to the segment\n                Lmax = seglength/parallel,    // May be infinity\n                size = relative ? sizevect[i]*seglength : sizevect[i],\n                normal1 = tangent1-(tangent1*segdir)*segdir,   // Components of the tangents orthogonal to the segment\n                normal2 = tangent2-(tangent2*segdir)*segdir,\n                p = [ [-3 ,6,-3 ],                   // polynomial in power form\n                      [ 7,-9, 2 ],\n                      [-5, 3, 0 ],\n                      [ 1, 0, 0 ] ]*[normal1*normal1, normal1*normal2, normal2*normal2],\n                uextreme = approx(norm(p),0) ? []\n                                             : [for(root = real_roots(p)) if (root>0 && root<1) root],\n                distlist = [for(d=bezier_points([normal1*0, normal1, normal2, normal2*0], uextreme)) norm(d)],\n                scale = len(distlist)==0 ? 0 :\n                        len(distlist)==1 ? distlist[0]\n                                         : sum(distlist) - 2*min(distlist),\n                Ldesired = size/scale,   // This will be infinity when the polynomial is zero\n                L = min(Lmax, Ldesired)\n            )\n            each [\n                  first, \n                  first + L*tangent1,\n                  second + L*tangent2 \n                 ],\n        select(path,lastpt)\n    ];\n\n\n\n\n// Function: bezpath_close_to_axis()\n// Synopsis: Closes a 2D bezier path to the specified axis.\n// SynTags: Path\n// Topics: Bezier Paths\n// See Also: bezpath_offset()\n// Usage:\n//   bezpath = bezpath_close_to_axis(bezpath, [axis], [N]);\n// Description:\n//   Takes a 2D bezier path and closes it to the specified axis.\n// Arguments:\n//   bezpath = The 2D bezier path to close to the axis.\n//   axis = The axis to close to, \"X\", or \"Y\".  Default: \"X\"\n//   N = The degree of the bezier curves.  Cubic beziers have N=3.  Default: 3\n// Example(2D):\n//   bez = [[50,30], [40,10], [10,50], [0,30],\n//          [-10, 10], [-30,10], [-50,20]];\n//   closed = bezpath_close_to_axis(bez);\n//   debug_bezier(closed);\n// Example(2D):\n//   bez = [[30,50], [10,40], [50,10], [30,0],\n//          [10, -10], [10,-30], [20,-50]];\n//   closed = bezpath_close_to_axis(bez, axis=\"Y\");\n//   debug_bezier(closed);\nfunction bezpath_close_to_axis(bezpath, axis=\"X\", N=3) =\n    assert(is_path(bezpath,2), \"bezpath_close_to_axis() can only work on 2D bezier paths.\")\n    assert(is_int(N))\n    assert(len(bezpath)%N == 1, str(\"A degree \",N,\" bezier path shound have a multiple of \",N,\" points in it, plus 1.\"))\n    let(\n        sp = bezpath[0],\n        ep = last(bezpath)\n    ) (axis==\"X\")? concat(\n        lerpn([sp.x,0], sp, N, false),\n        list_head(bezpath),\n        lerpn(ep, [ep.x,0], N, false),\n        lerpn([ep.x,0], [sp.x,0], N+1)\n    ) : (axis==\"Y\")? concat(\n        lerpn([0,sp.y], sp, N, false),\n        list_head(bezpath),\n        lerpn(ep, [0,ep.y], N, false),\n        lerpn([0,ep.y], [0,sp.y], N+1)\n    ) : (\n        assert(in_list(axis, [\"X\",\"Y\"]))\n    );\n\n\n// Function: bezpath_offset()\n// Synopsis: Forms a closed bezier path loop with a translated and reversed copy of itself.\n// SynTags: Path\n// Topics: Bezier Paths\n// See Also: bezpath_close_to_axis()\n// Usage:\n//   bezpath = bezpath_offset(offset, bezier, [N]);\n// Description:\n//   Takes a 2D bezier path and closes it with a matching reversed path that is offset by the given `offset` [X,Y] distance.\n// Arguments:\n//   offset = Amount to offset second path by.\n//   bezier = The 2D bezier path.\n//   N = The degree of the bezier curves.  Cubic beziers have N=3.  Default: 3\n// Example(2D):\n//   bez = [[50,30], [40,10], [10,50], [0,30], [-10, 10], [-30,10], [-50,20]];\n//   closed = bezpath_offset([0,-5], bez);\n//   debug_bezier(closed);\n// Example(2D):\n//   bez = [[30,50], [10,40], [50,10], [30,0], [10, -10], [10,-30], [20,-50]];\n//   closed = bezpath_offset([-5,0], bez);\n//   debug_bezier(closed);\nfunction bezpath_offset(offset, bezier, N=3) =\n    assert(is_vector(offset,2))\n    assert(is_path(bezier,2), \"bezpath_offset() can only work on 2D bezier paths.\")\n    assert(is_int(N))\n    assert(len(bezier)%N == 1, str(\"A degree \",N,\" bezier path shound have a multiple of \",N,\" points in it, plus 1.\"))\n    let(\n        backbez = reverse([ for (pt = bezier) pt+offset ]),\n        bezend = len(bezier)-1\n    ) concat(\n        list_head(bezier),\n        lerpn(bezier[bezend], backbez[0], N, false),\n        list_head(backbez),\n        lerpn(backbez[bezend], bezier[0], N+1)\n    );\n\n\n\n// Section: Cubic Bezier Path Construction\n\n// Function: bez_begin()\n// Synopsis: Calculates starting bezier path control points.\n// Topics: Bezier Paths\n// See Also: bez_tang(), bez_joint(), bez_end()\n// Usage:\n//   pts = bez_begin(pt, a, r, [p=]);\n//   pts = bez_begin(pt, VECTOR, [r], [p=]);\n// Description:\n//   This is used to create the first endpoint and control point of a cubic bezier path.\n// Arguments:\n//   pt = The starting endpoint for the bezier path.\n//   a = If given a scalar, specifies the theta (XY plane) angle in degrees from X+.  If given a vector, specifies the direction and possibly distance of the first control point.\n//   r = Specifies the distance of the control point from the endpoint `pt`.\n//   ---\n//   p = If given, specifies the number of degrees away from the Z+ axis.\n// Example(2D): 2D Bezier Path by Angle\n//   bezpath = flatten([\n//       bez_begin([-50,  0],  45,20),\n//       bez_tang ([  0,  0],-135,20),\n//       bez_joint([ 20,-25], 135, 90, 10, 15),\n//       bez_end  ([ 50,  0], -90,20),\n//   ]);\n//   debug_bezier(bezpath);\n// Example(2D): 2D Bezier Path by Vector\n//   bezpath = flatten([\n//       bez_begin([-50,0],[0,-20]),\n//       bez_tang ([-10,0],[0,-20]),\n//       bez_joint([ 20,-25], [-10,10], [0,15]),\n//       bez_end  ([ 50,0],[0, 20]),\n//   ]);\n//   debug_bezier(bezpath);\n// Example(2D): 2D Bezier Path by Vector and Distance\n//   bezpath = flatten([\n//       bez_begin([-30,0],FWD, 30),\n//       bez_tang ([  0,0],FWD, 30),\n//       bez_joint([ 20,-25], 135, 90, 10, 15),\n//       bez_end  ([ 30,0],BACK,30),\n//   ]);\n//   debug_bezier(bezpath);\n// Example(3D,FlatSpin,VPD=200): 3D Bezier Path by Angle\n//   bezpath = flatten([\n//       bez_begin([-30,0,0],90,20,p=135),\n//       bez_tang ([  0,0,0],-90,20,p=135),\n//       bez_joint([20,-25,0], 135, 90, 15, 10, p1=135, p2=45),\n//       bez_end  ([ 30,0,0],-90,20,p=45),\n//   ]);\n//   debug_bezier(bezpath);\n// Example(3D,FlatSpin,VPD=225): 3D Bezier Path by Vector\n//   bezpath = flatten([\n//       bez_begin([-30,0,0],[0,-20, 20]),\n//       bez_tang ([  0,0,0],[0,-20,-20]),\n//       bez_joint([20,-25,0],[0,10,-10],[0,15,15]),\n//       bez_end  ([ 30,0,0],[0,-20,-20]),\n//   ]);\n//   debug_bezier(bezpath);\n// Example(3D,FlatSpin,VPD=225): 3D Bezier Path by Vector and Distance\n//   bezpath = flatten([\n//       bez_begin([-30,0,0],FWD, 20),\n//       bez_tang ([  0,0,0],DOWN,20),\n//       bez_joint([20,-25,0],LEFT,DOWN,r1=20,r2=15),\n//       bez_end  ([ 30,0,0],DOWN,20),\n//   ]);\n//   debug_bezier(bezpath);\nfunction bez_begin(pt,a,r,p) =\n    assert(is_finite(r) || is_vector(a))\n    assert(len(pt)==3 || is_undef(p))\n    is_vector(a)? [pt, pt+(is_undef(r)? a : r*unit(a))] :\n    is_finite(a)? [pt, pt+spherical_to_xyz(r,a,default(p,90))] :\n    assert(false, \"Bad arguments.\");\n\n\n// Function: bez_tang()\n// Synopsis: Calculates control points for a smooth bezier path joint.\n// Topics: Bezier Paths\n// See Also: bez_begin(), bez_joint(), bez_end()\n// Usage:\n//   pts = bez_tang(pt, a, r1, r2, [p=]);\n//   pts = bez_tang(pt, VECTOR, [r1], [r2], [p=]);\n// Description:\n//   This creates a smooth joint in a cubic bezier path.  It creates three points, being the\n//   approaching control point, the fixed bezier control point, and the departing control\n//   point.  The two control points will be collinear with the fixed point, making for a\n//   smooth bezier curve at the fixed point. See {{bez_begin()}} for examples.\n// Arguments:\n//   pt = The fixed point for the bezier path.\n//   a = If given a scalar, specifies the theta (XY plane) angle in degrees from X+.  If given a vector, specifies the direction and possibly distance of the departing control point.\n//   r1 = Specifies the distance of the approching control point from the fixed point.  Overrides the distance component of the vector if `a` contains a vector.\n//   r2 = Specifies the distance of the departing control point from the fixed point.  Overrides the distance component of the vector if `a` contains a vector.  If `r1` is given and `r2` is not, uses the value of `r1` for `r2`.\n//   ---\n//   p = If given, specifies the number of degrees away from the Z+ axis.\nfunction bez_tang(pt,a,r1,r2,p) =\n    assert(is_finite(r1) || is_vector(a))\n    assert(len(pt)==3 || is_undef(p))\n    let(\n        r1 = is_num(r1)? r1 : norm(a),\n        r2 = default(r2,r1),\n        p = default(p, 90)\n    )\n    is_vector(a)? [pt-r1*unit(a), pt, pt+r2*unit(a)] :\n    is_finite(a)? [\n        pt-spherical_to_xyz(r1,a,p),\n        pt,\n        pt+spherical_to_xyz(r2,a,p)\n    ] :\n    assert(false, \"Bad arguments.\");\n\n\n// Function: bez_joint()\n// Synopsis: Calculates control points for a disjointed corner bezier path joint.\n// Topics: Bezier Paths\n// See Also: bez_begin(), bez_tang(), bez_end()\n// Usage:\n//   pts = bez_joint(pt, a1, a2, r1, r2, [p1=], [p2=]);\n//   pts = bez_joint(pt, VEC1, VEC2, [r1=], [r2=], [p1=], [p2=]);\n// Description:\n//   This creates a disjoint corner joint in a cubic bezier path.  It creates three points, being\n//   the aproaching control point, the fixed bezier control point, and the departing control point.\n//   The two control points can be directed in different arbitrary directions from the fixed bezier\n//   point. See {{bez_begin()}} for examples.\n// Arguments:\n//   pt = The fixed point for the bezier path.\n//   a1 = If given a scalar, specifies the theta (XY plane) angle in degrees from X+.  If given a vector, specifies the direction and possibly distance of the approaching control point.\n//   a2 = If given a scalar, specifies the theta (XY plane) angle in degrees from X+.  If given a vector, specifies the direction and possibly distance of the departing control point.\n//   r1 = Specifies the distance of the approching control point from the fixed point.  Overrides the distance component of the vector if `a1` contains a vector.\n//   r2 = Specifies the distance of the departing control point from the fixed point.  Overrides the distance component of the vector if `a2` contains a vector.\n//   ---\n//   p1 = If given, specifies the number of degrees away from the Z+ axis of the approaching control point.\n//   p2 = If given, specifies the number of degrees away from the Z+ axis of the departing control point.\nfunction bez_joint(pt,a1,a2,r1,r2,p1,p2) =\n    assert(is_finite(r1) || is_vector(a1))\n    assert(is_finite(r2) || is_vector(a2))\n    assert(len(pt)==3 || (is_undef(p1) && is_undef(p2)))\n    let(\n        r1 = is_num(r1)? r1 : norm(a1),\n        r2 = is_num(r2)? r2 : norm(a2),\n        p1 = default(p1, 90),\n        p2 = default(p2, 90)\n    ) [\n        if (is_vector(a1)) (pt+r1*unit(a1))\n        else if (is_finite(a1)) (pt+spherical_to_xyz(r1,a1,p1))\n        else assert(false, \"Bad Arguments\"),\n        pt,\n        if (is_vector(a2)) (pt+r2*unit(a2))\n        else if (is_finite(a2)) (pt+spherical_to_xyz(r2,a2,p2))\n        else assert(false, \"Bad Arguments\")\n    ];\n\n\n// Function: bez_end()\n// Synopsis: Calculates ending bezier path control points.\n// Topics: Bezier Paths\n// See Also: bez_tang(), bez_joint(), bez_end()\n// Usage:\n//   pts = bez_end(pt, a, r, [p=]);\n//   pts = bez_end(pt, VECTOR, [r], [p=]);\n// Description:\n//   This is used to create the approaching control point, and the endpoint of a cubic bezier path.\n//   See {{bez_begin()}} for examples.\n// Arguments:\n//   pt = The starting endpoint for the bezier path.\n//   a = If given a scalar, specifies the theta (XY plane) angle in degrees from X+.  If given a vector, specifies the direction and possibly distance of the first control point.\n//   r = Specifies the distance of the control point from the endpoint `pt`.\n//   p = If given, specifies the number of degrees away from the Z+ axis.\nfunction bez_end(pt,a,r,p) =\n    assert(is_finite(r) || is_vector(a))\n    assert(len(pt)==3 || is_undef(p))\n    is_vector(a)? [pt+(is_undef(r)? a : r*unit(a)), pt] :\n    is_finite(a)? [pt+spherical_to_xyz(r,a,default(p,90)), pt] :\n    assert(false, \"Bad arguments.\");\n\n\n\n// Section: Bezier Surfaces\n\n\n// Function: is_bezier_patch()\n// Synopsis: Returns true if the given item is a bezier patch.\n// Topics: Bezier Patches, Type Checking\n// Usage:\n//   bool = is_bezier_patch(x);\n// Description:\n//   Returns true if the given item is a bezier patch. (a 2D array of 3D points.)\n// Arguments:\n//   x = The value to check the type of.\nfunction is_bezier_patch(x) =\n    is_list(x) && is_list(x[0]) && is_vector(x[0][0]) && len(x[0]) == len(x[len(x)-1]);  \n\n\n// Function: bezier_patch_flat()\n// Synopsis: Creates a flat bezier patch.\n// Topics: Bezier Patches\n// See Also: bezier_patch_points()\n// Usage:\n//   patch = bezier_patch_flat(size, [N=], [spin=], [orient=], [trans=]);\n// Description:\n//   Returns a flat rectangular bezier patch of degree `N`, centered on the XY plane.\n// Arguments:\n//   size = scalar or 2-vector giving the X and Y dimensions of the patch. \n//   ---\n//   N = Degree of the patch to generate.  Since this is flat, a degree of 1 should usually be sufficient.  Default: 1\n//   orient = A direction vector.  Point the patch normal in this direction.  \n//   spin = Spin angle to apply to the patch\n//   trans = Amount to translate patch, after orient and spin. \n// Example(3D):\n//   patch = bezier_patch_flat(size=[100,100]);\n//   debug_bezier_patches([patch], size=1, showcps=true);\nfunction bezier_patch_flat(size, N=1, spin=0, orient=UP, trans=[0,0,0]) =\n    assert(N>0)\n    let(size = force_list(size,2))\n    assert(is_vector(size,2))\n    let(\n        patch = [\n            for (x=[0:1:N]) [\n                for (y=[0:1:N])\n                v_mul(point3d(size), [x/N-0.5, 0.5-y/N, 0])\n            ]\n        ],\n        m = move(trans) * rot(a=spin, from=UP, to=orient)\n    ) [for (row=patch) apply(m, row)];\n\n\n\n// Function: bezier_patch_reverse()\n// Synopsis: Reverses the orientation of a bezier patch.\n// Topics: Bezier Patches\n// See Also: bezier_patch_points(), bezier_patch_flat()\n// Usage:\n//   rpatch = bezier_patch_reverse(patch);\n// Description:\n//   Reverses the patch, so that the faces generated from it are flipped back to front.\n// Arguments:\n//   patch = The patch to reverse.\nfunction bezier_patch_reverse(patch) =\n    [for (row=patch) reverse(row)];\n\n\n// Function: bezier_patch_points()\n// Synopsis: Computes one or more specified points across a bezier surface patch.\n// Topics: Bezier Patches\n// See Also: bezier_patch_normals(), bezier_points(), bezier_curve(), bezpath_curve()\n// Usage:\n//   pt = bezier_patch_points(patch, u, v);\n//   ptgrid = bezier_patch_points(patch, LIST, LIST);\n//   ptgrid = bezier_patch_points(patch, RANGE, RANGE);\n// Description:\n//   Sample a bezier patch on a listed point set.  The bezier patch must be a rectangular array of\n//   points, and it will be sampled at all the (u,v) pairs that you specify.  If you give u and v\n//   as single numbers you'll get a single point back.  If you give u and v as lists or ranges you'll\n//   get a 2d rectangular array of points.  If one but not both of u and v is a list or range then you'll\n//   get a list of points.  \n// Arguments:\n//   patch = The 2D array of control points for a Bezier patch.\n//   u = The bezier u parameter (inner list of patch).  Generally between 0 and 1. Can be a list, range or value.\n//   v = The bezier v parameter (outer list of patch).  Generally between 0 and 1. Can be a list, range or value.\n// Example(3D):\n//   patch = [\n//       [[-50, 50,  0], [-16, 50,  20], [ 16, 50,  20], [50, 50,  0]],\n//       [[-50, 16, 20], [-16, 16,  40], [ 16, 16,  40], [50, 16, 20]],\n//       [[-50,-16, 20], [-16,-16,  40], [ 16,-16,  40], [50,-16, 20]],\n//       [[-50,-50,  0], [-16,-50,  20], [ 16,-50,  20], [50,-50,  0]]\n//   ];\n//   debug_bezier_patches(patches=[patch], size=1, showcps=true);\n//   pt = bezier_patch_points(patch, 0.6, 0.75);\n//   translate(pt) color(\"magenta\") sphere(d=3, $fn=12);\n// Example(3D): Getting Multiple Points at Once\n//   patch = [\n//       [[-50, 50,  0], [-16, 50,  20], [ 16, 50,  20], [50, 50,  0]],\n//       [[-50, 16, 20], [-16, 16,  40], [ 16, 16,  40], [50, 16, 20]],\n//       [[-50,-16, 20], [-16,-16,  40], [ 16,-16,  40], [50,-16, 20]],\n//       [[-50,-50,  0], [-16,-50,  20], [ 16,-50,  20], [50,-50,  0]]\n//   ];\n//   debug_bezier_patches(patches=[patch], size=1, showcps=true);\n//   pts = bezier_patch_points(patch, [0:0.2:1], [0:0.2:1]);\n//   for (row=pts) move_copies(row) color(\"magenta\") sphere(d=3, $fn=12);\nfunction bezier_patch_points(patch, u, v) =\n    assert(is_range(u) || is_vector(u) || is_finite(u), \"Input u is invalid\")\n    assert(is_range(v) || is_vector(v) || is_finite(v), \"Input v is invalid\")\n      !is_num(u) && !is_num(v) ?\n            let(\n                vbezes = [for (i = idx(patch[0])) bezier_points(column(patch,i), u)]\n            )\n            [for (i = idx(vbezes[0])) bezier_points(column(vbezes,i), v)]\n    : is_num(u) && is_num(v)? bezier_points([for (bez = patch) bezier_points(bez, v)], u)\n    : is_num(u) ? bezier_patch_points(patch,force_list(u),v)[0]\n    :             column(bezier_patch_points(patch,u,force_list(v)),0);\n\n\n  \n\nfunction _bezier_rectangle(patch, splinesteps=16, style=\"default\") =\n    let(\n        uvals = lerpn(0,1,splinesteps.x+1),\n        vvals = lerpn(1,0,splinesteps.y+1),\n        pts = bezier_patch_points(patch, uvals, vvals)\n    )\n    vnf_vertex_array(pts, style=style, reverse=false);\n\n\n// Function: bezier_vnf()\n// Synopsis: Generates a (probably non-manifold) VNF for one or more bezier surface patches.\n// SynTags: VNF\n// Topics: Bezier Patches\n// See Also: bezier_patch_points(), bezier_patch_flat()\n// Usage:\n//   vnf = bezier_vnf(patches, [splinesteps], [style]);\n// Description:\n//   Convert a patch or list of patches into the corresponding Bezier surface, representing the\n//   result as a [VNF structure](vnf.scad).  The `splinesteps` argument specifies the sampling grid of\n//   the surface for each patch by specifying the number of segments on the borders of the surface.\n//   It can be a scalar, which gives a uniform grid, or\n//   it can be [USTEPS, VSTEPS], which gives difference spacing in the U and V parameters. \n//   Note that the surface you produce may be disconnected and is not necessarily a valid manifold in OpenSCAD.\n//   You must also ensure that the patches mate exactly along their edges, or the VNF will be invalid.  \n// Arguments:\n//   patches = The bezier patch or list of bezier patches to convert into a vnf.\n//   splinesteps = Number of segments on the border of the bezier surface.  You can specify [USTEPS,VSTEPS].  Default: 16\n//   style = The style of subdividing the quads into faces.  Valid options are \"default\", \"alt\", \"min_edge\", \"quincunx\", \"convex\" and \"concave\".  See {{vnf_vertex_array()}}.  Default: \"default\"\n// Example(3D):\n//   patch = [\n//       // u=0,v=0                                         u=1,v=0\n//       [[-50,-50,  0], [-16,-50,  20], [ 16,-50, -20], [50,-50,  0]],\n//       [[-50,-16, 20], [-16,-16,  20], [ 16,-16, -20], [50,-16, 20]],\n//       [[-50, 16, 20], [-16, 16, -20], [ 16, 16,  20], [50, 16, 20]],\n//       [[-50, 50,  0], [-16, 50, -20], [ 16, 50,  20], [50, 50,  0]],\n//       // u=0,v=1                                         u=1,v=1\n//   ];\n//   vnf = bezier_vnf(patch, splinesteps=16);\n//   vnf_polyhedron(vnf);\n// Example(3D,FlatSpin,VPD=444): Combining multiple patches\n//   patch = 100*[\n//       // u=0,v=0                                u=1,v=0\n//       [[0,  0,0], [1/3,  0,  0], [2/3,  0,  0], [1,  0,0]],\n//       [[0,1/3,0], [1/3,1/3,1/3], [2/3,1/3,1/3], [1,1/3,0]],\n//       [[0,2/3,0], [1/3,2/3,1/3], [2/3,2/3,1/3], [1,2/3,0]],\n//       [[0,  1,0], [1/3,  1,  0], [2/3,  1,  0], [1,  1,0]],\n//       // u=0,v=1                                u=1,v=1\n//   ];\n//   fpatch = bezier_patch_flat([100,100]);\n//   tpatch = translate([-50,-50,50], patch);\n//   flatpatch = translate([0,0,50], fpatch);\n//   vnf = bezier_vnf([\n//                     tpatch,\n//                     xrot(90, tpatch),\n//                     xrot(-90, tpatch),\n//                     xrot(180, tpatch),\n//                     yrot(90, flatpatch),\n//                     yrot(-90, tpatch)]);\n//   vnf_polyhedron(vnf);\n// Example(3D):\n//   patch1 = [\n//       [[18,18,0], [33,  0,  0], [ 67,  0,  0], [ 82, 18,0]],\n//       [[ 0,40,0], [ 0,  0,100], [100,  0, 20], [100, 40,0]],\n//       [[ 0,60,0], [ 0,100,100], [100,100, 20], [100, 60,0]],\n//       [[18,82,0], [33,100,  0], [ 67,100,  0], [ 82, 82,0]],\n//   ];\n//   patch2 = [\n//       [[18,82,0], [33,100,  0], [ 67,100,  0], [ 82, 82,0]],\n//       [[ 0,60,0], [ 0,100,-50], [100,100,-50], [100, 60,0]],\n//       [[ 0,40,0], [ 0,  0,-50], [100,  0,-50], [100, 40,0]],\n//       [[18,18,0], [33,  0,  0], [ 67,  0,  0], [ 82, 18,0]],\n//   ];\n//   vnf = bezier_vnf(patches=[patch1, patch2], splinesteps=16);\n//   vnf_polyhedron(vnf);\n// Example(3D): Connecting Patches with asymmetric splinesteps.  Note it is fastest to join all the VNFs at once, which happens in vnf_polyhedron, rather than generating intermediate joined partial surfaces.  \n//   steps = 8;\n//   edge_patch = [\n//       // u=0, v=0                    u=1,v=0\n//       [[-60, 0,-40], [0, 0,-40], [60, 0,-40]],\n//       [[-60, 0,  0], [0, 0,  0], [60, 0,  0]],\n//       [[-60,40,  0], [0,40,  0], [60,40,  0]],\n//       // u=0, v=1                    u=1,v=1\n//   ];\n//   corner_patch = [\n//       // u=0, v=0                    u=1,v=0\n//       [[ 0, 40,-40], [ 0,  0,-40], [40,  0,-40]],\n//       [[ 0, 40,  0], [ 0,  0,  0], [40,  0,  0]],\n//       [[40, 40,  0], [40, 40,  0], [40, 40,  0]],\n//       // u=0, v=1                    u=1,v=1\n//   ];\n//   face_patch = bezier_patch_flat([120,120],orient=LEFT);\n//   edges = [\n//       for (axrot=[[0,0,0],[0,90,0],[0,0,90]], xang=[-90:90:180])\n//           bezier_vnf(\n//               splinesteps=[steps,1],\n//               rot(a=axrot,\n//                   p=rot(a=[xang,0,0],\n//                       p=translate(v=[0,-100,100],p=edge_patch)\n//                   )\n//               )\n//           )\n//   ];\n//   corners = [\n//       for (xang=[0,180], zang=[-90:90:180])\n//           bezier_vnf(\n//               splinesteps=steps,\n//               rot(a=[xang,0,zang],\n//                   p=translate(v=[-100,-100,100],p=corner_patch)\n//               )\n//           )\n//   ];\n//   faces = [\n//       for (axrot=[[0,0,0],[0,90,0],[0,0,90]], zang=[0,180])\n//           bezier_vnf(\n//               splinesteps=1,\n//               rot(a=axrot,\n//                   p=zrot(zang,move([-100,0,0], face_patch))\n//               )\n//           )\n//   ];\n//   vnf_polyhedron(concat(edges,corners,faces));\nfunction bezier_vnf(patches=[], splinesteps=16, style=\"default\") =\n    assert(is_num(splinesteps) || is_vector(splinesteps,2))\n    assert(all_positive(splinesteps))\n    let(splinesteps = force_list(splinesteps,2))\n    is_bezier_patch(patches)? _bezier_rectangle(patches, splinesteps=splinesteps,style=style)\n  : assert(is_list(patches),\"Invalid patch list\")\n    vnf_join(\n      [\n        for (patch=patches)\n          is_bezier_patch(patch)? _bezier_rectangle(patch, splinesteps=splinesteps,style=style)\n        : assert(false,\"Invalid patch list\")\n      ]\n    );\n          \n\n\n// Function: bezier_vnf_degenerate_patch()\n// Synopsis: Generates a VNF for a degenerate bezier surface patch.\n// SynTags: VNF\n// Topics: Bezier Patches\n// See Also: bezier_patch_points(), bezier_patch_flat(), bezier_vnf()\n// Usage:\n//   vnf = bezier_vnf_degenerate_patch(patch, [splinesteps], [reverse]);\n//   vnf_edges = bezier_vnf_degenerate_patch(patch, [splinesteps], [reverse], return_edges=true);\n// Description:\n//   Returns a VNF for a degenerate rectangular bezier patch where some of the corners of the patch are\n//   equal.  If the resulting patch has no faces then returns an empty VNF.  Note that due to the degeneracy,\n//   the shape of the surface can be triangular even though the underlying patch is a rectangle.  \n//   If you specify return_edges then the return is a list whose first element is the vnf and whose second\n//   element lists the edges in the order [left, right, top, bottom], where each list is a list of the actual\n//   point values, but possibly only a single point if that edge is degenerate.\n//   The method checks for various types of degeneracy and uses a triangular or partly triangular array of sample points. \n//   See examples below for the types of degeneracy detected and how the patch is sampled for those cases.\n//   Note that splinesteps is the same for both directions of the patch, so it cannot be an array. \n// Arguments:\n//   patch = Patch to process\n//   splinesteps = Number of segments to produce on each side.  Default: 16\n//   reverse = reverse direction of faces.  Default: false\n//   return_edges = if true return the points on the four edges: [left, right, top, bottom].  Default: false\n// Example(3D,NoAxes): This quartic patch is degenerate at one corner, where a row of control points are equal.  Processing this degenerate patch normally produces excess triangles near the degenerate point. \n//   splinesteps=8;\n//   patch=[\n//         repeat([-12.5, 12.5, 15],5),\n//          [[-6.25, 11.25, 15], [-6.25, 8.75, 15], [-6.25, 6.25, 15], [-8.75, 6.25, 15], [-11.25, 6.25, 15]],\n//          [[0, 10, 15], [0, 5, 15], [0, 0, 15], [-5, 0, 15], [-10, 0, 15]],\n//          [[0, 10, 8.75], [0, 5, 8.75], [0, 0, 8.75], [-5, 0, 8.75], [-10, 0, 8.75]],\n//          [[0, 10, 2.5], [0, 5, 2.5], [0, 0, 2.5], [-5, 0, 2.5], [-10, 0, 2.5]]\n//         ];\n//   vnf_wireframe((bezier_vnf(patch, splinesteps)),width=0.1);\n//   color(\"red\")move_copies(flatten(patch)) sphere(r=0.3,$fn=9);\n// Example(3D,NoAxes): With bezier_vnf_degenerate_patch the degenerate point does not have excess triangles.  The top half of the patch decreases the number of sampled points by 2 for each row.  \n//   splinesteps=8;\n//   patch=[\n//          repeat([-12.5, 12.5, 15],5),\n//          [[-6.25, 11.25, 15], [-6.25, 8.75, 15], [-6.25, 6.25, 15], [-8.75, 6.25, 15], [-11.25, 6.25, 15]],\n//          [[0, 10, 15], [0, 5, 15], [0, 0, 15], [-5, 0, 15], [-10, 0, 15]],\n//          [[0, 10, 8.75], [0, 5, 8.75], [0, 0, 8.75], [-5, 0, 8.75], [-10, 0, 8.75]],\n//          [[0, 10, 2.5], [0, 5, 2.5], [0, 0, 2.5], [-5, 0, 2.5], [-10, 0, 2.5]]\n//         ];\n//   vnf_wireframe(bezier_vnf_degenerate_patch(patch, splinesteps),width=0.1);\n//   color(\"red\")move_copies(flatten(patch)) sphere(r=0.3,$fn=9);\n// Example(3D,NoAxes): With splinesteps odd you get one \"odd\" row where the point count decreases by 1 instead of 2.  You may prefer even values for splinesteps to avoid this. \n//   splinesteps=7;\n//   patch=[\n//          repeat([-12.5, 12.5, 15],5),\n//          [[-6.25, 11.25, 15], [-6.25, 8.75, 15], [-6.25, 6.25, 15], [-8.75, 6.25, 15], [-11.25, 6.25, 15]],\n//          [[0, 10, 15], [0, 5, 15], [0, 0, 15], [-5, 0, 15], [-10, 0, 15]],\n//          [[0, 10, 8.75], [0, 5, 8.75], [0, 0, 8.75], [-5, 0, 8.75], [-10, 0, 8.75]],\n//          [[0, 10, 2.5], [0, 5, 2.5], [0, 0, 2.5], [-5, 0, 2.5], [-10, 0, 2.5]]\n//         ];\n//   vnf_wireframe(bezier_vnf_degenerate_patch(patch, splinesteps),width=0.1);\n//   color(\"red\")move_copies(flatten(patch)) sphere(r=0.3,$fn=9);\n// Example(3D,NoAxes): A more extreme degeneracy occurs when the top half of a patch is degenerate to a line.  (For odd length patches the middle row must be degenerate to trigger this style.)  In this case the number of points in each row decreases by 1 for every row.  It doesn't matter if splinesteps is odd or even. \n//   splinesteps=8;\n//   patch = [[[10, 0, 0], [10, -10.4, 0], [10, -20.8, 0], [1.876, -14.30, 0], [-6.24, -7.8, 0]],\n//            [[5, 0, 0], [5, -5.2, 0], [5, -10.4, 0], [0.938, -7.15, 0], [-3.12, -3.9, 0]],\n//            repeat([0,0,0],5),\n//            repeat([0,0,5],5),\n//            repeat([0,0,10],5)\n//           ];\n//   vnf_wireframe(bezier_vnf_degenerate_patch(patch, splinesteps),width=0.1);\n//   color(\"red\")move_copies(flatten(patch)) sphere(r=0.3,$fn=9);\n// Example(3D,NoScales): Here is a degenerate cubic patch.\n//   splinesteps=8;\n//   patch = [ [ [-20,0,0],  [-10,0,0],[0,10,0],[0,20,0] ],\n//             [ [-20,0,10], [-10,0,10],[0,10,10],[0,20,10]],\n//             [ [-10,0,20], [-5,0,20], [0,5,20], [0,10,20]],\n//              repeat([0,0,30],4)\n//               ];\n//   color(\"red\")move_copies(flatten(patch)) sphere(r=0.3,$fn=9);\n//   vnf_wireframe(bezier_vnf_degenerate_patch(patch, splinesteps),width=0.1);\n// Example(3D,NoScales): A more extreme degenerate cubic patch, where two rows are equal.\n//   splinesteps=8;\n//   patch = [ [ [-20,0,0], [-10,0,0],[0,10,0],[0,20,0] ],\n//             [ [-20,0,10], [-10,0,10],[0,10,10],[0,20,10] ],\n//              repeat([-10,10,20],4),\n//              repeat([-10,10,30],4)          \n//           ];\n//   color(\"red\")move_copies(flatten(patch)) sphere(r=0.3,$fn=9);\n//   vnf_wireframe(bezier_vnf_degenerate_patch(patch, splinesteps),width=0.1);\n// Example(3D,NoScales): Quadratic patch degenerate at the right side:\n//   splinesteps=8;\n//   patch = [[[0, -10, 0],[10, -5, 0],[20, 0, 0]],\n//            [[0, 0, 0],  [10, 0, 0], [20, 0, 0]],\n//            [[0, 0, 10], [10, 0, 5], [20, 0, 0]]];\n//   vnf_wireframe(bezier_vnf_degenerate_patch(patch, splinesteps),width=0.1);\n//   color(\"red\")move_copies(flatten(patch)) sphere(r=0.3,$fn=9);\n// Example(3D,NoAxes): Cubic patch degenerate at both ends.  In this case the point count changes by 2 at every row.  \n//   splinesteps=8;\n//   patch = [\n//            repeat([10,-10,0],4),\n//            [ [-20,0,0], [-1,0,0],[0,10,0],[0,20,0] ],\n//            [ [-20,0,10], [-10,0,10],[0,10,10],[0,20,10] ],\n//            repeat([-10,10,20],4),\n//           ];\n//   vnf_wireframe(bezier_vnf_degenerate_patch(patch, splinesteps),width=0.1);\n//   color(\"red\")move_copies(flatten(patch)) sphere(r=0.3,$fn=9);\nfunction bezier_vnf_degenerate_patch(patch, splinesteps=16, reverse=false, return_edges=false) =\n    !return_edges ? bezier_vnf_degenerate_patch(patch, splinesteps, reverse, true)[0] :\n    assert(is_bezier_patch(patch), \"Input is not a Bezier patch\")\n    assert(is_int(splinesteps) && splinesteps>0, \"splinesteps must be a positive integer\")\n    let(\n        row_degen = [for(row=patch) all_equal(row,eps=EPSILON)],\n        col_degen = [for(col=transpose(patch)) all_equal(col,eps=EPSILON)],\n        top_degen = row_degen[0],\n        bot_degen = last(row_degen),\n        left_degen = col_degen[0],\n        right_degen = last(col_degen),\n        samplepts = lerpn(0,1,splinesteps+1)\n    )\n    all(row_degen) && all(col_degen) ?  // fully degenerate case\n        [EMPTY_VNF, repeat([patch[0][0]],4)] :\n    all(row_degen) ?                         // degenerate to a line (top to bottom)\n        let(pts = bezier_points(column(patch,0), samplepts))\n        [EMPTY_VNF, [pts,pts,[pts[0]],[last(pts)]]] :\n    all(col_degen) ?                         // degenerate to a line (left to right)\n        let(pts = bezier_points(patch[0], samplepts))\n        [EMPTY_VNF, [[pts[0]], [last(pts)], pts, pts]] :\n    !top_degen && !bot_degen && !left_degen && !right_degen ?       // non-degenerate case\n       let(pts = bezier_patch_points(patch, samplepts, samplepts))\n       [\n        vnf_vertex_array(pts, reverse=!reverse),\n        [column(pts,0), column(pts,len(pts)-1), pts[0], last(pts)]\n       ] :\n    top_degen && bot_degen ?\n       let(\n            rowcount = [\n                        each list([3:2:splinesteps]),\n                        if (splinesteps%2==0) splinesteps+1,\n                        each reverse(list([3:2:splinesteps]))\n                       ],\n            bpatch = [for(i=[0:1:len(patch[0])-1]) bezier_points(column(patch,i), samplepts)],\n            pts = [\n                  [bpatch[0][0]],\n                  for(j=[0:splinesteps-2]) bezier_points(column(bpatch,j+1), lerpn(0,1,rowcount[j])),\n                  [last(bpatch[0])]\n                  ],\n            vnf = vnf_tri_array(pts, reverse=!reverse)\n         ) [\n            vnf,\n            [\n             column(pts,0),\n             [for(row=pts) last(row)],\n             pts[0],\n             last(pts),\n            ]\n          ]  :    \n    bot_degen ?                                           // only bottom is degenerate\n       let(\n           result = bezier_vnf_degenerate_patch(reverse(patch), splinesteps=splinesteps, reverse=!reverse, return_edges=true)\n       )\n       [\n          result[0],\n          [reverse(result[1][0]), reverse(result[1][1]), (result[1][3]), (result[1][2])]\n       ] :\n    top_degen ?                                          // only top is degenerate\n       let(\n           full_degen = len(patch)>=4 && all(select(row_degen,1,ceil(len(patch)/2-1))),\n           rowmax = full_degen ? count(splinesteps+1) :\n                                 [for(j=[0:splinesteps]) j<=splinesteps/2 ? 2*j : splinesteps],\n           bpatch = [for(i=[0:1:len(patch[0])-1]) bezier_points(column(patch,i), samplepts)],\n           pts = [\n                  [bpatch[0][0]],\n                  for(j=[1:splinesteps]) bezier_points(column(bpatch,j), lerpn(0,1,rowmax[j]+1))\n                 ],\n           vnf = vnf_tri_array(pts, reverse=!reverse)\n        ) [\n            vnf,\n            [\n             column(pts,0),\n             [for(row=pts) last(row)],\n             pts[0],\n             last(pts),\n            ]\n          ] :\n      // must have left or right degeneracy, so transpose and recurse\n      let(\n          result = bezier_vnf_degenerate_patch(transpose(patch), splinesteps=splinesteps, reverse=!reverse, return_edges=true)\n      )\n      [result[0],\n       select(result[1],[2,3,0,1])\n      ];\n\n\n// Function: bezier_patch_normals()\n// Synopsis: Computes surface normals for one or more places on a bezier surface patch.\n// Topics: Bezier Patches\n// See Also: bezier_patch_points(), bezier_points(), bezier_curve(), bezpath_curve()\n// Usage:\n//   n = bezier_patch_normals(patch, u, v);\n//   ngrid = bezier_patch_normals(patch, LIST, LIST);\n//   ngrid = bezier_patch_normals(patch, RANGE, RANGE);\n// Description:\n//   Compute the unit normal vector to a bezier patch at the listed point set.  The bezier patch must be a rectangular array of\n//   points, and the normal will be computed at all the (u,v) pairs that you specify.  If you give u and v\n//   as single numbers you'll get a single point back.  If you give u and v as lists or ranges you'll\n//   get a 2d rectangular array of points.  If one but not both of u and v is a list or range then you'll\n//   get a list of points.\n//   .\n//   This function works by computing the cross product of the tangents.  In some degenerate cases the one of the tangents\n//   can be zero, so the normal vector does not exist.  In this case, undef is returned.  Another degenerate case\n//   occurs when the tangents are parallel, or nearly parallel.  In this case you will get a unit vector returned but it will not\n//   be the correct normal vector.   This can happen if you use a degenerate patch, or if you give two of the edges of your patch a smooth \"corner\"\n//   so that the u and v directions are parallel at the corner.  \n// Arguments:\n//   patch = The 2D array of control points for a Bezier patch.\n//   u = The bezier u parameter (inner list of patch).  Generally between 0 and 1. Can be a list, range or value.\n//   v = The bezier v parameter (outer list of patch).  Generally between 0 and 1. Can be a list, range or value.\n// Example(3D,Med,VPR=[71.1,0,155.9],VPD=292.705,VPT=[20.4724,38.7273,22.7683],NoAxes): Normal vectors on a patch\n//   patch = [\n//        // u=0,v=0                                         u=1,v=0\n//        [[-50,-50,  0], [-16,-50,  20], [ 16,-50, -20], [50,-50,  0]],\n//        [[-50,-16, 40], [-16,-16,  20], [ 16,-16, -20], [50,-16, 70]],\n//        [[-50, 16, 20], [-16, 16, -20], [ 16, 37,  20], [70, 16, 20]],\n//        [[-50, 50,  0], [73, 50, -40], [ 16, 50,  20], [50, 50,  0]],\n//        // u=0,v=1                                         u=1,v=1\n//   ];\n//   vnf_polyhedron(bezier_vnf(patch,splinesteps=30));\n//   uv = lerpn(0,1,12);\n//   pts = bezier_patch_points(patch, uv, uv);\n//   normals = bezier_patch_normals(patch, uv, uv);\n//     for(i=idx(uv),j=idx(uv)){\n//        stroke([pts[i][j],pts[i][j]-6*normals[i][j]], width=0.5,\n//               endcap1=\"dot\",endcap2=\"arrow2\",color=\"blue\");\n//   }\n// Example(3D,NoAxes,Med,VPR=[72.5,0,288.9],VPD=192.044,VPT=[51.6089,48.118,5.89088]): This example gives invalid normal vectors at the four corners of the patch where the u and v directions are parallel.  You can see how the line of triangulation is approaching parallel at the edge, and the invalid vectors in red point in a completely incorrect direction.  \n//   patch = [\n//       [[18,18,0], [33,  0,  0], [ 67,  0,  0], [ 82, 18,0]],\n//       [[ 0,40,0], [ 0,  0,100], [100,  0, 20], [100, 40,0]],\n//       [[ 0,60,0], [ 0,100,100], [100,100, 20], [100, 60,0]],\n//       [[18,82,0], [33,100,  0], [ 67,100,  0], [ 82, 82,0]],\n//   ];\n//   vnf_polyhedron(bezier_vnf(patch,splinesteps=30));\n//   uv = lerpn(0,1,7);\n//   pts = bezier_patch_points(patch, uv, uv);\n//   normals = bezier_patch_normals(patch, uv, uv);\n//     for(i=idx(uv),j=idx(uv)){\n//        color=((uv[i]==0 || uv[i]==1) && (uv[j]==0 || uv[j]==1))\n//             ? \"red\" : \"blue\";\n//        stroke([pts[i][j],pts[i][j]-8*normals[i][j]], width=0.5,\n//               endcap1=\"dot\",endcap2=\"arrow2\",color=color);\n//   }\n// Example(3D,Med,NoAxes,VPR=[56.4,0,71.9],VPD=66.9616,VPT=[10.2954,1.33721,19.4484]): This degenerate patch has normals everywhere, but computation of the normal fails at the point of degeneracy, the top corner.  \n//    patch=[\n//             repeat([-12.5, 12.5, 15],5),\n//              [[-6.25, 11.25, 15], [-6.25, 8.75, 15], [-6.25, 6.25, 15], [-8.75, 6.25, 15], [-11.25, 6.25, 15]],\n//              [[0, 10, 15], [0, 5, 15], [0, 0, 15], [-5, 0, 15], [-10, 0, 15]],\n//              [[0, 10, 8.75], [0, 5, 8.75], [0, 0, 8.75], [-5, 0, 8.75], [-10, 0, 8.75]],\n//              [[0, 10, 2.5], [0, 5, 2.5], [0, 0, 2.5], [-5, 0, 2.5], [-10, 0, 2.5]]\n//             ];\n//    vnf_polyhedron(bezier_vnf(patch, 32));\n//    uv = lerpn(0,1,8);\n//    pts = bezier_patch_points(patch, uv, uv);\n//    normals = bezier_patch_normals(patch, uv, uv);\n//      for(i=idx(uv),j=idx(uv)){\n//        if (is_def(normals[i][j]))\n//          stroke([pts[i][j],pts[i][j]-2*normals[i][j]], width=0.1,\n//                 endcap1=\"dot\",endcap2=\"arrow2\",color=\"blue\");\n//    }\n// Example(3D,Med,NoAxes,VPR=[48,0,23.6],VPD=32.0275,VPT=[-0.145727,-0.0532125,1.74224]): This example has a singularities where the tangent lines don't exist, so the normal will be undef at those points.  \n//    pts1 = [ [-5,0,0], [5,0,5], [-5,0,5], [5,0,0] ];\n//    pts2 = [ [0,-5,0], [0,5,5], [0,-5,5], [0,5,0] ];\n//    patch = [for(i=[0:3])\n//            [for(j=[0:3]) pts1[i]+pts2[j] ] ];\n//    vnf_polyhedron(bezier_vnf(patch, 163));\n//    uv = [0,.1,.2,.3,.7,.8,.9,1];//lerpn(0,1,8);\n//    pts = bezier_patch_points(patch, uv, uv);\n//    normals = bezier_patch_normals(patch, uv, uv);\n//    for(i=idx(uv),j=idx(uv))\n//      stroke([pts[i][j],pts[i][j]+2*normals[i][j]], width=0.08,\n//               endcap1=\"dot\",endcap2=\"arrow2\",color=\"blue\");\n  \nfunction bezier_patch_normals(patch, u, v) =\n    assert(is_range(u) || is_vector(u) || is_finite(u), \"Input u is invalid\")\n    assert(is_range(v) || is_vector(v) || is_finite(v), \"Input v is invalid\")\n      !is_num(u) && !is_num(v) ?\n          let(\n              vbezes = [for (i = idx(patch[0])) bezier_points(column(patch,i), u)],\n              dvbezes = [for (i = idx(patch[0])) bezier_derivative(column(patch,i), u)],\n              v_tangent = [for (i = idx(vbezes[0])) bezier_derivative(column(vbezes,i), v)],\n              u_tangent = [for (i = idx(vbezes[0])) bezier_points(column(dvbezes,i), v)]\n          )\n          [for(i=idx(u_tangent)) [for(j=idx(u_tangent[0])) unit(cross(u_tangent[i][j],v_tangent[i][j]),undef)]]\n    : is_num(u) && is_num(v)?\n          let(\n                du = bezier_derivative([for (bez = patch) bezier_points(bez, v)], u),\n                dv = bezier_points([for (bez = patch) bezier_derivative(bez, v)], u)\n          )\n          unit(cross(du,dv),undef)\n    : is_num(u) ? bezier_patch_normals(patch,force_list(u),v)[0]\n    :             column(bezier_patch_normals(patch,u,force_list(v)),0);\n\n\n\n// Section: Debugging Beziers\n\n\n// Module: debug_bezier()\n// Synopsis: Shows a bezier path and it's associated control points.\n// SynTags: Geom\n// Topics: Bezier Paths, Debugging\n// See Also: bezpath_curve()\n// Usage:\n//   debug_bezier(bez, [size], [N=]);\n// Description:\n//   Renders 2D or 3D bezier paths and their associated control points.\n//   Useful for debugging bezier paths.\n// Arguments:\n//   bez = the array of points in the bezier.\n//   size = diameter of the lines drawn.\n//   ---\n//   N = Mark the first and every Nth vertex after in a different color and shape.\n// Example(2D):\n//   bez = [\n//       [-10,   0],  [-15,  -5],\n//       [ -5, -10],  [  0, -10],  [ 5, -10],\n//       [ 14,  -5],  [ 15,   0],  [16,   5],\n//       [  5,  10],  [  0,  10]\n//   ];\n//   debug_bezier(bez, N=3, width=0.5);\nmodule debug_bezier(bezpath, width=1, N=3) {\n    no_children($children);\n    check = \n      assert(is_path(bezpath),\"bezpath must be a path\")\n      assert(is_int(N) && N>0, \"N must be a positive integer\")\n      assert(len(bezpath)%N == 1, str(\"A degree \",N,\" bezier path shound have a multiple of \",N,\" points in it, plus 1.\"));\n    $fn=8;\n    stroke(bezpath_curve(bezpath, N=N), width=width, color=\"cyan\");\n    color(\"green\")\n      if (N!=3) \n           stroke(bezpath, width=width);\n      else \n           for(i=[1:3:len(bezpath)]) stroke(select(bezpath,max(0,i-2), min(len(bezpath)-1,i)), width=width);\n    twodim = len(bezpath[0])==2;\n    color(\"red\") move_copies(bezpath)\n      if ($idx % N !=0)\n          if (twodim){\n            rect([width/2, width*3]);\n            rect([width*3, width/2]);\n          } else {\n           zcyl(d=width/2, h=width*3);\n           xcyl(d=width/2, h=width*3);\n           ycyl(d=width/2, h=width*3);\n        }\n    color(\"blue\") move_copies(bezpath)\n      if ($idx % N ==0)\n        if (twodim) circle(d=width*2.25); else sphere(d=width*2.25);\n    if (twodim) color(\"red\") move_copies(bezpath)\n      if ($idx % N !=0) circle(d=width/2);\n}\n\n\n// Module: debug_bezier_patches()\n// Synopsis: Shows a bezier surface patch and its associated control points.\n// SynTags: Geom\n// Topics: Bezier Patches, Debugging\n// See Also: bezier_patch_points(), bezier_patch_flat(), bezier_vnf()\n// Usage:\n//   debug_bezier_patches(patches, [size=], [splinesteps=], [showcps=], [showdots=], [showpatch=], [convexity=], [style=]);\n// Description:\n//   Shows the surface, and optionally, control points of a list of bezier patches.\n// Arguments:\n//   patches = A list of rectangular bezier patches.\n//   ---\n//   splinesteps = Number of segments to divide each bezier curve into. Default: 16\n//   showcps = If true, show the controlpoints as well as the surface.  Default: true.\n//   showdots = If true, shows the calculated surface vertices.  Default: false.\n//   showpatch = If true, shows the surface faces.  Default: true.\n//   size = Size to show control points and lines.\n//   style = The style of subdividing the quads into faces.  Valid options are \"default\", \"alt\", and \"quincunx\".\n//   convexity = Max number of times a line could intersect a wall of the shape.\n// Example:\n//   patch1 = [\n//       [[15,15,0], [33,  0,  0], [ 67,  0,  0], [ 85, 15,0]],\n//       [[ 0,33,0], [33, 33, 50], [ 67, 33, 50], [100, 33,0]],\n//       [[ 0,67,0], [33, 67, 50], [ 67, 67, 50], [100, 67,0]],\n//       [[15,85,0], [33,100,  0], [ 67,100,  0], [ 85, 85,0]],\n//   ];\n//   patch2 = [\n//       [[15,85,0], [33,100,  0], [ 67,100,  0], [ 85, 85,0]],\n//       [[ 0,67,0], [33, 67,-50], [ 67, 67,-50], [100, 67,0]],\n//       [[ 0,33,0], [33, 33,-50], [ 67, 33,-50], [100, 33,0]],\n//       [[15,15,0], [33,  0,  0], [ 67,  0,  0], [ 85, 15,0]],\n//   ];\n//   debug_bezier_patches(patches=[patch1, patch2], splinesteps=8, showcps=true);\nmodule debug_bezier_patches(patches=[], size, splinesteps=16, showcps=true, showdots=false, showpatch=true, convexity=10, style=\"default\")\n{\n    no_children($children);\n    assert(is_undef(size)||is_num(size));\n    assert(is_int(splinesteps) && splinesteps>0);\n    assert(is_list(patches) && all([for (patch=patches) is_bezier_patch(patch)]));\n    assert(is_bool(showcps));\n    assert(is_bool(showdots));\n    assert(is_bool(showpatch));\n    assert(is_int(convexity) && convexity>0);\n    for (patch = patches) {\n        size = is_num(size)? size :\n               let( bounds = pointlist_bounds(flatten(patch)) )\n               max(bounds[1]-bounds[0])*0.01;\n        if (showcps) {\n            move_copies(flatten(patch)) color(\"red\") sphere(d=size*2);\n            color(\"cyan\") \n                for (i=[0:1:len(patch)-1], j=[0:1:len(patch[i])-1]) {\n                        if (i<len(patch)-1) extrude_from_to(patch[i][j], patch[i+1][j]) circle(d=size);\n                        if (j<len(patch[i])-1) extrude_from_to(patch[i][j], patch[i][j+1]) circle(d=size);\n                }        \n        }\n        if (showpatch || showdots){\n            vnf = bezier_vnf(patch, splinesteps=splinesteps, style=style);\n            if (showpatch) vnf_polyhedron(vnf, convexity=convexity);\n            if (showdots) color(\"blue\") move_copies(vnf[0]) sphere(d=size);\n        }\n    }\n}\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-4", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\nmodule translate_copies(a=[[0,0,0]]) move_copies(a) children();\n\nmodule xspread(spacing, n, l, sp) xcopies(spacing=spacing, n=n, l=l, sp=sp) children();\nmodule yspread(spacing, n, l, sp) ycopies(spacing=spacing, n=n, l=l, sp=sp) children();\nmodule zspread(spacing, n, l, sp) zcopies(spacing=spacing, n=n, l=l, sp=sp) children();\n\nmodule spread(p1=[0,0,0], p2=[10,0,0], spacing, l, n=2) line_copies(p1=p1, p2=p2, spacing=spacing, l=l, n=n) children();\nmodule grid_of(xa=[0],ya=[0],za=[0],count,spacing) grid3d(xa=xa, ya=ya, za=za, n=count, spacing=spacing) children();\n\nmodule xring(n=2,r=0,sa=0,cp=[0,0,0],rot=true) xrot_copies(n=n,r=r,sa=sa,cp=cp,subrot=rot) children();\nmodule yring(n=2,r=0,sa=0,cp=[0,0,0],rot=true) yrot_copies(n=n,r=r,sa=sa,cp=cp,subrot=rot) children();\nmodule zring(n=2,r=0,sa=0,cp=[0,0,0],rot=true) zrot_copies(n=n,r=r,sa=sa,cp=cp,subrot=rot) children();\n\nmodule leftcube(size) cube(size, anchor=RIGHT);\nmodule rightcube(size) cube(size, anchor=LEFT);\nmodule fwdcube(size) cube(size, anchor=BACK);\nmodule backcube(size) cube(size, anchor=FWD);\nmodule downcube(size) cube(size, anchor=TOP);\nmodule upcube(size) cube(size, anchor=BOT);\n\nmodule cube2pt(p1,p2) cuboid(p1=p1,p2=p2);\nmodule offsetcube(size=[1,1,1],v=[0,0,0]) cuboid(size,anchor=-v);\nmodule rrect(size=[1,1,1], r=0.25, center=false) cuboid(size,rounding=r,edges=\"Z\",anchor=center?CENTER:BOT);\nmodule rcube(size=[1,1,1], r=0.25, center=false) cuboid(size,rounding=r,anchor=center?CENTER:BOT);\nmodule chamfcube(size=[1,1,1],chamfer=0.25,chamfaxes=[1,1,1],chamfcorners=false) {\n    cuboid(\n        size=size, chamfer=chamfer,\n        trimcorners=chamfcorners,\n        edges=[\n            if (chamfaxes.x) \"X\",\n            if (chamfaxes.y) \"Y\",\n            if (chamfaxes.z) \"Z\",\n        ]\n    );\n}\n\nmodule trapezoid(size1=[1,1], size2=[1,1], h=1, shift=[0,0], align=CTR, orient=0, center)\n    prismoid(size1=size1, size2=size2, h=h, shift=shift, spin=orient, anchor=center==undef? -align : center?CENTER:BOT);\n\nmodule pyramid(n=4, h=1, l=1, r, d, circum=false) {\n    radius = get_radius(r=r, d=d, dflt=l/2/sin(180/n));\n    cyl(r1=radius, r2=0, l=h, circum=circum, $fn=n, realign=true, anchor=BOT);\n}\n\nmodule prism(n=3, h=1, l=1, r, d, circum=false, center=false) {\n    radius = get_radius(r=r, d=d, dflt=l/2/sin(180/n));\n    cyl(r=radius, l=h, circum=circum, $fn=n, realign=true, anchor=center?CENTER:BOT);\n}\n\nmodule chamferred_cylinder(h,r,d,chamfer=0.25,chamfedge,angle=45,top=true,bottom=true,center=false) {\n    chamf = chamfedge!=undef? chamfedge*sin(angle) : chamfer;\n    cyl(h=h, r=r, d=d, chamfer1=(bottom?chamf:0), chamfer2=(top?chamf:0), chamfang=angle, anchor=center?CENTER:BOT);\n}\n\nmodule chamf_cyl(h=1, r, d, chamfer=0.25, chamfedge, angle=45, center=false, top=true, bottom=true) {\n    chamf = chamfedge!=undef? chamfedge*sin(angle) : chamfer;\n    cyl(h=h, r=r, d=d, chamfer1=(bottom?chamf:0), chamfer2=(top?chamf:0), chamfang=angle, anchor=center?CENTER:BOT);\n}\n\nmodule filleted_cylinder(h=1, r, d, r1, r2, d1, d2, fillet=0.25, center=false)\n    cyl(l=h, r=r, d=d, r1=r1, r2=r2, d1=d1, d2=d2, rounding=fillet, anchor=center?CENTER:BOT);\n\nmodule rcylinder(h=1, r=1, r1, r2, d, d1, d2, fillet=0.25, center=false)\n    cyl(l=h, r=r, d=d, r1=r1, r2=r2, d1=d1, d2=d2, rounding=fillet, anchor=center?CENTER:BOT);\n\nmodule thinning_brace(h=50, l=100, thick=5, ang=30, strut=5, wall=3, center=true)\n    thinning_triangle(h=h, l=l, thick=thick, ang=ang, strut=strut, wall=wall, diagonly=true, center=center);\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-5", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: bottlecaps.scad\n//   Bottle caps and necks for PCO18XX standard plastic beverage bottles, and SPI standard bottle necks.  \n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/bottlecaps.scad>\n// FileGroup: Threaded Parts\n// FileSummary: Standard bottle caps and necks.\n//////////////////////////////////////////////////////////////////////\n\n\ninclude <threading.scad>\ninclude <structs.scad>\ninclude <rounding.scad>\n\n// Section: PCO-1810 Bottle Threading\n\n\n// Module: pco1810_neck()\n// Synopsis: Creates a neck for a PCO1810 standard bottle.\n// SynTags: Geom\n// Topics: Bottles, Threading\n// See Also: pco1810_cap()\n// Usage:\n//   pco1810_neck([wall]) [ATTACHMENTS];\n// Description:\n//   Creates an approximation of a standard PCO-1810 threaded beverage bottle neck.\n// Arguments:\n//   wall = Wall thickness in mm.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Extra Anchors:\n//   \"tamper-ring\" = Centered at the top of the anti-tamper ring channel.\n//   \"support-ring\" = Centered at the bottom of the support ring.\n// Example:\n//   pco1810_neck();\n// Example: Standard Anchors\n//   pco1810_neck() show_anchors(custom=false);\n// Example: Custom Named Anchors\n//   expose_anchors(0.3)\n//       pco1810_neck()\n//           show_anchors(std=false);\nmodule pco1810_neck(wall=2, anchor=\"support-ring\", spin=0, orient=UP)\n{\n    inner_d = 21.74;\n    neck_d = 26.19;\n    neck_h = 5.00;\n    support_d = 33.00;\n    support_width = 1.45;\n    support_rad = 0.40;\n    support_h = 21.00;\n    support_ang = 16;\n    tamper_ring_d = 27.97;\n    tamper_ring_width = 0.50;\n    tamper_ring_r = 1.60;\n    tamper_base_d = 25.71;\n    tamper_base_h = 14.10;\n    threadbase_d = 24.51;\n    thread_pitch = 3.18;\n    flank_angle = 20;\n    thread_od = 27.43;\n    lip_d = 25.07;\n    lip_h = 1.70;\n    lip_leadin_r = 0.20;\n    lip_recess_d = 24.94;\n    lip_recess_h = 1.00;\n    lip_roundover_r = 0.58;\n\n    $fn = segs(support_d/2);\n    h = support_h+neck_h;\n    thread_h = (thread_od-threadbase_d)/2;\n    anchors = [\n        named_anchor(\"support-ring\", [0,0,neck_h-h/2]),\n        named_anchor(\"tamper-ring\", [0,0,h/2-tamper_base_h])\n    ];\n    attachable(anchor,spin,orient, d1=neck_d, d2=lip_recess_d+2*lip_leadin_r, l=h, anchors=anchors) {\n        down(h/2) {\n            rotate_extrude(convexity=10) {\n                polygon(turtle(\n                    state=[inner_d/2,0], [\n                        \"untilx\", neck_d/2,\n                        \"left\", 90,\n                        \"move\", neck_h - 1,\n                        \"arcright\", 1, 90,\n                        \"untilx\", support_d/2-support_rad,\n                        \"arcleft\", support_rad, 90,\n                        \"move\", support_width,\n                        \"arcleft\", support_rad, 90-support_ang,\n                        \"untilx\", tamper_base_d/2,\n                        \"right\", 90-support_ang,\n                        \"untily\", h-tamper_base_h,   // Tamper ring holder base.\n                        \"right\", 90,\n                        \"untilx\", tamper_ring_d/2,\n                        \"left\", 90,\n                        \"move\", tamper_ring_width,\n                        \"arcleft\", tamper_ring_r, 90,\n                        \"untilx\", threadbase_d/2,\n                        \"right\", 90,\n                        \"untily\", h-lip_h-lip_leadin_r,  // Lip base.\n                        \"arcright\", lip_leadin_r, 90,\n                        \"untilx\", lip_d/2,\n                        \"left\", 90,\n                        \"untily\", h-lip_recess_h,\n                        \"left\", 90,\n                        \"untilx\", lip_recess_d/2,\n                        \"right\", 90,\n                        \"untily\", h-lip_roundover_r,\n                        \"arcleft\", lip_roundover_r, 90,\n                        \"untilx\", inner_d/2\n                    ]\n                ));\n            }\n            up(h-lip_h) {\n                bottom_half() {\n                    difference() {\n                        thread_helix(\n                            d=threadbase_d-0.1,\n                            pitch=thread_pitch,\n                            thread_depth=thread_h+0.1,\n                            flank_angle=flank_angle,\n                            turns=810/360,\n                            lead_in=-thread_h*2,\n                            anchor=TOP\n                        );\n                        zrot_copies(rots=[90,270]) {\n                            zrot_copies(rots=[-28,28], r=threadbase_d/2) {\n                                prismoid([20,1.82], [20,1.82+2*sin(29)*thread_h], h=thread_h+0.1, anchor=BOT, orient=RIGHT);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\nfunction  pco1810_neck(wall=2, anchor=\"support-ring\", spin=0, orient=UP) =\n    no_function(\"pco1810_neck\");\n\n\n// Module: pco1810_cap()\n// Synopsis: Creates a cap for a PCO1810 standard bottle.\n// SynTags: Geom\n// Topics: Bottles, Threading\n// See Also: pco1810_neck()\n// Usage:\n//   pco1810_cap([h], [r|d], [wall], [texture]) [ATTACHMENTS];\n// Description:\n//   Creates a basic cap for a PCO1810 threaded beverage bottle.\n// Arguments:\n//   h = The height of the cap.\n//   r = Outer radius of the cap.\n//   d = Outer diameter of the cap.\n//   wall = Wall thickness in mm.\n//   texture = The surface texture of the cap.  Valid values are \"none\", \"knurled\", or \"ribbed\".  Default: \"none\"\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Extra Anchors:\n//   \"inside-top\" = Centered on the inside top of the cap.\n// Examples:\n//   pco1810_cap();\n//   pco1810_cap(texture=\"knurled\");\n//   pco1810_cap(texture=\"ribbed\");\n// Example: Standard Anchors\n//   pco1810_cap(texture=\"ribbed\") show_anchors(custom=false);\n// Example: Custom Named Anchors\n//   expose_anchors(0.3)\n//       pco1810_cap(texture=\"ribbed\")\n//           show_anchors(std=false);\nmodule pco1810_cap(h, r, d, wall, texture=\"none\", anchor=BOTTOM, spin=0, orient=UP)\n{\n    cap_id = 28.58;\n    tamper_ring_h = 14.10;\n    thread_pitch = 3.18;\n    flank_angle = 20;\n    thread_od = cap_id;\n    thread_depth = 1.6;\n\n    rr = get_radius(r=r, d=d, dflt=undef);\n    wwall = default(u_sub(rr,cap_id/2), default(wall, 2));\n    hh = default(h, tamper_ring_h + wwall);\n    checks =\n        assert(wwall >= 0, \"wall can't be negative.\")\n        assert(hh >= tamper_ring_h, str(\"height can't be less than \", tamper_ring_h, \".\"));\n\n    $fn = segs(33/2);\n    w = cap_id + 2*wwall;\n    anchors = [\n        named_anchor(\"inside-top\", [0,0,-(hh/2-wwall)])\n    ];\n    attachable(anchor,spin,orient, d=w, l=hh, anchors=anchors) {\n        down(hh/2) zrot(45) {\n            difference() {\n                union() {\n                    if (texture == \"knurled\") {\n                        cyl(d=w, h=hh, texture=\"diamonds\", tex_size=[3,3], tex_style=\"concave\", anchor=BOT);\n                    } else if (texture == \"ribbed\") {\n                        cyl(d=w, h=hh, texture=\"ribs\", tex_size=[3,3], tex_style=\"min_edge\", anchor=BOT);\n                    } else {\n                        cyl(d=w, l=hh, anchor=BOTTOM);\n                    }\n                }\n                up(hh-tamper_ring_h) cyl(d=cap_id, h=tamper_ring_h+wwall, anchor=BOTTOM);\n            }\n            up(hh-tamper_ring_h+2) thread_helix(d=thread_od-thread_depth*2, pitch=thread_pitch, thread_depth=thread_depth, flank_angle=flank_angle, turns=810/360, lead_in=-thread_depth, internal=true, anchor=BOTTOM);\n        }\n        children();\n    }\n}\n\nfunction pco1810_cap(h, r, d, wall, texture=\"none\", anchor=BOTTOM, spin=0, orient=UP) =\n    no_function(\"pco1810_cap\");\n\n\n\n// Section: PCO-1881 Bottle Threading\n\n\n// Module: pco1881_neck()\n// Synopsis: Creates a neck for a PCO1881 standard bottle.\n// SynTags: Geom\n// Topics: Bottles, Threading\n// See Also: pco1881_cap()\n// Usage:\n//   pco1881_neck([wall]) [ATTACHMENTS];\n// Description:\n//   Creates an approximation of a standard PCO-1881 threaded beverage bottle neck.\n// Arguments:\n//   wall = Wall thickness in mm.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Extra Anchors:\n//   \"tamper-ring\" = Centered at the top of the anti-tamper ring channel.\n//   \"support-ring\" = Centered at the bottom of the support ring.\n// Example:\n//   pco1881_neck();\n// Example:\n//   pco1881_neck() show_anchors(custom=false);\n// Example:\n//   expose_anchors(0.3)\n//       pco1881_neck()\n//           show_anchors(std=false);\nmodule pco1881_neck(wall=2, anchor=\"support-ring\", spin=0, orient=UP)\n{\n    inner_d = 21.74;\n    neck_d = 26.19;\n    neck_h = 5.00;\n    support_d = 33.00;\n    support_width = 0.58;\n    support_rad = 0.30;\n    support_h = 17.00;\n    support_ang = 15;\n    tamper_ring_d = 28.00;\n    tamper_ring_width = 0.30;\n    tamper_ring_ang = 45;\n    tamper_base_d = 25.71;\n    tamper_base_h = 11.20;\n    tamper_divot_r = 1.08;\n    threadbase_d = 24.20;\n    thread_pitch = 2.70;\n    flank_angle = 15;\n    thread_od = 27.4;\n    lip_d = 25.07;\n    lip_h = 1.70;\n    lip_leadin_r = 0.30;\n    lip_recess_d = 24.94;\n    lip_recess_h = 1.00;\n    lip_roundover_r = 0.58;\n\n    $fn = segs(support_d/2);\n    h = support_h+neck_h;\n    thread_h = (thread_od-threadbase_d)/2;\n    anchors = [\n        named_anchor(\"support-ring\", [0,0,neck_h-h/2]),\n        named_anchor(\"tamper-ring\", [0,0,h/2-tamper_base_h])\n    ];\n    attachable(anchor,spin,orient, d1=neck_d, d2=lip_recess_d+2*lip_leadin_r, l=h, anchors=anchors) {\n        down(h/2) {\n            rotate_extrude(convexity=10) {\n                polygon(turtle(\n                    state=[inner_d/2,0], [\n                        \"untilx\", neck_d/2,\n                        \"left\", 90,\n                        \"move\", neck_h - 1,\n                        \"arcright\", 1, 90,\n                        \"untilx\", support_d/2-support_rad,\n                        \"arcleft\", support_rad, 90,\n                        \"move\", support_width,\n                        \"arcleft\", support_rad, 90-support_ang,\n                        \"untilx\", tamper_base_d/2,\n                        \"arcright\", tamper_divot_r, 180-support_ang*2,\n                        \"left\", 90-support_ang,\n                        \"untily\", h-tamper_base_h,   // Tamper ring holder base.\n                        \"right\", 90,\n                        \"untilx\", tamper_ring_d/2,\n                        \"left\", 90,\n                        \"move\", tamper_ring_width,\n                        \"left\", tamper_ring_ang,\n                        \"untilx\", threadbase_d/2,\n                        \"right\", tamper_ring_ang,\n                        \"untily\", h-lip_h-lip_leadin_r,  // Lip base.\n                        \"arcright\", lip_leadin_r, 90,\n                        \"untilx\", lip_d/2,\n                        \"left\", 90,\n                        \"untily\", h-lip_recess_h,\n                        \"left\", 90,\n                        \"untilx\", lip_recess_d/2,\n                        \"right\", 90,\n                        \"untily\", h-lip_roundover_r,\n                        \"arcleft\", lip_roundover_r, 90,\n                        \"untilx\", inner_d/2\n                    ]\n                ));\n            }\n            up(h-lip_h) {\n                difference() {\n                    thread_helix(\n                        d=threadbase_d-0.1,\n                        pitch=thread_pitch,\n                        thread_depth=thread_h+0.1,\n                        flank_angle=flank_angle,\n                        turns=650/360,\n                        lead_in=-thread_h*2,\n                        anchor=TOP\n                    );\n                    zrot_copies(rots=[90,270]) {\n                        zrot_copies(rots=[-28,28], r=threadbase_d/2) {\n                            prismoid([20,1.82], [20,1.82+2*sin(29)*thread_h], h=thread_h+0.1, anchor=BOT, orient=RIGHT);\n                        }\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\nfunction pco1881_neck(wall=2, anchor=\"support-ring\", spin=0, orient=UP) =\n    no_function(\"pco1881_neck\");\n\n\n// Module: pco1881_cap()\n// Synopsis: Creates a cap for a PCO1881 standard bottle.\n// SynTags: Geom\n// Topics: Bottles, Threading\n// See Also: pco1881_neck()\n// Usage:\n//   pco1881_cap(wall, [texture]) [ATTACHMENTS];\n// Description:\n//   Creates a basic cap for a PCO1881 threaded beverage bottle.\n// Arguments:\n//   wall = Wall thickness in mm.\n//   texture = The surface texture of the cap.  Valid values are \"none\", \"knurled\", or \"ribbed\".  Default: \"none\"\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Extra Anchors:\n//   \"inside-top\" = Centered on the inside top of the cap.\n// Examples:\n//   pco1881_cap();\n//   pco1881_cap(texture=\"knurled\");\n//   pco1881_cap(texture=\"ribbed\");\n// Example: Standard Anchors\n//   pco1881_cap(texture=\"ribbed\") show_anchors(custom=false);\n// Example: Custom Named Anchors\n//   expose_anchors(0.5)\n//       pco1881_cap(texture=\"ribbed\")\n//           show_anchors(std=false);\nmodule pco1881_cap(wall=2, texture=\"none\", anchor=BOTTOM, spin=0, orient=UP)\n{\n    $fn = segs(33/2);\n    w = 28.58 + 2*wall;\n    h = 11.2 + wall;\n    anchors = [\n        named_anchor(\"inside-top\", [0,0,-(h/2-wall)])\n    ];\n    attachable(anchor,spin,orient, d=w, l=h, anchors=anchors) {\n        down(h/2) zrot(45) {\n            difference() {\n                union() {\n                    if (texture == \"knurled\") {\n                        cyl(d=w, h=11.2+wall, texture=\"diamonds\", tex_size=[3,3], tex_style=\"concave\", anchor=BOT);\n                    } else if (texture == \"ribbed\") {\n                        cyl(d=w, h=11.2+wall, texture=\"ribs\", tex_size=[3,3], tex_style=\"min_edge\", anchor=BOT);\n                    } else {\n                        cyl(d=w, l=11.2+wall, anchor=BOTTOM);\n                    }\n                }\n                up(wall) cyl(d=28.58, h=11.2+wall, anchor=BOTTOM);\n            }\n            up(wall+2) thread_helix(d=25.5, pitch=2.7, thread_depth=1.6, flank_angle=15, turns=650/360, lead_in=-1.6, internal=true, anchor=BOTTOM);\n        }\n        children();\n    }\n}\n\nfunction pco1881_cap(wall=2, texture=\"none\", anchor=BOTTOM, spin=0, orient=UP) =\n    no_function(\"pco1881_cap\");\n\n\n\n// Section: Generic Bottle Connectors\n\n// Module: generic_bottle_neck()\n// Synopsis: Creates a generic neck for a bottle.\n// SynTags: Geom\n// Topics: Bottles, Threading\n// See Also: generic_bottle_cap()\n// Usage:\n//   generic_bottle_neck([wall], ...) [ATTACHMENTS];\n// Description:\n//   Creates a bottle neck given specifications.\n// Arguments:\n//   wall = distance between ID and any wall that may be below the support\n//   ---\n//   neck_d = Outer diameter of neck without threads\n//   id = Inner diameter of neck\n//   thread_od = Outer diameter of thread\n//   height = Height of neck above support\n//   support_d = Outer diameter of support ring.  Set to 0 for no support.\n//   pitch = Thread pitch\n//   round_supp = True to round the lower edge of the support ring\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Extra Anchors:\n//   \"support-ring\" = Centered at the bottom of the support ring.\n// Example:\n//   generic_bottle_neck();\nmodule generic_bottle_neck(\n    wall,\n    neck_d = 25,\n    id = 21.4,\n    thread_od = 27.2,\n    height = 17,\n    support_d = 33.0,\n    pitch = 3.2,\n    round_supp = false,\n    anchor = \"support-ring\",\n    spin = 0,\n    orient = UP\n) {\n    inner_d = id;\n    neck_d = neck_d;\n    supp_d = max(neck_d, support_d);\n    thread_pitch = pitch;\n    flank_angle = 15;\n\n    diamMagMult = neck_d / 26.19;\n    heightMagMult = height / 17.00;\n\n    assert(all_nonnegative([support_d]),\"support_d must be a nonnegative number\");\n    sup_r = 0.30 * (heightMagMult > 1 ? heightMagMult : 1);\n    support_r = floor(((supp_d == neck_d) ? sup_r : min(sup_r, (supp_d - neck_d) / 2)) * 5000) / 10000;\n    support_rad = (wall == undef || !round_supp) ? support_r :\n        min(support_r, floor((supp_d - (inner_d + 2 * wall)) * 5000) / 10000);\n        //Too small of a radius will cause errors with the arc, this limits granularity to .0001mm\n    support_width = max(heightMagMult,1) * sign(support_d);\n    roundover = 0.58 * diamMagMult;\n    lip_roundover_r = (roundover > (neck_d - inner_d) / 2) ? 0 : roundover;\n    h = height + support_width;\n    echo(h=h);\n    threadbase_d = neck_d - 0.8 * diamMagMult;\n\n    $fn = segs(33 / 2);\n    thread_h = (thread_od - threadbase_d) / 2;\n    anchors = [\n        named_anchor(\"support-ring\", [0, 0, 0 - h / 2])\n    ];\n    attachable(anchor, spin, orient, d = neck_d, l = h, anchors = anchors) {\n        down(h / 2) {\n            rotate_extrude(convexity = 10) {\n                polygon(turtle(\n                    state = [inner_d / 2, 0], (supp_d != neck_d) ? [\n                        \"untilx\", supp_d / 2 - ((round_supp) ? support_rad : 0),\n                        \"arcleft\", ((round_supp) ? support_rad : 0), 90,\n                        \"untily\", support_width - support_rad,\n                        \"arcleft\", support_rad, 90,\n                        \"untilx\", neck_d / 2,\n                        \"right\", 90,\n                        \"untily\", h - lip_roundover_r,\n                        \"arcleft\", lip_roundover_r, 90,\n                        \"untilx\", inner_d / 2\n                    ] : [\n                        \"untilx\", supp_d / 2 - ((round_supp) ? support_rad : 0),\n                        \"arcleft\", ((round_supp) ? support_rad : 0), 90,\n                        \"untily\", h - lip_roundover_r,\n                        \"arcleft\", lip_roundover_r, 90,\n                        \"untilx\", inner_d / 2\n                    ]\n                ));\n            }\n            up(h - pitch / 2 - lip_roundover_r) {\n                difference() {\n                    thread_helix(\n                        d = threadbase_d - 0.1 * diamMagMult,\n                        pitch = thread_pitch,\n                        thread_depth = thread_h + 0.1 * diamMagMult,\n                        flank_angle = flank_angle,\n                        turns = (height - pitch - lip_roundover_r) * .6167 / pitch,\n                        lead_in = -thread_h * 2,\n                        anchor = TOP\n                    );\n                    zrot_copies(rots = [90, 270]) {\n                        zrot_copies(rots = [-28, 28], r = threadbase_d / 2) {\n                            prismoid(\n                                [20 * heightMagMult, 1.82 * diamMagMult],\n                                [20 * heightMagMult, 1.82 * diamMagMult * .6 + 2 * sin(29) * thread_h],\n                                h = thread_h + 0.1 * diamMagMult,\n                                anchor = BOT,\n                                orient = RIGHT\n                            );\n                        }\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\nfunction generic_bottle_neck(\n    neck_d,\n    id,\n    thread_od,\n    height,\n    support_d,\n    pitch,\n    round_supp,\n    wall,\n    anchor, spin, orient\n) = no_function(\"generic_bottle_neck\");\n\n\n// Module: generic_bottle_cap()\n// Synopsis: Creates a generic cap for a bottle.\n// SynTags: Geom\n// Topics: Bottles, Threading\n// See Also: generic_bottle_neck()\n// Usage:\n//   generic_bottle_cap(wall, [texture], ...) [ATTACHMENTS];\n// Description:\n//   Creates a basic threaded cap given specifications.\n// Arguments:\n//   wall = Wall thickness in mm.\n//   texture = The surface texture of the cap.  Valid values are \"none\", \"knurled\", or \"ribbed\".  Default: \"none\"\n//   ---\n//   height = Interior height of the cap in mm.\n//   thread_od = Outer diameter of the threads in mm.\n//   tolerance = Extra space to add to the outer diameter of threads and neck in mm.  Applied to radius.\n//   neck_od = Outer diameter of neck in mm.\n//   flank_angle = Angle of taper on threads.\n//   pitch = Thread pitch in mm.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Extra Anchors:\n//   \"inside-top\" = Centered on the inside top of the cap.\n// Examples:\n//   generic_bottle_cap();\n//   generic_bottle_cap(texture=\"knurled\");\n//   generic_bottle_cap(texture=\"ribbed\");\nmodule generic_bottle_cap(\n    wall = 2,\n    texture = \"none\",\n    height = 11.2,\n    thread_depth = 2.34,\n    tolerance = .2,\n    neck_od = 25.5,\n    flank_angle = 15,\n    pitch = 4,\n    anchor = BOTTOM,\n    spin = 0,\n    orient = UP\n) {\n    $fn = segs(33 / 2);\n    threadOuterDTol = neck_od + 2*(thread_depth - 0.8) + 2 * tolerance;   // WTF; Engineered for consistency with old code, but \n    w = threadOuterDTol + 2 * wall;                                       // no clue why this was chosen\n    h = height + wall;\n    neckOuterDTol = neck_od + 2 * tolerance;\n\n    diamMagMult = (w > 32.58) ? w / 32.58 : 1;\n    heightMagMult = (height > 11.2) ? height / 11.2 : 1;\n\n    anchors = [\n        named_anchor(\"inside-top\", [0, 0, -(h / 2 - wall)])\n    ];\n    attachable(anchor, spin, orient, d = w, l = h, anchors = anchors) {\n        down(h / 2) {\n            difference() {\n                union() {\n                    // For the knurled and ribbed caps the PCO caps in BOSL2 cut into the wall\n                    // thickness so the wall+texture are the specified wall thickness.  That\n                    // seems wrong so this does specified thickness+texture\n                    if (texture == \"knurled\") {\n                        cyl(d=w + 1.5*diamMagMult, l=h, texture=\"diamonds\", tex_size=[3,3], tex_style=\"concave\", anchor=BOT);\n                    } else if (texture == \"ribbed\") {\n                        cyl(d=w + 1.5*diamMagMult, l=h, texture=\"ribs\", tex_size=[3,3], tex_style=\"min_edge\", anchor=BOT);\n                    } else {\n                        cyl(d = w, l = h, anchor = BOTTOM);\n                    }\n                }\n                up(wall) cyl(d = threadOuterDTol, h = h, anchor = BOTTOM);\n            }\n            difference(){\n                up(wall + pitch / 2) {\n                    thread_helix(d = neckOuterDTol, pitch = pitch, thread_depth = thread_depth, flank_angle = flank_angle,\n                                 turns = ((height - pitch) / pitch), lead_in = -thread_depth, internal = true, anchor = BOTTOM);\n                }\n            }\n        }\n        children();\n    }\n}\n\nfunction generic_bottle_cap(\n    wall, texture, height,\n    thread_od, tolerance,\n    neck_od, flank_angle, pitch,\n    anchor, spin, orient\n) = no_function(\"generic_bottle_cap\");\n\n\n// Module: bottle_adapter_neck_to_cap()\n// Synopsis: Creates a generic adaptor between a neck and a cap.\n// SynTags: Geom\n// Topics: Bottles, Threading\n// See Also: bottle_adapter_neck_to_neck()\n// Usage:\n//   bottle_adapter_neck_to_cap(wall, [texture], ...) [ATTACHMENTS];\n// Description:\n//   Creates a threaded neck to cap adapter\n// Arguments:\n//   wall = Thickness of wall between neck and cap when d=0.  Leave undefined to have the outside of the tube go from the OD of the neck support ring to the OD of the cap.  Default: undef\n//   texture = The surface texture of the cap.  Valid values are \"none\", \"knurled\", or \"ribbed\".  Default: \"none\"\n//   cap_wall = Wall thickness of the cap in mm.\n//   cap_h = Interior height of the cap in mm.\n//   cap_thread_depth = Cap thread depth.  Default: 2.34\n//   tolerance = Extra space to add to the outer diameter of threads and neck in mm.  Applied to radius.\n//   cap_neck_od = Inner diameter of the cap threads.\n//   cap_neck_id = Inner diameter of the hole through the cap.\n//   cap_thread_taper = Angle of taper on threads.\n//   cap_thread_pitch = Thread pitch in mm\n//   neck_d = Outer diameter of neck w/o threads\n//   neck_id = Inner diameter of neck\n//   neck_thread_od = 27.2\n//   neck_h = Height of neck down to support ring\n//   neck_thread_pitch = Thread pitch in mm.\n//   neck_support_od = Outer diameter of neck support ring.  Leave undefined to set equal to OD of cap.  Set to 0 for no ring.  Default: undef\n//   d = Distance between bottom of neck and top of cap\n//   taper_lead_in = Length to leave straight before tapering on tube between neck and cap if exists.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   bottle_adapter_neck_to_cap();\nmodule bottle_adapter_neck_to_cap(\n    wall,\n    texture = \"none\",\n    cap_wall = 2,\n    cap_h = 11.2,\n    cap_thread_depth = 2.34,\n    tolerance = .2,\n    cap_neck_od = 25.5,\n    cap_neck_id,\n    cap_thread_taper = 15,\n    cap_thread_pitch = 4,\n    neck_d = 25,\n    neck_id = 21.4,\n    neck_thread_od = 27.2,\n    neck_h = 17,\n    neck_thread_pitch = 3.2,\n    neck_support_od,\n    d = 0,\n    taper_lead_in = 0, anchor, spin,orient\n) {\n    cap_od = cap_neck_od + 2*(cap_thread_depth - 0.8) + 2 * tolerance;\n    neck_support_od = (neck_support_od == undef || (d == 0 && neck_support_od < cap_od)) ? cap_od+2*cap_wall\n                    : neck_support_od;\n    cap_neck_id = default(cap_neck_id,neck_id);\n    wall = default(wall, neck_support_od + neck_d + cap_od + neck_id - 2*tolerance);\n    echo(wall=wall);\n\n    $fn = segs(33 / 2);\n    wallt1 = min(wall, (max(neck_support_od, neck_d) - neck_id) / 2);\n    wallt2 = min(wall, (cap_od + 2 * cap_wall - cap_neck_id) / 2);\n\n    top_h = neck_h + max(1,neck_h/17)*sign(neck_support_od);\n    echo(top_h=top_h);\n    bot_h = cap_h + cap_wall;\n    attachable(anchor=anchor,orient=orient,spin=spin, r=max([neck_id/2+wallt1, cap_neck_id/2+wallt2, neck_support_od/2]), h=top_h+bot_h+d) {      \n      zmove((bot_h-top_h)/2)\n        difference(){\n            union(){\n                up(d / 2) {\n                    generic_bottle_neck(neck_d = neck_d,\n                        id = neck_id,\n                        thread_od = neck_thread_od,\n                        height = neck_h,\n                        support_d = neck_support_od,\n                        pitch = neck_thread_pitch,\n                        round_supp = ((wallt1 < (neck_support_od - neck_id) / 2) && (d > 0 || neck_support_od > (cap_thread_od + 2 * (cap_wall + tolerance)))),\n                        wall = (d > 0) ? wallt1 : min(wallt1, ((cap_od + 2 * (cap_wall) - neck_id) / 2))\n                    );\n                }\n                if (d != 0) {\n                    rotate_extrude(){\n                        polygon(points = [\n                            [0, d / 2],\n                            [neck_id / 2 + wallt1, d / 2],\n                            [neck_id / 2 + wallt1, d / 2 - taper_lead_in],\n                            [cap_neck_id / 2 + wallt2, taper_lead_in - d / 2],\n                            [cap_neck_id / 2 + wallt2, -d / 2],\n                            [0, -d / 2]\n                        ]);\n                    }\n                }\n                down(d / 2){\n                    generic_bottle_cap(wall = cap_wall,\n                        texture = texture,\n                        height = cap_h,\n                        thread_depth = cap_thread_depth,\n                        tolerance = tolerance,\n                        neck_od = cap_neck_od,\n                        flank_angle = cap_thread_taper,\n                        orient = DOWN,\n                        pitch = cap_thread_pitch\n                    );\n                }\n            }\n            rotate_extrude() {\n                polygon(points = [\n                    [0, d / 2 + 0.1],\n                    [neck_id / 2, d / 2],\n                    [neck_id / 2, d / 2 - taper_lead_in],\n                    [cap_neck_id / 2, taper_lead_in - d / 2],\n                    [cap_neck_id / 2, -d / 2 - cap_wall],\n                    [0, -d / 2 - cap_wall - 0.1]\n                ]);\n            }\n        }\n      children();\n    }\n}\n\nfunction bottle_adapter_neck_to_cap(\n    wall, texture, cap_wall, cap_h, cap_thread_depth1,\n    tolerance, cap_neck_od, cap_neck_id, cap_thread_taper,\n    cap_thread_pitch, neck_d, neck_id, neck_thread_od,\n    neck_h, neck_thread_pitch, neck_support_od, d, taper_lead_in\n) = no_fuction(\"bottle_adapter_neck_to_cap\");\n\n\n// Module: bottle_adapter_cap_to_cap()\n// Synopsis: Creates a generic adaptor between a cap and a cap.\n// SynTags: Geom\n// Topics: Bottles, Threading\n// See Also: bottle_adapter_neck_to_cap(), bottle_adapter_neck_to_neck()\n// Usage:\n//   bottle_adapter_cap_to_cap(wall, [texture]) [ATTACHMENTS];\n// Description:\n//   Creates a threaded cap to cap adapter.\n// Arguments:\n//   wall = Wall thickness in mm.\n//   texture = The surface texture of the cap.  Valid values are \"none\", \"knurled\", or \"ribbed\".  Default: \"none\"\n//   cap_h1 = Interior height of top cap.\n//   cap_thread_depth1 = Thread depth on top cap.  Default: 2.34\n//   tolerance = Extra space to add to the outer diameter of threads and neck in mm.  Applied to radius.\n//   cap_neck_od1 = Inner diameter of threads on top cap.\n//   cap_thread_pitch1 = Thread pitch of top cap in mm.\n//   cap_h2 = Interior height of bottom cap.  Leave undefined to duplicate cap_h1.\n//   cap_thread_depth2 = Thread depth on bottom cap.  Default: same as cap_thread_depth1\n//   cap_neck_od2 = Inner diameter of threads on top cap.  Leave undefined to duplicate cap_neck_od1.\n//   cap_thread_pitch2 = Thread pitch of bottom cap in mm.  Leave undefinced to duplicate cap_thread_pitch1.\n//   d = Distance between caps.\n//   neck_id1 = Inner diameter of cutout in top cap.\n//   neck_id2 = Inner diameter of cutout in bottom cap.\n//   taper_lead_in = Length to leave straight before tapering on tube between caps if exists.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   bottle_adapter_cap_to_cap();\nmodule bottle_adapter_cap_to_cap(\n    wall = 2,\n    texture = \"none\",\n    cap_h1 = 11.2,\n    cap_thread_depth1 = 2.34,\n    tolerance = .2,\n    cap_neck_od1 = 25.5,\n    cap_thread_pitch1 = 4,\n    cap_h2,\n    cap_thread_depth2,\n    cap_neck_od2,\n    cap_thread_pitch2,\n    d = 0,\n    neck_id,\n    taper_lead_in = 0, anchor, spin,orient\n) {\n    cap_h2 = default(cap_h2,cap_h1);\n    cap_thread_depth2 = default(cap_thread_depth2,cap_thread_depth1);\n    cap_neck_od2 = default(cap_neck_od2,cap_neck_od1);\n    cap_thread_pitch2 = default(cap_thread_pitch2,cap_thread_pitch1);\n    taper_lead_in = (d >= taper_lead_in * 2) ? taper_lead_in : d / 2;\n\n    neck_id = min(cap_neck_od1 - cap_thread_depth1, cap_neck_od2-cap_thread_depth2);\n    \n    top_h = cap_h1+wall;\n    bot_h = cap_h2+wall;\n    \n\n    cap_od1 = cap_neck_od1 + 2*(cap_thread_depth1 - 0.8) + 2 * tolerance;   // WTF; Engineered for consistency with old code, but\n    cap_od2 = cap_neck_od2 + 2*(cap_thread_depth2 - 0.8) + 2 * tolerance;   // WTF; Engineered for consistency with old code, but \n    \n    $fn = segs(33 / 2);\n    attachable(anchor=anchor,spin=spin,orient=orient, h=top_h+bot_h+d, d=max(cap_od1,cap_od2)+2*wall){\n      zmove((bot_h-top_h)/2)\n        difference(){\n          union(){\n              up(d / 2){\n                  generic_bottle_cap(\n                      orient = UP,\n                      wall = wall,\n                      texture = texture,\n                      height = cap_h1,\n                      thread_depth = cap_thread_depth1,\n                      tolerance = tolerance,\n                      neck_od = cap_neck_od1,\n                      pitch = cap_thread_pitch1\n                  );\n              }\n              if (d != 0) {\n                  rotate_extrude() {\n                      polygon(points = [\n                          [0, d / 2],\n                          [cap_od1 / 2 + wall, d / 2],\n                          [cap_od1 / 2 + wall, d / 2 - taper_lead_in],\n                          [cap_od2 / 2 + wall, taper_lead_in - d / 2],\n                          [cap_od2 / 2 + wall, -d / 2],\n                          [0, -d / 2]\n                      ]);\n                  }\n              }\n              down(d / 2){\n                  generic_bottle_cap(\n                      orient = DOWN,\n                      wall = wall,\n                      texture = texture,\n                      height = cap_h2,\n                      thread_depth = cap_thread_depth2,\n                      tolerance = tolerance,\n                      neck_od = cap_neck_od2,\n                      pitch = cap_thread_pitch2\n                  );\n              }\n          }\n          rotate_extrude() {\n                  polygon(points = [\n                      [0, wall + d / 2 + 0.1],\n                      [neck_id / 2, wall + d / 2],\n                      [neck_id / 2, wall + d / 2 - taper_lead_in],\n                      [neck_id / 2, taper_lead_in - d / 2 - wall],\n                      [neck_id / 2, -d / 2 - wall],\n                      [0, -d / 2 - wall - 0.1]\n                  ]);\n              }\n      }\n      children();\n    }\n}\n\nfunction bottle_adapter_cap_to_cap(\n    wall, texture, cap_h1, cap_thread_od1, tolerance,\n    cap_neck_od1, cap_thread_pitch1, cap_h2, cap_thread_od2,\n    cap_neck_od2, cap_thread_pitch2, d, neck_id1, neck_id2, taper_lead_in\n) = no_function(\"bottle_adapter_cap_to_cap\");\n\n\n// Module: bottle_adapter_neck_to_neck()\n// Synopsis: Creates a generic adaptor between a neck and a neck.\n// SynTags: Geom\n// Topics: Bottles, Threading\n// See Also: bottle_adapter_neck_to_cap(), bottle_adapter_cap_to_cap()\n// Usage:\n//   bottle_adapter_neck_to_neck(...) [ATTACHMENTS];\n// Description:\n//   Creates a threaded neck to neck adapter.\n// Arguments:\n//   ---\n//   d = Distance between bottoms of necks\n//   neck_od1 = Outer diameter of top neck w/o threads\n//   neck_id1 = Inner diameter of top neck\n//   thread_od1 = Outer diameter of threads on top neck\n//   height1 =  Height of top neck above support ring.\n//   support_od1 = Outer diameter of the support ring on the top neck.  Set to 0 for no ring.\n//   thread_pitch1 = Thread pitch of top neck.\n//   neck_od2 = Outer diameter of bottom neck w/o threads.  Leave undefined to duplicate neck_od1\n//   neck_id2 = Inner diameter of bottom neck.  Leave undefined to duplicate neck_id1\n//   thread_od2 = Outer diameter of threads on bottom neck.  Leave undefined to duplicate thread_od1\n//   height2 = Height of bottom neck above support ring.  Leave undefined to duplicate height1\n//   support_od2 = Outer diameter of the support ring on bottom neck.  Set to 0 for no ring.  Leave undefined to duplicate support_od1 \n//   pitch2 = Thread pitch of bottom neck.  Leave undefined to duplicate thread_pitch1\n//   taper_lead_in = Length to leave straight before tapering on tube between necks if exists.\n//   wall = Thickness of tube wall between necks.  Leave undefined to match outer diameters with the neckODs/supportODs.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   bottle_adapter_neck_to_neck();\nmodule bottle_adapter_neck_to_neck(\n    d = 0,\n    neck_od1 = 25,\n    neck_id1 = 21.4,\n    thread_od1 = 27.2,\n    height1 = 17,\n    support_od1 = 33.0,\n    thread_pitch1 = 3.2,\n    neck_od2, neck_id2,\n    thread_od2, height2,\n    support_od2,  pitch2,\n    taper_lead_in = 0, wall, anchor, spin, orient\n) {\n    neck_od2 = (neck_od2 == undef) ? neck_od1 : neck_od2;\n    neck_id2 = (neck_id2 == undef) ? neck_id1 : neck_id2;\n    thread_od2 = (thread_od2 == undef) ? thread_od1 : thread_od2;\n    height2 = (height2 == undef) ? height1 : height2;\n    support_od2 = (support_od2 == undef) ? support_od1 : support_od2;\n    pitch2 = (pitch2 == undef) ? thread_pitch1 : pitch2;\n    wall = (wall == undef) ? support_od1 + support_od2 + neck_id1 + neck_id2 : wall;\n\n    supprtOD2 = (d == 0 && support_od2 != 0) ? max(neck_od1, support_od2) : support_od2;\n    supprtOD1 = (d == 0 && support_od1 != 0) ? max(neck_od2, support_od1) : support_od1;\n\n    $fn = segs(33 / 2);\n    wallt1 = min(wall, (max(supprtOD1, neck_od1) - neck_id1) / 2);\n    wallt2 = min(wall, (max(supprtOD2, neck_od2) - neck_id2) / 2);\n\n    taper_lead_in = (d >= taper_lead_in * 2) ? taper_lead_in : d / 2;\n\n    top_h = height1 + max(1,height1/17)*sign(support_od1);\n    bot_h = height2 + max(1,height2/17)*sign(support_od2);\n    \n    attachable(anchor=anchor,orient=orient,spin=spin, h=top_h+bot_h+d, d=max(neck_od1,neck_od2)){\n      zmove((bot_h-top_h)/2)\n      difference(){\n          union(){\n              up(d / 2){\n                  generic_bottle_neck(orient = UP,\n                      neck_d = neck_od1,\n                      id = neck_id1,\n                      thread_od = thread_od1,\n                      height = height1,\n                      support_d = supprtOD1,\n                      pitch = thread_pitch1,\n                      round_supp = ((wallt1 < (supprtOD1 - neck_id1) / 2) || (support_od1 > max(neck_od2, support_od2) && d == 0)),\n                      wall = (d > 0) ? wallt1 : min(wallt1, ((max(neck_od2, support_od2)) - neck_id1) / 2)\n                  );\n              }\n              if (d != 0) {\n                  rotate_extrude() {\n                      polygon(points = [\n                          [0, d / 2],\n                          [neck_id1 / 2 + wallt1, d / 2],\n                          [neck_id1 / 2 + wallt1, d / 2 - taper_lead_in],\n                          [neck_id2 / 2 + wallt2, taper_lead_in - d / 2],\n                          [neck_id2 / 2 + wallt2, -d / 2],\n                          [0, -d / 2]\n                      ]);\n                  }\n              }\n              down(d / 2){\n                  generic_bottle_neck(orient = DOWN,\n                      neck_d = neck_od2,\n                      id = neck_id2,\n                      thread_od = thread_od2,\n                      height = height2,\n                      support_d = supprtOD2,\n                      pitch = pitch2,\n                      round_supp = ((wallt2 < (supprtOD2 - neck_id2) / 2) || (support_od2 > max(neck_od1, support_od1) && d == 0)),\n                      wall = (d > 0) ? wallt2 : min(wallt2, ((max(neck_od1, support_od1)) - neck_id2) / 2)\n                  );\n              }\n          }\n          if (neck_id1 != undef || neck_id2 != undef) {\n              neck_id1 = (neck_id1 == undef) ? neck_id2 : neck_id1;\n              neck_id2 = (neck_id2 == undef) ? neck_id1 : neck_id2;\n\n              rotate_extrude() {\n                  polygon(points = [\n                      [0, d / 2],\n                      [neck_id1 / 2, d / 2],\n                      [neck_id1 / 2, d / 2 - taper_lead_in],\n                      [neck_id2 / 2, taper_lead_in - d / 2],\n                      [neck_id2 / 2, -d / 2],\n                      [0, -d / 2]\n                  ]);\n              }\n          }\n      }\n      children();\n    }\n}\n\nfunction bottle_adapter_neck_to_neck(\n    d, neck_od1, neck_id1, thread_od1, height1,\n    support_od1, thread_pitch1, neck_od2, neck_id2,\n    thread_od2, height2, support_od2,\n    pitch2, taper_lead_in, wall\n) = no_fuction(\"bottle_adapter_neck_to_neck\");\n\n\n\n// Section: SPI Bottle Threading\n\n\n// Module: sp_neck()\n// Synopsis: Creates an SPI threaded bottle neck.\n// SynTags: Geom\n// Topics: Bottles, Threading\n// See Also: sp_cap()\n// Usage:\n//   sp_neck(diam, type, wall|id=, [style=], [bead=]) [ATTACHMENTS];\n// Description:\n//   Make a SPI (Society of Plastics Industry) threaded bottle neck.  You must\n//   supply the nominal outer diameter of the threads and the thread type, one of\n//   400, 410 and 415.  The 400 type neck has 360 degrees of thread, the 410\n//   neck has 540 degrees of thread, and the 415 neck has 720 degrees of thread.\n//   You can also choose between the L style thread, which is symmetric and\n//   the M style thread, which is an asymmetric buttress thread.  The M style\n//   may be good for 3d printing if printed with the flat face up.  \n//   You can specify the wall thickness (measured from the base of the threads) or\n//   the inner diameter, and you can specify an optional bead at the base of the threads.\n// Arguments:\n//   diam = nominal outer diameter of threads\n//   type = thread type, one of 400, 410 and 415\n//   wall = wall thickness\n//   ---\n//   id = inner diameter\n//   style = Either \"L\" or \"M\" to specify the thread style.  Default: \"L\"\n//   bead = if true apply a bad to the neck.  Default: false\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   sp_neck(48,400,2);\n//   sp_neck(48,400,2,bead=true);\n//   sp_neck(22,410,2);\n//   sp_neck(22,410,2,bead=true);\n//   sp_neck(28,415,id=20,style=\"M\");\n//   sp_neck(13,415,wall=1,style=\"M\",bead=true);\n\n\n// Thread specs from https://www.isbt.com/threadspecs-downloads.asp\n\n//  T = peak to peak diameter (outer diameter)\n//  I = Inner diameter\n//  S = space above top thread\n//  H = total height of neck\n\n_sp_specs = [\n  [400, //diam     T      I      H     S    tpi\n        [[ 18, [ 17.68,  8.26,  9.42, 0.94, 8]],\n         [ 20, [ 19.69, 10.26,  9.42, 0.94, 8]],\n         [ 22, [ 21.69, 12.27,  9.42, 0.94, 8]],\n         [ 24, [ 23.67, 13.11, 10.16, 1.17, 8]],\n         [ 28, [ 27.38, 15.60, 10.16, 1.17, 6]],\n         [ 30, [ 28.37, 16.59, 10.24, 1.17, 6]],\n         [ 33, [ 31.83, 20.09, 10.24, 1.17, 6]],\n         [ 35, [ 34.34, 22.23, 10.24, 1.17, 6]],\n         [ 38, [ 37.19, 25.07, 10.24, 1.17, 6]],\n         [ 40, [ 39.75, 27.71, 10.24, 1.17, 6]],\n         [ 43, [ 41.63, 29.59, 10.24, 1.17, 6]],\n         [ 45, [ 43.82, 31.78, 10.24, 1.17, 6]],\n         [ 48, [ 47.12, 35.08, 10.24, 1.17, 6]],\n         [ 51, [ 49.56, 37.57, 10.36, 1.17, 6]],\n         [ 53, [ 52.07, 40.08, 10.36, 1.17, 6]],\n         [ 58, [ 56.06, 44.07, 10.36, 1.17, 6]],\n         [ 60, [ 59.06, 47.07, 10.36, 1.17, 6]],\n         [ 63, [ 62.08, 50.09, 10.36, 1.17, 6]],\n         [ 66, [ 65.07, 53.09, 10.36, 1.17, 6]],\n         [ 70, [ 69.06, 57.07, 10.36, 1.17, 6]],\n         [ 75, [ 73.56, 61.57, 10.36, 1.17, 6]],\n         [ 77, [ 76.66, 64.67, 12.37, 1.52, 6]],\n         [ 83, [ 82.58, 69.93, 12.37, 1.52, 5]],\n         [ 89, [ 88.75, 74.12, 13.59, 1.52, 5]],\n         [100, [ 99.57, 84.94, 15.16, 1.52, 5]],\n         [110, [109.58, 94.92, 15.16, 1.52, 5]],\n         [120, [119.56,104.93, 17.40, 1.52, 5]],\n        ]],\n  [410, //diam     T      I      H     S    tpi  L      W\n        [[ 18, [ 17.68,  8.26, 13.28, 0.94, 8,  9.17, 2.13]],\n         [ 20, [ 19.59, 10.26, 14.07, 0.94, 8,  9.17, 2.13]],\n         [ 22, [ 21.69, 12.27, 14.86, 0.94, 8,  9.55, 2.13]],\n         [ 24, [ 23.67, 13.11, 16.41, 1.17, 8, 11.10, 2.13]],\n         [ 28, [ 27.38, 15.60, 17.98, 1.17, 6, 11.76, 2.39]],\n         ]],\n  [415, //diam     T      I      H     S    tpi  L      W\n        [[ 13, [ 12.90,  5.54, 11.48, 0.94,12,  7.77, 1.14]],\n         [ 15, [ 14.61,  6.55, 14.15, 0.94,12,  8.84, 1.14]],\n         [ 18, [ 17.68,  8.26, 15.67, 0.94, 8, 10.90, 2.13]],\n         [ 20, [ 19.69, 10.26, 18.85, 0.94, 8, 11.58, 2.13]],\n         [ 22, [ 21.69, 12.27, 21.26, 0.94, 8, 13.87, 2.13]],\n         [ 24, [ 23.67, 13.11, 24.31, 1.17, 8, 14.25, 2.13]],\n         [ 28, [ 27.38, 15.60, 27.48, 1.17, 6, 16.64, 2.39]],\n         [ 33, [ 31.83, 20.09, 32.36, 1.17, 6, 19.61, 2.39]],\n         ]]\n];\n\n_sp_twist = [ [400, 360],\n              [410, 540],\n              [415, 720]\n            ];\n\n\n// profile data: tpi, total width, depth, \n_sp_thread_width= [\n                [5, 3.05],\n                [6, 2.39],\n                [8, 2.13],\n                [12, 1.14],  // But note style M is different\n               ];\n\n\nfunction _sp_thread_profile(tpi, a, S, style, flip=false) = \n    let(\n        pitch = 1/tpi*INCH,\n        cL = a*(1-1/sqrt(3)),\n        cM = (1-tan(10))*a/2,\n        // SP specified roundings for the thread profile have special case for tpi=12\n        roundings = style==\"L\" && tpi < 12 ? 0.5 \n                  : style==\"M\" && tpi < 12 ? [0.25, 0.25, 0.75, 0.75]\n                  : style==\"L\" ? [0.38, 0.13, 0.13, 0.38]\n                  : /* style==\"M\" */  [0.25, 0.25, 0.2, 0.5],\n        path1 = style==\"L\"\n                  ? round_corners([[-1/2*pitch,-a/2],\n                                   [-a/2,-a/2],\n                                   [-cL/2,0],\n                                   [cL/2,0],\n                                   [a/2,-a/2],\n                                   [1/2*pitch,-a/2]], radius=roundings, closed=false,$fn=24)\n                  : round_corners(\n                       [[-1/2*pitch,-a/2],\n                                   [-a/2, -a/2],\n                                   [-cM, 0],\n                                   [0,0],\n                                   [a/2,-a/2],\n                                   [1/2*pitch,-a/2]], radius=roundings, closed=false, $fn=24),\n        path2 = flip ? reverse(xflip(path1)) : path1\n   )\n   // Shift so that the profile is S mm from the right end to create proper length S top gap\n   select(right(-a/2+1/2-S,p=path2),1,-2)/pitch;\n\n\nfunction sp_neck(diam,type,wall,id,style=\"L\",bead=false, anchor, spin, orient) = no_function(\"sp_neck\");\nmodule sp_neck(diam,type,wall,id,style=\"L\",bead=false, anchor, spin, orient)\n{\n    assert(num_defined([wall,id])==1, \"Must define exactly one of wall and id\");\n    \n    table = struct_val(_sp_specs,type);\n    dum1=assert(is_def(table),\"Unknown SP closure type.  Type must be one of 400, 410, or 415\");\n    entry = struct_val(table, diam);\n    dum2=assert(is_def(entry), str(\"Unknown closure nominal diameter.  Allowed diameters for SP\",type,\": \",struct_keys(table)))\n         assert(style==\"L\" || style==\"M\", \"style must be \\\"L\\\" or \\\"M\\\"\");\n\n    T = entry[0];\n    I = entry[1];\n    H = entry[2];\n    S = entry[3];\n    tpi = entry[4];\n\n    // a is the width of the thread \n    a = (style==\"M\" && tpi==12) ? 1.3 : struct_val(_sp_thread_width,tpi);\n\n    twist = struct_val(_sp_twist, type);\n\n    profile = _sp_thread_profile(tpi,a,S,style);\n\n    depth = a/2;\n    taperlen = 2*a;\n\n    beadmax = type==400 ? (T/2-depth)+depth*1.25\n            : diam <=15 ? (T-.15)/2 : (T-.05)/2;\n    \n    W = type==400 ? a*1.5      // arbitrary decision for type 400\n                  : entry[6];  // specified width for 410 and 415\n\n    beadpts = [\n                [0,-W/2],\n                each arc(16, points = [[T/2-depth, -W/2],\n                                       [beadmax, 0],\n                                       [T/2-depth, W/2]]),\n                [0,W/2]\n              ];\n\n    isect400 = [for(seg=pair(beadpts)) let(segisect = line_intersection([[T/2,0],[T/2,1]] , seg, LINE, SEGMENT)) if (is_def(segisect)) segisect.y];\n\n    extra_bot = type==400 && bead ? -min(column(beadpts,1))+max(isect400) : 0;\n    bead_shift = type==400 ? H+max(isect400) : entry[5]+W/2;  // entry[5] is L\n\n    attachable(anchor,spin,orient,r=bead ? beadmax : T/2, l=H+extra_bot){\n        up((H+extra_bot)/2){\n            difference(){\n                union(){\n                    thread_helix(d=T-.01, profile=profile, pitch = INCH/tpi, turns=twist/360, lead_in=taperlen, anchor=TOP);\n                    cylinder(d=T-depth*2,h=H,anchor=TOP);\n                    if (bead)\n                      down(bead_shift)\n                         rotate_extrude()\n                            polygon(beadpts);\n                }\n                up(.5)cyl(d=is_def(id) ? id : T-a-2*wall, l=H-extra_bot+1, anchor=TOP);\n            }\n        }\n        children();\n    }\n}\n\n\n\n// Module: sp_cap()\n// Synopsis: Creates an SPI threaded bottle cap.\n// SynTags: Geom\n// Topics: Bottles, Threading\n// See Also: sp_neck()\n// Usage:\n//   sp_cap(diam, type, wall, [style=], [top_adj=], [bot_adj=], [texture=], [$slop]) [ATTACHMENTS];\n// Description:\n//   Make a SPI (Society of Plastics Industry) threaded bottle neck.  You must\n//   supply the nominal outer diameter of the threads and the thread type, one of\n//   400, 410 and 415.  The 400 type neck has 360 degrees of thread, the 410\n//   neck has 540 degrees of thread, and the 415 neck has 720 degrees of thread.\n//   You can also choose between the L style thread, which is symmetric and\n//   the M style thread, which is an asymmetric buttress thread.  Note that it\n//   is OK to mix styles, so you can put an L-style cap onto an M-style neck.  \n//   .\n//   The 410 and 415 caps have very long unthreaded sections at the bottom.\n//   The bot_adj parameter specifies an amount to reduce that bottom extension, which might be\n//   necessary if the cap bottoms out on the bead.  Be careful that you don't shrink past the threads,\n//   especially if making adjustments to 400 caps which have a very small bottom extension.  \n//   These caps often contain a cardboard or foam sealer disk, which can be as much as 1mm thick, and\n//   would cause the cap to stop in a higher position.\n//   .\n//   You can also adjust the space between the top of the cap and the threads using top_adj.  This\n//   will change how the threads engage when the cap is fully seated.\n//   .\n//   The inner diameter of the cap is set to allow 10% of the thread depth in clearance.  The diameter\n//   is further increased by `2 * $slop` so you can increase clearance if necessary. \n//   .\n//   Note: there is a published SPI standard for necks, but absolutely nothing for caps.  This\n//   cap module was designed based on the neck standard to mate reasonably well, but if you\n//   find ways that it does the wrong thing, file a report.  \n// Arguments:\n//   diam = nominal outer diameter of threads\n//   type = thread type, one of 400, 410 and 415\n//   wall = wall thickness\n//   ---\n//   style = Either \"L\" or \"M\" to specify the thread style.  Default: \"L\"\n//   top_adj = Amount to reduce top space in the cap, which means it doesn't screw down as far.  Default: 0\n//   bot_adj = Amount to reduce extension of cap at the bottom, which also means it doesn't screw down as far.  Default: 0\n//   texture = texture for outside of cap, one of \"knurled\", \"ribbed\" or \"none.  Default: \"none\"\n//   $slop = Increase inner diameter by `2 * $slop`.  \n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   sp_cap(48,400,2);\n//   sp_cap(22,400,2);\n//   sp_cap(22,410,2);\n//   sp_cap(28,415,1.5,style=\"M\");\nmodule sp_cap(diam,type,wall,style=\"L\",top_adj=0, bot_adj=0, texture=\"none\", anchor, spin, orient)\n{\n    table = struct_val(_sp_specs,type);\n    dum1=assert(is_def(table),\"Unknown SP closure type.  Type must be one of 400, 410, or 415\");\n    entry = struct_val(table, diam);\n    dum2=assert(is_def(entry), str(\"Unknown closure nominal diameter.  Allowed diameters for SP\",type,\": \",struct_keys(table)))\n         assert(style==\"L\" || style==\"M\", \"style must be \\\"L\\\" or \\\"M\\\"\");\n\n    T = entry[0];\n    I = entry[1];\n    H = entry[2]-0.5;\n    S = entry[3];\n    tpi = entry[4];\n    a = (style==\"M\" && tpi==12) ? 1.3 : struct_val(_sp_thread_width,tpi);\n\n    twist = struct_val(_sp_twist, type);\n\n    echo(top_adj=top_adj,bot_adj=bot_adj);\n    dum3=assert(top_adj<S+0.75*a, str(\"The top_adj value is too large so the thread won't fit.  It must be smaller than \",S+0.75*a));\n    oprofile = _sp_thread_profile(tpi,a,S+0.75*a-top_adj,style,flip=true);\n    bounds=pointlist_bounds(oprofile);\n    profile = fwd(-bounds[0].y,yflip(oprofile));\n\n    depth = a/2;\n    taperlen = 2*a;\n    assert(in_list(texture, [\"none\",\"knurled\",\"ribbed\"]));\n    space=2*depth/10+2*get_slop();\n    attachable(anchor,spin,orient,r= (T+space)/2+wall, l=H-bot_adj+wall){\n        xrot(180)\n        up((H-bot_adj)/2-wall/2){\n            difference(){\n                up(wall){\n                   if (texture==\"knurled\")\n                        cyl(d=T+space+2*wall,l=H+wall-bot_adj,anchor=TOP,texture=\"trunc_pyramids\", tex_size=[3,3], tex_style=\"convex\");\n                   else if (texture == \"ribbed\") \n                        cyl(d=T+space+2*wall,l=H+wall-bot_adj,anchor=TOP,chamfer2=.8,tex_taper=0,texture=\"trunc_ribs\", tex_size=[3,3], tex_style=\"min_edge\");\n                   else\n                        cyl(d=T+space+2*wall,l=H+wall-bot_adj,anchor=TOP,chamfer2=.8);\n                }\n                cyl(d=T+space, l=H-bot_adj+1, anchor=TOP);\n            }\n            thread_helix(d=T+space-.01, profile=profile, pitch = INCH/tpi, turns=twist/360, lead_in=taperlen, anchor=TOP, internal=true);\n        }\n        children();\n    }\n}\n\n\n\n// Function: sp_diameter()\n// Synopsis: Returns the base diameter of an SPI bottle neck from the nominal diameter and type number.\n// Topics: Bottles, Threading\n// See Also: sp_neck(), sp_cap()\n// Usage:\n//   true_diam = sp_diameter(diam,type)\n// Description:\n//   Returns the actual base diameter (root of the threads) for a SPI plastic bottle neck given the nominal diameter and type number (400, 410, 415). \n// Arguments:\n//   diam = nominal diameter\n//   type = closure type number (400, 410 or 415)\nfunction sp_diameter(diam,type) =\n  let(\n      table = struct_val(_sp_specs,type)\n  )\n  assert(is_def(table),\"Unknown SP closure type.  Type must be one of 400, 410, or 415\")\n  let(\n      entry = struct_val(table, diam)\n  )\n  assert(is_def(entry), str(\"Unknown closure nominal diameter.  Allowed diameters for SP\",type,\": \",struct_keys(table)))\n  entry[0];\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-6", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n/// Undocumented LibFile: builtins.scad\n///   This file has indirect calls to OpenSCAD's builtin functions and modules.\n/// Includes:\n///   use <BOSL2/builtins.scad>\n//////////////////////////////////////////////////////////////////////\n\n/// Section: Builtin Functions\n\n/// Section: Builtin Modules\nmodule _square(size,center=false) square(size,center=center);\n\nmodule _circle(r,d) circle(r=r,d=d);\n\nmodule _text(text,size,font,halign,valign,spacing,direction,language,script)\n    text(text, size=size, font=font,\n        halign=halign, valign=valign,\n        spacing=spacing, direction=direction,\n        language=language, script=script\n    );\n\nmodule _color(color) if (color==undef || color==\"default\") children(); else color(color) children();\n\nmodule _cube(size,center) cube(size,center=center);\n\nmodule _cylinder(h,r1,r2,center,r,d,d1,d2) cylinder(h,r=r,d=d,r1=r1,r2=r2,d1=d1,d2=d2,center=center);\n\nmodule _sphere(r,d) sphere(r=r,d=d);\n\nmodule _multmatrix(m) multmatrix(m) children();\nmodule _translate(v) translate(v) children();\nmodule _rotate(a,v) rotate(a=a,v=v) children();\nmodule _scale(v) scale(v) children();\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-7", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: color.scad\n//   HSV and HSL conversion, rainbow() module for coloring multiple objects. \n//   The recolor() and color_this() modules allow you to change the color\n//   of previously colored attachable objects.  \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: HSV and HSL conversion, color multiple objects, change color of objects\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\nuse <builtins.scad>\n\n// Section: Coloring Objects\n\n// Module: recolor()\n// Synopsis:  Sets the color for attachable children and their descendants.\n// SynTags: Trans\n// Topics: Attachments\n// See Also: color_this(), hsl(), hsv()\n// Usage:\n//   recolor([c]) CHILDREN;\n// Description:\n//   Sets the color for attachable children and their descendants, down until another {{recolor()}}\n//   or {{color_this()}}.  This only works with attachables and you cannot have any color() modules\n//   above it in any parents, only other {{recolor()}} or {{color_this()}} modules.  This works by\n//   setting the special `$color` variable, which attachable objects make use of to set the color. \n// Arguments:\n//   c = Color name or RGBA vector.  Default: The default color in your color scheme. \n// Side Effects:\n//   Changes the value of `$color`.\n//   Sets the color of child attachments.\n// Example:\n//   cuboid([10,10,5])\n//     recolor(\"green\")attach(TOP,BOT) cuboid([9,9,4.5])\n//       attach(TOP,BOT) cuboid([8,8,4])\n//         recolor(\"purple\") attach(TOP,BOT) cuboid([7,7,3.5])\n//           attach(TOP,BOT) cuboid([6,6,3])\n//             recolor(\"cyan\")attach(TOP,BOT) cuboid([5,5,2.5])\n//               attach(TOP,BOT) cuboid([4,4,2]);\nmodule recolor(c=\"default\")\n{\n    req_children($children);  \n    $color=c;\n    children();\n}\n\n\n// Module: color_this()\n// Synopsis: Sets the color for children at the current level only.\n// SynTags: Trans\n// Topics: Attachments\n// See Also: recolor(), hsl(), hsv()\n// Usage:\n//   color_this([c]) CHILDREN;\n// Description:\n//   Sets the color for children at one level, reverting to the previous color for further descendants.\n//   This works only with attachables and you cannot have any color() modules above it in any parents,\n//   only recolor() or other color_this() modules.  This works using the `$color` and `$save_color` variables,\n//   which attachable objects make use of to set the color. \n// Arguments:\n//   c = Color name or RGBA vector.  Default: the default color in your color scheme\n// Side Effects:\n//   Changes the value of `$color` and `$save_color`.\n//   Sets the color of child attachments.\n// Example:\n//   cuboid([10,10,5])\n//     color_this(\"green\")attach(TOP,BOT) cuboid([9,9,4.5])\n//       attach(TOP,BOT) cuboid([8,8,4])\n//         color_this(\"purple\") attach(TOP,BOT) cuboid([7,7,3.5])\n//           attach(TOP,BOT) cuboid([6,6,3])\n//             color_this(\"cyan\")attach(TOP,BOT) cuboid([5,5,2.5])\n//               attach(TOP,BOT) cuboid([4,4,2]);\nmodule color_this(c=\"default\")\n{\n  req_children($children);  \n  $save_color=default($color,\"default\");\n  $color=c;\n  children();\n}\n\n\n// Module: rainbow()\n// Synopsis: Iterates through a list, displaying children in different colors.\n// SynTags: Trans\n// Topics: List Handling\n// See Also: hsl(), hsv()\n// Usage:\n//   rainbow(list,[stride],[maxhues],[shuffle],[seed]) CHILDREN;\n// Description:\n//   Iterates the list, displaying children in different colors for each list item.  The color\n//   is set using the color() module, so this module is not compatible with {{recolor()}} or\n//   {{color_this()}}.  This is useful for debugging regions or lists of paths. \n// Arguments:\n//   list = The list of items to iterate through.\n//   stride = Consecutive colors stride around the color wheel divided into this many parts.\n//   maxhues = max number of hues to use (to prevent lots of indistinguishable hues)\n//   shuffle = if true then shuffle the hues in a random order.  Default: false\n//   seed = seed to use for shuffle\n// Side Effects:\n//   Sets the color to progressive values along the ROYGBIV spectrum for each item.\n//   Sets `$idx` to the index of the current item in `list` that we want to show.\n//   Sets `$item` to the current item in `list` that we want to show.\n// Example(2D):\n//   rainbow([\"Foo\",\"Bar\",\"Baz\"]) fwd($idx*10) text(text=$item,size=8,halign=\"center\",valign=\"center\");\n// Example(2D):\n//   rgn = [circle(d=45,$fn=3), circle(d=75,$fn=4), circle(d=50)];\n//   rainbow(rgn) stroke($item, closed=true);\nmodule rainbow(list, stride=1, maxhues, shuffle=false, seed)\n{\n    req_children($children);  \n    ll = len(list);\n    maxhues = first_defined([maxhues,ll]);\n    huestep = 360 / maxhues;\n    huelist = [for (i=[0:1:ll-1]) posmod(i*huestep+i*360/stride,360)];\n    hues = shuffle ? shuffle(huelist, seed=seed) : huelist;\n    for($idx=idx(list)) {\n        $item = list[$idx];\n        hsv(h=hues[$idx]) children();\n    }\n}\n\n\n// Module: color_overlaps()\n// Synopsis: Shows ghostly children, with overlaps highlighted in color.\n// SynTags: Trans\n// Topics: Debugging\n// See Also: rainbow(), debug_vnf()\n// Usage:\n//   color_overlaps([color]) CHILDREN;\n// Description:\n//   Displays the given children in ghostly transparent gray, while the places where the\n//   they overlap are highlighted with the given color.\n// Arguments:\n//   color = The color to highlight overlaps with.  Default: \"red\"\n// Example(2D): 2D Overlaps\n//   color_overlaps() {\n//       circle(d=50);\n//       left(20) circle(d=50);\n//       right(20) circle(d=50);\n//   }\n// Example(): 3D Overlaps\n//   color_overlaps() {\n//       cuboid(50);\n//       left(30) sphere(d=50);\n//       right(30) sphere(d=50);\n//       xcyl(d=10,l=120);\n//   }\nmodule color_overlaps(color=\"red\") {\n    pairs = [for (i=[0:1:$children-1], j=[i+1:1:$children-1]) [i,j]];\n    for (p = pairs) {\n        color(color) {\n            intersection() {\n                children(p.x);\n                children(p.y);\n            }\n        }\n    }\n    %children();\n}\n\n\n// Section: Colorspace Conversion\n\n// Function&Module: hsl()\n// Synopsis: Sets the color of children to a specified hue, saturation, lightness and optional alpha channel value.\n// SynTags: Trans\n// See Also: hsv(), recolor(), color_this()\n// Topics: Colors, Colorspace\n// Usage:\n//   hsl(h,[s],[l],[a]) CHILDREN;\n//   rgb = hsl(h,[s],[l],[a]);\n// Description:\n//   When called as a function, returns the `[R,G,B]` color for the given hue `h`, saturation `s`, and\n//   lightness `l` from the HSL colorspace.  If you supply the `a` value then you'll get a length 4\n//   list `[R,G,B,A]`.  When called as a module, sets the color using the color() module to the given\n//   hue `h`, saturation `s`, and lightness `l` from the HSL colorspace.\n// Arguments:\n//   h = The hue, given as a value between 0 and 360.  0=red, 60=yellow, 120=green, 180=cyan, 240=blue, 300=magenta.\n//   s = The saturation, given as a value between 0 and 1.  0 = grayscale, 1 = vivid colors.  Default: 1\n//   l = The lightness, between 0 and 1.  0 = black, 0.5 = bright colors, 1 = white.  Default: 0.5\n//   a = Specifies the alpha channel as a value between 0 and 1.  0 = fully transparent, 1=opaque.  Default: 1\n// Side Effects:\n//   When called as a module, sets the color of all children.\n// Example:\n//   hsl(h=120,s=1,l=0.5) sphere(d=60);\n// Example:\n//   rgb = hsl(h=270,s=0.75,l=0.6);\n//   color(rgb) cube(60, center=true);\nfunction hsl(h,s=1,l=0.5,a) =\n    let(\n        h=posmod(h,360)\n    ) [\n        for (n=[0,8,4])\n          let(k=(n+h/30)%12)\n          l - s*min(l,1-l)*max(min(k-3,9-k,1),-1),\n        if (is_def(a)) a\n    ];\n\nmodule hsl(h,s=1,l=0.5,a=1)\n{\n  req_children($children);  \n  color(hsl(h,s,l),a) children();\n}\n\n\n// Function&Module: hsv()\n// Synopsis: Sets the color of children to a hue, saturation, value and optional alpha channel value.\n// SynTags: Trans\n// See Also: hsl(), recolor(), color_this()\n// Topics: Colors, Colorspace\n// Usage:\n//   hsv(h,[s],[v],[a]) CHILDREN;\n//   rgb = hsv(h,[s],[v],[a]);\n// Description:\n//   When called as a function, returns the `[R,G,B]` color for the given hue `h`, saturation `s`, and\n//   value `v` from the HSV colorspace.  If you supply the `a` value then you'll get a length 4 list\n//   `[R,G,B,A]`.  When called as a module, sets the color using the color() module to the given hue\n//   `h`, saturation `s`, and value `v` from the HSV colorspace.\n// Arguments:\n//   h = The hue, given as a value between 0 and 360.  0=red, 60=yellow, 120=green, 180=cyan, 240=blue, 300=magenta.\n//   s = The saturation, given as a value between 0 and 1.  0 = grayscale, 1 = vivid colors.  Default: 1\n//   v = The value, between 0 and 1.  0 = darkest black, 1 = bright.  Default: 1\n//   a = Specifies the alpha channel as a value between 0 and 1.  0 = fully transparent, 1=opaque.  Default: 1\n// Side Effects:\n//   When called as a module, sets the color of all children.\n// Example:\n//   hsv(h=120,s=1,v=1) sphere(d=60);\n// Example:\n//   rgb = hsv(h=270,s=0.75,v=0.9);\n//   color(rgb) cube(60, center=true);\nfunction hsv(h,s=1,v=1,a) =\n    assert(s>=0 && s<=1)\n    assert(v>=0 && v<=1)\n    assert(is_undef(a) || a>=0 && a<=1)\n    let(\n        h = posmod(h,360),\n        c = v * s,\n        hprime = h/60,\n        x = c * (1- abs(hprime % 2 - 1)),\n        rgbprime = hprime <=1 ? [c,x,0]\n                 : hprime <=2 ? [x,c,0]\n                 : hprime <=3 ? [0,c,x]\n                 : hprime <=4 ? [0,x,c]\n                 : hprime <=5 ? [x,0,c]\n                 : hprime <=6 ? [c,0,x]\n                 : [0,0,0],\n        m=v-c\n    )\n    is_def(a) ? point4d(add_scalar(rgbprime,m),a)\n              : add_scalar(rgbprime,m);\n\nmodule hsv(h,s=1,v=1,a=1)\n{\n    req_children($children);\n    color(hsv(h,s,v),a) children();\n}    \n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-8", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: comparisons.scad\n//   Functions for comparisons with lists, ordering and sorting\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Data Management\n// FileSummary: Comparisons and sorting.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: List comparison operations\n\n// Function: approx()\n// Synopsis: Returns true if two values are equal to within a small epsilon value.\n// Topics: Comparisons\n// See Also: all_zero(), all_nonzero()\n// Usage:\n//   test = approx(a, b, [eps])\n// Description:\n//   Compares two numbers, vectors, or matrices.  Returns true if they are closer than `eps` to each other.\n//   Results are undefined if `a` and `b` are of different types, or if vectors or matrices contain non-numbers.\n// Arguments:\n//   a = First value.\n//   b = Second value.\n//   eps = The maximum allowed difference between `a` and `b` that will return true. Defaults to 1e-9.\n// Example:\n//   test1 = approx(-0.3333333333,-1/3);  // Returns: true\n//   test2 = approx(0.3333333333,1/3);    // Returns: true\n//   test3 = approx(0.3333,1/3);          // Returns: false\n//   test4 = approx(0.3333,1/3,eps=1e-3); // Returns: true\n//   test5 = approx(PI,3.1415926536);     // Returns: true\n//   test6 = approx([0,0,sin(45)],[0,0,sqrt(2)/2]);  // Returns: true\nfunction approx(a,b,eps=EPSILON) = \n    a == b? is_bool(a) == is_bool(b) :\n    is_num(a) && is_num(b)? abs(a-b) <= eps :\n    is_list(a) && is_list(b) && len(a) == len(b)? (\n        [] == [\n            for (i=idx(a))\n            let(aa=a[i], bb=b[i])\n            if(\n                is_num(aa) && is_num(bb)? abs(aa-bb) > eps :\n                !approx(aa,bb,eps=eps)\n            ) 1\n        ]\n    ) : false;\n\n\n// Function: all_zero()\n// Synopsis: Returns true if the value(s) given are aproximately zero.\n// Topics: Comparisons, List Handling\n// See Also: approx(), all_zero(), all_nonzero()\n// Usage:\n//   x = all_zero(x, [eps]);\n// Description:\n//   Returns true if its argument is approximately zero, to within `eps`.\n//   If passed a list returns true if all its entries are approximately equal to zero. \n//   Otherwise, returns false.\n// Arguments:\n//   x = The value to check.\n//   eps = The maximum allowed variance.  Default: `EPSILON` (1e-9)\n// Example:\n//   a = all_zero(0);  // Returns: true.\n//   b = all_zero(1e-3);  // Returns: false.\n//   c = all_zero([0,0,0]);  // Returns: true.\n//   d = all_zero([0,0,1e-3]);  // Returns: false.\nfunction all_zero(x, eps=EPSILON) =\n    is_finite(x)? abs(x)<eps :\n    is_vector(x) && [for (xx=x) if(abs(xx)>eps) 1] == [];\n\n\n// Function: all_nonzero()\n// Synopsis: Returns true if the value(s) given are not aproximately zero.\n// Topics: Comparisons, List Handling\n// See Also: approx(), all_zero(), all_nonzero()\n// Usage:\n//   test = all_nonzero(x, [eps]);\n// Description:\n//   Returns true if its argument is finite and different from zero by `eps`.\n//   If passed a list returns true if all the entries of the list are finite numbers that are different from zero by `eps`.  \n//   Otherwise, returns false.\n// Arguments:\n//   x = The value to check.\n//   eps = The maximum allowed variance.  Default: `EPSILON` (1e-9)\n// Example:\n//   a = all_nonzero(0);  // Returns: false.\n//   b = all_nonzero(1e-3);  // Returns: true.\n//   c = all_nonzero([0,0,0]);  // Returns: false.\n//   d = all_nonzero([0,0,1e-3]);  // Returns: false.\n//   e = all_nonzero([1e-3,1e-3,1e-3]);  // Returns: true.\nfunction all_nonzero(x, eps=EPSILON) =\n    is_finite(x)? abs(x)>eps :\n    is_vector(x) && [for (xx=x) if(abs(xx)<eps) 1] == [];\n\n\n// Function: all_positive()\n// Synopsis: Returns true if the value(s) given are greater than zero.\n// Topics: Comparisons, List Handling\n// See Also: approx(), all_zero(), all_nonzero(), all_negative(), all_nonpositive(), all_nonnegative()\n// Usage:\n//   test = all_positive(x,[eps]);\n// Description:\n//   Returns true if the argument is finite and greater than zero, within epsilon tolerance if desired.\n//   If passed a list returns true if all the entries are finite positive numbers.\n//   Otherwise, returns false.\n// Arguments:\n//   x = The value to check.\n//   eps = Tolerance. Default: 0\n// Example:\n//   a = all_positive(-2);  // Returns: false.\n//   b = all_positive(0);  // Returns: false.\n//   c = all_positive(2);  // Returns: true.\n//   d = all_positive([0,0,0]);  // Returns: false.\n//   e = all_positive([0,1,2]);  // Returns: false.\n//   f = all_positive([3,1,2]);  // Returns: true.\n//   g = all_positive([3,-1,2]);  // Returns: false.\nfunction all_positive(x,eps=0) =\n    is_finite(x)? x>eps :\n    is_vector(x) && [for (xx=x) if(xx<=0) 1] == [];\n\n\n// Function: all_negative()\n// Synopsis: Returns true if the value(s) given are less than zero.\n// Topics: Comparisons, List Handling\n// See Also: approx(), all_zero(), all_nonzero(), all_positive(), all_nonpositive(), all_nonnegative()\n// Usage:\n//   test = all_negative(x, [eps]);\n// Description:\n//   Returns true if the argument is finite and less than zero, within epsilon tolerance if desired.\n//   If passed a list, returns true if all the elements are finite negative numbers. \n//   Otherwise, returns false.\n// Arguments:\n//   x = The value to check.\n//   eps = tolerance.  Default: 0\n// Example:\n//   a = all_negative(-2);  // Returns: true.\n//   b = all_negative(0);  // Returns: false.\n//   c = all_negative(2);  // Returns: false.\n//   d = all_negative([0,0,0]);  // Returns: false.\n//   e = all_negative([0,1,2]);  // Returns: false.\n//   f = all_negative([3,1,2]);  // Returns: false.\n//   g = all_negative([3,-1,2]);  // Returns: false.\n//   h = all_negative([-3,-1,-2]);  // Returns: true.\nfunction all_negative(x, eps=0) =\n    is_finite(x)? x<-eps :\n    is_vector(x) && [for (xx=x) if(xx>=-eps) 1] == [];\n\n\n// Function: all_nonpositive()\n// Synopsis: Returns true if the value(s) given are less than or equal to zero.\n// Topics: Comparisons, List Handling\n// See Also: approx(), all_zero(), all_nonzero(), all_positive(), all_negative(), all_nonpositive(), all_nonnegative()\n// Usage:\n//   all_nonpositive(x, [eps]);\n// Description:\n//   Returns true if its argument is finite and less than or equal to zero.\n//   If passed a list, returns true if all the elements are finite non-positive numbers.\n//   Otherwise, returns false. \n// Arguments:\n//   x = The value to check.\n//   eps = tolerance.  Default: 0\n// Example:\n//   a = all_nonpositive(-2);  // Returns: true.\n//   b = all_nonpositive(0);  // Returns: true.\n//   c = all_nonpositive(2);  // Returns: false.\n//   d = all_nonpositive([0,0,0]);  // Returns: true.\n//   e = all_nonpositive([0,1,2]);  // Returns: false.\n//   f = all_nonpositive([3,1,2]);  // Returns: false.\n//   g = all_nonpositive([3,-1,2]);  // Returns: false.\n//   h = all_nonpositive([-3,-1,-2]);  // Returns: true.\nfunction all_nonpositive(x,eps=0) =\n    is_num(x)? x<=eps :\n    is_vector(x) && [for (xx=x) if(xx>eps) 1] == []; \n\n\n// Function: all_nonnegative()\n// Synopsis: Returns true if the value(s) given are greater than or equal to zero.\n// Topics: Comparisons, List Handling\n// See Also: approx(), all_zero(), all_nonzero(), all_positive(), all_negative(), all_nonpositive(), all_nonnegative()\n// Usage:\n//   all_nonnegative(x, [eps]);\n// Description:\n//   Returns true if the finite number passed to it is greater than or equal to zero.\n//   If passed a list, returns true if all the elements are finite non-negative numbers. \n//   Otherwise, returns false.\n// Arguments:\n//   x = The value to check.\n//   eps = tolerance.  Default: 0\n// Example:\n//   a = all_nonnegative(-2);  // Returns: false.\n//   b = all_nonnegative(0);  // Returns: true.\n//   c = all_nonnegative(2);  // Returns: true.\n//   d = all_nonnegative([0,0,0]);  // Returns: true.\n//   e = all_nonnegative([0,1,2]);  // Returns: true.\n//   f = all_nonnegative([0,-1,-2]);  // Returns: false.\n//   g = all_nonnegative([3,1,2]);  // Returns: true.\n//   h = all_nonnegative([3,-1,2]);  // Returns: false.\n//   i = all_nonnegative([-3,-1,-2]);  // Returns: false.\nfunction all_nonnegative(x,eps=0) =\n    is_num(x)? x>=-eps :\n    is_vector(x) && [for (xx=x) if(xx<-eps) 1] == [];\n\n\n// Function: all_equal()\n// Synopsis: Returns true if all items in a list are approximately equal to each other.\n// Topics: Comparisons, List Handling\n// See Also: approx(), all_zero(), all_nonzero(), all_positive(), all_negative(), all_nonpositive(), all_nonnegative()\n// Usage:\n//   b = all_equal(vec, [eps]);\n// Description:\n//   Returns true if all of the entries in vec are equal to each other, or approximately equal to each other if eps is set.\n// Arguments:\n//   vec = vector to check\n//   eps = Set to tolerance for approximate equality.  Default: 0\nfunction all_equal(vec,eps=0) =\n   eps==0 ? [for(v=vec) if (v!=vec[0]) v] == []\n          : [for(v=vec) if (!approx(v,vec[0],eps)) v] == [];\n\n\n\n// Function: are_ends_equal()\n// Synopsis: Returns true if the first and last items in a list are approximately equal.\n// Topics: Comparisons, List Handling\n// See Also: approx(), all_zero(), all_nonzero(), all_positive(), all_negative(), all_nonpositive(), all_nonnegative()\n// Usage:\n//   are_ends_equal(list, [eps]);\n// Description:\n//   Returns true if the first and last points in the given list are equal to within epsilon.\n// Arguments:\n//   list = list to check\n//   eps = Tolerance for approximate equality.  Default: `EPSILON` (1e-9)\nfunction are_ends_equal(list, eps=EPSILON) =\n  assert(is_list(list) && len(list)>0, \"Must give a nonempty list\")\n  approx(list[0], list[len(list)-1], eps=eps);\n\n\n// Function: is_increasing()\n// Synopsis: Returns true if exery item in a list is greater than the previous item. \n// Topics: Comparisons, List Handling\n// See Also: max_index(), min_index(), is_increasing(), is_decreasing()\n// Usage:\n//    bool = is_increasing(list, [strict]);\n// Description:\n//   Returns true if the list is (non-strictly) increasing, or strictly increasing if `strict=true`.\n//   The list can be a list of any items that OpenSCAD can compare, or it can be a string which will be\n//   evaluated character by character.\n// Arguments:\n//   list = list (or string) to check\n//   strict = set to true to test that list is strictly increasing.  Default: false\n// Example:\n//   a = is_increasing([1,2,3,4]);  // Returns: true\n//   b = is_increasing([1,3,2,4]);  // Returns: false\n//   c = is_increasing([1,3,3,4]);  // Returns: true\n//   d = is_increasing([1,3,3,4],strict=true);  // Returns: false\n//   e = is_increasing([4,3,2,1]);  // Returns: false\nfunction is_increasing(list,strict=false) =\n    assert(is_list(list)||is_string(list))\n    strict ? len([for (p=pair(list)) if(p.x>=p.y) true])==0\n           : len([for (p=pair(list)) if(p.x>p.y) true])==0;\n\n\n// Function: is_decreasing()\n// Synopsis: Returns true if exery item in a list is less than the previous item. \n// Topics: Comparisons, List Handling\n// See Also: max_index(), min_index(), is_increasing(), is_decreasing()\n// Usage:\n//   bool = is_decreasing(list, [strict]);\n// Description:\n//   Returns true if the list is (non-strictly) decreasing, or strictly decreasing if `strict=true`.\n//   The list can be a list of any items that OpenSCAD can compare, or it can be a string which will be\n//   evaluated character by character.  \n// Arguments:\n//   list = list (or string) to check\n//   strict = set to true to test that list is strictly decreasing.  Default: false\n// Example:\n//   a = is_decreasing([1,2,3,4]);  // Returns: false\n//   b = is_decreasing([4,2,3,1]);  // Returns: false\n//   c = is_decreasing([4,3,2,1]);  // Returns: true\nfunction is_decreasing(list,strict=false) =\n    assert(is_list(list)||is_string(list))\n    strict ? len([for (p=pair(list)) if(p.x<=p.y) true])==0\n           : len([for (p=pair(list)) if(p.x<p.y) true])==0;\n\n\n\n\nfunction _type_num(x) =\n    is_undef(x)?  0 :\n    is_bool(x)?   1 :\n    is_num(x)?    2 :\n    is_nan(x)?    3 :\n    is_string(x)? 4 :\n    is_list(x)?   5 : 6;\n\n\n// Function: compare_vals()\n// Synopsis: Compares two values, possibly of different type.\n// Topics: Comparisons, List Handling\n// See Also: approx(), is_increasing(), is_decreasing()\n// Usage:\n//   test = compare_vals(a, b);\n// Description:\n//   Compares two values.  Lists are compared recursively.\n//   Returns a negative value if a<b.  Returns a positive value if a>b.  Returns 0 if a==b.\n//   If types are not the same, then undef < bool < nan < num < str < list < range.\n// Arguments:\n//   a = First value to compare.\n//   b = Second value to compare.\nfunction compare_vals(a, b) =\n    (a==b)? 0 :\n    let(t1=_type_num(a), t2=_type_num(b)) (t1!=t2)? (t1-t2) :\n    is_list(a)? compare_lists(a,b) :\n    is_nan(a)? 0 :\n    (a<b)? -1 : (a>b)? 1 : 0;\n\n\n// Function: compare_lists()\n// Synopsis: Compares two lists of values, possibly of different type.\n// Topics: Comparisons, List Handling\n// See Also: compare_vals(), approx(), is_increasing(), is_decreasing()\n// Usage:\n//   test = compare_lists(a, b)\n// Description:\n//   Compare contents of two lists using `compare_vals()`.\n//   Returns a negative number if `a`<`b`.\n//   Returns 0 if `a`==`b`.\n//   Returns a positive number if `a`>`b`.\n// Arguments:\n//   a = First list to compare.\n//   b = Second list to compare.\nfunction compare_lists(a, b) =\n    a==b? 0 :\n    let(\n        cmps = [\n            for (i = [0:1:min(len(a),len(b))-1])\n            let( cmp = compare_vals(a[i],b[i]) )\n            if (cmp!=0) cmp\n        ]\n    )\n    cmps==[]? (len(a)-len(b)) : cmps[0];\n\n\n\n// Section: Finding the index of the minimum or maximum of a list\n\n\n// Function: min_index()\n// Synopsis: Returns the index of the minimal value in the given list.\n// Topics: List Handling\n// See Also: max_index(), is_increasing(), is_decreasing()\n// Usage:\n//   idx = min_index(vals);\n//   idxlist = min_index(vals, all=true);\n// Description:\n//   Returns the index of the first occurrence of the minimum value in the given list. \n//   If `all` is true then returns a list of all indices where the minimum value occurs.\n// Arguments:\n//   vals = vector of values\n//   all = set to true to return indices of all occurences of the minimum.  Default: false\n// Example:\n//   a = min_index([5,3,9,6,2,7,8,2,1]); // Returns: 8\n//   b = min_index([5,3,9,6,2,7,8,2,7],all=true); // Returns: [4,7]\nfunction min_index(vals, all=false) =\n    assert( is_vector(vals), \"Invalid or list of numbers.\")\n    all ? search(min(vals),vals,0) : search(min(vals), vals)[0];\n\n\n// Function: max_index()\n// Synopsis: Returns the index of the minimal value in the given list.\n// Topics: List Handling\n// See Also: min_index(), is_increasing(), is_decreasing()\n// Usage:\n//   idx = max_index(vals);\n//   idxlist = max_index(vals, all=true);\n// Description:\n//   Returns the index of the first occurrence of the maximum value in the given list. \n//   If `all` is true then returns a list of all indices where the maximum value occurs.\n// Arguments:\n//   vals = vector of values\n//   all = set to true to return indices of all occurences of the maximum.  Default: false\n// Example:\n//   max_index([5,3,9,6,2,7,8,9,1]); // Returns: 2\n//   max_index([5,3,9,6,2,7,8,9,1],all=true); // Returns: [2,7]\nfunction max_index(vals, all=false) =\n    assert( is_vector(vals) && len(vals)>0 , \"Invalid or empty list of numbers.\")\n    all ? search(max(vals),vals,0) : search(max(vals), vals)[0];\n\n\n// Section: Dealing with duplicate list entries\n\n\n// Function: find_approx()\n// Synopsis: Finds the indexes of the item(s) in the given list that are aproximately the given value.\n// Topics: List Handling\n// See Also: in_list()\n// Usage:\n//   idx = find_approx(val, list, [start=], [eps=]);\n//   indices = find_approx(val, list, all=true, [start=], [eps=]);\n// Description:\n//   Finds the first item in `list` that matches `val` to within `eps` tolerance, returning the index.  Returns `undef` if there is no match.\n//   If `all=true` then returns all the items that agree within `eps` and returns the empty list if no such items exist.  \n// Arguments:\n//   val = The value to search for.  \n//   list = The list to search.\n//   ---\n//   start = The index to start searching from.  Default: 0\n//   all = If true, returns a list of all matching item indices.  Default: false\n//   eps = The maximum allowed floating point rounding error for numeric comparisons.  Default: EPSILON (1e-9)\n// Example:\n//   find_approx(3,[4,5,3.01,2,2.99], eps=0.1);  // Returns 2\n//   find_approx(9,[4,5,3.01,2,2.99], eps=0.1);  // Returns undef\n//   find_approx(3,[4,5,3.01,2,2.99], all=true, eps=0.1);  // Returns [2,4]\n//   find_approx(9,[4,5,3.01,2,2.99], all=true, eps=0.1);  // Returns []\nfunction find_approx(val, list, start=0, all=false, eps=EPSILON) =\n    all ? [for (i=[start:1:len(list)-1]) if (approx(val, list[i], eps=eps)) i]\n        :  __find_approx(val, list, eps=eps, i=start);\n\nfunction __find_approx(val, list, eps, i=0) =\n    i >= len(list)? undef :\n    approx(val, list[i], eps=eps)\n          ? i\n          : __find_approx(val, list, eps=eps, i=i+1);\n\n\n\n// Function: deduplicate()\n// Synopsis: Returns a list with all consecutive duplicate values removed.\n// Topics: List Handling\n// See Also: deduplicate_indexed()\n// Usage:\n//   list = deduplicate(list, [closed], [eps]);\n// Description:\n//   Removes consecutive duplicate items in a list.\n//   When `eps` is zero, the comparison between consecutive items is exact.\n//   Otherwise, when all list items and subitems are numbers, the comparison is within the tolerance `eps`.\n//   Unlike `unique()` only consecutive duplicates are removed and the list is *not* sorted.\n//   If `closed` is set to true then the first and last entries in `list` are treated as adjacent,\n//   so all trailing items that match `list[0]` are dropped.  \n// Arguments:\n//   list = The list to deduplicate.\n//   closed = If true, treats first and last list entry as adjacent.  Default: false\n//   eps = The maximum tolerance between items.  Default: EPSILON\n// Example:\n//   a = deduplicate([8,3,4,4,4,8,2,3,3,8,8]);  // Returns: [8,3,4,8,2,3,8]\n//   b = deduplicate(closed=true, [8,3,4,4,4,8,2,3,3,8,8]);  // Returns: [8,3,4,8,2,3]\n//   c = deduplicate(\"Hello\");  // Returns: \"Helo\"\n//   d = deduplicate([[3,4],[7,2],[7,1.99],[1,4]],eps=0.1);  // Returns: [[3,4],[7,2],[1,4]]\n//   e = deduplicate([[7,undef],[7,undef],[1,4],[1,4+1e-12]],eps=0);    // Returns: [[7,undef],[1,4],[1,4+1e-12]]\nfunction deduplicate(list, closed=false, eps=EPSILON) =\n    assert(is_list(list)||is_string(list))\n    let(\n        l = len(list),\n        end = l-(closed?0:1)\n    )\n    is_string(list) ? str_join([for (i=[0:1:l-1]) if (i==end || list[i] != list[(i+1)%l]) list[i]]) :\n    eps==0 ? [for (i=[0:1:l-1]) if (i==end || list[i] != list[(i+1)%l]) list[i]] :\n    [for (i=[0:1:l-1]) if (i==end || !approx(list[i], list[(i+1)%l], eps)) list[i]];\n\n\n// Function: deduplicate_indexed()\n// Synopsis: Takes a list of indices into a list of values, and returns a list of indices whose values are not consecutively the same.\n// Topics: List Handling\n// See Also: deduplicate()\n// Usage:\n//   new_idxs = deduplicate_indexed(list, indices, [closed], [eps]);\n// Description:\n//   Given a list, and a list of indices, removes consecutive indices corresponding to list values that are equal\n//   or approximately equal.  \n// Arguments:\n//   list = The list that the indices index into.\n//   indices = The list of indices to deduplicate.\n//   closed = If true, drops trailing indices if their list value matches the list value corresponding to the first index. \n//   eps = The maximum difference to allow between numbers or vectors.\n// Example:\n//   a = deduplicate_indexed([8,6,4,6,3], [1,4,3,1,2,2,0,1]);  // Returns: [1,4,3,2,0,1]\n//   b = deduplicate_indexed([8,6,4,6,3], [1,4,3,1,2,2,0,1], closed=true);  // Returns: [1,4,3,2,0]\n//   c = deduplicate_indexed([[7,undef],[7,undef],[1,4],[1,4],[1,4+1e-12]],eps=0);    // Returns: [0,2,4]\nfunction deduplicate_indexed(list, indices, closed=false, eps=EPSILON) =\n    assert(is_list(list)||is_string(list), \"Improper list or string.\")\n    indices==[]? [] :\n    assert(is_vector(indices), \"Indices must be a list of numbers.\")\n    let(\n        ll = len(list),\n        l = len(indices),\n        end = l-(closed?0:1)\n    ) [\n        for (i = [0:1:l-1]) let(\n           idx1 = indices[i],\n           idx2 = indices[(i+1)%l],\n           a = assert(idx1>=0,\"Bad index.\")\n               assert(idx1<len(list),\"Bad index in indices.\")\n               list[idx1],\n           b = assert(idx2>=0,\"Bad index.\")\n               assert(idx2<len(list),\"Bad index in indices.\")\n               list[idx2],\n           eq = (a == b)? true :\n                (a*0 != b*0) || (eps==0)? false :\n                is_num(a) || is_vector(a) ? approx(a, b, eps=eps) \n                : false\n        ) \n        if (i==end || !eq) indices[i]\n    ];\n\n\n\n\n// Function: list_wrap()\n// Synopsis: Returns a list whose last value is the same as the first.\n// Topics: List Handling, Paths\n// See Also: list_unwrap(), deduplicate()\n// Usage:\n//   list_wrap(path, [eps]);\n// Description:\n//   Force a list to wrap around so that its last point is equal to its first point:  if the first and last entries are equal, simply returns the list unchanged.\n//   Otherwise returns the list with the first point duplicated at the end of the list.  Comparisons are done to the tolerance `eps`.  Lists of length 0 or\n//   1 are returned unchanged.  \n// Arguments:\n//   list = list to unwrap\n//   eps = epsilon for comparison.  Default: EPSILON (1e-9)\n\nfunction list_wrap(list, eps=EPSILON) =\n    assert(is_list(list))\n    len(list)<2 || are_ends_equal(list,eps=eps)? list : [each list, list[0]];\n\n\nfunction cleanup_path(list,eps=EPSILON) =\n  echo(\"***** Function cleanup_path() has been replaced by list_unwrap() and will be removed in a future version *****\")\n  list_unwrap(list,eps);\n\nfunction close_path(list,eps=EPSILON) =\n  echo(\"***** Function close_path() has been replaced by list_wrap() and will be removed in a future version *****\")\n  list_wrap(list,eps);\n\n// Function: list_unwrap()\n// Synopsis: Removes the last item of a list if its first and last values are equal.\n// Topics: List Handling, Paths\n// See Also: list_wrap(), deduplicate()\n// Usage:\n//   list_unwrap(list, [eps]);\n// Description:\n//   If a list's last point matches its first point then delete the last point.  Inverse operation to {{list_wrap()}}.  Note that if the first/last points\n//   are repeated then the output may still have the first point equal to the last point.  Comparisons are done to the tolerance `eps`.  If the list has\n//   length 0 or 1 it is returned unchanged.  \n// Arguments:\n//   list = list to unwrap\n//   eps = epsilon for comparison.  Default: EPSILON (1e-9)\nfunction list_unwrap(list, eps=EPSILON) =\n    assert(is_list(list))\n    len(list)>=2 && are_ends_equal(list,eps=eps)? [for (i=[0:1:len(list)-2]) list[i]] : list;\n\n\n\n// Function: unique()\n// Synopsis: Returns a sorted list with all duplicates removed.\n// Topics: List Handling\n// See Also: shuffle(), sort(), sortidx(), unique_count()\n// Usage:\n//   ulist = unique(list);\n// Description:\n//   Given a string or a list returns the sorted string or the sorted list with all repeated items removed.\n//   The sorting order of non homogeneous lists is the function `sort` order.\n// Arguments:\n//   list = The list to process.\n// Example:\n//   sorted = unique([5,2,8,3,1,3,8,7,5]);  // Returns: [1,2,3,5,7,8]\n//   sorted = unique(\"axdbxxc\");  // Returns: \"abcdx\"\n//   sorted = unique([true,2,\"xba\",[1,0],true,[0,0],3,\"a\",[0,0],2]); // Returns: [true,2,3,\"a\",\"xba\",[0,0],[1,0]]\nfunction unique(list) =\n    assert(is_list(list)||is_string(list), \"Invalid input.\" )\n    is_string(list)? str_join(unique([for (x = list) x])) :\n    len(list)<=1? list : \n    is_homogeneous(list,1) && ! is_list(list[0])\n    ?   _unique_sort(list)\n    :   let( sorted = sort(list))\n        [\n            for (i=[0:1:len(sorted)-1])\n                if (i==0 || (sorted[i] != sorted[i-1]))\n                    sorted[i]\n        ];\n\nfunction _unique_sort(l) =\n    len(l) <= 1 ? l : \n    let(\n        pivot   = l[floor(len(l)/2)],\n        equal   = [ for(li=l) if( li==pivot) li ],\n        lesser  = [ for(li=l) if( li<pivot ) li ],\n        greater = [ for(li=l) if( li>pivot) li ]\n    )\n    concat(\n        _unique_sort(lesser), \n        equal[0], \n        _unique_sort(greater)\n    );    \n\n\n// Function: unique_count()\n// Synopsis: Returns a sorted list of unique items with counts.\n// Topics: List Handling\n// See Also: shuffle(), sort(), sortidx(), unique()\n// Usage:\n//   sorted_counts = unique_count(list);\n// Description:\n//   Returns `[sorted,counts]` where `sorted` is a sorted list of the unique items in `list` and `counts` is a list such \n//   that `count[i]` gives the number of times that `sorted[i]` appears in `list`.  \n// Arguments:\n//   list = The list to analyze. \n// Example:\n//   sorted = unique([5,2,8,3,1,3,8,3,5]);  // Returns: [ [1,2,3,5,8], [1,1,3,2,2] ]\nfunction unique_count(list) =\n    assert(is_list(list) || is_string(list), \"Invalid input.\" )\n    list == [] ? [[],[]] : \n    is_homogeneous(list,1) && ! is_list(list[0])\n    ?    let( sorted = _group_sort(list) )\n        [ [for(s=sorted) s[0] ], [for(s=sorted) len(s) ] ]\n    :   let( \n            list = sort(list),\n            ind = [0, for(i=[1:1:len(list)-1]) if (list[i]!=list[i-1]) i] \n        )\n        [ select(list,ind), deltas( concat(ind,[len(list)]) ) ];\n\n\n\n// Section: Sorting\n\n\n// returns true for valid index specifications idx in the interval [imin, imax) \n// note that idx can't have any value greater or EQUAL to imax\n// this allows imax=INF as a bound to numerical lists\nfunction _valid_idx(idx,imin,imax) =\n    is_undef(idx) \n    || ( is_finite(idx)  \n         && ( is_undef(imin) || idx>=imin ) \n         && ( is_undef(imax) || idx< imax ) )\n    || ( is_list(idx)  \n         && ( is_undef(imin) || min(idx)>=imin ) \n         && ( is_undef(imax) || max(idx)< imax ) )\n    || ( is_range(idx) \n         && ( is_undef(imin) || (idx[1]>0 && idx[0]>=imin ) || (idx[1]<0 && idx[0]<=imax ) )\n         && ( is_undef(imax) || (idx[1]>0 && idx[2]<=imax ) || (idx[1]<0 && idx[2]>=imin ) ) );\n\n// idx should be an index of the arrays l[i]\nfunction _group_sort_by_index(l,idx) =\n    len(l) == 0 ? [] :\n    len(l) == 1 ? [l] : \n    let(\n        pivot   = l[floor(len(l)/2)][idx],\n        equal   = [ for(li=l) if( li[idx]==pivot) li ],\n        lesser  = [ for(li=l) if( li[idx]< pivot) li ],\n        greater = [ for(li=l) if( li[idx]> pivot) li ]\n    )\n    concat(\n        _group_sort_by_index(lesser,idx), \n        [equal], \n        _group_sort_by_index(greater,idx)\n    );  \n            \n\nfunction _group_sort(l) =\n    len(l) == 0 ? [] : \n    len(l) == 1 ? [l] : \n    let(\n        pivot   = l[floor(len(l)/2)],\n        equal   = [ for(li=l) if( li==pivot) li ],\n        lesser  = [ for(li=l) if( li< pivot) li ],\n        greater = [ for(li=l) if( li> pivot) li ]\n    )\n    concat(\n        _group_sort(lesser), \n        [equal], \n        _group_sort(greater)\n    );    \n\n\n// Sort a vector of scalar values with the native comparison operator\n// all elements should have the same type.\nfunction _sort_scalars(arr) =\n    len(arr)<=1 ? arr : \n    let(\n        pivot   = arr[floor(len(arr)/2)],\n        lesser  = [ for (y = arr) if (y  < pivot) y ],\n        equal   = [ for (y = arr) if (y == pivot) y ],\n        greater = [ for (y = arr) if (y  > pivot) y ]\n    ) \n    concat( _sort_scalars(lesser), equal, _sort_scalars(greater) );\n\n\n// lexical sort of a homogeneous list of vectors \n// uses native comparison operator\nfunction _sort_vectors(arr, _i=0) =\n    len(arr)<=1 || _i>=len(arr[0]) ? arr :\n    let(\n        pivot   = arr[floor(len(arr)/2)][_i],\n        lesser  = [ for (entry=arr) if (entry[_i]  < pivot ) entry ],\n        equal   = [ for (entry=arr) if (entry[_i] == pivot ) entry ],\n        greater = [ for (entry=arr) if (entry[_i]  > pivot ) entry ]\n    )\n    concat(\n        _sort_vectors(lesser,  _i   ), \n        _sort_vectors(equal,   _i+1 ), \n        _sort_vectors(greater, _i ) );\n        \n\n// lexical sort of a homogeneous list of vectors by the vector components with indices in idxlist\n// all idxlist indices should be in the range of the vector dimensions\n// idxlist must be undef or a simple list of numbers\n// uses native comparison operator\nfunction _sort_vectors(arr, idxlist, _i=0) =\n    len(arr)<=1 || ( is_list(idxlist) && _i>=len(idxlist) ) || _i>=len(arr[0])  ? arr :\n    let(\n        k = is_list(idxlist) ? idxlist[_i] : _i,\n        pivot   = arr[floor(len(arr)/2)][k],\n        lesser  = [ for (entry=arr) if (entry[k]  < pivot ) entry ],\n        equal   = [ for (entry=arr) if (entry[k] == pivot ) entry ],\n        greater = [ for (entry=arr) if (entry[k]  > pivot ) entry ]\n      )\n    concat(\n        _sort_vectors(lesser,  idxlist, _i  ), \n        _sort_vectors(equal,   idxlist, _i+1), \n        _sort_vectors(greater, idxlist, _i  ) );\n        \n \n// sorting using compare_vals(); returns indexed list when `indexed==true`\nfunction _sort_general(arr, idx=undef, indexed=false) =\n    (len(arr)<=1) ? arr :\n    ! indexed && is_undef(idx)\n    ? _lexical_sort(arr)\n    : let( labeled = is_undef(idx) ? [for(i=idx(arr)) [i,arr[i]]]\n                                   : [for(i=idx(arr)) [i, for(j=idx) arr[i][j]]],\n           arrind = _indexed_sort(labeled))\n      indexed \n      ? arrind\n      : [for(i=arrind) arr[i]];\n      \n// lexical sort using compare_vals()\nfunction _lexical_sort(arr) = \n    len(arr)<=1? arr : \n    let( pivot = arr[floor(len(arr)/2)] )\n    let(\n        lesser  = [ for (entry=arr) if (compare_vals(entry, pivot) <0 ) entry ],\n        equal   = [ for (entry=arr) if (compare_vals(entry, pivot)==0 ) entry ],\n        greater = [ for (entry=arr) if (compare_vals(entry, pivot) >0 ) entry ]\n      )\n    concat(_lexical_sort(lesser), equal, _lexical_sort(greater));\n\n\n// given a list of pairs, return the first element of each pair of the list sorted by the second element of the pair\n// the sorting is done using compare_vals()\nfunction _indexed_sort(arrind) = \n    arrind==[] ? [] : len(arrind)==1? [arrind[0][0]] : \n    let( pivot = arrind[floor(len(arrind)/2)][1] )\n    let(\n        lesser  = [ for (entry=arrind) if (compare_vals(entry[1], pivot) <0 ) entry ],\n        equal   = [ for (entry=arrind) if (compare_vals(entry[1], pivot)==0 ) entry[0] ],\n        greater = [ for (entry=arrind) if (compare_vals(entry[1], pivot) >0 ) entry ]\n      )\n    concat(_indexed_sort(lesser), equal, _indexed_sort(greater));\n\n\n// Function: sort()\n// Synopsis: Returns a sorted list.\n// Topics: List Handling\n// See Also: shuffle(), sortidx(), unique(), unique_count(), group_sort()\n// Usage:\n//   slist = sort(list, [idx]);\n// Description:\n//   Sorts the given list in lexicographic order. The sort is stable, meaning equivalent items will not change order. \n//   If the input is a homogeneous simple list or a homogeneous \n//   list of vectors (see function is_homogeneous), the sorting method uses the native comparison operator and is faster. \n//   When sorting non homogeneous list the elements are compared with `compare_vals`, with types ordered according to\n//   `undef < boolean < number < string < list`.  Comparison of lists is recursive. \n//   When comparing vectors, homogeneous or not, the parameter `idx` may be used to select the components to compare.\n//   Note that homogeneous lists of vectors may contain mixed types provided that for any two list elements\n//   list[i] and list[j] satisfies  type(list[i][k])==type(list[j][k]) for all k. \n//   Strings are allowed as any list element and are compared with the native operators although no substring\n//   comparison is possible.  \n// Arguments:\n//   list = The list to sort.\n//   idx = If given, do the comparison based just on the specified index, range or list of indices.  \n// Example: \n//   // Homogeneous lists\n//   l1 = [45,2,16,37,8,3,9,23,89,12,34];\n//   sorted1 = sort(l1);  // Returns [2,3,8,9,12,16,23,34,37,45,89]\n//   l2 = [[\"oat\",0], [\"cat\",1], [\"bat\",3], [\"bat\",2], [\"fat\",3]];\n//   sorted2 = sort(l2); // Returns: [[\"bat\",2],[\"bat\",3],[\"cat\",1],[\"fat\",3],[\"oat\",0]]\n//   // Non-homegenous list\n//   l3 = [[4,0],[7],[3,9],20,[4],[3,1],[8]];\n//   sorted3 = sort(l3); // Returns: [20,[3,1],[3,9],[4],[4,0],[7],[8]]\nfunction sort(list, idx=undef) = \n    assert(is_list(list)||is_string(list), \"Invalid input.\" )\n    is_string(list)? str_join(sort([for (x = list) x],idx)) :\n    !is_list(list) || len(list)<=1 ? list :\n    is_homogeneous(list,1)\n    ?   let(size = list_shape(list[0]))\n        size==0 ?         _sort_scalars(list)\n        : len(size)!=1 ?  _sort_general(list,idx)  \n        : is_undef(idx) ? _sort_vectors(list)\n        : assert( _valid_idx(idx) , \"Invalid indices.\")\n          _sort_vectors(list,[for(i=idx) i])        \n    : _sort_general(list,idx);\n        \n\n// Function: sortidx()\n// Synopsis: Returns a list of sorted indices into a list.\n// Topics: List Handling\n// See Also: shuffle(), sort(), group_sort(), unique(), unique_count()\n// Usage:\n//   idxlist = sortidx(list, [idx]);\n// Description:\n//   Given a list, sort it as function `sort()`, and returns\n//   a list of indexes into the original list in that sorted order.\n//   The sort is stable, so equivalent items will not change order.  \n//   If you iterate the returned list in order, and use the list items\n//   to index into the original list, you will be iterating the original\n//   values in sorted order.\n// Arguments:\n//   list = The list to sort.\n//   idx = If given, do the comparison based just on the specified index, range or list of indices.  \n// Example:\n//   lst = [\"d\",\"b\",\"e\",\"c\"];\n//   idxs = sortidx(lst);  // Returns: [1,3,0,2]\n//   ordered = select(lst, idxs);   // Returns: [\"b\", \"c\", \"d\", \"e\"]\n// Example:\n//   lst = [\n//       [\"foo\", 88, [0,0,1], false],\n//       [\"bar\", 90, [0,1,0], true],\n//       [\"baz\", 89, [1,0,0], false],\n//       [\"qux\", 23, [1,1,1], true]\n//   ];\n//   idxs1 = sortidx(lst, idx=1); // Returns: [3,0,2,1]\n//   idxs2 = sortidx(lst, idx=0); // Returns: [1,2,0,3]\n//   idxs3 = sortidx(lst, idx=[1,3]); // Returns: [3,0,2,1]\nfunction sortidx(list, idx=undef) = \n    assert(is_list(list)||is_string(list), \"Invalid list.\" )\n    is_homogeneous(list,1)\n    ?   let( \n            size = list_shape(list[0]),\n            aug  = ! (size==0 || len(size)==1) ? 0 // for general sorting\n                   : [for(i=[0:len(list)-1]) concat(i,list[i])], // for scalar or vector sorting\n            lidx = size==0? [1] :                                // scalar sorting\n                   len(size)==1 \n                   ? is_undef(idx) ? [for(i=[0:len(list[0])-1]) i+1] // vector sorting\n                                   : [for(i=idx) i+1]                // vector sorting\n                   : 0   // just to signal\n            )\n        assert( ! ( size==0 && is_def(idx) ), \n                \"The specification of `idx` is incompatible with scalar sorting.\" ) \n        assert( _valid_idx(idx) , \"Invalid indices.\" ) \n        lidx!=0\n        ?   let( lsort = _sort_vectors(aug,lidx) )\n            [for(li=lsort) li[0] ]\n        :   _sort_general(list,idx,indexed=true)\n    : _sort_general(list,idx,indexed=true);\n\n\n\n\n// Function: group_sort()\n// Synopsis: Returns a sorted list of groups of values.\n// Topics: List Handling\n// See Also: group_data(), shuffle(), sort(), sortidx(), unique(), unique_count()\n// Usage:\n//   ulist = group_sort(list,[idx]);\n// Description:\n//   Given a list of numbers, sorts the list into a sequence of lists, where each list contains any repeated values.\n//   If there are no repeated values the output will be a list of singleton lists.  \n//   If you apply {{flatten()}} to the output, the result will be a simple sorted list.  \n//   .\n//   When the input is a list of lists, the sorting is done based on index `idx` of the entries in `list`.\n//   In this case, `list[i][idx]` must be a number for every `i`, and the entries in `list` are grouped\n//   together in the output if they match at index `idx`.  This function can be used to group together\n//   items that are tagged with the same index.  \n// Arguments:\n//   list = The list to sort.\n//   idx = If input is a list of lists, index to sort on.  Default: 0.  \n// Example:\n//   sorted = group_sort([5,2,8,3,1,3,8,7,5]);  // Returns: [[1],[2],[3,3],[5,5],[7],[8,8]]\n//   // Next example returns: [ [[2,\"b\"],[2,\"e\"]], [[3,\"d\"]], [[5,\"a\"],[5,\"c\"]] ]\n//   sorted2 = group_sort([[5,\"a\"],[2,\"b\"], [5,\"c\"], [3,\"d\"], [2,\"e\"] ], idx=0);  \nfunction group_sort(list, idx) = \n    assert(is_list(list), \"Input should be a list.\" )\n    assert(is_undef(idx) || (is_int(idx) && idx>=0) , \"Invalid index.\" )\n    len(list)<=1 ? [list] :\n    is_vector(list)? assert(is_undef(idx),\"Cannot give idx with a vector input\") _group_sort(list) :\n    let( idx = default(idx,0) )\n    assert( [for(entry=list) if(!is_list(entry) || len(entry)<idx || !is_num(entry[idx]) ) 1]==[],\n        \"Some entry of the list is a list shorter than `idx` or the indexed entry of it is not a number.\")\n    _group_sort_by_index(list,idx);\n        \n\n\n// Function: group_data()\n// Synopsis: Groups list data by integer group numbers.\n// Topics: List Handling\n// See Also: group_sort(), shuffle(), sort(), sortidx(), unique(), unique_count()\n// Usage:\n//   groupings = group_data(groups, values);\n// Description:\n//   Given a list of integer group numbers, and an equal-length list of values,\n//   returns a list of groups with the values sorted into the corresponding groups.\n//   Ie: if you have a groups index list of `[2,3,2]` and values of `[\"A\",\"B\",\"C\"]`, then\n//   the values `\"A\"` and `\"C\"` will be put in group 2, and `\"B\"` will be in group 3.\n//   Groups that have no values grouped into them will be an empty list.  So the\n//   above would return `[[], [], [\"A\",\"C\"], [\"B\"]]`\n// Arguments:\n//   groups = A list of integer group index numbers.\n//   values = A list of values to sort into groups.\n// Example:\n//   groups = group_data([1,2,0], [\"A\",\"B\",\"C\"]);  // Returns [[\"B\"],[\"C\"],[\"A\"]]\n// Example:\n//   groups = group_data([1,3,1], [\"A\",\"B\",\"C\"]);  // Returns [[],[\"A\",\"C\"],[],[\"B\"]]\nfunction group_data(groups, values) =\n    assert(all_integer(groups) && all_nonnegative(groups))\n    assert(is_list(values))\n    assert(len(groups)==len(values),\n           \"The groups and values arguments should be lists of matching length.\")\n    let( sorted = _group_sort_by_index([for(i=idx(groups))[groups[i],values[i]]],0) )\n    // retrieve values and insert []\n    [\n        for (i = idx(sorted))\n        let(\n            a  = i==0? 0 : sorted[i-1][0][0]+1,\n            g0 = sorted[i]\n        )\n        each [\n            for (j = [a:1:g0[0][0]-1]) [],\n            [for (g1 = g0) g1[1]]\n        ]\n    ];\n\n\n// Function: list_smallest()\n// Synopsis: Returns the `k` smallest values in the list, in arbitrary order.\n// Topics: List Handling\n// See Also: group_sort(), shuffle(), sort(), sortidx(), unique(), unique_count()\n// Usage:\n//   small = list_smallest(list, k)\n// Description:\n//   Returns a set of the k smallest items in list in arbitrary order.  The items must be\n//   mutually comparable with native OpenSCAD comparison operations.  You will get \"undefined operation\"\n//   errors if you provide invalid input. \n// Arguments:\n//   list = list to process\n//   k = number of items to return\nfunction list_smallest(list, k) =\n    assert(is_list(list))\n    assert(is_int(k) && k>=0, \"k must be nonnegative\")\n    let( \n        v       = list[rand_int(0,len(list)-1,1)[0]],\n        smaller = [for(li=list) if(li<v) li ],\n        equal   = [for(li=list) if(li==v) li ]\n    )\n    len(smaller)   == k ? smaller :\n    len(smaller)<k && len(smaller)+len(equal) >= k ? [ each smaller, for(i=[1:k-len(smaller)]) v ] :\n    len(smaller)   >  k ? list_smallest(smaller, k) :\n    let( bigger  = [for(li=list) if(li>v) li ] )\n    concat(smaller, equal, list_smallest(bigger, k-len(smaller) -len(equal)));\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-9", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: constants.scad\n//   Constants for directions (used with anchoring), and for specifying line termination for\n//   use with geometry.scad.  \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: Constants provided by the library\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n// a value that the user should never enter randomly;\n// result of `dd if=/dev/random bs=32 count=1 |base64` :\n_UNDEF=\"LRG+HX7dy89RyHvDlAKvb9Y04OTuaikpx205CTh8BSI\";\n\n// Section: General Constants\n\n// Constant: $slop\n// Synopsis: The slop amount to make printed items fit closely. `0.0` by default.\n// Topics: Constants\n// Description:\n//   A number of printers, particularly FDM/FFF printers, tend to be a bit sloppy in their printing.\n//   This has made it so that some parts won't fit together without adding a bit of extra slop space.\n//   That is what the `$slop` value is for.  The value for this will vary from printer to printer.\n//   By default, we use a value of 0.00 so that parts should fit exactly for resin and other precision\n//   printers.  This value is measured in millimeters.  When making your own parts, you should add\n//   `$slop` to both sides of a hole that another part is to fit snugly into. For a loose fit, add\n//   `2*$slop` to each side.  This should be done for both X and Y axes.  The Z axis will require a\n//   slop that depends on your layer height and bridging settings, and hole sizes.  We leave that as\n//   a more complicated exercise for the user.\n//   .\n//   Note that the slop value is accessed using the {{get_slop()}} function.  This function provides\n//   the default value of 0 if you have not set `$slop`. This approach makes it possible for you to\n//   set `$slop` in your programs without experiencing peculiar OpenSCAD issues having to do with multiple\n//   definitions of the variable.  If you write code that uses `$slop` be sure to reference it using {{get_slop()}}. \n// DefineHeader(NumList): Calibration\n// Calibration: To calibrate the `$slop` value for your printer, follow this procedure:\n//   Print the Slop Calibration part from the example below.\n//   Take the long block and orient it so the numbers are upright, facing you.\n//   Take the plug and orient it so that the arrow points down, facing you.\n//   Starting with the hole with the largest number in front of it, insert the small end of the plug into the hole.\n//   If you can insert and remove the small end of the plug from the hole without much force, then try again with the hole with the next smaller number.\n//   Repeat step 5 until you have found the hole with the smallest number that the plug fits into without much force.\n//   The correct hole should hold the plug when the long block is turned upside-down.\n//   The number in front of that hole will indicate the `$slop` value that is ideal for your printer.\n//   Remember to set that slop value in your scripts after you include the BOSL2 library:  ie: `$slop = 0.15;`\n// Example(3D,Med): Slop Calibration Part.\n//   min_slop = 0.00;\n//   slop_step = 0.05;\n//   holes = 8;\n//   holesize = [15,15,15];\n//   height = 20;\n//   gap = 5;\n//   l = holes * (holesize.x + gap) + gap;\n//   w = holesize.y + 2*gap;\n//   h = holesize.z + 5;\n//   diff(\"holes\")\n//   cuboid([l, w, h], anchor=BOT) {\n//     for (i=[0:holes-1]) {\n//       right((i-holes/2+0.5)*(holesize.x+gap)) {\n//         s = min_slop + slop_step * i;\n//         tag(\"holes\") {\n//           cuboid([holesize.x + 2*s, holesize.y + 2*s, h+0.2]);\n//           fwd(w/2-1) xrot(90) linear_extrude(1.1) {\n//             text(\n//               text=format_fixed(s,2),\n//               size=0.4*holesize.x,\n//               halign=\"center\",\n//               valign=\"center\"\n//             );\n//           }\n//         }\n//       }\n//     }\n//   }\n//   back(holesize.y*2.5) {\n//     difference() {\n//       union() {\n//         cuboid([holesize.x+10, holesize.y+10, 15], anchor=BOT);\n//         cuboid([holesize.x, holesize.y, 15+holesize.z], anchor=BOT);\n//       }\n//       up(3) fwd((holesize.y+10)/2) {\n//         prismoid([holesize.x/2,1], [0,1], h=holesize.y-6);\n//       }\n//     }\n//   }\n// Example(2D): Where to add `$slop` gaps.\n//   $slop = 0.2;\n//   difference() {\n//     square([20,12],center=true);\n//     back(3) square([10+2*$slop,11],center=true);\n//   }\n//   back(8) {\n//     rect([15,5],anchor=FWD);\n//     rect([10,8],anchor=BACK);\n//   }\n//   color(\"#000\") {\n//     arrow_path = [[5.1,6.1], [6.0,7.1], [8,7.1], [10.5,10]];\n//     xflip_copy()\n//       stroke(arrow_path, width=0.3, endcap1=\"arrow2\");\n//     xcopies(21) back(10.5) {\n//         back(1.8) text(\"$slop\", size=1.5, halign=\"center\");\n//         text(\"gap\", size=1.5, halign=\"center\");\n//     }\n//   }\n\n// Function: get_slop()\n// Synopsis: Returns the $slop value.\n// Topics: Slop\n// See Also: $slop\n// Usage:\n//    slop = get_slop();\n// Description:\n//    Returns the current $slop value, or the default value if the user did not set $slop.\n//    Always acess the `$slop` variable using this function.  \nfunction get_slop() = is_undef($slop) ? 0 : $slop;\n\n\n// Constant: INCH\n// Synopsis: A constant containing the  number of millimeters in an inch. `25.4`\n// Topics: Constants\n// Description:\n//   The number of millimeters in an inch.\n// Example(2D):\n//   square(2*INCH, center=true);\n// Example(3D):\n//   cube([4,3,2.5]*INCH, center=true);\nINCH = 25.4;\n\n\n// Constant: IDENT\n// Synopsis: A constant containing the 3D identity transformation matrix.\n// SynTags: Mat\n// Topics: Constants, Affine, Matrices, Transforms\n// See Also: ident()\n// Description: Identity transformation matrix for three-dimensional transforms.  Equal to `ident(4)`.  \nIDENT=ident(4);\n\n\n\n// Section: Directional Vectors\n//   Vectors useful for `rotate()`, `mirror()`, and `anchor` arguments for `cuboid()`, `cyl()`, etc.\n\n// Constant: LEFT\n// Synopsis: The left-wards (X-) direction vector constant `[-1,0,0]`.\n// Topics: Constants, Vectors\n// See Also: RIGHT, FRONT, BACK, UP, DOWN, CENTER\n// Description: Vector pointing left.  [-1,0,0]\n// Example(3D): Usage with `anchor`\n//   cuboid(20, anchor=LEFT);\nLEFT  = [-1,  0,  0];\n\n// Constant: RIGHT\n// Synopsis: The right-wards (X+) direction vector constant `[1,0,0]`.\n// Topics: Constants, Vectors\n// See Also: LEFT, FRONT, BACK, UP, DOWN, CENTER\n// Description: Vector pointing right.  [1,0,0]\n// Example(3D): Usage with `anchor`\n//   cuboid(20, anchor=RIGHT);\nRIGHT = [ 1,  0,  0];\n\n// Constant: FRONT\n// Aliases: FWD, FORWARD\n// Synopsis: The front-wards (Y-) direction vector constant `[0,-1,0]`.\n// Topics: Constants, Vectors\n// See Also: LEFT, RIGHT, BACK, UP, DOWN, CENTER\n// Description: Vector pointing forward.  [0,-1,0]\n// Example(3D): Usage with `anchor`\n//   cuboid(20, anchor=FRONT);\nFRONT = [ 0, -1,  0];\nFWD = FRONT;\nFORWARD = FRONT;\n\n// Constant: BACK\n// Synopsis: The backwards (Y+) direction vector constant `[0,1,0]`.\n// Topics: Constants, Vectors\n// See Also: LEFT, RIGHT, FRONT, UP, DOWN, CENTER\n// Description: Vector pointing back.  [0,1,0]\n// Example(3D): Usage with `anchor`\n//   cuboid(20, anchor=BACK);\nBACK  = [ 0,  1,  0];\n\n// Constant: BOTTOM\n// Aliases: BOT, DOWN\n// Synopsis: The down-wards (Z-) direction vector constant `[0,0,-1]`.\n// Topics: Constants, Vectors\n// See Also: LEFT, RIGHT, FRONT, BACK, UP, CENTER\n// Description: Vector pointing down.  [0,0,-1]\n// Example(3D): Usage with `anchor`\n//   cuboid(20, anchor=BOTTOM);\nBOTTOM  = [ 0,  0, -1];\nBOT = BOTTOM;\nDOWN = BOTTOM;\n\n// Constant: TOP\n// Aliases: UP\n// Synopsis: The top-wards (Z+) direction vector constant `[0,0,1]`.\n// Topics: Constants, Vectors\n// See Also: LEFT, RIGHT, FRONT, BACK, DOWN, CENTER\n// Description: Vector pointing up.  [0,0,1]\n// Example(3D): Usage with `anchor`\n//   cuboid(20, anchor=TOP);\nTOP = [ 0,  0,  1];\nUP = TOP;\n\n// Constant: CENTER\n// Aliases: CTR, CENTRE\n// Synopsis: The center vector constant `[0,0,0]`.\n// Topics: Constants, Vectors\n// See Also: LEFT, RIGHT, FRONT, BACK, UP, DOWN\n// Description: Zero vector.  Centered.  [0,0,0]\n// Example(3D): Usage with `anchor`\n//   cuboid(20, anchor=CENTER);\nCENTER = [ 0,  0,  0];  // Centered zero vector.\nCTR = CENTER;\nCENTRE = CENTER;\n\n\n// Section: Line specifiers\n//   Used by functions in geometry.scad for specifying whether two points\n//   are treated as an unbounded line, a ray with one endpoint, or a segment\n//   with two endpoints.  \n\n// Constant: SEGMENT\n// Synopsis: A constant for specifying a line segment in various geometry.scad functions.  `[true,true]`\n// Topics: Constants, Lines\n// See Also: RAY, LINE\n// Description: Treat a line as a segment.  [true, true]\n// Example: Usage with line_intersection:\n//    line1 = 10*[[9, 4], [5, 7]];\n//    line2 = 10*[[2, 3], [6, 5]];\n//    isect = line_intersection(line1, line2, SEGMENT, SEGMENT);\nSEGMENT = [true,true];\n\n\n// Constant: RAY\n// Synopsis: A constant for specifying a ray line in various geometry.scad functions.  `[true,false]`\n// Topics: Constants, Lines\n// See Also: SEGMENT, LINE\n// Description: Treat a line as a ray, based at the first point.  [true, false]\n// Example: Usage with line_intersection:\n//    line = [[-30,0],[30,30]];\n//    pt = [40,25];\n//    closest = line_closest_point(line,pt,RAY);\nRAY = [true, false];\n\n\n// Constant: LINE\n// Synopsis: A constant for specifying an unbounded line in various geometry.scad functions.  `[false,false]`\n// Topics: Constants, Lines\n// See Also: RAY, SEGMENT\n// Description: Treat a line as an unbounded line.  [false, false]\n// Example: Usage with line_intersection:\n//    line1 = 10*[[9, 4], [5, 7]];\n//    line2 = 10*[[2, 3], [6, 5]];\n//    isect = line_intersection(line1, line2, LINE, SEGMENT);\nLINE = [false, false];\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-10", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: coords.scad\n//   Coordinate transformations and coordinate system conversions.\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Math\n// FileSummary: Conversions between coordinate systems.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Coordinate Manipulation\n\n// Function: point2d()\n// Synopsis: Convert a vector to 2D. \n// Topics: Coordinates, Points\n// See Also: path2d(), point3d(), path3d()\n// Usage:\n//   pt = point2d(p, [fill]);\n// Description:\n//   Returns a 2D vector/point from a 2D or 3D vector.  If given a 3D point, removes the Z coordinate.\n// Arguments:\n//   p = The coordinates to force into a 2D vector/point.\n//   fill = Value to fill missing values in vector with.  Default: 0\nfunction point2d(p, fill=0) = assert(is_list(p)) [for (i=[0:1]) (p[i]==undef)? fill : p[i]];\n\n\n// Function: path2d()\n// Synopsis: Convert a path to 2D. \n// SynTags: Path\n// Topics: Coordinates, Points, Paths\n// See Also: point2d(), point3d(), path3d()\n// Usage:\n//   pts = path2d(points);\n// Description:\n//   Returns a list of 2D vectors/points from a list of 2D, 3D or higher dimensional vectors/points.\n//   Removes the extra coordinates from higher dimensional points.  The input must be a path, where\n//   every vector has the same length.\n// Arguments:\n//   points = A list of 2D or 3D points/vectors.\nfunction path2d(points) =\n    assert(is_path(points,dim=undef,fast=true),\"Input to path2d is not a path\")\n    let (result = points * concat(ident(2), repeat([0,0], len(points[0])-2)))\n    assert(is_def(result), \"Invalid input to path2d\")\n    result;\n\n\n// Function: point3d()\n// Synopsis: Convert a vector to 3D. \n// Topics: Coordinates, Points\n// See Also: path2d(), point2d(), path3d()\n// Usage:\n//   pt = point3d(p, [fill]);\n// Description:\n//   Returns a 3D vector/point from a 2D or 3D vector.\n// Arguments:\n//   p = The coordinates to force into a 3D vector/point.\n//   fill = Value to fill missing values in vector with.  Default: 0\nfunction point3d(p, fill=0) =\n    assert(is_list(p)) \n    [for (i=[0:2]) (p[i]==undef)? fill : p[i]];\n\n\n// Function: path3d()\n// Synopsis: Convert a path to 3D. \n// SynTags: Path\n// Topics: Coordinates, Points, Paths\n// See Also: point2d(), path2d(), point3d()\n// Usage:\n//   pts = path3d(points, [fill]);\n// Description:\n//   Returns a list of 3D vectors/points from a list of 2D or higher dimensional vectors/points\n//   by removing extra coordinates or adding the z coordinate.  \n// Arguments:\n//   points = A list of 2D, 3D or higher dimensional points/vectors.\n//   fill = Value to fill missing values in vectors with (in the 2D case).  Default: 0\nfunction path3d(points, fill=0) =\n    assert(is_num(fill))\n    assert(is_path(points, dim=undef, fast=true), \"Input to path3d is not a path\")\n    let (\n        change = len(points[0])-3,\n        M = change < 0? [[1,0,0],[0,1,0]] : \n            concat(ident(3), repeat([0,0,0],change)),\n        result = points*M\n    )\n    assert(is_def(result), \"Input to path3d is invalid\")\n    fill == 0 || change>=0 ? result : result + repeat([0,0,fill], len(result));\n\n\n// Function: point4d()\n// Synopsis: Convert a vector to 4d. \n// Topics: Coordinates, Points\n// See Also: point2d(), path2d(), point3d(), path3d(), path4d()\n// Usage:\n//   pt = point4d(p, [fill]);\n// Description:\n//   Returns a 4D vector/point from a 2D or 3D vector.\n// Arguments:\n//   p = The coordinates to force into a 4D vector/point.\n//   fill = Value to fill missing values in vector with.  Default: 0\nfunction point4d(p, fill=0) = assert(is_list(p))\n                              [for (i=[0:3]) (p[i]==undef)? fill : p[i]];\n\n\n// Function: path4d()\n// Synopsis: Convert a path to 4d.  \n// SynTags: Path\n// Topics: Coordinates, Points, Paths\n// See Also: point2d(), path2d(), point3d(), path3d(), point4d()\n// Usage:\n//   pt = path4d(points, [fill]);\n// Description:\n//   Returns a list of 4D vectors/points from a list of 2D or 3D vectors/points.\n// Arguments:\n//   points = A list of 2D or 3D points/vectors.\n//   fill = Value to fill missing values in vectors with.  Default: 0 \nfunction path4d(points, fill=0) = \n   assert(is_num(fill) || is_vector(fill))\n   assert(is_path(points, dim=undef, fast=true), \"Input to path4d is not a path\")\n   let (\n      change = len(points[0])-4,\n      M = change < 0 ? select(ident(4), 0, len(points[0])-1) :\n                       concat(ident(4), repeat([0,0,0,0],change)),\n      result = points*M\n   ) \n   assert(is_def(result), \"Input to path4d is invalid\")\n   fill == 0 || change >= 0 ? result :\n    let(\n      addition = is_list(fill) ? concat(0*points[0],fill) :\n                                 concat(0*points[0],repeat(fill,-change))\n    )\n    assert(len(addition) == 4, \"Fill is the wrong length\")\n    result + repeat(addition, len(result));\n\n\n\n// Section: Coordinate Systems\n\n// Function: polar_to_xy()\n// Synopsis: Convert 2D polar coordinates to cartesian coordinates. \n// SynTags: Path\n// Topics: Coordinates, Points, Paths\n// See Also: xy_to_polar(), xyz_to_cylindrical(), cylindrical_to_xyz(), xyz_to_spherical(), spherical_to_xyz()\n// Usage:\n//   pt = polar_to_xy(r, theta);\n//   pt = polar_to_xy([R, THETA]);\n//   pts = polar_to_xy([[R,THETA], [R,THETA], ...]);\n// Description:\n//   Called with two arguments, converts the `r` and `theta` 2D polar coordinate into an `[X,Y]` cartesian coordinate.\n//   Called with one `[R,THETA]` vector argument, converts the 2D polar coordinate into an `[X,Y]` cartesian coordinate.\n//   Called with a list of `[R,THETA]` vector arguments, converts each 2D polar coordinate into `[X,Y]` cartesian coordinates.\n//   Theta is the angle counter-clockwise of X+ on the XY plane.\n// Arguments:\n//   r = distance from the origin.\n//   theta = angle in degrees, counter-clockwise of X+.\n// Example:\n//   xy = polar_to_xy(20,45);    // Returns: ~[14.1421365, 14.1421365]\n//   xy = polar_to_xy(40,30);    // Returns: ~[34.6410162, 15]\n//   xy = polar_to_xy([40,30]);  // Returns: ~[34.6410162, 15]\n//   xy = polar_to_xy([[40,30],[20,120]]);  // Returns: ~[[34.6410162, 15], [-10, 17.3205]]\n// Example(2D):\n//   r=40; ang=30; $fn=36;\n//   pt = polar_to_xy(r,ang);\n//   stroke(circle(r=r), closed=true, width=0.5);\n//   color(\"black\") stroke([[r,0], [0,0], pt], width=0.5);\n//   color(\"black\") stroke(arc(r=15, angle=ang), width=0.5);\n//   color(\"red\") move(pt) circle(d=3);\nfunction polar_to_xy(r,theta) =\n    theta != undef\n      ? assert(is_num(r) && is_num(theta), \"Bad Arguments.\")\n        [r*cos(theta), r*sin(theta)]\n      : assert(is_list(r), \"Bad Arguments\")\n        is_num(r.x)\n          ? polar_to_xy(r.x, r.y)\n          : [for(p = r) polar_to_xy(p.x, p.y)];\n\n\n// Function: xy_to_polar()\n// Synopsis: Convert 2D cartesian coordinates to polar coordinates (radius and angle)\n// Topics: Coordinates, Points, Paths\n// See Also: polar_to_xy(), xyz_to_cylindrical(), cylindrical_to_xyz(), xyz_to_spherical(), spherical_to_xyz()\n// Usage:\n//   r_theta = xy_to_polar(x,y);\n//   r_theta = xy_to_polar([X,Y]);\n//   r_thetas = xy_to_polar([[X,Y], [X,Y], ...]);\n// Description:\n//   Called with two arguments, converts the `x` and `y` 2D cartesian coordinate into a `[RADIUS,THETA]` polar coordinate.\n//   Called with one `[X,Y]` vector argument, converts the 2D cartesian coordinate into a `[RADIUS,THETA]` polar coordinate.\n//   Called with a list of `[X,Y]` vector arguments, converts each 2D cartesian coordinate into `[RADIUS,THETA]` polar coordinates.\n//   Theta is the angle counter-clockwise of X+ on the XY plane.\n// Arguments:\n//   x = X coordinate.\n//   y = Y coordinate.\n// Example:\n//   plr = xy_to_polar(20,30);\n//   plr = xy_to_polar([40,60]);\n//   plrs = xy_to_polar([[40,60],[-10,20]]);\n// Example(2D):\n//   pt = [-20,30]; $fn = 36;\n//   rt = xy_to_polar(pt);\n//   r = rt[0]; ang = rt[1];\n//   stroke(circle(r=r), closed=true, width=0.5);\n//   zrot(ang) stroke([[0,0],[r,0]],width=0.5);\n//   color(\"red\") move(pt) circle(d=3);\nfunction xy_to_polar(x, y) =\n    y != undef\n      ? assert(is_num(x) && is_num(y), \"Bad Arguments.\")\n        [norm([x, y]), atan2(y, x)]\n      : assert(is_list(x), \"Bad Arguments\")\n        is_num(x.x)\n          ? xy_to_polar(x.x, x.y)\n          : [for(p = x) xy_to_polar(p.x, p.y)];\n\n\n// Function: project_plane()\n// Synopsis: Project a set of points onto a specified plane, returning 2D points.  \n// SynTags: Path\n// Topics: Coordinates, Points, Paths\n// See Also: lift_plane()\n// Usage: \n//   xy = project_plane(plane, p);\n// Usage: To get a transform matrix\n//   M = project_plane(plane)\n// Description:\n//   Maps the provided 3D point(s) from 3D coordinates to a 2D coordinate system defined by `plane`.  Points that are not\n//   on the specified plane will be projected orthogonally onto the plane.  This coordinate system is useful if you need\n//   to perform 2D operations on a coplanar set of data.  After those operations are done you can return the data\n//   to 3D with `lift_plane()`.  You could also use this to force approximately coplanar data to be exactly coplanar.\n//   The parameter p can be a point, path, region, bezier patch or VNF.\n//   The plane can be specified as\n//   - A list of three points.  The planar coordinate system will have [0,0] at plane[0], and plane[1] will lie on the Y+ axis.\n//   - A list of coplanar points that define a plane (not-collinear)\n//   - A plane definition `[A,B,C,D]` where `Ax+By+CZ=D`.  The closest point on that plane to the origin will map to the origin in the new coordinate system.\n//   .\n//   If you omit the point specification then `project_plane()` returns a rotation matrix that maps the specified plane to the XY plane.\n//   Note that if you apply this transformation to data lying on the plane it will produce 3D points with the Z coordinate of zero.\n// Arguments:\n//   plane = plane specification or point list defining the plane\n//   p = 3D point, path, region, VNF or bezier patch to project\n// Example:\n//   pt = [5,-5,5];\n//   a=[0,0,0];  b=[10,-10,0];  c=[10,0,10];\n//   xy = project_plane([a,b,c],pt);\n// Example(3D): The yellow points in 3D project onto the red points in 2D\n//   M = [[-1, 2, -1, -2], [-1, -3, 2, -1], [2, 3, 4, 53], [0, 0, 0, 1]];\n//   data = apply(M,path3d(circle(r=10, $fn=20)));\n//   move_copies(data) sphere(r=1);\n//   color(\"red\") move_copies(project_plane(data, data)) sphere(r=1);\n// Example:\n//   xyzpath = move([10,20,30], p=yrot(25, p=path3d(circle(d=100))));\n//   mat = project_plane(xyzpath);\n//   xypath = path2d(apply(mat, xyzpath));\n//   #stroke(xyzpath,closed=true);\n//   stroke(xypath,closed=true);\nfunction project_plane(plane,p) =\n      is_matrix(plane,3,3) && is_undef(p) ? // no data, 3 points given\n          assert(!is_collinear(plane),\"Points defining the plane must not be collinear\")\n          let(\n              v = plane[2]-plane[0],\n              y = unit(plane[1]-plane[0]),        // y axis goes to point b\n              x = unit(v-(v*y)*y)   // x axis \n          )            \n          frame_map(x,y) * move(-plane[0])\n    : is_vector(plane,4) && is_undef(p) ?            // no data, plane given in \"plane\"\n          assert(_valid_plane(plane), \"Plane is not valid\")\n          let(\n               n = point3d(plane),\n               cp = n * plane[3] / (n*n)\n          )\n          rot(from=n, to=UP) * move(-cp)\n    : is_path(plane,3) && is_undef(p) ?               // no data, generic point list plane\n          assert(len(plane)>=3, \"Need three points to define a plane\")\n          let(plane = plane_from_points(plane))\n          assert(is_def(plane), \"Point list is not coplanar\")\n          project_plane(plane)\n    : assert(is_def(p), str(\"Invalid plane specification: \",plane))\n      is_vnf(p) ? [project_plane(plane,p[0]), p[1]] \n    : is_list(p) && is_list(p[0]) && is_vector(p[0][0],3) ?  // bezier patch or region\n           [for(plist=p) project_plane(plane,plist)]\n    : assert(is_vector(p,3) || is_path(p,3),str(\"Data must be a 3D point, path, region, vnf or bezier patch\",p))\n      is_matrix(plane,3,3) ?\n          assert(!is_collinear(plane),\"Points defining the plane must not be collinear\")\n          let(\n              v = plane[2]-plane[0],\n              y = unit(plane[1]-plane[0]),        // y axis goes to point b\n              x = unit(v-(v*y)*y)  // x axis \n          ) move(-plane[0],p) * transpose([x,y])\n    : is_vector(p) ? point2d(apply(project_plane(plane),p))\n    : path2d(apply(project_plane(plane),p));\n\n\n\n// Function: lift_plane()\n// Synopsis: Map a list of 2D points onto a plane in 3D. \n// SynTags: Path\n// Topics: Coordinates, Points, Paths\n// See Also: project_plane()\n// Usage: \n//   xyz = lift_plane(plane, p);\n// Usage: to get transform matrix\n//   M =  lift_plane(plane);\n// Description:\n//   Converts the given 2D point on the plane to 3D coordinates of the specified plane.\n//   The parameter p can be a point, path, region, bezier patch or VNF.\n//   The plane can be specified as\n//   - A list of three points.  The planar coordinate system will have [0,0] at plane[0], and plane[1] will lie on the Y+ axis.\n//   - A list of coplanar points that define a plane (not-collinear)\n//   - A plane definition `[A,B,C,D]` where `Ax+By+CZ=D`.  The closest point on that plane to the origin will map to the origin in the new coordinate system.\n//   .\n//   If you do not supply `p` then you get a transformation matrix which operates in 3D, assuming that the Z coordinate of the points is zero.\n//   This matrix is a rotation, the inverse of the one produced by project_plane.\n// Arguments:\n//   plane = Plane specification or list of points to define a plane\n//   p = points, path, region, VNF, or bezier patch to transform. \nfunction lift_plane(plane, p) =\n      is_matrix(plane,3,3) && is_undef(p) ? // no data, 3 p given\n          let(\n              v = plane[2]-plane[0],\n              y = unit(plane[1]-plane[0]),        // y axis goes to point b\n              x = unit(v-(v*y)*y)   // x axis \n          )            \n          move(plane[0]) * frame_map(x,y,reverse=true)\n    : is_vector(plane,4) && is_undef(p) ?            // no data, plane given in \"plane\"\n          assert(_valid_plane(plane), \"Plane is not valid\")\n          let(\n               n = point3d(plane),\n               cp = n * plane[3] / (n*n)\n          )\n          move(cp) * rot(from=UP, to=n)\n    : is_path(plane,3) && is_undef(p) ?               // no data, generic point list plane\n          assert(len(plane)>=3, \"Need three p to define a plane\")\n          let(plane = plane_from_points(plane))\n          assert(is_def(plane), \"Point list is not coplanar\")\n          lift_plane(plane)\n    : is_vnf(p) ? [lift_plane(plane,p[0]), p[1]] \n    : is_list(p) && is_list(p[0]) && is_vector(p[0][0],3) ?  // bezier patch or region\n           [for(plist=p) lift_plane(plane,plist)]\n    : assert(is_vector(p,2) || is_path(p,2),\"Data must be a 2D point, path, region, vnf or bezier patch\")\n      is_matrix(plane,3,3) ?\n          let(\n              v = plane[2]-plane[0],\n              y = unit(plane[1]-plane[0]),        // y axis goes to point b\n              x = unit(v-(v*y)*y)  // x axis \n          ) move(plane[0],p * [x,y])\n    : apply(lift_plane(plane),is_vector(p) ? point3d(p) : path3d(p));\n\n\n// Function: cylindrical_to_xyz()\n// Synopsis: Convert cylindrical coordinates to cartesian coordinates. \n// SynTags: Path\n// Topics: Coordinates, Points, Paths\n// See Also: xyz_to_cylindrical(), xy_to_polar(), polar_to_xy(), xyz_to_spherical(), spherical_to_xyz()\n// Usage:\n//   pt = cylindrical_to_xyz(r, theta, z);\n//   pt = cylindrical_to_xyz([RADIUS,THETA,Z]);\n//   pts = cylindrical_to_xyz([[RADIUS,THETA,Z], [RADIUS,THETA,Z], ...]);\n// Description:\n//   Called with three arguments, converts the `r`, `theta`, and 'z' 3D cylindrical coordinate into an `[X,Y,Z]` cartesian coordinate.\n//   Called with one `[RADIUS,THETA,Z]` vector argument, converts the 3D cylindrical coordinate into an `[X,Y,Z]` cartesian coordinate.\n//   Called with a list of `[RADIUS,THETA,Z]` vector arguments, converts each 3D cylindrical coordinate into `[X,Y,Z]` cartesian coordinates.\n//   Theta is the angle counter-clockwise of X+ on the XY plane.  Z is height above the XY plane.\n// Arguments:\n//   r = distance from the Z axis.\n//   theta = angle in degrees, counter-clockwise of X+ on the XY plane.\n//   z = Height above XY plane.\n// Example:\n//   xyz = cylindrical_to_xyz(20,30,40);\n//   xyz = cylindrical_to_xyz([40,60,50]);\nfunction cylindrical_to_xyz(r,theta,z) =\n    theta != undef\n      ? assert(is_num(r) && is_num(theta) && is_num(z), \"Bad Arguments.\")\n        [r*cos(theta), r*sin(theta), z]\n      : assert(is_list(r), \"Bad Arguments\")\n        is_num(r.x)\n          ? cylindrical_to_xyz(r.x, r.y, r.z)\n          : [for(p = r) cylindrical_to_xyz(p.x, p.y, p.z)];\n\n\n// Function: xyz_to_cylindrical()\n// Synopsis: Convert 3D cartesian coordinates to cylindrical coordinates. \n// Topics: Coordinates, Points, Paths\n// See Also: cylindrical_to_xyz(), xy_to_polar(), polar_to_xy(), xyz_to_spherical(), spherical_to_xyz()\n// Usage:\n//   rtz = xyz_to_cylindrical(x,y,z);\n//   rtz = xyz_to_cylindrical([X,Y,Z]);\n//   rtzs = xyz_to_cylindrical([[X,Y,Z], [X,Y,Z], ...]);\n// Description:\n//   Called with three arguments, converts the `x`, `y`, and `z` 3D cartesian coordinate into a `[RADIUS,THETA,Z]` cylindrical coordinate.\n//   Called with one `[X,Y,Z]` vector argument, converts the 3D cartesian coordinate into a `[RADIUS,THETA,Z]` cylindrical coordinate.\n//   Called with a list of `[X,Y,Z]` vector arguments, converts each 3D cartesian coordinate into `[RADIUS,THETA,Z]` cylindrical coordinates.\n//   Theta is the angle counter-clockwise of X+ on the XY plane.  Z is height above the XY plane.\n// Arguments:\n//   x = X coordinate.\n//   y = Y coordinate.\n//   z = Z coordinate.\n// Example:\n//   cyl = xyz_to_cylindrical(20,30,40);\n//   cyl = xyz_to_cylindrical([40,50,70]);\n//   cyls = xyz_to_cylindrical([[40,50,70], [-10,15,-30]]);\nfunction xyz_to_cylindrical(x,y,z) =\n    y != undef\n      ? assert(is_num(x) && is_num(y) && is_num(z), \"Bad Arguments.\")\n        [norm([x,y]), atan2(y,x), z]\n      : assert(is_list(x), \"Bad Arguments\")\n        is_num(x.x)\n          ? xyz_to_cylindrical(x.x, x.y, x.z)\n          : [for(p = x) xyz_to_cylindrical(p.x, p.y, p.z)];\n\n\n// Function: spherical_to_xyz()\n// Synopsis: Convert spherical coordinates to 3D cartesian coordinates. \n// SynTags: Path\n// Topics: Coordinates, Points, Paths\n// See Also: cylindrical_to_xyz(), xyz_to_spherical(), xyz_to_cylindrical(), altaz_to_xyz(), xyz_to_altaz()\n// Usage:\n//   pt = spherical_to_xyz(r, theta, phi);\n//   pt = spherical_to_xyz([RADIUS,THETA,PHI]);\n//   pts = spherical_to_xyz([[RADIUS,THETA,PHI], [RADIUS,THETA,PHI], ...]);\n// Description:\n//   Called with three arguments, converts the `r`, `theta`, and 'phi' 3D spherical coordinate into an `[X,Y,Z]` cartesian coordinate.\n//   Called with one `[RADIUS,THETA,PHI]` vector argument, converts the 3D spherical coordinate into an `[X,Y,Z]` cartesian coordinate.\n//   Called with a list of `[RADIUS,THETA,PHI]` vector arguments, converts each 3D spherical coordinate into `[X,Y,Z]` cartesian coordinates.\n//   Theta is the angle counter-clockwise of X+ on the XY plane.  Phi is the angle down from the Z+ pole.\n// Arguments:\n//   r = distance from origin.\n//   theta = angle in degrees, counter-clockwise of X+ on the XY plane.\n//   phi = angle in degrees from the vertical Z+ axis.\n// Example:\n//   xyz = spherical_to_xyz(20,30,40);\n//   xyz = spherical_to_xyz([40,60,50]);\n//   xyzs = spherical_to_xyz([[40,60,50], [50,120,100]]);\nfunction spherical_to_xyz(r,theta,phi) =\n    theta != undef\n      ? assert(is_num(r) && is_num(theta) && is_num(phi), \"Bad Arguments.\")\n        r*[cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)]\n      : assert(is_list(r), \"Bad Arguments\")\n        is_num(r.x)\n          ? spherical_to_xyz(r.x, r.y, r.z)\n          : [for(p = r) spherical_to_xyz(p.x, p.y, p.z)];\n\n\n// Function: xyz_to_spherical()\n// Usage:\n//   r_theta_phi = xyz_to_spherical(x,y,z)\n//   r_theta_phi = xyz_to_spherical([X,Y,Z])\n//   r_theta_phis = xyz_to_spherical([[X,Y,Z], [X,Y,Z], ...])\n// Topics: Coordinates, Points, Paths\n// Synopsis: Convert 3D cartesian coordinates to spherical coordinates. \n// See Also: cylindrical_to_xyz(), spherical_to_xyz(), xyz_to_cylindrical(), altaz_to_xyz(), xyz_to_altaz()\n// Description:\n//   Called with three arguments, converts the `x`, `y`, and `z` 3D cartesian coordinate into a `[RADIUS,THETA,PHI]` spherical coordinate.\n//   Called with one `[X,Y,Z]` vector argument, converts the 3D cartesian coordinate into a `[RADIUS,THETA,PHI]` spherical coordinate.\n//   Called with a list of `[X,Y,Z]` vector arguments, converts each 3D cartesian coordinate into `[RADIUS,THETA,PHI]` spherical coordinates.\n//   Theta is the angle counter-clockwise of X+ on the XY plane.  Phi is the angle down from the Z+ pole.\n// Arguments:\n//   x = X coordinate.\n//   y = Y coordinate.\n//   z = Z coordinate.\n// Example:\n//   sph = xyz_to_spherical(20,30,40);\n//   sph = xyz_to_spherical([40,50,70]);\n//   sphs = xyz_to_spherical([[40,50,70], [25,-14,27]]);\nfunction xyz_to_spherical(x,y,z) =\n    y != undef\n      ? assert(is_num(x) && is_num(y) && is_num(z), \"Bad Arguments.\")\n        [norm([x,y,z]), atan2(y,x), atan2(norm([x,y]),z)]\n      : assert(is_list(x), \"Bad Arguments\")\n        is_num(x.x)\n          ? xyz_to_spherical(x.x, x.y, x.z)\n          : [for(p = x) xyz_to_spherical(p.x, p.y, p.z)];\n\n\n// Function: altaz_to_xyz()\n// Synopsis: Convert altitude/azimuth/range to 3D cartesian coordinates. \n// SynTags: Path\n// Topics: Coordinates, Points, Paths\n// See Also: cylindrical_to_xyz(), xyz_to_spherical(), spherical_to_xyz(), xyz_to_cylindrical(), xyz_to_altaz()\n// Usage:\n//   pt = altaz_to_xyz(alt, az, r);\n//   pt = altaz_to_xyz([ALT,AZ,R]);\n//   pts = altaz_to_xyz([[ALT,AZ,R], [ALT,AZ,R], ...]);\n// Description:\n//   Convert altitude/azimuth/range coordinates to 3D cartesian coordinates.\n//   Called with three arguments, converts the `alt`, `az`, and 'r' 3D altitude-azimuth coordinate into an `[X,Y,Z]` cartesian coordinate.\n//   Called with one `[ALTITUDE,AZIMUTH,RANGE]` vector argument, converts the 3D alt-az coordinate into an `[X,Y,Z]` cartesian coordinate.\n//   Called with a list of `[ALTITUDE,AZIMUTH,RANGE]` vector arguments, converts each 3D alt-az coordinate into `[X,Y,Z]` cartesian coordinates.\n//   Altitude is the angle above the XY plane, Azimuth is degrees clockwise of Y+ on the XY plane, and Range is the distance from the origin.\n// Arguments:\n//   alt = altitude angle in degrees above the XY plane.\n//   az = azimuth angle in degrees clockwise of Y+ on the XY plane.\n//   r = distance from origin.\n// Example:\n//   xyz = altaz_to_xyz(20,30,40);\n//   xyz = altaz_to_xyz([40,60,50]);\nfunction altaz_to_xyz(alt,az,r) =\n    az != undef\n      ? assert(is_num(alt) && is_num(az) && is_num(r), \"Bad Arguments.\")\n        r*[cos(90-az)*cos(alt), sin(90-az)*cos(alt), sin(alt)]\n      : assert(is_list(alt), \"Bad Arguments\")\n        is_num(alt.x)\n          ? altaz_to_xyz(alt.x, alt.y, alt.z)\n          : [for(p = alt) altaz_to_xyz(p.x, p.y, p.z)];\n\n\n\n// Function: xyz_to_altaz()\n// Synopsis: Convert 3D cartesian coordinates to [altitude,azimuth,range]. \n// Topics: Coordinates, Points, Paths\n// See Also: cylindrical_to_xyz(), xyz_to_spherical(), spherical_to_xyz(), xyz_to_cylindrical(), altaz_to_xyz()\n// Usage:\n//   alt_az_r = xyz_to_altaz(x,y,z);\n//   alt_az_r = xyz_to_altaz([X,Y,Z]);\n//   alt_az_rs = xyz_to_altaz([[X,Y,Z], [X,Y,Z], ...]);\n// Description:\n//   Converts 3D cartesian coordinates to altitude/azimuth/range coordinates.\n//   Called with three arguments, converts the `x`, `y`, and `z` 3D cartesian coordinate into an `[ALTITUDE,AZIMUTH,RANGE]` coordinate.\n//   Called with one `[X,Y,Z]` vector argument, converts the 3D cartesian coordinate into a `[ALTITUDE,AZIMUTH,RANGE]` coordinate.\n//   Called with a list of `[X,Y,Z]` vector arguments, converts each 3D cartesian coordinate into `[ALTITUDE,AZIMUTH,RANGE]` coordinates.\n//   Altitude is the angle above the XY plane, Azimuth is degrees clockwise of Y+ on the XY plane, and Range is the distance from the origin.\n// Arguments:\n//   x = X coordinate.\n//   y = Y coordinate.\n//   z = Z coordinate.\n// Example:\n//   aa = xyz_to_altaz(20,30,40);\n//   aa = xyz_to_altaz([40,50,70]);\nfunction xyz_to_altaz(x,y,z) =\n    y != undef\n      ? assert(is_num(x) && is_num(y) && is_num(z), \"Bad Arguments.\")\n        [atan2(z,norm([x,y])), atan2(x,y), norm([x,y,z])]\n      : assert(is_list(x), \"Bad Arguments\")\n        is_num(x.x)\n          ? xyz_to_altaz(x.x, x.y, x.z)\n          : [for(p = x) xyz_to_altaz(p.x, p.y, p.z)];\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-11", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////////\n// LibFile: cubetruss.scad\n//   Parts for making modular open-frame cross-braced trusses and connectors.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/cubetruss.scad>\n// FileGroup: Parts\n// FileSummary: Modular open-framed trusses and joiners.\n//////////////////////////////////////////////////////////////////////////\n\n$cubetruss_size = 30;\n$cubetruss_strut_size = 4;\n$cubetruss_bracing = true;\n$cubetruss_clip_thickness = 1.6;\n\n\n// Section: Cube Trusses\n\n// Module: cubetruss()\n// Synopsis: Creates a multi-cube straight cubetruss shape.\n// SynTags: Geom\n// Topics: Trusses, CubeTruss, FDM Optimized, Parts\n// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()\n// Usage:\n//   cubetruss(extents, [clips=], [bracing=], [size=], [strut=], [clipthick=], ...) [ATTACHMENTS];\n// Description:\n//   Creates a cubetruss truss, assembled out of one or more cubical segments.\n// Arguments:\n//   extents = The number of cubes in length to make the truss.  If given as a [X,Y,Z] vector, specifies the number of cubes in each dimension.\n//   clips = List of vectors pointing towards the sides to add clips to.\n//   bracing = If true, adds internal cross-braces.  Default: `$cubetruss_bracing` (usually true)\n//   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)\n//   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)\n//   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   cubetruss(extents=3);\n//   cubetruss(extents=3, clips=FRONT);\n//   cubetruss(extents=3, clips=[FRONT,BACK]);\n//   cubetruss(extents=[2,3]);\n//   cubetruss(extents=[1,4,2]);\n//   cubetruss(extents=[1,4,2], bracing=false);\nmodule cubetruss(extents=6, clips=[], bracing, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {\n    clips = is_vector(clips)? [clips] : clips;\n    size = is_undef(size)? $cubetruss_size : size;\n    strut = is_undef(strut)? $cubetruss_strut_size : strut;\n    bracing = is_undef(bracing)? $cubetruss_bracing : bracing;\n    clipthick = is_undef(clipthick)? $cubetruss_clip_thickness : clipthick;\n    extents = is_vector(extents)? point3d(extents,fill=1) : [1,extents,1];\n    w = extents[0];\n    l = extents[1];\n    h = extents[2];\n    s = [cubetruss_dist(w,1), cubetruss_dist(l,1), cubetruss_dist(h,1)];\n    attachable(anchor,spin,orient, size=s) {\n        union() {\n            for (zrow = [0:h-1]) {\n                up((zrow-(h-1)/2)*(size-strut)) {\n                    for (xcol = [0:w-1]) {\n                        right((xcol-(w-1)/2)*(size-strut)) {\n                            for (ycol = [0:l-1]) {\n                                back((ycol-(l-1)/2)*(size-strut)) {\n                                    cubetruss_segment(size=size, strut=strut, bracing=bracing);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (clipthick > 0) {\n                for (vec = clips) {\n                    exts = v_abs(rot(from=FWD, to=vec, p=extents));\n                    rot(from=FWD,to=vec) {\n                        for (zrow = [0:1:exts.z-1]) {\n                            up((zrow-(exts.z-1)/2)*(size-strut)) {\n                                fwd((exts.y*(size-strut)+strut)/2) {\n                                    cubetruss_clip(size=size, strut=strut, extents=exts.x, clipthick=clipthick);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: cubetruss_corner()\n// Synopsis: Creates a multi-cube corner cubetruss shape.\n// SynTags: Geom\n// Topics: Trusses, CubeTruss, FDM Optimized, Parts\n// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()\n// Usage:\n//   cubetruss_corner(h, extents, [bracing=], [size=], [strut=], [clipthick=]);\n// Description:\n//   Creates a corner cubetruss with extents jutting out in one or more directions.\n// Arguments:\n//   h = The number of cubes high to make the base and horizontal extents.\n//   extents = The number of cubes to extend beyond the corner.  If given as a vector of cube counts, gives the number of cubes to extend right, back, left, front, and up in order.  If the vector is shorter than length 5 the extra cube counts are taken to be zero.  \n//   bracing = If true, adds internal cross-braces.  Default: `$cubetruss_bracing` (usually true)\n//   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)\n//   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)\n//   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   cubetruss_corner(extents=2);\n//   cubetruss_corner(extents=2, h=2);\n//   cubetruss_corner(extents=[3,3,0,0,2]);\n//   cubetruss_corner(extents=[3,0,3,0,2]);\n//   cubetruss_corner(extents=[3,3,3,3,2]);\nmodule cubetruss_corner(h=1, extents=[1,1,0,0,1], bracing, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {\n    size = is_undef(size)? $cubetruss_size : size;\n    strut = is_undef(strut)? $cubetruss_strut_size : strut;\n    bracing = is_undef(bracing)? $cubetruss_bracing : bracing;\n    clipthick = is_undef(clipthick)? $cubetruss_clip_thickness : clipthick;\n    exts = is_vector(extents)? list_pad(extents,5,fill=0) : [extents, extents, 0, 0, extents];\n    dummy = assert(len(exts)==5, \"Input extents must be a scalar or vector with length 5 or less.\");\n    s = [cubetruss_dist(exts[0]+1+exts[2],1), cubetruss_dist(exts[1]+1+exts[3],1), cubetruss_dist(h+exts[4],1)];\n    offset = [cubetruss_dist(exts[0]-exts[2],0), cubetruss_dist(exts[1]-exts[3],0), cubetruss_dist(h+exts[4]-1,0)]/2;\n    attachable(anchor,spin,orient, size=s, offset=offset) {\n        union() {\n            for (zcol = [0:h-1]) {\n                up((size-strut)*zcol) {\n                    cubetruss_segment(size=size, strut=strut, bracing=bracing);\n                }\n            }\n            for (dir = [0:3]) {\n                if (exts[dir] != undef && exts[dir] > 0) {\n                    zrot(dir*90) {\n                        for (zcol = [0:h-1]) {\n                            up((size-strut+0.01)*zcol) {\n                                for (i = [1:exts[dir]]) {\n                                    right((size-strut+0.01)*i) cubetruss_segment(size=size, strut=strut, bracing=bracing);\n                                }\n                                if (clipthick > 0) {\n                                    right(exts[dir]*(size-strut)+size/2) {\n                                        zrot(90) cubetruss_clip(size=size, strut=strut, clipthick=clipthick);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (exts[4] != undef && exts[4] > 0) {\n                for (i = [1:exts[4]]) {\n                    up((size-strut+0.01)*(i+h-1)) cubetruss_segment(size=size, strut=strut, bracing=bracing);\n                }\n                if (clipthick > 0) {\n                    up((exts[4]+h-1)*(size-strut)+size/2) {\n                        xrot(-90) cubetruss_clip(size=size, strut=strut, clipthick=clipthick);\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: cubetruss_support()\n// Synopsis: Creates a cubetruss support structure shape.\n// SynTags: Geom\n// Topics: Trusses, CubeTruss, FDM Optimized, Parts\n// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()\n// Usage:\n//   cubetruss_support([size=], [strut=], [extents=]) [ATTACHMENTS];\n// Description:\n//   Creates a single cubetruss support.\n// Arguments:\n//   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)\n//   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)\n//   extents = If given as an integer, specifies the number of vertical segments for the support.  If given as a list of 3 integers, specifies the number of segments in the X, Y, and Z directions.  Default: 1.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example(VPT=[0,0,0],VPD=150):\n//   cubetruss_support();\n// Example(VPT=[0,0,0],VPD=200):\n//   cubetruss_support(extents=2);\n// Example(VPT=[0,0,0],VPD=250):\n//   cubetruss_support(extents=3);\n// Example(VPT=[0,0,0],VPD=350):\n//   cubetruss_support(extents=[2,2,3]);\n// Example(VPT=[0,0,0],VPD=150):\n//   cubetruss_support(strut=4);\n// Example(VPT=[0,0,0],VPD=260):\n//   cubetruss_support(extents=2) show_anchors();\nmodule cubetruss_support(size, strut, extents=1, anchor=CENTER, spin=0, orient=UP) {\n    extents = is_num(extents)? [1,1,extents] : extents;\n    size = is_undef(size)? $cubetruss_size : size;\n    strut = is_undef(strut)? $cubetruss_strut_size : strut;\n    check =\n      assert(is_int(extents.x) && extents.x > 0)\n      assert(is_int(extents.y) && extents.y > 0)\n      assert(is_int(extents.z) && extents.z > 0);\n    w = (size-strut) * extents.x + strut;\n    l = (size-strut) * extents.y + strut;\n    h = (size-strut) * extents.z + strut;\n    attachable(anchor,spin,orient, size=[w,l,h], size2=[l,0], shift=[0,l/2], axis=DOWN) {\n        xcopies(size-strut, n=extents.x) {\n            difference() {\n                half_of(BACK/extents.y + UP/extents.z, s=size*(max(extents)+1))\n                    cube([size,l,h], center=true);\n                half_of(BACK/extents.y + UP/extents.z, cp=strut, s=size*(max(extents)+1)) {\n                    ycopies(size-strut, n=extents.y) {\n                        zcopies(size-strut, n=extents.z) {\n                            cyl(h=size+1, d=size-2*strut, circum=true, realign=true, orient=RIGHT, $fn=8);\n                            cyl(h=size+1, d=size-2*strut, circum=true, realign=true, $fn=8);\n                            cube(size-2*strut, center=true);\n                        }\n                    }\n                }\n                zcopies(size-strut, n=extents.z) {\n                    cyl(h=extents.y*size+1, d=size-2*strut, circum=true, realign=true, orient=BACK, $fn=8);\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n\n// Section: Cubetruss Support\n\n// Module: cubetruss_foot()\n// Synopsis: Creates a foot that can connect two cubetrusses.\n// SynTags: Geom\n// Topics: Trusses, CubeTruss, FDM Optimized, Parts\n// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()\n// Usage:\n//   cubetruss_foot(w, [size=], [strut=], [clipthick=]) [ATTACHMENTS];\n// Description:\n//   Creates a foot that can be clipped onto the bottom of a truss for support.\n// Arguments:\n//   w = The number of cube segments to span between the clips.  Default: 1\n//   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)\n//   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)\n//   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)\n//   ---\n//   $slop = make fit looser to allow for printer overextrusion\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   cubetruss_foot(w=1);\n//   cubetruss_foot(w=3);\nmodule cubetruss_foot(w=1, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {\n    size = is_undef(size)? $cubetruss_size : size;\n    strut = is_undef(strut)? $cubetruss_strut_size : strut;\n    clipthick = is_undef(clipthick)? $cubetruss_clip_thickness : clipthick;\n    clipsize = 0.5;\n    wall_h = strut+clipthick*1.5;\n    cyld = (size-2*strut)/cos(180/8);\n    s = [w*(size-strut)+strut+2*clipthick, size-2*strut, strut+clipthick];\n    attachable(anchor,spin,orient, size=s, offset=[0,0,(strut-clipthick)/2]) {\n        down(clipthick) {\n            // Base\n            up(clipthick/2) {\n                cuboid([w*(size-strut)+strut+2*clipthick, size-2*strut, clipthick], chamfer=strut, edges=\"Z\");\n            }\n\n            // Walls\n            xcopies(w*(size-strut)+strut+clipthick) {\n                up(clipthick-0.01) {\n                    prismoid([clipthick, (size-4*strut)], [clipthick, size/3.5], h=wall_h, anchor=BOT);\n                }\n            }\n\n            // Horiz Wall Clips\n            up(clipthick+strut+get_slop()*2) {\n                xcopies(w*(size-strut)+strut) {\n                    prismoid([clipsize*2, size/3.5], [0.1, size/3.5], h=clipsize*3, anchor=BOT);\n                }\n            }\n\n            // Middle plugs\n            for (xcol = [0:w-1]) {\n                right((xcol-(w-1)/2)*(size-strut)) {\n                    difference() {\n                        // Start with octagon to fit sides.\n                        up(clipthick-0.01) {\n                            zrot(180/8) cylinder(h=strut, d1=cyld-4*get_slop(), d2=cyld-4*get_slop()-1, center=false, $fn=8);\n                        }\n\n                        // Bevel to fit.\n                        up(clipthick+strut) {\n                            ycopies(size-2*strut-4*get_slop()) {\n                                chamfer_edge_mask(l=size-strut, chamfer=strut*2/3, orient=RIGHT);\n                            }\n                        }\n\n                        // Cut out X for possible top mount.\n                        zrot_copies([-45, 45]) {\n                            cube([size*3, strut/sqrt(2)+2*get_slop(), size*3], center=true);\n                        }\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: cubetruss_joiner()\n// Synopsis: Creates a joiner that can connect two cubetrusses end-to-end.\n// SynTags: Geom\n// Topics: Trusses, CubeTruss, FDM Optimized, Parts\n// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()\n// Usage:\n//   cubetruss_joiner([w=], [vert=], [size=], [strut=], [clipthick=]) [ATTACHMENTS];\n// Description:\n//   Creates a part to join two cubetruss trusses end-to-end.\n// Arguments:\n//   w = The number of cube segments to span between the clips.  Default: 1\n//   vert = If true, add vertical risers to clip to the ends of the cubetruss trusses.  Default: true\n//   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)\n//   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)\n//   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)\n//   ---\n//   $slop = Make fit looser by this amount to allow for printer overextrusion\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   cubetruss_joiner(w=1, vert=false);\n//   cubetruss_joiner(w=1, vert=true);\n//   cubetruss_joiner(w=2, vert=true, anchor=BOT);\nmodule cubetruss_joiner(w=1, vert=true, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {\n    size = is_undef(size)? $cubetruss_size : size;\n    strut = is_undef(strut)? $cubetruss_strut_size : strut;\n    clipthick = is_undef(clipthick)? $cubetruss_clip_thickness : clipthick;\n    clipsize = 0.5;\n    s = [cubetruss_dist(w,1)+2*clipthick, cubetruss_dist(2,0)-0.1, strut+clipthick];\n    attachable(anchor,spin,orient, size=s, offset=[0,0,-(clipthick-strut)/2]) {\n        down(clipthick) {\n            // Base\n            cube([w*(size-strut)+strut+2*clipthick, size, clipthick], anchor=BOT);\n\n            xcopies(w*(size-strut)+strut+clipthick) {\n                cube([clipthick, size, clipthick+strut*3/4], anchor=BOT);\n            }\n\n            // Use feet\n            ycopies(size) {\n                cubetruss_foot(w=w, size=size, strut=strut, clipthick=clipthick, anchor=BOT);\n            }\n\n            if (vert) {\n                // Vert Walls\n                xcopies(w*(size-strut)+strut+clipthick) {\n                    up(clipthick-0.01) {\n                        prismoid([clipthick, size], [clipthick, 2*strut+2*clipthick], h=size*0.6, anchor=BOT);\n                    }\n                }\n\n                // Vert Wall Clips\n                up(size/2) {\n                    xflip_copy(offset=(w*(size-strut)+strut+0.02)/2) {\n                        yflip_copy(offset=strut+get_slop()/2) {\n                            yrot(-90) {\n                                back_half() {\n                                    prismoid([size/3.5, clipthick*2], [size/3.5-4*2*clipsize, 0.1], h=2*clipsize, anchor=BOT);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: cubetruss_uclip()\n// Synopsis: Creates a joiner that can connect two cubetrusses end-to-end.\n// SynTags: Geom\n// Topics: Trusses, CubeTruss, FDM Optimized, Parts\n// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()\n// Usage:\n//   cubetruss_uclip(dual, [size=], [strut=], [clipthick=]) [ATTACHMENTS];\n// Description:\n//   Creates a small clip that can snap around one or two adjacent struts.\n// Arguments:\n//   dual = If true, create a clip to clip around two adjacent struts.  If false, just fit around one strut.  Default: true\n//   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)\n//   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)\n//   clipthick = The thickness of the clips.  Default: `$cubetruss_clip_thickness` (usually 1.6)\n//   ---\n//   $slop = Make fit looser by this amount\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   cubetruss_uclip(dual=false);\n//   cubetruss_uclip(dual=true);\nmodule cubetruss_uclip(dual=true, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {\n    size = is_undef(size)? $cubetruss_size : size;\n    strut = is_undef(strut)? $cubetruss_strut_size : strut;\n    clipthick = is_undef(clipthick)? $cubetruss_clip_thickness : clipthick;\n    clipsize = 0.5;\n    s = [(dual?2:1)*strut+2*clipthick+get_slop(), strut+2*clipthick, size/3.5];\n    attachable(anchor,spin,orient, size=s) {\n        union() {\n            difference() {\n                cube(s, center=true);\n                back(clipthick) cube([(dual?2:1)*strut+get_slop(), strut+2*clipthick, size+1], center=true);\n            }\n            back((strut+get_slop())/2) {\n                xflip_copy(offset=(dual?1:0.5)*strut+get_slop()/2) {\n                    yrot(-90) {\n                        back_half() {\n                            prismoid([size/3.5, clipthick*1.87], [size/3.5, 0.1], h=clipsize, anchor=BOT);\n                        }\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n\n// Section: Cubetruss Primitives\n\n// Module: cubetruss_segment()\n// Synopsis: Creates a single cubetruss cube.\n// SynTags: Geom\n// Topics: Trusses, CubeTruss, FDM Optimized, Parts\n// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()\n// Usage:\n//   cubetruss_segment([size=], [strut=], [bracing=]);\n// Description:\n//   Creates a single cubetruss cube segment.\n// Arguments:\n//   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)\n//   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)\n//   bracing = If true, adds internal cross-braces.  Default: `$cubetruss_bracing` (usually true)\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   cubetruss_segment(bracing=false);\n//   cubetruss_segment(bracing=true);\n//   cubetruss_segment(strut=4);\n//   cubetruss_segment(size=40);\nmodule cubetruss_segment(size, strut, bracing, anchor=CENTER, spin=0, orient=UP) {\n    size = is_undef(size)? $cubetruss_size : size;\n    strut = is_undef(strut)? $cubetruss_strut_size : strut;\n    bracing = is_undef(bracing)? $cubetruss_bracing : bracing;\n    h = size;\n    crossthick = strut/sqrt(2);\n    voffset = 0.333;\n    attachable(anchor,spin,orient, size=[size,size,size]) {\n        render(convexity=10)\n        union() {\n            difference() {\n                // Start with a cube.\n                cube([size, size, h], center=true);\n\n                cube([size-strut*2, size-strut*2, h-strut*2+1], center=true);\n\n                // Hollow out octogons in X and Y axes.\n                zrot_copies([0,90]) {\n                    xrot(90) zrot(180/8) cylinder(h=max(h,size)+1, d=(min(h,size)-2*strut)/cos(180/8), center=true, $fn=8);\n                }\n\n                // Hollow out octogon vertically.\n                zrot(180/8) cylinder(h=max(h,size)+1, d=(min(h,size)-2*strut)/cos(180/8), center=true, $fn=8);\n            }\n\n            // Interior cross-supports\n            if (bracing) {\n                for (i = [-1,1]) {\n                    zrot(i*45) {\n                        difference() {\n                            cube([crossthick, (size-strut)*sqrt(2), h], center=true);\n                            up(i*voffset) {\n                                yscale(1.3) {\n                                    yrot(90) {\n                                        zrot(180/6) {\n                                            cylinder(h=crossthick+1, d=(min(h,size)-2*strut)/cos(180/6)-2*voffset, center=true, $fn=6);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: cubetruss_clip()\n// Synopsis: Creates a clip for the end of a cubetruss to snap-lock it to another cubetruss.\n// SynTags: Geom\n// Topics: Trusses, CubeTruss, FDM Optimized, Parts\n// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()\n// Usage:\n//   cubetruss_clip(extents, [size=], [strut=], [clipthick=]) [ATTACHMENTS];\n// Description:\n//   Creates a pair of clips to add onto the end of a truss.\n// Arguments:\n//   extents = How many cubes to separate the clips by.\n//   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)\n//   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)\n//   clipthick = The thickness of the clip.  Default: `$cubetruss_clip_thickness` (usually 1.6)\n//   ---\n//   $slop = allowance for printer overextrusion\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   cubetruss_clip(extents=2);\n//   cubetruss_clip(extents=1);\n//   cubetruss_clip(clipthick=2.5);\nmodule cubetruss_clip(extents=1, size, strut, clipthick, anchor=CENTER, spin=0, orient=UP) {\n    size = is_undef(size)? $cubetruss_size : size;\n    strut = is_undef(strut)? $cubetruss_strut_size : strut;\n    clipthick = is_undef(clipthick)? $cubetruss_clip_thickness : clipthick;\n    cliplen = strut * 2.6;\n    clipheight = min(size+strut, size/3+2*strut*2.6);\n    clipsize = 0.5;\n    s = [extents*(size-strut)+strut+2*clipthick, strut*2, clipheight-2*strut];\n    attachable(anchor,spin,orient, size=s) {\n        xflip_copy(offset=(extents*(size-strut)+strut)/2) {\n            difference() {\n                union() {\n                    difference() {\n                        right(clipthick/2-0.01) {\n                            back(strut) {\n                                difference() {\n                                    xrot(90) prismoid([clipthick, clipheight], [clipthick, clipheight-cliplen*2], h=cliplen);\n                                    right(clipthick/2) chamfer_edge_mask(l=clipheight+0.1, chamfer=clipthick);\n                                }\n                            }\n                        }\n                        fwd(strut*3/2) {\n                            cube([get_slop(), strut*3, size], center=true);\n                        }\n                    }\n                    right(get_slop()/2+0.01) {\n                        fwd(strut*1.25+get_slop()) {\n                            yrot(-90) prismoid([clipheight-cliplen*2, strut/2], [clipheight-cliplen*2-2*clipsize, strut/2], h=clipsize+0.01);\n                        }\n                    }\n                }\n                fwd(strut*1.6) {\n                    left(clipsize) {\n                        yscale(1.5) chamfer_edge_mask(l=size+1, chamfer=clipsize+clipthick/3);\n                    }\n                }\n                zcopies(clipheight-strut) cube([clipthick*3, cliplen*2, strut], center=true);\n                zcopies(clipheight-2*strut) right(clipthick) chamfer_edge_mask(l=cliplen*2, chamfer=clipthick, orient=BACK);\n            }\n        }\n        children();\n    }\n}\n\n\n// Function: cubetruss_dist()\n// Synopsis: Returns the length of a cubetruss truss.\n// Topics: Trusses, CubeTruss, FDM Optimized, Parts\n// See Also: cubetruss_segment(), cubetruss_support(), cubetruss(), cubetruss_corner()\n// Usage:\n//   length = cubetruss_dist(cubes, [gaps], [size=], [strut=]);\n// Description:\n//   Function to calculate the length of a cubetruss truss.\n// Arguments:\n//   cubes = The number of cubes along the truss's length.\n//   gaps = The number of extra strut widths to add in, corresponding to each time a truss butts up against another.\n//   size = The length of each side of the cubetruss cubes.  Default: `$cubetruss_size` (usually 30)\n//   strut = The width of the struts on the cubetruss cubes.  Default: `$cubetruss_strut_size` (usually 3)\nfunction cubetruss_dist(cubes=0, gaps=0, size, strut) =\n    let(\n        size = is_undef(size)? $cubetruss_size : size,\n        strut = is_undef(strut)? $cubetruss_strut_size : strut\n    ) cubes*(size-strut)+gaps*strut;\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-12", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: distributors.scad\n//   Functions and modules to distribute children or copies of children onto\n//   a line, a grid, or an arbitrary path.  The $idx mechanism means that\n//   the \"copies\" of children can vary.  Also includes shortcuts for mirroring.  \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: Copy or distribute objects onto a line, grid, or path.  Mirror shortcuts. \n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n// Section: Adaptive Children Using `$` Variables\n//   The distributor methods create multiple copies of their children and place them in various ways.  While many models \n//   require multiple identical copies of an object, this framework is more powerful than\n//   might be immediately obvious because of `$` variables.  The distributors set `$` variables that the children can use to change their\n//   behavior from one child to the next within a single distributor invocation.  This means the copies need not be identical.  \n//   The {{xcopies()}} module sets `$idx` to the index number of the copy, and in the examples below we use `$idx`, but the various\n//   distributors offer a variety of `$` variables that you can use in your children.  Check the \"Side Effects\" section for each module\n//   to learn what variables that module provides.\n//   .\n//   Two gotchas may lead to models that don't behave as expected.  While `if` statements work to control modules, you cannot\n//   use them to make variable assignments in your child object.  If you write a statement like \n//   ```\n//   if (condition) { c=\"red\";}\n//   else {c=\"green\";}\n//   ```\n//   then the `c` variable is set only in the scope of the `if` and `else` clauses and is not available later on when you actually\n//   try to use it.  Instead you must use the ternary operator and write:\n//   ```\n//   c = condition ? \"red\" : \"green\";\n//   ```\n//   The second complication is\n//   that in OpenSCAD version 2021.01 and earlier, assignments in children were executed before their parent.  This means \n//   that `$` variables like `$idx` are not available in assignments because the parent hasn't run to set them, so if you use them\n//   you will get a warning about an unknown variable.\n//   Two workarounds exist, neither of which are needed in newer versions of OpenSCAD.  The workarounds solve the problem because\n//   **modules** execute after their parent, so the `$` variables **are** available in modules.  You can put your assignments\n//   in a `let()` module, or you can wrap your child in a `union()`.  Both methods appear below.\n// Figure(2D,NoScales): This example shows how we can use `$idx` to produce **different** geometry at each index.\n//   xcopies(n=10, spacing=10)\n//     text(str($idx));\n// Continues:\n//   ```\n//   xcopies(n=10, spacing=10)\n//     text(str($idx));\n//   ```\n// Figure(2D,NoScales): Here the children are sometimes squares and sometimes circles as determined by the conditional `if` module. This use of `if` is OK because no variables are assigned.  \n//   xcopies(n=4, spacing=10)\n//     if($idx%2==0) circle(r=3,$fn=16);\n//     else rect(6);\n// Continues:\n//   ```\n//   xcopies(n=4, spacing=10)\n//     if($idx%2==0) circle(r=3,$fn=16);\n//     else rect(6);\n//   ```\n// Figure(2D,NoScales): Suppose we would like to color odd and even index copies differently.  In this example we compute the color for a given child from `$idx` using the ternary operator.  The `let()` module is a module that sets variables and makes them available to its children.  Note that multiple assignments in `let()` are separated by commas, not semicolons.  \n//   xcopies(n=6, spacing=10){\n//       let(c = $idx % 2 == 0 ? \"red\" : \"green\")\n//           color(c) rect(6);\n//   }\n// Continues:\n//   ```\n//   xcopies(n=6, spacing=10){\n//       let(c = $idx % 2 == 0 ? \"red\" : \"green\")\n//           color(c) rect(6);\n//   }\n//   ```\n// Figure(2D,NoScales):  This example shows how you can change the position of children adaptively.  If you want to avoid repeating your code for each case, this requires storing a transformation matrix in a variable and then applying it using `multmatrix()`.  We wrap our code in `union()` to ensure that it works in OpenSCAD 2021.01.  \n//   xcopies(n=5,spacing=10)\n//     union()\n//     {\n//       shiftback = $idx%2==0 ? back(10) : IDENT;\n//       spin = zrot(180*$idx/4);\n//       multmatrix(shiftback*spin) stroke([[-4,0],[4,0]],endcap2=\"arrow2\",width=3/4, color=\"red\");\n//     }\n// Continues:\n//   ```\n//   xcopies(n=5,spacing=10)\n//     union()\n//     {\n//       shiftback = $idx%2==0 ? back(10) : IDENT;\n//       spin = zrot(180*$idx/4);\n//       multmatrix(shiftback*spin) stroke([[-4,0],[4,0]],endcap2=\"arrow2\",width=3/4,color=\"red\");\n//     }\n//   ```\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Translating copies of all the children\n//////////////////////////////////////////////////////////////////////\n\n// Function&Module: move_copies()\n// Synopsis: Translates copies of all children.\n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Translation, Copiers\n// See Also: xcopies(), ycopies(), zcopies(), line_copies(), grid_copies(), rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies()\n//\n// Usage:\n//   move_copies(a) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = move_copies(a, p=);\n// Usage: Get Translation Matrices\n//   mats = move_copies(a);\n// Description:\n//   When called as a module, translates copies of all children to each given translation offset.\n//   When called as a function, with no `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   a = Array of XYZ offset vectors. Default `[[0,0,0]]`\n//   ---\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$pos` is set to the relative centerpoint of each child copy, and can be used to modify each child individually.\n//   `$idx` is set to the index number of each child being copied.\n//\n//\n// Example:\n//   #sphere(r=10);\n//   move_copies([[-25,-25,0], [25,-25,0], [0,0,50], [0,25,0]]) sphere(r=10);\nmodule move_copies(a=[[0,0,0]])\n{\n    req_children($children);\n    assert(is_list(a));\n    for ($idx = idx(a)) {\n        $pos = a[$idx];\n        assert(is_vector($pos),\"move_copies offsets should be a 2d or 3d vector.\");\n        translate($pos) children();\n    }\n}\n\nfunction move_copies(a=[[0,0,0]],p=_NO_ARG) =\n    assert(is_list(a))\n    let(\n        mats = [\n            for (pos = a)\n            assert(is_vector(pos),\"move_copies offsets should be a 2d or 3d vector.\")\n            translate(pos)\n        ]\n    )\n    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];\n\n\n// Function&Module: xcopies()\n// Synopsis: Places copies of children along the X axis. \n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Translation, Copiers\n// See Also: move_copies(), ycopies(), zcopies(), line_copies(), grid_copies(), rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies()\n//\n// Usage:\n//   xcopies(spacing, [n], [sp=]) CHILDREN;\n//   xcopies(l=, [n=], [sp=]) CHILDREN;\n//   xcopies(LIST) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = xcopies(spacing, [n], [sp=], p=);\n//   copies = xcopies(l=, [n=], [sp=], p=);\n//   copies = xcopies(LIST, p=);\n// Usage: Get Translation Matrices\n//   mats = xcopies(spacing, [n], [sp=]);\n//   mats = xcopies(l=, [n=], [sp=]);\n//   mats = xcopies(LIST);\n// Description:\n//   When called as a module, places `n` copies of the children along a line on the X axis.\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   spacing = Given a scalar, specifies a uniform spacing between copies. Given a list of scalars, each one gives a specific position along the line. (Default: 1.0)\n//   n = Number of copies to place. (Default: 2)\n//   ---\n//   l = If given, the length to place copies over.\n//   sp = If given as a point, copies will be placed on a line to the right of starting position `sp`.  If given as a scalar, copies will be placed on a line segment to the right of starting position `[sp,0,0]`.  If not given, copies will be placed along a line segment that is centered at [0,0,0].\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$pos` is set to the relative centerpoint of each child copy, and can be used to modify each child individually.\n//   `$idx` is set to the index number of each child being copied.\n//\n// Examples:\n//   xcopies(20) sphere(3);\n//   xcopies(20, n=3) sphere(3);\n//   xcopies(spacing=15, l=50) sphere(3);\n//   xcopies(n=4, l=30, sp=[0,10,0]) sphere(3);\n// Example:\n//   xcopies(10, n=3) {\n//       cube(size=[1,3,1],center=true);\n//       cube(size=[3,1,1],center=true);\n//   }\n// Example:\n//   xcopies([1,2,3,5,7]) sphere(d=1);\nmodule xcopies(spacing, n, l, sp)\n{\n    assert(is_undef(n) || num_defined([l,spacing])==1, \"When n is given must give exactly one of spacing or l\")\n    assert(is_def(n) || num_defined([l,spacing])>=1, \"When n is not given must give at least one of spacing or l\")  \n    req_children($children);\n    dir = RIGHT;\n    sp = is_finite(sp)? (sp*dir) : sp;\n    if (is_vector(spacing)) {\n        translate(default(sp,[0,0,0])) {\n            for (i = idx(spacing)) {\n                $idx = i;\n                $pos = spacing[i]*dir;\n                translate($pos) children();\n            }\n        }\n    } else {\n        line_copies(\n            l=u_mul(l,dir),\n            spacing=u_mul(spacing,dir),\n            n=n, p1=sp\n        ) children();\n    }\n}\n\n\nfunction xcopies(spacing, n, l, sp, p=_NO_ARG) =\n    assert(is_undef(n) || num_defined([l,spacing])==1, \"When n is given must give exactly one of spacing or l\")\n    assert(is_def(n) || num_defined([l,spacing])>=1, \"When n is not given must give at least one of spacing or l\")  \n    let(\n        dir = RIGHT,\n        sp = is_finite(sp)? (sp*dir) : sp,\n        mats = is_vector(spacing)\n          ? let(sp = default(sp,[0,0,0])) [for (n = spacing) translate(sp + n*dir)]\n          : line_copies(l=u_mul(l,dir), spacing=u_mul(spacing,dir), n=n, p1=sp)\n    )\n    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];\n\n\n// Function&Module: ycopies()\n// Synopsis: Places copies of children along the Y axis. \n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Translation, Copiers\n// See Also: move_copies(), xcopies(), zcopies(), line_copies(), grid_copies(), rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies()\n//\n// Usage:\n//   ycopies(spacing, [n], [sp=]) CHILDREN;\n//   ycopies(l=, [n=], [sp=]) CHILDREN;\n//   ycopies(LIST) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = ycopies(spacing, [n], [sp=], p=);\n//   copies = ycopies(l=, [n=], [sp=], p=);\n//   copies = ycopies(LIST, p=);\n// Usage: Get Translation Matrices\n//   mats = ycopies(spacing, [n], [sp=]);\n//   mats = ycopies(l=, [n=], [sp=]);\n//   mats = ycopies(LIST);\n// Description:\n//   When called as a module, places `n` copies of the children along a line on the Y axis.\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   spacing = Given a scalar, specifies a uniform spacing between copies. Given a list of scalars, each one gives a specific position along the line. (Default: 1.0)\n//   n = Number of copies to place on the line. (Default: 2)\n//   ---\n//   l = If given, the length to place copies over.\n//   sp = If given as a point, copies will be place on a line back from starting position `sp`.  If given as a scalar, copies will be placed on a line back from starting position `[0,sp,0]`.  If not given, copies will be placed along a line that is centered at [0,0,0].\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$pos` is set to the relative centerpoint of each child copy, and can be used to modify each child individually.\n//   `$idx` is set to the index number of each child being copied.\n//\n// Examples:\n//   ycopies(20) sphere(3);\n//   ycopies(20, n=3) sphere(3);\n//   ycopies(spacing=15, l=50) sphere(3);\n//   ycopies(n=4, l=30, sp=[10,0,0]) sphere(3);\n// Example:\n//   ycopies(10, n=3) {\n//       cube(size=[1,3,1],center=true);\n//       cube(size=[3,1,1],center=true);\n//   }\n// Example:\n//   ycopies([1,2,3,5,7]) sphere(d=1);\nmodule ycopies(spacing, n, l, sp)\n{\n    assert(is_undef(n) || num_defined([l,spacing])==1, \"When n is given must give exactly one of spacing or l\")\n    assert(is_def(n) || num_defined([l,spacing])>=1, \"When n is not given must give at least one of spacing or l\")  \n    req_children($children);  \n    dir = BACK;\n    sp = is_finite(sp)? (sp*dir) : sp;\n    if (is_vector(spacing)) {\n        translate(default(sp,[0,0,0])) {\n            for (i = idx(spacing)) {\n                $idx = i;\n                $pos = spacing[i]*dir;\n                translate($pos) children();\n            }\n        }\n    } else {\n        line_copies(\n            l=u_mul(l,dir),\n            spacing=u_mul(spacing,dir),\n            n=n, p1=sp\n        ) children();\n    }\n}\n\n\nfunction ycopies(spacing, n, l, sp, p=_NO_ARG) =\n    assert(is_undef(n) || num_defined([l,spacing])==1, \"When n is given must give exactly one of spacing or l\")\n    assert(is_def(n) || num_defined([l,spacing])>=1, \"When n is not given must give at least one of spacing or l\")  \n    let(\n        dir = BACK,\n        sp = is_finite(sp)? (sp*dir) : sp,\n        mats = is_vector(spacing)\n          ? let(sp = default(sp,[0,0,0])) [for (n = spacing) translate(sp + n*dir)]\n          : line_copies(l=u_mul(l,dir), spacing=u_mul(spacing,dir), n=n, p1=sp)\n    )\n    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];\n\n\n// Function&Module: zcopies()\n// Synopsis: Places copies of children along the Z axis. \n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Translation, Copiers\n// See Also: move_copies(), xcopies(), ycopies(), line_copies(), grid_copies(), rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies()\n//\n// Usage:\n//   zcopies(spacing, [n], [sp=]) CHILDREN;\n//   zcopies(l=, [n=], [sp=]) CHILDREN;\n//   zcopies(LIST) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = zcopies(spacing, [n], [sp=], p=);\n//   copies = zcopies(l=, [n=], [sp=], p=);\n//   copies = zcopies(LIST, p=);\n// Usage: Get Translation Matrices\n//   mats = zcopies(spacing, [n], [sp=]);\n//   mats = zcopies(l=, [n=], [sp=]);\n//   mats = zcopies(LIST);\n// Description:\n//   When called as a module, places `n` copies of the children along a line on the Z axis.\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   spacing = Given a scalar, specifies a uniform spacing between copies. Given a list of scalars, each one gives a specific position along the line. (Default: 1.0)\n//   n = Number of copies to place. (Default: 2)\n//   ---\n//   l = If given, the length to place copies over.\n//   sp = If given as a point, copies will be placed on a line up from starting position `sp`.  If given as a scalar, copies will be placed on a line up from starting position `[0,0,sp]`.  If not given, copies will be placed on a line that is centered at [0,0,0].\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$pos` is set to the relative centerpoint of each child copy, and can be used to modify each child individually.\n//   `$idx` is set to the index number of each child being copied.\n//\n// Examples:\n//   zcopies(20) sphere(3);\n//   zcopies(20, n=3) sphere(3);\n//   zcopies(spacing=15, l=50) sphere(3);\n//   zcopies(n=4, l=30, sp=[10,0,0]) sphere(3);\n// Example:\n//   zcopies(10, n=3) {\n//       cube(size=[1,3,1],center=true);\n//       cube(size=[3,1,1],center=true);\n//   }\n// Example: Cubic sphere packing\n//   s = 20;\n//   s2 = s * sin(45);\n//   zcopies(s2,n=8)\n//       grid_copies([s2,s2],n=8,stagger=($idx%2)? true : \"alt\")\n//          sphere(d=s);\n// Example: Hexagonal sphere packing\n//   s = 20;\n//   xyr = adj_ang_to_hyp(s/2,30);\n//   h = hyp_adj_to_opp(s,xyr);\n//   zcopies(h,n=8)\n//       back(($idx%2)*xyr*cos(60))\n//           grid_copies(s,n=[12,7],stagger=($idx%2)? \"alt\" : true)\n//               sphere(d=s);\n// Example:\n//   zcopies([1,2,3,5,7]) sphere(d=1);\nmodule zcopies(spacing, n, l, sp)\n{\n    assert(is_undef(n) || num_defined([l,spacing])==1, \"When n is given must give exactly one of spacing or l\")\n    assert(is_def(n) || num_defined([l,spacing])>=1, \"When n is not given must give at least one of spacing or l\")  \n    req_children($children);  \n    dir = UP;\n    sp = is_finite(sp)? (sp*dir) : sp;\n    if (is_vector(spacing)) {\n        translate(default(sp,[0,0,0])) {\n            for (i = idx(spacing)) {\n                $idx = i;\n                $pos = spacing[i]*dir;\n                translate($pos) children();\n            }\n        }\n    } else {\n        line_copies(\n            l=u_mul(l,dir),\n            spacing=u_mul(spacing,dir),\n            n=n, p1=sp\n        ) children();\n    }\n}\n\n\nfunction zcopies(spacing, n, l, sp, p=_NO_ARG) =\n    assert(is_undef(n) || num_defined([l,spacing])==1, \"When n is given must give exactly one of spacing or l\")\n    assert(is_def(n) || num_defined([l,spacing])>=1, \"When n is not given must give at least one of spacing or l\")  \n    let(\n        dir = UP,\n        sp = is_finite(sp)? (sp*dir) : sp,\n        mats = is_vector(spacing)\n          ? let(sp = default(sp,[0,0,0])) [for (n = spacing) translate(sp + n*dir)]\n          : line_copies(l=u_mul(l,dir), spacing=u_mul(spacing,dir), n=n, p1=sp)\n    )\n    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];\n\n\n\n// Function&Module: line_copies()\n// Synopsis: Places copies of children along an arbitrary line. \n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Translation, Copiers\n// See Also: move_copies(), xcopies(), ycopies(), zcopies(), rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies()\n//\n// Usage: Place `n` copies at a given spacing along the line\n//   line_copies(spacing, [n], [p1=]) CHILDREN;\n// Usage: Place as many copies as will fit at a given spacing\n//   line_copies(spacing, [l=], [p1=]) CHILDREN;\n// Usage: Place `n` copies along the length of the line\n//   line_copies([n=], [l=], [p1=]) CHILDREN;\n// Usage: Place `n` copies along the line from `p1` to `p2`\n//   line_copies([n=], [p1=], [p2=]) CHILDREN;\n// Usage: Place copies at the given spacing, centered along the line from `p1` to `p2`\n//   line_copies([spacing], [p1=], [p2=]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = line_copies([spacing], [n], [p1=], p=);\n//   copies = line_copies([spacing], [l=], [p1=], p=);\n//   copies = line_copies([n=], [l=], [p1=], p=);\n//   copies = line_copies([n=], [p1=], [p2=], p=);\n//   copies = line_copies([spacing], [p1=], [p2=], p=);\n// Usage: Get Translation Matrices\n//   mats = line_copies([spacing], [n], [p1=]);\n//   mats = line_copies([spacing], [l=], [p1=]);\n//   mats = line_copies([n=], [l=], [p1=]);\n//   mats = line_copies([n=], [p1=], [p2=]);\n//   mats = line_copies([spacing], [p1=], [p2=]);\n// Description:\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//   When called as a module, copies `children()` at one or more evenly spaced positions along a line.\n//   By default, the line will be centered at the origin, unless the starting point `p1` is given.\n//   The line will be pointed towards `RIGHT` (X+) unless otherwise given as a vector in `l`,\n//   `spacing`, or `p1`/`p2`.  The psotion of the copies is specified in one of several ways:\n//   .\n//   If You Know...                   | Then Use Something Like...\n//   -------------------------------- | --------------------------------\n//   Spacing distance, Count          | `line_copies(spacing=10, n=5) ...` or `line_copies(10, n=5) ...`\n//   Spacing vector, Count            | `line_copies(spacing=[10,5], n=5) ...` or `line_copies([10,5], n=5) ...`\n//   Spacing distance, Line length    | `line_copies(spacing=10, l=50) ...` or `line_copies(10, l=50) ...`\n//   Spacing distance, Line vector    | `line_copies(spacing=10, l=[50,30]) ...` or `line_copies(10, l=[50,30]) ...`\n//   Spacing vector, Line length      | `line_copies(spacing=[10,5], l=50) ...` or `line_copies([10,5], l=50) ...`\n//   Line length, Count               | `line_copies(l=50, n=5) ...`\n//   Line vector, Count               | `line_copies(l=[50,40], n=5) ...`\n//   Line endpoints, Count            | `line_copies(p1=[10,10], p2=[60,-10], n=5) ...`\n//   Line endpoints, Spacing distance | `line_copies(p1=[10,10], p2=[60,-10], spacing=10) ...`\n//\n// Arguments:\n//   spacing = Either the scalar spacing distance along the X+ direction, or the vector giving both the direction and spacing distance between each set of copies.\n//   n = Number of copies to distribute along the line. (Default: 2)\n//   ---\n//   l = Either the scalar length of the line, or a vector giving both the direction and length of the line.\n//   p1 = If given, specifies the starting point of the line.\n//   p2 = If given with `p1`, specifies the ending point of line, and indirectly calculates the line length.\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$pos` is set to the relative centerpoint of each child copy, and can be used to modify each child individually.\n//   `$idx` is set to the index number of each child being copied.\n//\n// Examples:\n//   line_copies(10) sphere(d=1.5);\n//   line_copies(10, n=5) sphere(d=3);\n//   line_copies([10,5], n=5) sphere(d=3);\n//   line_copies(spacing=10, n=6) sphere(d=3);\n//   line_copies(spacing=[10,5], n=6) sphere(d=3);\n//   line_copies(spacing=10, l=50) sphere(d=3);\n//   line_copies(spacing=10, l=[50,30]) sphere(d=3);\n//   line_copies(spacing=[10,5], l=50) sphere(d=3);\n//   line_copies(l=50, n=4) sphere(d=3);\n//   line_copies(l=[50,-30], n=4) sphere(d=3);\n// Example(FlatSpin,VPD=133):\n//   line_copies(p1=[0,0,0], p2=[5,5,20], n=6) cuboid([3,2,1]);\n// Example(FlatSpin,VPD=133):\n//   line_copies(p1=[0,0,0], p2=[5,5,20], spacing=6) cuboid([3,2,1]);\n// Example: All children are copied to each position\n//   line_copies(l=20, n=3) {\n//       cube(size=[1,3,1],center=true);\n//       cube(size=[3,1,1],center=true);\n//   }\n// Example(2D): The functional form of line_copies() returns a list of transform matrices.\n//   mats = line_copies([10,5],n=5);\n//   for (m = mats) multmatrix(m)  circle(d=3);\n// Example(2D): The functional form of line_copies() returns a list of points if given a point.\n//   pts = line_copies([10,5],n=5,p=[0,0,0]);\n//   move_copies(pts) circle(d=3);\n\nmodule line_of(spacing, n, l, p1, p2) {\n    deprecate(\"line_copies\");\n    line_copies(spacing, n, l, p1, p2) children();\n}\n\nmodule line_copies(spacing, n, l, p1, p2)\n{\n    req_children($children);\n    pts = line_copies(spacing=spacing, n=n, l=l, p1=p1, p2=p2, p=[0,0,0]);\n    for (i=idx(pts)) {\n        $idx = i;\n        $pos = pts[i];\n        translate($pos) children();\n    }\n}\n\nfunction line_copies(spacing, n, l, p1, p2, p=_NO_ARG) =\n    assert(is_undef(spacing) || is_finite(spacing) || is_vector(spacing))\n    assert(is_undef(n) || is_finite(n))\n    assert(is_undef(l) || is_finite(l) || is_vector(l))\n    assert(is_undef(p1) || is_vector(p1))\n    assert(is_undef(p2) || is_vector(p2))\n    assert(is_undef(p2) || is_def(p1), \"If p2 is given must also give p1\")\n    assert(is_undef(p2) || is_undef(l), \"Cannot give both p2 and l\")\n    assert(is_undef(n) || num_defined([l,spacing,p2])==1,\"If n is given then must give exactly one of 'l', 'spacing', or the 'p1'/'p2' pair\")\n    assert(is_def(n) || num_defined([l,spacing,p2])>=1,\"If n is given then must give at least one of 'l', 'spacing', or the 'p1'/'p2' pair\")    \n    let(\n        ll = is_def(l)? scalar_vec3(l, 0)\n           : is_def(spacing) && is_def(n)? (n-1) * scalar_vec3(spacing, 0)\n           : is_def(p1) && is_def(p2)? point3d(p2-p1)\n           : undef,\n        cnt = is_def(n)? n\n            : is_def(spacing) && is_def(ll) ? floor(norm(ll) / norm(scalar_vec3(spacing, 0)) + 1.000001)\n            : 2,\n        spc = cnt<=1? [0,0,0]\n            : is_undef(spacing) && is_def(ll)? ll/(cnt-1) \n            : is_num(spacing) && is_def(ll)? (ll/(cnt-1)) \n            : scalar_vec3(spacing, 0)\n    )\n    assert(!is_undef(cnt), \"Need two of `spacing`, 'l', 'n', or `p1`/`p2` arguments in `line_copies()`.\")\n    let( spos = !is_undef(p1)? point3d(p1) : -(cnt-1)/2 * spc )\n    [for (i=[0:1:cnt-1]) translate(i * spc + spos, p=p)];\n\n\n\n// Function&Module: grid_copies()\n// Synopsis: Places copies of children in an [X,Y] grid. \n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Translation, Copiers\n// See Also: move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies()\n//\n// Usage:\n//   grid_copies(spacing, size=, [stagger=], [scale=], [inside=]) CHILDREN;\n//   grid_copies(n=, size=, [stagger=], [scale=], [inside=]) CHILDREN;\n//   grid_copies(spacing, [n], [stagger=], [scale=], [inside=]) CHILDREN;\n//   grid_copies(n=, inside=, [stagger], [scale]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = grid_copies(spacing, size=, [stagger=], [scale=], [inside=], p=);\n//   copies = grid_copies(n=, size=, [stagger=], [scale=], [inside=], p=);\n//   copies = grid_copies(spacing, [n], [stagger=], [scale=], [inside=], p=);\n//   copies = grid_copies(n=, inside=, [stagger], [scale], p=);\n// Usage: Get Translation Matrices\n//   mats = grid_copies(spacing, size=, [stagger=], [scale=], [inside=]);\n//   mats = grid_copies(n=, size=, [stagger=], [scale=], [inside=]);\n//   mats = grid_copies(spacing, [n], [stagger=], [scale=], [inside=]);\n//   mats = grid_copies(n=, inside=, [stagger], [scale]);\n// Description:\n//   When called as a module, makes a square or hexagonal grid of copies of children, with an optional masking polygon or region.\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   spacing = Distance between copies in [X,Y] or scalar distance.\n//   n = How many columns and rows of copies to make.  Can be given as `[COLS,ROWS]`, or just as a scalar that specifies both.  If staggered, count both staggered and unstaggered columns and rows.  Default: 2 (3 if staggered)\n//   size = The [X,Y] size to spread the copies over.\n//   ---\n//   stagger = If true, make a staggered (hexagonal) grid.  If false, make square grid.  If `\"alt\"`, makes alternate staggered pattern.  Default: false\n//   inside = If given a list of polygon points, or a region, only creates copies whose center would be inside the polygon or region.  Polygon can be concave and/or self crossing.\n//   nonzero = If inside is set to a polygon with self-crossings then use the nonzero method for deciding if points are in the polygon.  Default: false\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$pos` is set to the relative centerpoint of each child copy, and can be used to modify each child individually.\n//   `$col` is set to the integer column number for each child.\n//   `$row` is set to the integer row number for each child.\n//\n// Examples:\n//   grid_copies(size=50, spacing=10) cylinder(d=10, h=1);\n//   grid_copies(size=50, spacing=[10,15]) cylinder(d=10, h=1);\n//   grid_copies(spacing=10, n=[13,7], stagger=true) cylinder(d=6, h=5);\n//   grid_copies(spacing=10, n=[13,7], stagger=\"alt\") cylinder(d=6, h=5);\n//   grid_copies(size=50, n=11, stagger=true) cylinder(d=5, h=1);\n//\n// Example:\n//   poly = [[-25,-25], [25,25], [-25,25], [25,-25]];\n//   grid_copies(spacing=5, stagger=true, inside=poly)\n//      zrot(180/6) cylinder(d=5, h=1, $fn=6);\n//   %polygon(poly);\n//\n// Example: Using `$row` and `$col`\n//   grid_copies(spacing=8, n=8)\n//       color(($row+$col)%2?\"black\":\"red\")\n//           cube([8,8,0.01], center=false);\n//\n// Example: Makes a grid of hexagon pillars whose tops are all angled to reflect light at [0,0,50], if they were shiny.\n//   hexregion = circle(r=50.01,$fn=6);\n//   grid_copies(spacing=10, stagger=true, inside=hexregion)\n//     union() {   // Needed for OpenSCAD 2021.01 as noted above\n//       ref_v = (unit([0,0,50]-point3d($pos)) + UP)/2;\n//       half_of(v=-ref_v, cp=[0,0,5])\n//           zrot(180/6)\n//               cylinder(h=20, d=10/cos(180/6)+0.01, $fn=6);\n//     }\n\nmodule grid2d(spacing, n, size, stagger=false, inside=undef, nonzero)\n{\n   deprecate(\"grid_copies\");\n   grid_copies(spacing, n, size, stagger, inside, nonzero) children();\n}   \n\nmodule grid_copies(spacing, n, size, stagger=false, inside=undef, nonzero)\n{\n    req_children($children);    \n    dummy = assert(in_list(stagger, [false, true, \"alt\"]));\n    bounds = is_undef(inside)? undef :\n        is_path(inside)? pointlist_bounds(inside) :\n        assert(is_region(inside))\n        pointlist_bounds(flatten(inside));\n    nonzero = is_path(inside) ? default(nonzero,false)\n            : assert(is_undef(nonzero), \"nonzero only allowed if inside is a polygon\")\n              false;\n    size = is_num(size)? [size, size] :\n        is_vector(size)? assert(len(size)==2) size :\n        bounds!=undef? [\n            for (i=[0:1]) 2*max(abs(bounds[0][i]),bounds[1][i])\n        ] : undef;\n    spacing = is_num(spacing)? (\n            stagger!=false? polar_to_xy(spacing,60) :\n            [spacing,spacing]\n        ) :\n        is_vector(spacing)? assert(len(spacing)==2) spacing :\n        size!=undef? (\n            is_num(n)? v_div(size,(n-1)*[1,1]) :\n            is_vector(n)? assert(len(n)==2) v_div(size,n-[1,1]) :\n            v_div(size,(stagger==false? [1,1] : [2,2]))\n        ) :\n        undef;\n    n = is_num(n)? [n,n] :\n        is_vector(n)? assert(len(n)==2) n :\n        size!=undef && spacing!=undef? v_floor(v_div(size,spacing))+[1,1] :\n        [2,2];\n    offset = v_mul(spacing, n-[1,1])/2;\n    if (stagger == false) {\n        for (row = [0:1:n.y-1]) {\n            for (col = [0:1:n.x-1]) {\n                pos = v_mul([col,row],spacing) - offset;\n                if (\n                    is_undef(inside) ||\n                    (is_path(inside) && point_in_polygon(pos, inside, nonzero=nonzero)>=0) ||\n                    (is_region(inside) && point_in_region(pos, inside)>=0)\n                ) {\n                    $col = col;\n                    $row = row;\n                    $pos = pos;\n                    translate(pos) children();\n                }\n            }\n        }\n    } else {\n        // stagger == true or stagger == \"alt\"\n        staggermod = (stagger == \"alt\")? 1 : 0;\n        cols1 = ceil(n.x/2);\n        cols2 = n.x - cols1;\n        for (row = [0:1:n.y-1]) {\n            rowcols = ((row%2) == staggermod)? cols1 : cols2;\n            if (rowcols > 0) {\n                for (col = [0:1:rowcols-1]) {\n                    rowdx = (row%2 != staggermod)? spacing.x : 0;\n                    pos = v_mul([2*col,row],spacing) + [rowdx,0] - offset;\n                    if (\n                        is_undef(inside) ||\n                        (is_path(inside) && point_in_polygon(pos, inside, nonzero=nonzero)>=0) ||\n                        (is_region(inside) && point_in_region(pos, inside)>=0)\n                    ) {\n                        $col = col * 2 + ((row%2!=staggermod)? 1 : 0);\n                        $row = row;\n                        $pos = pos;\n                        translate(pos) children();\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nfunction grid_copies(spacing, n, size, stagger=false, inside=undef, nonzero, p=_NO_ARG) =\n    let(\n        dummy = assert(in_list(stagger, [false, true, \"alt\"])),\n        bounds = is_undef(inside)? undef :\n            is_path(inside)? pointlist_bounds(inside) :\n            assert(is_region(inside))\n            pointlist_bounds(flatten(inside)),\n        nonzero = is_path(inside) ? default(nonzero,false)\n                : assert(is_undef(nonzero), \"nonzero only allowed if inside is a polygon\")\n                  false,\n        size = is_num(size)? [size, size] :\n            is_vector(size)? assert(len(size)==2) size :\n            bounds!=undef? [\n                for (i=[0:1]) 2*max(abs(bounds[0][i]),bounds[1][i])\n            ] : undef,\n        spacing = is_num(spacing)? (\n                stagger!=false? polar_to_xy(spacing,60) :\n                [spacing,spacing]\n            ) :\n            is_vector(spacing)? assert(len(spacing)==2) spacing :\n            size!=undef? (\n                is_num(n)? v_div(size,(n-1)*[1,1]) :\n                is_vector(n)? assert(len(n)==2) v_div(size,n-[1,1]) :\n                v_div(size,(stagger==false? [1,1] : [2,2]))\n            ) :\n            undef,\n        n = is_num(n)? [n,n] :\n            is_vector(n)? assert(len(n)==2) n :\n            size!=undef && spacing!=undef? v_floor(v_div(size,spacing))+[1,1] :\n            [2,2],\n        offset = v_mul(spacing, n-[1,1])/2,\n        mats = stagger == false\n          ? [\n                for (row = [0:1:n.y-1], col = [0:1:n.x-1])\n                let( pos = v_mul([col,row],spacing) - offset )\n                if (\n                    is_undef(inside) ||\n                    (is_path(inside) && point_in_polygon(pos, inside, nonzero=nonzero)>=0) ||\n                    (is_region(inside) && point_in_region(pos, inside)>=0)\n                )\n                translate(pos)\n            ]\n          : // stagger == true or stagger == \"alt\"\n            let(\n                staggermod = (stagger == \"alt\")? 1 : 0,\n                cols1 = ceil(n.x/2),\n                cols2 = n.x - cols1\n            )\n            [\n                for (row = [0:1:n.y-1])\n                let( rowcols = ((row%2) == staggermod)? cols1 : cols2 )\n                if (rowcols > 0)\n                for (col = [0:1:rowcols-1])\n                let(\n                    rowdx = (row%2 != staggermod)? spacing.x : 0,\n                    pos = v_mul([2*col,row],spacing) + [rowdx,0] - offset\n                )\n                if (\n                    is_undef(inside) ||\n                    (is_path(inside) && point_in_polygon(pos, inside, nonzero=nonzero)>=0) ||\n                    (is_region(inside) && point_in_region(pos, inside)>=0)\n                )\n                translate(pos)\n            ]\n    )\n    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Rotating copies of all children\n//////////////////////////////////////////////////////////////////////\n\n// Function&Module: rot_copies()\n// Synopsis: Rotates copies of children.\n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Rotation, Copiers\n// See Also: rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() \n//\n// Usage:\n//   rot_copies(rots, [cp=], [sa=], [delta=], [subrot=]) CHILDREN;\n//   rot_copies(rots, v, [cp=], [sa=], [delta=], [subrot=]) CHILDREN;\n//   rot_copies(n=, [v=], [cp=], [sa=], [delta=], [subrot=]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = rot_copies(rots, [cp=], [sa=], [delta=], [subrot=], p=);\n//   copies = rot_copies(rots, v, [cp=], [sa=], [delta=], [subrot=], p=);\n//   copies = rot_copies(n=, [v=], [cp=], [sa=], [delta=], [subrot=], p=);\n// Usage: Get Translation Matrices\n//   mats = rot_copies(rots, [cp=], [sa=], [delta=], [subrot=]);\n//   mats = rot_copies(rots, v, [cp=], [sa=], [delta=], [subrot=]);\n//   mats = rot_copies(n=, [v=], [cp=], [sa=], [delta=], [subrot=]);\n// Description:\n//   When called as a module:\n//   - Given a list of [X,Y,Z] rotation angles in `rots`, rotates copies of the children to each of those angles, regardless of axis of rotation.\n//   - Given a list of scalar angles in `rots`, rotates copies of the children to each of those angles around the axis of rotation.\n//   - If given a vector `v`, that becomes the axis of rotation.  Default axis of rotation is UP.\n//   - If given a count `n`, makes that many copies, rotated evenly around the axis.\n//   - If given an offset `delta`, translates each child by that amount before rotating them into place.  This makes rings.\n//   - If given a centerpoint `cp`, centers the ring around that centerpoint.\n//   - If `subrot` is true, each child will be rotated in place to keep the same size towards the center when making rings.\n//   - The first (unrotated) copy will be placed at the relative starting angle `sa`.\n//   .\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   rots = A list of [X,Y,Z] rotation angles in degrees.  If `v` is given, this will be a list of scalar angles in degrees to rotate around `v`.\n//   v = If given, this is the vector of the axis to rotate around.\n//   cp = Centerpoint to rotate around.  Default: `[0,0,0]`\n//   ---\n//   n = Optional number of evenly distributed copies, rotated around the axis.\n//   sa = Starting angle, in degrees.  For use with `n`.  Angle is in degrees counter-clockwise.  Default: 0\n//   delta = [X,Y,Z] amount to move away from cp before rotating.  Makes rings of copies.  Default: `[0,0,0]`\n//   subrot = If false, don't sub-rotate children as they are copied around the ring.  Only makes sense when used with `delta`.  Default: `true`\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$ang` is set to the rotation angle (or XYZ rotation triplet) of each child copy, and can be used to modify each child individually.\n//   `$idx` is set to the index value of each child copy.\n//   `$axis` is set to the axis to rotate around, if `rots` was given as a list of angles instead of a list of [X,Y,Z] rotation angles.\n//\n//\n// Example:\n//   #cylinder(h=20, r1=5, r2=0);\n//   rot_copies([[45,0,0],[0,45,90],[90,-45,270]]) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   rot_copies([45, 90, 135], v=DOWN+BACK)\n//       yrot(90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   rot_copies(n=6, v=DOWN+BACK)\n//       yrot(90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   rot_copies(n=6, v=DOWN+BACK, delta=[10,0,0])\n//       yrot(90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   rot_copies(n=6, v=UP+FWD, delta=[10,0,0], sa=45)\n//       yrot(90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   rot_copies(n=6, v=DOWN+BACK, delta=[20,0,0], subrot=false)\n//       yrot(90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);\nmodule rot_copies(rots=[], v, cp=[0,0,0], n, sa=0, offset=0, delta=[0,0,0], subrot=true)\n{\n    req_children($children);  \n    sang = sa + offset;\n    angs = !is_undef(n)?\n        (n<=0? [] : [for (i=[0:1:n-1]) i/n*360+sang]) :\n        rots==[]? [] :\n        assert(!is_string(rots), \"Argument rots must be an angle, a list of angles, or a range of angles.\")\n        assert(!is_undef(rots[0]), \"Argument rots must be an angle, a list of angles, or a range of angles.\")\n        [for (a=rots) a];\n    for ($idx = idx(angs)) {\n        $ang = angs[$idx];\n        $axis = v;\n        translate(cp) {\n            rotate(a=$ang, v=v) {\n                translate(delta) {\n                    rot(a=(subrot? sang : $ang), v=v, reverse=true) {\n                        translate(-cp) {\n                            children();\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\nfunction rot_copies(rots=[], v, cp=[0,0,0], n, sa=0, offset=0, delta=[0,0,0], subrot=true, p=_NO_ARG) =\n    let(\n        sang = sa + offset,\n        angs = !is_undef(n)?\n            (n<=0? [] : [for (i=[0:1:n-1]) i/n*360+sang]) :\n            rots==[]? [] :\n            assert(!is_string(rots), \"Argument rots must be an angle, a list of angles, or a range of angles.\")\n            assert(!is_undef(rots[0]), \"Argument rots must be an angle, a list of angles, or a range of angles.\")\n            [for (a=rots) a],\n        mats = [\n            for (ang = angs)\n            translate(cp) *\n                rot(a=ang, v=v) *\n                translate(delta) *\n                rot(a=(subrot? sang : ang), v=v, reverse=true) *\n                translate(-cp)\n        ]\n    )\n    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];\n\n\n// Function&Module: xrot_copies()\n// Synopsis: Rotates copies of children around the X axis.\n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Rotation, Copiers\n// See Also: rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() \n//\n// Usage:\n//   xrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=]) CHILDREN;\n//   xrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = xrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=], p=);\n//   copies = xrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=], p=);\n// Usage: Get Translation Matrices\n//   mats = xrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=]);\n//   mats = xrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=]);\n// Description:\n//   When called as a module:\n//   - Given an array of angles, rotates copies of the children to each of those angles around the X axis.\n//   - If given a count `n`, makes that many copies, rotated evenly around the X axis.\n//   - If given a radius `r` (or diameter `d`), distributes children around a ring of that size around the X axis.\n//   - If given a centerpoint `cp`, centers the rotation around that centerpoint.\n//   - If `subrot` is true, each child will be rotated in place to keep the same size towards the center when making rings.\n//   - The first (unrotated) copy will be placed at the relative starting angle `sa`.\n//   .\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   rots = Optional array of rotation angles, in degrees, to make copies at.\n//   cp = Centerpoint to rotate around.\n//   ---\n//   n = Optional number of evenly distributed copies to be rotated around the ring.\n//   sa = Starting angle, in degrees.  For use with `n`.  Angle is in degrees counter-clockwise from Y+, when facing the origin from X+.  First unrotated copy is placed at that angle.\n//   r = If given, makes a ring of child copies around the X axis, at the given radius.  Default: 0\n//   d = If given, makes a ring of child copies around the X axis, at the given diameter.\n//   subrot = If false, don't sub-rotate children as they are copied around the ring.\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$idx` is set to the index value of each child copy.\n//   `$ang` is set to the rotation angle of each child copy, and can be used to modify each child individually.\n//   `$axis` is set to the axis vector rotated around.\n//\n//\n// Example:\n//   xrot_copies([180, 270, 315])\n//       cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   xrot_copies(n=6)\n//       cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   xrot_copies(n=6, r=10)\n//       xrot(-90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) xrot(-90) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   xrot_copies(n=6, r=10, sa=45)\n//       xrot(-90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) xrot(-90) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   xrot_copies(n=6, r=20, subrot=false)\n//       xrot(-90) cylinder(h=20, r1=5, r2=0, center=true);\n//   color(\"red\",0.333) xrot(-90) cylinder(h=20, r1=5, r2=0, center=true);\nmodule xrot_copies(rots=[], cp=[0,0,0], n, sa=0, r, d, subrot=true)\n{\n    req_children($children);  \n    r = get_radius(r=r, d=d, dflt=0);\n    rot_copies(rots=rots, v=RIGHT, cp=cp, n=n, sa=sa, delta=[0, r, 0], subrot=subrot) children();\n}\n\n\nfunction xrot_copies(rots=[], cp=[0,0,0], n, sa=0, r, d, subrot=true, p=_NO_ARG) =\n    let( r = get_radius(r=r, d=d, dflt=0) )\n    rot_copies(rots=rots, v=RIGHT, cp=cp, n=n, sa=sa, delta=[0, r, 0], subrot=subrot, p=p);\n\n\n// Function&Module: yrot_copies()\n// Synopsis: Rotates copies of children around the Y axis.\n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Rotation, Copiers\n// See Also: rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() \n//\n// Usage:\n//   yrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=]) CHILDREN;\n//   yrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = yrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=], p=);\n//   copies = yrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=], p=);\n// Usage: Get Translation Matrices\n//   mats = yrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=]);\n//   mats = yrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=]);\n// Description:\n//   When called as a module:\n//   - Given an array of angles, rotates copies of the children to each of those angles around the Y axis.\n//   - If given a count `n`, makes that many copies, rotated evenly around the Y axis.\n//   - If given a radius `r` (or diameter `d`), distributes children around a ring of that size around the Y axis.\n//   - If given a centerpoint `cp`, centers the rotation around that centerpoint.\n//   - If `subrot` is true, each child will be rotated in place to keep the same size towards the center when making rings.\n//   - The first (unrotated) copy will be placed at the relative starting angle `sa`.\n//   .\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   rots = Optional array of rotation angles, in degrees, to make copies at.\n//   cp = Centerpoint to rotate around.\n//   ---\n//   n = Optional number of evenly distributed copies to be rotated around the ring.\n//   sa = Starting angle, in degrees.  For use with `n`.  Angle is in degrees counter-clockwise from X-, when facing the origin from Y+.\n//   r = If given, makes a ring of child copies around the Y axis, at the given radius.  Default: 0\n//   d = If given, makes a ring of child copies around the Y axis, at the given diameter.\n//   subrot = If false, don't sub-rotate children as they are copied around the ring.\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$idx` is set to the index value of each child copy.\n//   `$ang` is set to the rotation angle of each child copy, and can be used to modify each child individually.\n//   `$axis` is set to the axis vector rotated around.\n//\n//\n// Example:\n//   yrot_copies([180, 270, 315])\n//       cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   yrot_copies(n=6)\n//       cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   yrot_copies(n=6, r=10)\n//       yrot(-90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) yrot(-90) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   yrot_copies(n=6, r=10, sa=45)\n//       yrot(-90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) yrot(-90) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   yrot_copies(n=6, r=20, subrot=false)\n//       yrot(-90) cylinder(h=20, r1=5, r2=0, center=true);\n//   color(\"red\",0.333) yrot(-90) cylinder(h=20, r1=5, r2=0, center=true);\nmodule yrot_copies(rots=[], cp=[0,0,0], n, sa=0, r, d, subrot=true)\n{\n    req_children($children);\n    r = get_radius(r=r, d=d, dflt=0);\n    rot_copies(rots=rots, v=BACK, cp=cp, n=n, sa=sa, delta=[-r, 0, 0], subrot=subrot) children();\n}\n\n\nfunction yrot_copies(rots=[], cp=[0,0,0], n, sa=0, r, d, subrot=true, p=_NO_ARG) =\n    let( r = get_radius(r=r, d=d, dflt=0) )\n    rot_copies(rots=rots, v=BACK, cp=cp, n=n, sa=sa, delta=[-r, 0, 0], subrot=subrot, p=p);\n\n\n// Function&Module: zrot_copies()\n// Synopsis: Rotates copies of children around the Z axis.\n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Rotation, Copiers\n// See Also: rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), sphere_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() \n//\n// Usage:\n//   zrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=]) CHILDREN;\n//   zrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = zrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=], p=);\n//   copies = zrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=], p=);\n// Usage: Get Translation Matrices\n//   mats = zrot_copies(rots, [cp], [r=|d=], [sa=], [subrot=]);\n//   mats = zrot_copies(n=, [cp=], [r=|d=], [sa=], [subrot=]);\n//\n// Description:\n//   When called as a module:\n//   - Given an array of angles, rotates copies of the children to each of those angles around the Z axis.\n//   - If given a count `n`, makes that many copies, rotated evenly around the Z axis.\n//   - If given a radius `r` (or diameter `d`), distributes children around a ring of that size around the Z axis.\n//   - If given a centerpoint `cp`, centers the rotation around that centerpoint.\n//   - If `subrot` is true, each child will be rotated in place to keep the same size towards the center when making rings.\n//   - The first (unrotated) copy will be placed at the relative starting angle `sa`.\n//   .\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   rots = Optional array of rotation angles, in degrees, to make copies at.\n//   cp = Centerpoint to rotate around.  Default: [0,0,0]\n//   ---\n//   n = Optional number of evenly distributed copies to be rotated around the ring.\n//   sa = Starting angle, in degrees.  For use with `n`.  Angle is in degrees counter-clockwise from X+, when facing the origin from Z+.  Default: 0\n//   r = If given, makes a ring of child copies around the Z axis, at the given radius.  Default: 0\n//   d = If given, makes a ring of child copies around the Z axis, at the given diameter.\n//   subrot = If false, don't sub-rotate children as they are copied around the ring.  Default: true\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$idx` is set to the index value of each child copy.\n//   `$ang` is set to the rotation angle of each child copy, and can be used to modify each child individually.\n//   `$axis` is set to the axis vector rotated around.\n//\n//\n// Example:\n//   zrot_copies([180, 270, 315])\n//       yrot(90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   zrot_copies(n=6)\n//       yrot(90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   zrot_copies(n=6, r=10)\n//       yrot(90) cylinder(h=20, r1=5, r2=0);\n//   color(\"red\",0.333) yrot(90) cylinder(h=20, r1=5, r2=0);\n//\n// Example:\n//   zrot_copies(n=6, r=20, sa=45)\n//       yrot(90) cylinder(h=20, r1=5, r2=0, center=true);\n//   color(\"red\",0.333) yrot(90) cylinder(h=20, r1=5, r2=0, center=true);\n//\n// Example:\n//   zrot_copies(n=6, r=20, subrot=false)\n//       yrot(-90) cylinder(h=20, r1=5, r2=0, center=true);\n//   color(\"red\",0.333) yrot(-90) cylinder(h=20, r1=5, r2=0, center=true);\nmodule zrot_copies(rots=[], cp=[0,0,0], n, sa=0, r, d, subrot=true)\n{\n    r = get_radius(r=r, d=d, dflt=0);\n    rot_copies(rots=rots, v=UP, cp=cp, n=n, sa=sa, delta=[r, 0, 0], subrot=subrot) children();\n}\n\n\nfunction zrot_copies(rots=[], cp=[0,0,0], n, sa=0, r, d, subrot=true, p=_NO_ARG) =\n    let( r = get_radius(r=r, d=d, dflt=0) )\n    rot_copies(rots=rots, v=UP, cp=cp, n=n, sa=sa, delta=[r, 0, 0], subrot=subrot, p=p);\n\n\n// Function&Module: arc_copies()\n// Synopsis: Distributes duplicates of children along an arc.\n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Rotation, Copiers\n// See Also: rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), sphere_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() \n//\n// Usage:\n//   arc_copies(n, r|d=, [sa=], [ea=], [rot=]) CHILDREN;\n//   arc_copies(n, rx=|dx=, ry=|dy=, [sa=], [ea=], [rot=]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = arc_copies(n, r|d=, [sa=], [ea=], [rot=], p=);\n//   copies = arc_copies(n, rx=|dx=, ry=|dy=, [sa=], [ea=], [rot=], p=);\n// Usage: Get Translation Matrices\n//   mats = arc_copies(n, r|d=, [sa=], [ea=], [rot=]);\n//   mats = arc_copies(n, rx=|dx=, ry=|dy=, [sa=], [ea=], [rot=]);\n//\n//\n// Description:\n//   When called as a module, evenly distributes n duplicate children around an ovoid arc on the XY plane.\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   n = number of copies to distribute around the circle. (Default: 6)\n//   r = radius of circle (Default: 1)\n//   ---\n//   rx = radius of ellipse on X axis. Used instead of r.\n//   ry = radius of ellipse on Y axis. Used instead of r.\n//   d = diameter of circle. (Default: 2)\n//   dx = diameter of ellipse on X axis. Used instead of d.\n//   dy = diameter of ellipse on Y axis. Used instead of d.\n//   rot = whether to rotate the copied children.  (Default: true)\n//   sa = starting angle. (Default: 0.0)\n//   ea = ending angle. Will distribute copies CCW from sa to ea. (Default: 360.0)\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$ang` is set to the rotation angle of each child copy, and can be used to modify each child individually.\n//   `$pos` is set to the relative centerpoint of each child copy, and can be used to modify each child individually.\n//   `$idx` is set to the index value of each child copy.\n//\n//\n// Example:\n//   #cube(size=[10,3,3],center=true);\n//   arc_copies(d=40, n=5) cube(size=[10,3,3],center=true);\n//\n// Example:\n//   #cube(size=[10,3,3],center=true);\n//   arc_copies(d=40, n=5, sa=45, ea=225) cube(size=[10,3,3],center=true);\n//\n// Example:\n//   #cube(size=[10,3,3],center=true);\n//   arc_copies(r=15, n=8, rot=false) cube(size=[10,3,3],center=true);\n//\n// Example:\n//   #cube(size=[10,3,3],center=true);\n//   arc_copies(rx=20, ry=10, n=8) cube(size=[10,3,3],center=true);\n// Example(2D): Using `$idx` to alternate shapes\n//   arc_copies(r=50, n=19, sa=0, ea=180)\n//       if ($idx % 2 == 0) rect(6);\n//       else circle(d=6);\n\nmodule arc_of(n=6,r,rx,ry,d,dx,dy,sa=0,ea=360,rot=true){\n    deprecate(\"arc_copies\");\n    arc_copies(n,r,rx,ry,d,dx,dy,sa,ea,rot) children();\n}    \n\n\nmodule arc_copies(\n    n=6,\n    r=undef,\n    rx=undef, ry=undef,\n    d=undef, dx=undef, dy=undef,\n    sa=0, ea=360,\n    rot=true\n) {\n    req_children($children);  \n    rx = get_radius(r1=rx, r=r, d1=dx, d=d, dflt=1);\n    ry = get_radius(r1=ry, r=r, d1=dy, d=d, dflt=1);\n    sa = posmod(sa, 360);\n    ea = posmod(ea, 360);\n    n = (abs(ea-sa)<0.01)?(n+1):n;\n    delt = (((ea<=sa)?360.0:0)+ea-sa)/(n-1);\n    for ($idx = [0:1:n-1]) {\n        $ang = sa + ($idx * delt);\n        $pos =[rx*cos($ang), ry*sin($ang), 0];\n        translate($pos) {\n            zrot(rot? atan2(ry*sin($ang), rx*cos($ang)) : 0) {\n                children();\n            }\n        }\n    }\n}\n\n\nfunction arc_copies(\n    n=6,\n    r=undef,\n    rx=undef, ry=undef,\n    d=undef, dx=undef, dy=undef,\n    sa=0, ea=360,\n    rot=true,\n    p=_NO_ARG\n) =\n    let(\n        rx = get_radius(r1=rx, r=r, d1=dx, d=d, dflt=1),\n        ry = get_radius(r1=ry, r=r, d1=dy, d=d, dflt=1),\n        sa = posmod(sa, 360),\n        ea = posmod(ea, 360),\n        n = (abs(ea-sa)<0.01)?(n+1):n,\n        delt = (((ea<=sa)?360.0:0)+ea-sa)/(n-1),\n        mats = [\n            for (i = [0:1:n-1])\n            let(\n                ang = sa + (i * delt),\n                pos =[rx*cos(ang), ry*sin(ang), 0],\n                ang2 = rot? atan2(ry*sin(ang), rx*cos(ang)) : 0\n            )\n            translate(pos) * zrot(ang2)\n        ]\n    )\n    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];\n\n\n\n// Function&Module: sphere_copies()\n// Synopsis: Distributes copies of children over the surface of a sphere. \n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Rotation, Copiers\n// See Also: rot_copies(), xrot_copies(), yrot_copies(), zrot_copies(), arc_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() \n//\n// Usage:\n//   sphere_copies(n, r|d=, [cone_ang=], [scale=], [perp=]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = sphere_copies(n, r|d=, [cone_ang=], [scale=], [perp=], p=);\n// Usage: Get Translation Matrices\n//   mats = sphere_copies(n, r|d=, [cone_ang=], [scale=], [perp=]);\n//\n// Description:\n//   When called as a module, spreads children semi-evenly over the surface of a sphere or ellipsoid.\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   n = How many copies to evenly spread over the surface.\n//   r = Radius of the sphere to distribute over\n//   ---\n//   d = Diameter of the sphere to distribute over\n//   cone_ang = Angle of the cone, in degrees, to limit how much of the sphere gets covered.  For full sphere coverage, use 180.  Measured pre-scaling.  Default: 180\n//   scale = The [X,Y,Z] scaling factors to reshape the sphere being covered.\n//   perp = If true, rotate children to be perpendicular to the sphere surface.  Default: true\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$pos` is set to the relative post-scaled centerpoint of each child copy, and can be used to modify each child individually.\n//   `$theta` is set to the theta angle of the child from the center of the sphere.\n//   `$phi` is set to the pre-scaled phi angle of the child from the center of the sphere.\n//   `$rad` is set to the pre-scaled radial distance of the child from the center of the sphere.\n//   `$idx` is set to the index number of each child being copied.\n//\n//\n// Example:\n//   sphere_copies(n=250, d=100, cone_ang=45, scale=[3,3,1])\n//       cylinder(d=10, h=10, center=false);\n//\n// Example:\n//   sphere_copies(n=500, d=100, cone_ang=180)\n//       color(unit(point3d(v_abs($pos))))\n//           cylinder(d=8, h=10, center=false);\n\nmodule ovoid_spread(n=100, r=undef, d=undef, cone_ang=90, scale=[1,1,1], perp=true)\n{\n  deprecate(\"sphere_copies\");\n  sphere_copies(n,r,d,cone_ang,scale,perp) children();\n}  \n\n\nmodule sphere_copies(n=100, r=undef, d=undef, cone_ang=90, scale=[1,1,1], perp=true)\n{\n    req_children($children);  \n    r = get_radius(r=r, d=d, dflt=50);\n    cnt = ceil(n / (cone_ang/180));\n\n    // Calculate an array of [theta,phi] angles for `n` number of\n    // points, almost evenly spaced across the surface of a sphere.\n    // This approximation is based on the golden spiral method.\n    theta_phis = [for (x=[0:1:n-1]) [180*(1+sqrt(5))*(x+0.5)%360, acos(1-2*(x+0.5)/cnt)]];\n\n    for ($idx = idx(theta_phis)) {\n        tp = theta_phis[$idx];\n        xyz = spherical_to_xyz(r, tp[0], tp[1]);\n        $pos = v_mul(xyz,point3d(scale,1));\n        $theta = tp[0];\n        $phi = tp[1];\n        $rad = r;\n        translate($pos) {\n            if (perp) {\n                rot(from=UP, to=xyz) children();\n            } else {\n                children();\n            }\n        }\n    }\n}\n\n\nfunction sphere_copies(n=100, r=undef, d=undef, cone_ang=90, scale=[1,1,1], perp=true, p=_NO_ARG) =\n    let(\n        r = get_radius(r=r, d=d, dflt=50),\n        cnt = ceil(n / (cone_ang/180)),\n\n        // Calculate an array of [theta,phi] angles for `n` number of\n        // points, almost evenly spaced across the surface of a sphere.\n        // This approximation is based on the golden spiral method.\n        theta_phis = [for (x=[0:1:n-1]) [180*(1+sqrt(5))*(x+0.5)%360, acos(1-2*(x+0.5)/cnt)]],\n\n        mats = [\n            for (tp = theta_phis)\n            let(\n                xyz = spherical_to_xyz(r, tp[0], tp[1]),\n                pos = v_mul(xyz,point3d(scale,1))\n            )\n            translate(pos) *\n            (perp? rot(from=UP, to=xyz) : ident(4))\n        ]\n    )\n    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];\n\n\n\n// Section: Placing copies of all children on a path\n\n\n// Function&Module: path_copies()\n// Synopsis: Uniformly distributes copies of children along a path.\n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Copiers\n// See Also: line_copies(), move_copies(), xcopies(), ycopies(), zcopies(), grid_copies(), xflip_copy(), yflip_copy(), zflip_copy(), mirror_copy()\n//\n// Usage: Uniformly distribute copies \n//   path_copies(path, [n], [spacing], [sp], [rotate_children], [closed=]) CHILDREN;\n// Usage: Place copies at specified locations\n//   path_copies(path, dist=, [rotate_children=], [closed=]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = path_copies(path, [n], [spacing], [sp], [rotate_children], [closed=], p=);\n//   copies = path_copies(path, dist=, [rotate_children=], [closed=], p=);\n// Usage: Get Translation Matrices\n//   mats = path_copies(path, [n], [spacing], [sp], [rotate_children], [closed=]);\n//   mats = path_copies(path, dist=, [rotate_children=], [closed=]);\n//\n// Description:\n//   When called as a module:\n//   - Place copies all of the children at points along the path based on path length.  You can specify `dist` as\n//   - a scalar or distance list and the children will be placed at the specified distances from the start of the path.  Otherwise the children are\n//   - placed at uniformly spaced points along the path.  If you specify `n` but not `spacing` then `n` copies will be placed\n//   - with one at path[0] if `closed` is true, or spanning the entire path from start to end if `closed` is false.\n//   - If you specify `spacing` but not `n` then copies will spread out starting from one set at path[0] for `closed=true` or at the path center for open paths.\n//   - If you specify `sp` then the copies will start at distance `sp` from the start of the path.\n//   .\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   path = path or 1-region where children are placed\n//   n = number of copies\n//   spacing = space between copies\n//   sp = if given, copies will start distance sp from the path start and spread beyond that point\n//   rotate_children = if true, rotate children to line up with curve normal.  Default: true\n//   ---\n//   dist = Specify a list of distances to determine placement of children.  \n//   closed = If true treat path as a closed curve.  Default: false\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$pos` is set to the center of each copy\n//   `$idx` is set to the index number of each copy.  In the case of closed paths the first copy is at `path[0]` unless you give `sp`.\n//   `$dir` is set to the direction vector of the path at the point where the copy is placed.\n//   `$normal` is set to the direction of the normal vector to the path direction that is coplanar with the path at this point\n//\n//\n// Example(2D):\n//   spiral = [for(theta=[0:360*8]) theta * [cos(theta), sin(theta)]]/100;\n//   stroke(spiral,width=.25);\n//   color(\"red\") path_copies(spiral, n=100) circle(r=1);\n// Example(2D):\n//   circle = regular_ngon(n=64, or=10);\n//   stroke(circle,width=1,closed=true);\n//   color(\"green\") path_copies(circle, n=7, closed=true) circle(r=1+$idx/3);\n// Example(2D):\n//   heptagon = regular_ngon(n=7, or=10);\n//   stroke(heptagon, width=1, closed=true);\n//   color(\"purple\") path_copies(heptagon, n=9, closed=true) rect([0.5,3],anchor=FRONT);\n// Example(2D): Direction at the corners is the average of the two adjacent edges\n//   heptagon = regular_ngon(n=7, or=10);\n//   stroke(heptagon, width=1, closed=true);\n//   color(\"purple\") path_copies(heptagon, n=7, closed=true) rect([0.5,3],anchor=FRONT);\n// Example(2D):  Don't rotate the children\n//   heptagon = regular_ngon(n=7, or=10);\n//   stroke(heptagon, width=1, closed=true);\n//   color(\"red\") path_copies(heptagon, n=9, closed=true, rotate_children=false) rect([0.5,3],anchor=FRONT);\n// Example(2D): Open path, specify `n`\n//   sinwav = [for(theta=[0:360]) 5*[theta/180, sin(theta)]];\n//   stroke(sinwav,width=.1);\n//   color(\"red\") path_copies(sinwav, n=5) rect([.2,1.5],anchor=FRONT);\n// Example(2D): Open path, specify `n` and `spacing`\n//   sinwav = [for(theta=[0:360]) 5*[theta/180, sin(theta)]];\n//   stroke(sinwav,width=.1);\n//   color(\"red\") path_copies(sinwav, n=5, spacing=1) rect([.2,1.5],anchor=FRONT);\n// Example(2D): Closed path, specify `n` and `spacing`, copies centered around circle[0]\n//   circle = regular_ngon(n=64,or=10);\n//   stroke(circle,width=.1,closed=true);\n//   color(\"red\") path_copies(circle, n=10, spacing=1, closed=true) rect([.2,1.5],anchor=FRONT);\n// Example(2D): Open path, specify `spacing`\n//   sinwav = [for(theta=[0:360]) 5*[theta/180, sin(theta)]];\n//   stroke(sinwav,width=.1);\n//   color(\"red\") path_copies(sinwav, spacing=5) rect([.2,1.5],anchor=FRONT);\n// Example(2D): Open path, specify `sp`\n//   sinwav = [for(theta=[0:360]) 5*[theta/180, sin(theta)]];\n//   stroke(sinwav,width=.1);\n//   color(\"red\") path_copies(sinwav, n=5, sp=18) rect([.2,1.5],anchor=FRONT);\n// Example(2D): Open path, specify `dist`\n//   sinwav = [for(theta=[0:360]) 5*[theta/180, sin(theta)]];\n//   stroke(sinwav,width=.1);\n//   color(\"red\") path_copies(sinwav, dist=[1,4,9,16]) rect([.2,1.5],anchor=FRONT);\n// Example(2D):\n//   wedge = arc(angle=[0,100], r=10, $fn=64);\n//   difference(){\n//     polygon(concat([[0,0]],wedge));\n//     path_copies(wedge,n=5,spacing=3) fwd(.1) rect([1,4],anchor=FRONT);\n//   }\n// Example(Spin,VPD=115): 3d example, with children rotated into the plane of the path\n//   tilted_circle = lift_plane([[0,0,0], [5,0,5], [0,2,3]],regular_ngon(n=64, or=12));\n//   path_sweep(regular_ngon(n=16,or=.1),tilted_circle);\n//   path_copies(tilted_circle, n=15,closed=true) {\n//      color(\"blue\") cyl(h=3,r=.2, anchor=BOTTOM);      // z-aligned cylinder\n//      color(\"red\") xcyl(h=10,r=.2, anchor=FRONT+LEFT); // x-aligned cylinder\n//   }\n// Example(Spin,VPD=115): 3d example, with rotate_children set to false\n//   tilted_circle = lift_plane([[0,0,0], [5,0,5], [0,2,3]], regular_ngon(n=64, or=12));\n//   path_sweep(regular_ngon(n=16,or=.1),tilted_circle);\n//   path_copies(tilted_circle, n=25,rotate_children=false,closed=true) {\n//      color(\"blue\") cyl(h=3,r=.2, anchor=BOTTOM);       // z-aligned cylinder\n//      color(\"red\") xcyl(h=10,r=.2, anchor=FRONT+LEFT);  // x-aligned cylinder\n//   }\n\nmodule path_spread(path, n, spacing, sp=undef, rotate_children=true, dist, closed){\n  deprecate(\"path_copes\");\n  path_copies(path,n,spacing,sp,dist,rotate_children,dist, closed) children();\n}  \n\n\nmodule path_copies(path, n, spacing, sp=undef, dist, rotate_children=true, dist, closed)\n{\n    req_children($children);  \n    is_1reg = is_1region(path);\n    path = is_1reg ? path[0] : path;\n    closed = default(closed, is_1reg);\n    length = path_length(path,closed);\n    distind = is_def(dist) ? sortidx(dist) : undef;\n    distances =\n        is_def(dist) ? assert(is_undef(n) && is_undef(spacing) && is_undef(sp), \"Can't use n, spacing or undef with dist\")\n                       select(dist,distind)\n      : is_def(sp)? (   // Start point given\n            is_def(n) && is_def(spacing)? count(n,sp,spacing) :\n            is_def(n)? lerpn(sp, length, n) :\n            list([sp:spacing:length])\n        )\n      : is_def(n) && is_undef(spacing)? lerpn(0,length,n,!closed) // N alone given\n      : (      // No start point and spacing is given, N maybe given\n        let(\n            n = is_def(n)? n : floor(length/spacing)+(closed?0:1),\n            ptlist = count(n,0,spacing),\n            listcenter = mean(ptlist)\n        ) closed?\n            sort([for(entry=ptlist) posmod(entry-listcenter,length)]) :\n            [for(entry=ptlist) entry + length/2-listcenter ]\n    );\n    distOK = min(distances)>=0 && max(distances)<=length;\n    dummy = assert(distOK,\"Cannot fit all of the copies\");\n    cutlist = path_cut_points(path, distances, closed, direction=true);\n    planar = len(path[0])==2;\n    for(i=[0:1:len(cutlist)-1]) {\n        $pos = cutlist[i][0];\n        $idx = is_def(dist) ? distind[i] : i;\n        $dir = !rotate_children ? (planar?[1,0]:[1,0,0]) : cutlist[i][2];\n        $normal = !rotate_children? (planar?[0,1]:[0,0,1]) : cutlist[i][3];\n        translate($pos) {\n            if (rotate_children) {\n                if(planar) {\n                    rot(from=[0,1],to=cutlist[i][3]) children();\n                } else {\n                    frame_map(x=cutlist[i][2], z=cutlist[i][3])\n                        children();\n                }\n            } else {\n                children();\n            }\n        }\n    }\n}\n\n\nfunction path_copies(path, n, spacing, sp=undef, dist, rotate_children=true, dist, closed, p=_NO_ARG) =\n    let(\n        is_1reg = is_1region(path),\n        path = is_1reg ? path[0] : path,\n        closed = default(closed, is_1reg),\n        length = path_length(path,closed),\n        distind = is_def(dist) ? sortidx(dist) : undef,\n        distances =\n            is_def(dist) ? assert(is_undef(n) && is_undef(spacing) && is_undef(sp), \"Can't use n, spacing or undef with dist\")\n                           select(dist,distind)\n          : is_def(sp)? (   // Start point given\n                is_def(n) && is_def(spacing)? count(n,sp,spacing) :\n                is_def(n)? lerpn(sp, length, n) :\n                list([sp:spacing:length])\n            )\n          : is_def(n) && is_undef(spacing)? lerpn(0,length,n,!closed) // N alone given\n          : (      // No start point and spacing is given, N maybe given\n            let(\n                n = is_def(n)? n : floor(length/spacing)+(closed?0:1),\n                ptlist = count(n,0,spacing),\n                listcenter = mean(ptlist)\n            ) closed?\n                sort([for(entry=ptlist) posmod(entry-listcenter,length)]) :\n                [for(entry=ptlist) entry + length/2-listcenter ]\n          ),\n        distOK = min(distances)>=0 && max(distances)<=length,\n        dummy = assert(distOK,\"Cannot fit all of the copies\"),\n        cutlist = path_cut_points(path, distances, closed, direction=true),\n        planar = len(path[0])==2,\n        mats = [\n            for(i=[0:1:len(cutlist)-1])\n            translate(cutlist[i][0]) * (\n                !rotate_children? ident(4) :\n                planar? rot(from=[0,1],to=cutlist[i][3]) :\n                frame_map(x=cutlist[i][2], z=cutlist[i][3])\n            )\n        ]\n    )\n    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Making a copy of all children with reflection\n//////////////////////////////////////////////////////////////////////\n\n// Function&Module: xflip_copy()\n// Synopsis: Makes a copy of children mirrored across the X axis.\n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Translation, Copiers\n// See Also: yflip_copy(), zflip_copy(), mirror_copy(), path_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() \n//\n// Usage:\n//   xflip_copy([offset], [x]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = xflip_copy([offset], [x], p=);\n// Usage: Get Translation Matrices\n//   mats = xflip_copy([offset], [x]);\n//\n// Description:\n//   When called as a module, makes a copy of the children, mirrored across the X axis.\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   offset = Distance to offset children right, before copying.\n//   x = The X coordinate of the mirroring plane.  Default: 0\n//   ---\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$orig` is true for the original instance of children.  False for the copy.\n//   `$idx` is set to the index value of each copy.\n//\n//\n// Example:\n//   xflip_copy() yrot(90) cylinder(h=20, r1=4, r2=0);\n//   color(\"blue\",0.25) cube([0.01,15,15], center=true);\n//\n// Example:\n//   xflip_copy(offset=5) yrot(90) cylinder(h=20, r1=4, r2=0);\n//   color(\"blue\",0.25) cube([0.01,15,15], center=true);\n//\n// Example:\n//   xflip_copy(x=-5) yrot(90) cylinder(h=20, r1=4, r2=0);\n//   color(\"blue\",0.25) left(5) cube([0.01,15,15], center=true);\nmodule xflip_copy(offset=0, x=0)\n{\n    req_children($children);  \n    mirror_copy(v=[1,0,0], offset=offset, cp=[x,0,0]) children();\n}\n\n\nfunction xflip_copy(offset=0, x=0, p=_NO_ARG) =\n    mirror_copy(v=[1,0,0], offset=offset, cp=[x,0,0], p=p);\n\n\n// Function&Module: yflip_copy()\n// Synopsis: Makes a copy of children mirrored across the Y axis.\n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Translation, Copiers\n// See Also: xflip_copy(), zflip_copy(), mirror_copy(), path_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() \n//\n// Usage:\n//   yflip_copy([offset], [y]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = yflip_copy([offset], [y], p=);\n// Usage: Get Translation Matrices\n//   mats = yflip_copy([offset], [y]);\n//\n// Description:\n//   When called as a module, makes a copy of the children, mirrored across the Y axis.\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   offset = Distance to offset children back, before copying.\n//   y = The Y coordinate of the mirroring plane.  Default: 0\n//   ---\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$orig` is true for the original instance of children.  False for the copy.\n//   `$idx` is set to the index value of each copy.\n//\n//\n// Example:\n//   yflip_copy() xrot(-90) cylinder(h=20, r1=4, r2=0);\n//   color(\"blue\",0.25) cube([15,0.01,15], center=true);\n//\n// Example:\n//   yflip_copy(offset=5) xrot(-90) cylinder(h=20, r1=4, r2=0);\n//   color(\"blue\",0.25) cube([15,0.01,15], center=true);\n//\n// Example:\n//   yflip_copy(y=-5) xrot(-90) cylinder(h=20, r1=4, r2=0);\n//   color(\"blue\",0.25) fwd(5) cube([15,0.01,15], center=true);\nmodule yflip_copy(offset=0, y=0)\n{\n    req_children($children);\n    mirror_copy(v=[0,1,0], offset=offset, cp=[0,y,0]) children();\n}\n\n\nfunction yflip_copy(offset=0, y=0, p=_NO_ARG) =\n    mirror_copy(v=[0,1,0], offset=offset, cp=[0,y,0], p=p);\n\n\n// Function&Module: zflip_copy()\n// Synopsis: Makes a copy of children mirrored across the Z axis.\n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Translation, Copiers\n// See Also: xflip_copy(), yflip_copy(), mirror_copy(), path_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() \n//\n// Usage:\n//   zflip_copy([offset], [z]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = zflip_copy([offset], [z], p=);\n// Usage: Get Translation Matrices\n//   mats = zflip_copy([offset], [z]);\n//\n// Description:\n//   When called as a module, makes a copy of the children, mirrored across the Z axis.\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   offset = Distance to offset children up, before copying.\n//   z = The Z coordinate of the mirroring plane.  Default: 0\n//   ---\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$orig` is true for the original instance of children.  False for the copy.\n//   `$idx` is set to the index value of each copy.\n//\n//\n// Example:\n//   zflip_copy() cylinder(h=20, r1=4, r2=0);\n//   color(\"blue\",0.25) cube([15,15,0.01], center=true);\n//\n// Example:\n//   zflip_copy(offset=5) cylinder(h=20, r1=4, r2=0);\n//   color(\"blue\",0.25) cube([15,15,0.01], center=true);\n//\n// Example:\n//   zflip_copy(z=-5) cylinder(h=20, r1=4, r2=0);\n//   color(\"blue\",0.25) down(5) cube([15,15,0.01], center=true);\nmodule zflip_copy(offset=0, z=0)\n{\n    req_children($children);  \n    mirror_copy(v=[0,0,1], offset=offset, cp=[0,0,z]) children();\n}\n\n\nfunction zflip_copy(offset=0, z=0, p=_NO_ARG) =\n    mirror_copy(v=[0,0,1], offset=offset, cp=[0,0,z], p=p);\n\n\n// Function&Module: mirror_copy()\n// Synopsis: Makes a copy of children mirrored across a given plane.\n// SynTags: MatList, Trans\n// Topics: Transformations, Distributors, Translation, Copiers\n// See Also: xflip_copy(), yflip_copy(), zflip_copy(), path_copies(), move_copies(), xcopies(), ycopies(), zcopies(), line_copies(), grid_copies() \n//\n// Usage:\n//   mirror_copy(v, [cp], [offset]) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   copies = mirror_copy(v, [cp], [offset], p=);\n// Usage: Get Translation Matrices\n//   mats = mirror_copy(v, [cp], [offset]);\n//\n// Description:\n//   When called as a module, makes a copy of the children, mirrored across the given plane.\n//   When called as a function, *without* a `p=` argument, returns a list of transformation matrices, one for each copy.\n//   When called as a function, *with* a `p=` argument, returns a list of transformed copies of `p=`.\n//\n// Arguments:\n//   v = The normal vector of the plane to mirror across.\n//   offset = distance to offset away from the plane.\n//   cp = A point that lies on the mirroring plane.\n//   ---\n//   p = Either a point, pointlist, VNF or Bezier patch to be translated when used as a function.\n//\n// Side Effects:\n//   `$orig` is true for the original instance of children.  False for the copy.\n//   `$idx` is set to the index value of each copy.\n//\n//\n// Example:\n//   mirror_copy([1,-1,0]) zrot(-45) yrot(90) cylinder(d1=10, d2=0, h=20);\n//   color(\"blue\",0.25) zrot(-45) cube([0.01,15,15], center=true);\n//\n// Example:\n//   mirror_copy([1,1,0], offset=5) rot(a=90,v=[-1,1,0]) cylinder(d1=10, d2=0, h=20);\n//   color(\"blue\",0.25) zrot(45) cube([0.01,15,15], center=true);\n//\n// Example:\n//   mirror_copy(UP+BACK, cp=[0,-5,-5]) rot(from=UP, to=BACK+UP) cylinder(d1=10, d2=0, h=20);\n//   color(\"blue\",0.25) translate([0,-5,-5]) rot(from=UP, to=BACK+UP) cube([15,15,0.01], center=true);\nmodule mirror_copy(v=[0,0,1], offset=0, cp)\n{\n    req_children($children);  \n    cp = is_vector(v,4)? plane_normal(v) * v[3] :\n        is_vector(cp)? cp :\n        is_num(cp)? cp*unit(v) :\n        [0,0,0];\n    nv = is_vector(v,4)? plane_normal(v) : unit(v);\n    off = nv*offset;\n    if (cp == [0,0,0]) {\n        translate(off) {\n            $orig = true;\n            $idx = 0;\n            children();\n        }\n        mirror(nv) translate(off) {\n            $orig = false;\n            $idx = 1;\n            children();\n        }\n    } else {\n        translate(off) children();\n        translate(cp) mirror(nv) translate(-cp) translate(off) children();\n    }\n}\n\n\nfunction mirror_copy(v=[0,0,1], offset=0, cp, p=_NO_ARG) =\n    let(\n        cp = is_vector(v,4)? plane_normal(v) * v[3] :\n            is_vector(cp)? cp :\n            is_num(cp)? cp*unit(v) :\n            [0,0,0],\n        nv = is_vector(v,4)? plane_normal(v) : unit(v),\n        off = nv*offset,\n        mats = [\n            translate(off),\n            translate(cp) *\n                mirror(nv) *\n                translate(-cp) *\n                translate(off)\n        ]\n    )\n    p==_NO_ARG? mats : [for (m = mats) apply(m, p)];\n\n\n\n////////////////////\n// Section: Distributing children individually along a line\n///////////////////\n// Module: xdistribute()\n// Synopsis: Distributes each child, individually, out along the X axis.\n// SynTags: Trans\n// See Also: xdistribute(), ydistribute(), zdistribute(), distribute()\n//\n// Usage:\n//   xdistribute(spacing, [sizes]) CHILDREN;\n//   xdistribute(l=, [sizes=]) CHILDREN;\n//\n//\n// Description:\n//   Spreads out the children individually along the X axis. \n//   Every child is placed at a different position, in order.\n//   This is useful for laying out groups of disparate objects\n//   where you only really care about the spacing between them.\n//\n// Arguments:\n//   spacing = spacing between each child. (Default: 10.0)\n//   sizes = Array containing how much space each child will need.\n//   l = Length to distribute copies along.\n//\n// Side Effects:\n//   `$pos` is set to the relative centerpoint of each child copy, and can be used to modify each child individually.\n//   `$idx` is set to the index number of each child being copied.\n//\n// Example:\n//   xdistribute(sizes=[100, 10, 30], spacing=40) {\n//       sphere(r=50);\n//       cube([10,20,30], center=true);\n//       cylinder(d=30, h=50, center=true);\n//   }\nmodule xdistribute(spacing=10, sizes=undef, l=undef)\n{\n    req_children($children);  \n    dir = RIGHT;\n    gaps = ($children < 2)? [0] :\n        !is_undef(sizes)? [for (i=[0:1:$children-2]) sizes[i]/2 + sizes[i+1]/2] :\n        [for (i=[0:1:$children-2]) 0];\n    spc = !is_undef(l)? ((l - sum(gaps)) / ($children-1)) : default(spacing, 10);\n    gaps2 = [for (gap = gaps) gap+spc];\n    spos = dir * -sum(gaps2)/2;\n    spacings = cumsum([0, each gaps2]);\n    for (i=[0:1:$children-1]) {\n        $pos = spos + spacings[i] * dir;\n        $idx = i;\n        translate($pos) children(i);\n    }\n}\n\n\n// Module: ydistribute()\n// Synopsis: Distributes each child, individually, out along the Y axis.\n// SynTags: Trans\n// See Also: xdistribute(), ydistribute(), zdistribute(), distribute()\n//\n// Usage:\n//   ydistribute(spacing, [sizes]) CHILDREN;\n//   ydistribute(l=, [sizes=]) CHILDREN;\n//\n// Description:\n//   Spreads out the children individually along the Y axis. \n//   Every child is placed at a different position, in order.\n//   This is useful for laying out groups of disparate objects\n//   where you only really care about the spacing between them.\n//\n// Arguments:\n//   spacing = spacing between each child. (Default: 10.0)\n//   sizes = Array containing how much space each child will need.\n//   l = Length to distribute copies along.\n//\n// Side Effects:\n//   `$pos` is set to the relative centerpoint of each child copy, and can be used to modify each child individually.\n//   `$idx` is set to the index number of each child being copied.\n//\n// Example:\n//   ydistribute(sizes=[30, 20, 100], spacing=40) {\n//       cylinder(d=30, h=50, center=true);\n//       cube([10,20,30], center=true);\n//       sphere(r=50);\n//   }\nmodule ydistribute(spacing=10, sizes=undef, l=undef)\n{\n    req_children($children);  \n    dir = BACK;\n    gaps = ($children < 2)? [0] :\n        !is_undef(sizes)? [for (i=[0:1:$children-2]) sizes[i]/2 + sizes[i+1]/2] :\n        [for (i=[0:1:$children-2]) 0];\n    spc = !is_undef(l)? ((l - sum(gaps)) / ($children-1)) : default(spacing, 10);\n    gaps2 = [for (gap = gaps) gap+spc];\n    spos = dir * -sum(gaps2)/2;\n    spacings = cumsum([0, each gaps2]);\n    for (i=[0:1:$children-1]) {\n        $pos = spos + spacings[i] * dir;\n        $idx = i;\n        translate($pos) children(i);\n    }\n}\n\n\n// Module: zdistribute()\n// Synopsis: Distributes each child, individually, out along the Z axis.\n// SynTags: Trans\n// See Also: xdistribute(), ydistribute(), zdistribute(), distribute()\n//\n// Usage:\n//   zdistribute(spacing, [sizes]) CHILDREN;\n//   zdistribute(l=, [sizes=]) CHILDREN;\n//\n// Description:\n//   Spreads out each individual child along the Z axis.\n//   Every child is placed at a different position, in order.\n//   This is useful for laying out groups of disparate objects\n//   where you only really care about the spacing between them.\n//\n// Arguments:\n//   spacing = spacing between each child. (Default: 10.0)\n//   sizes = Array containing how much space each child will need.\n//   l = Length to distribute copies along.\n//\n// Side Effects:\n//   `$pos` is set to the relative centerpoint of each child copy, and can be used to modify each child individually.\n//   `$idx` is set to the index number of each child being copied.\n//\n// Example:\n//   zdistribute(sizes=[30, 20, 100], spacing=40) {\n//       cylinder(d=30, h=50, center=true);\n//       cube([10,20,30], center=true);\n//       sphere(r=50);\n//   }\nmodule zdistribute(spacing=10, sizes=undef, l=undef)\n{\n    req_children($children);  \n    dir = UP;\n    gaps = ($children < 2)? [0] :\n        !is_undef(sizes)? [for (i=[0:1:$children-2]) sizes[i]/2 + sizes[i+1]/2] :\n        [for (i=[0:1:$children-2]) 0];\n    spc = !is_undef(l)? ((l - sum(gaps)) / ($children-1)) : default(spacing, 10);\n    gaps2 = [for (gap = gaps) gap+spc];\n    spos = dir * -sum(gaps2)/2;\n    spacings = cumsum([0, each gaps2]);\n    for (i=[0:1:$children-1]) {\n        $pos = spos + spacings[i] * dir;\n        $idx = i;\n        translate($pos) children(i);\n    }\n}\n\n\n\n// Module: distribute()\n// Synopsis: Distributes each child, individually, out along an arbitrary line.\n// SynTags: Trans\n// See Also: xdistribute(), ydistribute(), zdistribute(), distribute()\n//\n// Usage:\n//   distribute(spacing, sizes, dir) CHILDREN;\n//   distribute(l=, [sizes=], [dir=]) CHILDREN;\n//\n// Description:\n//   Spreads out the children individually along the direction `dir`.\n//   Every child is placed at a different position, in order.\n//   This is useful for laying out groups of disparate objects\n//   where you only really care about the spacing between them.\n//\n// Arguments:\n//   spacing = Spacing to add between each child. (Default: 10.0)\n//   sizes = Array containing how much space each child will need.\n//   dir = Vector direction to distribute copies along.  Default: RIGHT\n//   l = Length to distribute copies along.\n//\n// Side Effects:\n//   `$pos` is set to the relative centerpoint of each child copy, and can be used to modify each child individually.\n//   `$idx` is set to the index number of each child being copied.\n//\n// Example:\n//   distribute(sizes=[100, 30, 50], dir=UP) {\n//       sphere(r=50);\n//       cube([10,20,30], center=true);\n//       cylinder(d=30, h=50, center=true);\n//   }\nmodule distribute(spacing=undef, sizes=undef, dir=RIGHT, l=undef)\n{\n    req_children($children);  \n    gaps = ($children < 2)? [0] :\n        !is_undef(sizes)? [for (i=[0:1:$children-2]) sizes[i]/2 + sizes[i+1]/2] :\n        [for (i=[0:1:$children-2]) 0];\n    spc = !is_undef(l)? ((l - sum(gaps)) / ($children-1)) : default(spacing, 10);\n    gaps2 = [for (gap = gaps) gap+spc];\n    spos = dir * -sum(gaps2)/2;\n    spacings = cumsum([0, each gaps2]);\n    for (i=[0:1:$children-1]) {\n        $pos = spos + spacings[i] * dir;\n        $idx = i;\n        translate($pos) children(i);\n    }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-13", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: drawing.scad\n//   This file includes stroke(), which converts a path into a\n//   geometric object, like drawing with a pen.  It even works on\n//   three-dimensional paths.  You can make a dashed line or add arrow\n//   heads.  The turtle() function provides a turtle graphics style\n//   approach for producing paths.  The arc() function produces arc paths,\n//   and helix() produces helical paths.\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: Create and draw 2D and 3D paths: arc, helix, turtle graphics\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Line Drawing\n\n// Module: stroke()\n// Synopsis: Draws a line along a path or region boundry.\n// SynTags: Geom\n// Topics: Paths (2D), Paths (3D), Drawing Tools\n// See Also: dashed_stroke(), offset_stroke(), path_sweep()\n// Usage:\n//   stroke(path, [width], [closed], [endcaps], [endcap_width], [endcap_length], [endcap_extent], [trim]);\n//   stroke(path, [width], [closed], [endcap1], [endcap2], [endcap_width1], [endcap_width2], [endcap_length1], [endcap_length2], [endcap_extent1], [endcap_extent2], [trim1], [trim2]);\n// Description:\n//   Draws a 2D or 3D path with a given line width.  Joints and each endcap can be replaced with\n//   various marker shapes, and can be assigned different colors.  If passed a region instead of\n//   a path, draws each path in the region as a closed polygon by default. If `closed=false` is\n//   given with a region or list of paths, then each path is drawn without the closing line segment.\n//   When drawing a closed path or region, there are no endcaps, so you cannot give the endcap parameters. \n//   To facilitate debugging, stroke() accepts \"paths\" that have a single point.  These are drawn with\n//   the style of endcap1, but have their own scale parameter, `singleton_scale`, which defaults to 2\n//   so that singleton dots with endcap \"round\" are clearly visible.\n//   .\n//   In 2d the stroke module works by creating a sequence of rectangles (or trapezoids if line width varies) and\n//   filling in the gaps with rounded wedges.  This is fast and produces a good result.  In 3d the modules\n//   creates a cylinders (or cones) and fills the gaps with rounded wedges made using rotate_extrude.  This process will be slow for\n//   long paths due to the 3d unions, and the faces on sequential cylinders may not line up.  In many cases, {{path_sweep()}} will be\n//   a better choice, both running faster and producing superior output, when working in three dimensions. \n// Figure(Med,NoAxes,2D,VPR=[0,0,0],VPD=250): Endcap Types\n//   cap_pairs = [\n//       [\"butt\",  \"chisel\" ],\n//       [\"round\", \"square\" ],\n//       [\"line\",  \"cross\"  ],\n//       [\"x\",     \"diamond\"],\n//       [\"dot\",   \"block\"  ],\n//       [\"tail\",  \"arrow\"  ],\n//       [\"tail2\", \"arrow2\" ]\n//   ];\n//   for (i = idx(cap_pairs)) {\n//       fwd((i-len(cap_pairs)/2+0.5)*13) {\n//           stroke([[-20,0], [20,0]], width=3, endcap1=cap_pairs[i][0], endcap2=cap_pairs[i][1]);\n//           color(\"black\") {\n//               stroke([[-20,0], [20,0]], width=0.25, endcaps=false);\n//               left(28) text(text=cap_pairs[i][0], size=5, halign=\"right\", valign=\"center\");\n//               right(28) text(text=cap_pairs[i][1], size=5, halign=\"left\", valign=\"center\");\n//           }\n//       }\n//   }\n// Arguments:\n//   path = The path to draw along.\n//   width = The width of the line to draw.  If given as a list of widths, (one for each path point), draws the line with varying thickness to each point.\n//   closed = If true, draw an additional line from the end of the path to the start.\n//   joints  = Specifies the joint shape for each joint of the line.  If a 2D polygon is given, use that to draw custom joints.\n//   endcaps = Specifies the endcap type for both ends of the line.  If a 2D polygon is given, use that to draw custom endcaps.\n//   endcap1 = Specifies the endcap type for the start of the line.  If a 2D polygon is given, use that to draw a custom endcap.\n//   endcap2 = Specifies the endcap type for the end of the line.  If a 2D polygon is given, use that to draw a custom endcap.\n//   dots = Specifies both the endcap and joint types with one argument.  If given `true`, sets both to \"dot\".  If a 2D polygon is given, uses that to draw custom dots.\n//   joint_width = Some joint shapes are wider than the line.  This specifies the width of the shape, in multiples of the line width.\n//   endcap_width = Some endcap types are wider than the line.  This specifies the size of endcaps, in multiples of the line width.\n//   endcap_width1 = This specifies the size of starting endcap, in multiples of the line width.\n//   endcap_width2 = This specifies the size of ending endcap, in multiples of the line width.\n//   dots_width = This specifies the size of the joints and endcaps, in multiples of the line width.\n//   joint_length = Length of joint shape, in multiples of the line width.\n//   endcap_length = Length of endcaps, in multiples of the line width.\n//   endcap_length1 = Length of starting endcap, in multiples of the line width.\n//   endcap_length2 = Length of ending endcap, in multiples of the line width.\n//   dots_length = Length of both joints and endcaps, in multiples of the line width.\n//   joint_extent = Extents length of joint shape, in multiples of the line width.\n//   endcap_extent = Extents length of endcaps, in multiples of the line width.\n//   endcap_extent1 = Extents length of starting endcap, in multiples of the line width.\n//   endcap_extent2 = Extents length of ending endcap, in multiples of the line width.\n//   dots_extent = Extents length of both joints and endcaps, in multiples of the line width.\n//   joint_angle = Extra rotation given to joint shapes, in degrees.  If not given, the shapes are fully spun (for 3D lines).\n//   endcap_angle = Extra rotation given to endcaps, in degrees.  If not given, the endcaps are fully spun (for 3D lines).\n//   endcap_angle1 = Extra rotation given to a starting endcap, in degrees.  If not given, the endcap is fully spun (for 3D lines).\n//   endcap_angle2 = Extra rotation given to a ending endcap, in degrees.  If not given, the endcap is fully spun (for 3D lines).\n//   dots_angle = Extra rotation given to both joints and endcaps, in degrees.  If not given, the endcap is fully spun (for 3D lines).\n//   trim = Trim the the start and end line segments by this much, to keep them from interfering with custom endcaps.\n//   trim1 = Trim the the starting line segment by this much, to keep it from interfering with a custom endcap.\n//   trim2 = Trim the the ending line segment by this much, to keep it from interfering with a custom endcap.\n//   color = If given, sets the color of the line segments, joints and endcap.\n//   endcap_color = If given, sets the color of both endcaps.  Overrides `color=` and `dots_color=`.\n//   endcap_color1 = If give, sets the color of the starting endcap.  Overrides `color=`, `dots_color=`,  and `endcap_color=`.\n//   endcap_color2 = If given, sets the color of the ending endcap.  Overrides `color=`, `dots_color=`,  and `endcap_color=`.\n//   joint_color = If given, sets the color of the joints.  Overrides `color=` and `dots_color=`.\n//   dots_color = If given, sets the color of the endcaps and joints.  Overrides `color=`.\n//   singleton_scale = Change the scale of the endcap shape drawn for singleton paths.  Default: 2.  \n//   convexity = Max number of times a line could intersect a wall of an endcap.\n// Example(2D): Drawing a Path\n//   path = [[0,100], [100,100], [200,0], [100,-100], [100,0]];\n//   stroke(path, width=20);\n// Example(2D): Closing a Path\n//   path = [[0,100], [100,100], [200,0], [100,-100], [100,0]];\n//   stroke(path, width=20, closed=true);\n// Example(2D): Fancy Arrow Endcaps\n//   path = [[0,100], [100,100], [200,0], [100,-100], [100,0]];\n//   stroke(path, width=10, endcaps=\"arrow2\");\n// Example(2D): Modified Fancy Arrow Endcaps\n//   path = [[0,100], [100,100], [200,0], [100,-100], [100,0]];\n//   stroke(path, width=10, endcaps=\"arrow2\", endcap_width=6, endcap_length=3, endcap_extent=2);\n// Example(2D): Mixed Endcaps\n//   path = [[0,100], [100,100], [200,0], [100,-100], [100,0]];\n//   stroke(path, width=10, endcap1=\"tail2\", endcap2=\"arrow2\");\n// Example(2D): Plotting Points.  Setting endcap_angle to zero results in the weird arrow orientation. \n//   path = [for (a=[0:30:360]) [a-180, 60*sin(a)]];\n//   stroke(path, width=3, joints=\"diamond\", endcaps=\"arrow2\", endcap_angle=0, endcap_width=5, joint_angle=0, joint_width=5);\n// Example(2D): Default joint gives curves along outside corners of the path:\n//   stroke([square(40)], width=18);\n// Example(2D): Setting `joints=\"square\"` gives flat outside corners \n//   stroke([square(40)], width=18, joints=\"square\");\n// Example(2D): Setting `joints=\"butt\"` does not draw any transitions, just rectangular strokes for each segment, meeting at their centers:\n//   stroke([square(40)], width=18, joints=\"butt\");\n// Example(2D): Joints and Endcaps\n//   path = [for (a=[0:30:360]) [a-180, 60*sin(a)]];\n//   stroke(path, width=8, joints=\"dot\", endcaps=\"arrow2\");\n// Example(2D): Custom Endcap Shapes\n//   path = [[0,100], [100,100], [200,0], [100,-100], [100,0]];\n//   arrow = [[0,0], [2,-3], [0.5,-2.3], [2,-4], [0.5,-3.5], [-0.5,-3.5], [-2,-4], [-0.5,-2.3], [-2,-3]];\n//   stroke(path, width=10, trim=3.5, endcaps=arrow);\n// Example(2D): Variable Line Width\n//   path = circle(d=50,$fn=18);\n//   widths = [for (i=idx(path)) 10*i/len(path)+2];\n//   stroke(path,width=widths,$fa=1,$fs=1);\n// Example: 3D Path with Endcaps\n//   path = rot([15,30,0], p=path3d(pentagon(d=50)));\n//   stroke(path, width=2, endcaps=\"arrow2\", $fn=18);\n// Example: 3D Path with Flat Endcaps\n//   path = rot([15,30,0], p=path3d(pentagon(d=50)));\n//   stroke(path, width=2, endcaps=\"arrow2\", endcap_angle=0, $fn=18);\n// Example: 3D Path with Mixed Endcaps\n//   path = rot([15,30,0], p=path3d(pentagon(d=50)));\n//   stroke(path, width=2, endcap1=\"arrow2\", endcap2=\"tail\", endcap_angle2=0, $fn=18);\n// Example: 3D Path with Joints and Endcaps\n//   path = [for (i=[0:10:360]) [(i-180)/2,20*cos(3*i),20*sin(3*i)]];\n//   stroke(path, width=2, joints=\"dot\", endcap1=\"round\", endcap2=\"arrow2\", joint_width=2.0, endcap_width2=3, $fn=18);\n// Example: Coloring Lines, Joints, and Endcaps\n//   path = [for (i=[0:15:360]) [(i-180)/3,20*cos(2*i),20*sin(2*i)]];\n//   stroke(\n//       path, width=2, joints=\"dot\", endcap1=\"dot\", endcap2=\"arrow2\",\n//       color=\"lightgreen\", joint_color=\"red\", endcap_color=\"blue\",\n//       joint_width=2.0, endcap_width2=3, $fn=18\n//   );\n// Example(2D): Simplified Plotting\n//   path = [for (i=[0:15:360]) [(i-180)/3,20*cos(2*i)]];\n//   stroke(path, width=2, dots=true, color=\"lightgreen\", dots_color=\"red\", $fn=18);\n// Example(2D): Drawing a Region\n//   rgn = [square(100,center=true), circle(d=60,$fn=18)];\n//   stroke(rgn, width=2);\n// Example(2D): Drawing a List of Lines\n//   paths = [\n//       for (y=[-60:60:60]) [\n//           for (a=[-180:15:180])\n//           [a, 2*y+60*sin(a+y)]\n//       ]\n//   ];\n//   stroke(paths, closed=false, width=5);\n// Example(2D): Paths with a singleton.  Note that the singleton is not a single point, but a list containing a single point.  \n//   stroke([\n//           [[0,0],[1,1]],\n//           [[1.5,1.5]],\n//           [[2,2],[3,3]]\n//          ],width=0.2,closed=false,$fn=16);\nfunction stroke(\n    path, width=1, closed,\n    endcaps,       endcap1,        endcap2,        joints,       dots,\n    endcap_width,  endcap_width1,  endcap_width2,  joint_width,  dots_width,\n    endcap_length, endcap_length1, endcap_length2, joint_length, dots_length,\n    endcap_extent, endcap_extent1, endcap_extent2, joint_extent, dots_extent,\n    endcap_angle,  endcap_angle1,  endcap_angle2,  joint_angle,  dots_angle,\n    endcap_color,  endcap_color1,  endcap_color2,  joint_color,  dots_color, color,\n    trim, trim1, trim2, singleton_scale=2,\n    convexity=10\n) = no_function(\"stroke\");\n\n\nmodule stroke(\n    path, width=1, closed,\n    endcaps,       endcap1,        endcap2,        joints,       dots,\n    endcap_width,  endcap_width1,  endcap_width2,  joint_width,  dots_width,\n    endcap_length, endcap_length1, endcap_length2, joint_length, dots_length,\n    endcap_extent, endcap_extent1, endcap_extent2, joint_extent, dots_extent,\n    endcap_angle,  endcap_angle1,  endcap_angle2,  joint_angle,  dots_angle,\n    endcap_color,  endcap_color1,  endcap_color2,  joint_color,  dots_color, color,\n    trim, trim1, trim2, singleton_scale=2,\n    convexity=10\n) {\n    no_children($children);\n    module setcolor(clr) {\n        if (clr==undef) {\n            children();\n        } else {\n            color(clr) children();\n        }\n    }\n    function _shape_defaults(cap) =\n        cap==undef?     [1.00, 0.00, 0.00] :\n        cap==false?     [1.00, 0.00, 0.00] :\n        cap==true?      [1.00, 1.00, 0.00] :\n        cap==\"butt\"?    [1.00, 0.00, 0.00] :\n        cap==\"round\"?   [1.00, 1.00, 0.00] :\n        cap==\"chisel\"?  [1.00, 1.00, 0.00] :\n        cap==\"square\"?  [1.00, 1.00, 0.00] :\n        cap==\"block\"?   [2.00, 1.00, 0.00] :\n        cap==\"diamond\"? [2.50, 1.00, 0.00] :\n        cap==\"dot\"?     [2.00, 1.00, 0.00] :\n        cap==\"x\"?       [2.50, 0.40, 0.00] :\n        cap==\"cross\"?   [3.00, 0.33, 0.00] :\n        cap==\"line\"?    [3.50, 0.22, 0.00] :\n        cap==\"arrow\"?   [3.50, 0.40, 0.50] :\n        cap==\"arrow2\"?  [3.50, 1.00, 0.14] :\n        cap==\"tail\"?    [3.50, 0.47, 0.50] :\n        cap==\"tail2\"?   [3.50, 0.28, 0.50] :\n        is_path(cap)?   [0.00, 0.00, 0.00] :\n        assert(false, str(\"Invalid cap or joint: \",cap));\n\n    function _shape_path(cap,linewidth,w,l,l2) = (\n        cap==\"butt\" || cap==false || cap==undef ? [] : \n        cap==\"round\" || cap==true ? scale([w,l], p=circle(d=1, $fn=max(8, segs(w/2)))) :\n        cap==\"chisel\"?  scale([w,l], p=circle(d=1,$fn=4)) :\n        cap==\"diamond\"? circle(d=w,$fn=4) :\n        cap==\"square\"?  scale([w,l], p=square(1,center=true)) :\n        cap==\"block\"?   scale([w,l], p=square(1,center=true)) :\n        cap==\"dot\"?     circle(d=w, $fn=max(12, segs(w*3/2))) :\n        cap==\"x\"?       [for (a=[0:90:270]) each rot(a,p=[[w+l/2,w-l/2]/2, [w-l/2,w+l/2]/2, [0,l/2]]) ] :\n        cap==\"cross\"?   [for (a=[0:90:270]) each rot(a,p=[[l,w]/2, [-l,w]/2, [-l,l]/2]) ] :\n        cap==\"line\"?    scale([w,l], p=square(1,center=true)) :\n        cap==\"arrow\"?   [[0,0], [w/2,-l2], [w/2,-l2-l], [0,-l], [-w/2,-l2-l], [-w/2,-l2]] :\n        cap==\"arrow2\"?  [[0,0], [w/2,-l2-l], [0,-l], [-w/2,-l2-l]] :\n        cap==\"tail\"?    [[0,0], [w/2,l2], [w/2,l2-l], [0,-l], [-w/2,l2-l], [-w/2,l2]] :\n        cap==\"tail2\"?   [[w/2,0], [w/2,-l], [0,-l-l2], [-w/2,-l], [-w/2,0]] :\n        is_path(cap)? cap :\n        assert(false, str(\"Invalid endcap: \",cap))\n    ) * linewidth;\n\n    closed = default(closed, is_region(path));\n    check1 = assert(is_bool(closed))\n             assert(!closed || num_defined([endcaps,endcap1,endcap2])==0, \"Cannot give endcap parameter(s) with closed path or region\");\n\n    dots = dots==true? \"dot\" : dots;\n\n    endcap1 = first_defined([endcap1, endcaps, dots, \"round\"]);\n    endcap2 = first_defined([endcap2, endcaps, if (!closed) dots, \"round\"]);\n    joints  = first_defined([joints, dots, \"round\"]);\n    check2 =\n      assert(is_bool(endcap1) || is_string(endcap1) || is_path(endcap1))\n      assert(is_bool(endcap2) || is_string(endcap2) || is_path(endcap2))\n      assert(is_bool(joints)  || is_string(joints)  || is_path(joints));\n\n    endcap1_dflts = _shape_defaults(endcap1);\n    endcap2_dflts = _shape_defaults(endcap2);\n    joint_dflts   = _shape_defaults(joints);\n\n    endcap_width1 = first_defined([endcap_width1, endcap_width, dots_width, endcap1_dflts[0]]);\n    endcap_width2 = first_defined([endcap_width2, endcap_width, dots_width, endcap2_dflts[0]]);\n    joint_width   = first_defined([joint_width, dots_width, joint_dflts[0]]);\n\n    endcap_length1 = first_defined([endcap_length1, endcap_length, dots_length, endcap1_dflts[1]*endcap_width1]);\n    endcap_length2 = first_defined([endcap_length2, endcap_length, dots_length, endcap2_dflts[1]*endcap_width2]);\n    joint_length   = first_defined([joint_length, dots_length, joint_dflts[1]*joint_width]);\n\n    endcap_extent1 = first_defined([endcap_extent1, endcap_extent, dots_extent, endcap1_dflts[2]*endcap_width1]);\n    endcap_extent2 = first_defined([endcap_extent2, endcap_extent, dots_extent, endcap2_dflts[2]*endcap_width2]);\n    joint_extent   = first_defined([joint_extent, dots_extent, joint_dflts[2]*joint_width]);\n\n    endcap_angle1 = first_defined([endcap_angle1, endcap_angle, dots_angle]);\n    endcap_angle2 = first_defined([endcap_angle2, endcap_angle, dots_angle]);\n    joint_angle = first_defined([joint_angle, dots_angle]);\n    \n    check3 =\n      assert(all_nonnegative([endcap_length1]))\n      assert(all_nonnegative([endcap_length2]))\n      assert(all_nonnegative([joint_length]));\n      assert(all_nonnegative([endcap_extent1]))\n      assert(all_nonnegative([endcap_extent2]))\n      assert(all_nonnegative([joint_extent]));\n      assert(is_undef(endcap_angle1)||is_finite(endcap_angle1))\n      assert(is_undef(endcap_angle2)||is_finite(endcap_angle2))\n      assert(is_undef(joint_angle)||is_finite(joint_angle))\n      assert(all_positive([singleton_scale]))\n      assert(all_positive(width));\n      \n    endcap_color1 = first_defined([endcap_color1, endcap_color, dots_color, color]);\n    endcap_color2 = first_defined([endcap_color2, endcap_color, dots_color, color]);\n    joint_color = first_defined([joint_color, dots_color, color]);\n\n    // We want to allow \"paths\" with length 1, so we can't use the normal path/region checks\n    paths = is_matrix(path) ? [path] : path;\n    assert(is_list(paths),\"The path argument must be a list of 2D or 3D points, or a region.\");\n    attachable(){\n      for (path = paths) {\n          pathvalid = is_path(path,[2,3]) || same_shape(path,[[0,0]]) || same_shape(path,[[0,0,0]]);\n          assert(pathvalid,\"The path argument must be a list of 2D or 3D points, or a region.\");\n\n          check4 = assert(is_num(width) || len(width)==len(path),\n                          \"width must be a number or a vector the same length as the path (or all components of a region)\");\n          path = deduplicate( closed? list_wrap(path) : path );\n          width = is_num(width)? [for (x=path) width]\n                : closed? list_wrap(width)\n                : width;\n          check4a=assert(len(width)==len(path), \"path had duplicated points and width was given as a list: this is not allowd\");\n\n          endcap_shape1 = _shape_path(endcap1, width[0], endcap_width1, endcap_length1, endcap_extent1);\n          endcap_shape2 = _shape_path(endcap2, last(width), endcap_width2, endcap_length2, endcap_extent2);\n\n          trim1 = width[0] * first_defined([\n              trim1, trim,\n              (endcap1==\"arrow\")? endcap_length1-0.01 :\n              (endcap1==\"arrow2\")? endcap_length1*3/4 :\n              0\n          ]);\n\n          trim2 = last(width) * first_defined([\n              trim2, trim,\n              (endcap2==\"arrow\")? endcap_length2-0.01 :\n              (endcap2==\"arrow2\")? endcap_length2*3/4 :\n              0\n          ]);\n          check10 = assert(is_finite(trim1))\n                    assert(is_finite(trim2));\n\n          if (len(path) == 1) {\n              if (len(path[0]) == 2) {\n                  // Endcap1\n                  setcolor(endcap_color1) {\n                      translate(path[0]) {\n                          mat = is_undef(endcap_angle1)? ident(3) : zrot(endcap_angle1);\n                          multmatrix(mat) polygon(scale(singleton_scale,endcap_shape1));\n                      }\n                  }\n              } else {\n                  // Endcap1\n                  setcolor(endcap_color1) {\n                      translate(path[0]) {\n                          $fn = segs(width[0]/2);\n                          if (is_undef(endcap_angle1)) {\n                              rotate_extrude(convexity=convexity) {\n                                  right_half(planar=true) {\n                                      polygon(endcap_shape1);\n                                  }\n                              }\n                          } else {\n                              rotate([90,0,endcap_angle1]) {\n                                  linear_extrude(height=max(widths[0],0.001), center=true, convexity=convexity) {\n                                      polygon(endcap_shape1);\n                                  }\n                              }\n                          }\n                      }\n                  }\n              }\n          } else {\n              dummy=assert(trim1<path_length(path)-trim2, \"Path is too short for endcap(s).  Try a smaller width, or set endcap_length to a smaller value.\");\n              // This section shortens the path to allow room for the specified endcaps.  Note that if\n              // the path is closed, there are not endcaps, so we don't shorten the path, but in that case we\n              // duplicate entry 1 so that the path wraps around a little more and we can correctly create all the joints.\n              // (Why entry 1?  Because entry 0 was already duplicated by a list_wrap() call.)  \n              pathcut = path_cut_points(path, [trim1, path_length(path)-trim2], closed=false);\n              pathcut_su = _cut_to_seg_u_form(pathcut,path);\n              path2 = closed ? [each path, path[1]]\n                             : _path_cut_getpaths(path, pathcut, closed=false)[1];\n              widths = closed ? [each width, width[1]]\n                              : _path_select(width, pathcut_su[0][0], pathcut_su[0][1], pathcut_su[1][0], pathcut_su[1][1]);\n              start_vec = path[0] - path[1];\n              end_vec = last(path) - select(path,-2);\n\n              if (len(path[0]) == 2) {  // Two dimensional case\n                  // Straight segments\n                  setcolor(color) {\n                      for (i = idx(path2,e=-2)) {\n                          seg = select(path2,i,i+1);\n                          delt = seg[1] - seg[0];\n                          translate(seg[0]) {\n                              rot(from=BACK,to=delt) {\n                                  trapezoid(w1=widths[i], w2=widths[i+1], h=norm(delt), anchor=FRONT);\n                              }\n                          }\n                      }\n                  }\n\n                  // Joints\n                  setcolor(joint_color) {\n                      for (i = [1:1:len(path2)-2]) {\n                          $fn = quantup(segs(widths[i]/2),4);\n                          translate(path2[i]) {\n                              if (joints != undef && joints != \"round\" && joints != \"square\") {\n                                  joint_shape = _shape_path(\n                                                    joints, widths[i],\n                                                    joint_width,\n                                                    joint_length,\n                                                    joint_extent  \n                                  );\n                                  v1 = unit(path2[i] - path2[i-1]);\n                                  v2 = unit(path2[i+1] - path2[i]);\n                                  mat = is_undef(joint_angle)\n                                    ? rot(from=BACK,to=v1)\n                                    : zrot(joint_angle);\n                                  multmatrix(mat) polygon(joint_shape);\n                              } else {\n                                  // These are parallel to the path\n                                  v1 = path2[i] - path2[i-1];\n                                  v2 = path2[i+1] - path2[i];\n                                  ang = modang(v_theta(v2) - v_theta(v1));\n                                  // Need 90 deg offset to make wedge perpendicular to path, and the wedge\n                                  // position depends on whether we turn left (ang<0) or right (ang>0)\n                                  theta = v_theta(v1) - sign(ang)*90;\n\n                                  if (!approx(ang,0)){\n                                      // This section creates a rounded wedge to fill in gaps.  The wedge needs to be oversized for overlap\n                                      // in all directions, including its apex, but not big enough to create artifacts.\n                                      // The core of the wedge is the proper arc we need to create.  We then add side points based\n                                      // on firstang and secondang, where we try 1 degree, but if that appears too big we based it\n                                      // on the segment length.  We pick the radius based on the smaller of the width at this point\n                                      // and the adjacent width, which could be much smaller---meaning that we need a much smaller radius.\n                                      // The apex offset we pick to be simply based on the width at this point. \n                                      firstang = sign(ang)*min(1,0.5*norm(v1)/PI/widths[i]*360);\n                                      secondang = sign(ang)*min(1,0.5*norm(v2)/PI/widths[i]*360);\n                                      firstR = 0.5*min(widths[i], lerp(widths[i],widths[i-1], abs(firstang)*PI*widths[i]/360/norm(v1)));\n                                      secondR = 0.5*min(widths[i], lerp(widths[i],widths[i+1], abs(secondang)*PI*widths[i]/360/norm(v2)));\n                                      apex_offset = widths[i]/10;\n                                      arcpath = [\n                                                 firstR*[cos(theta-firstang), sin(theta-firstang)], \n                                                 each arc(d=widths[i], angle=[theta, theta+ang],n=joints==\"square\"?2:undef),\n                                                 secondR*[cos(theta+ang+secondang), sin(theta+ang+secondang)],\n                                                 -apex_offset*[cos(theta+ang/2), sin(theta+ang/2)]\n                                      ];\n                                      polygon(arcpath);\n                                  }\n                              }\n                          }\n                      }\n                  }\n                  if (!closed){\n                    // Endcap1\n                    setcolor(endcap_color1) {\n                        translate(path[0]) {\n                            mat = is_undef(endcap_angle1)? rot(from=BACK,to=start_vec) :\n                                zrot(endcap_angle1);\n                            multmatrix(mat) polygon(endcap_shape1);\n                        }\n                    }\n\n                    // Endcap2\n                    setcolor(endcap_color2) {\n                        translate(last(path)) {\n                            mat = is_undef(endcap_angle2)? rot(from=BACK,to=end_vec) :\n                                zrot(endcap_angle2);\n                            multmatrix(mat) polygon(endcap_shape2);\n                        }\n                    }\n                  }\n              } else {  // Three dimensional case\n                  rotmats = cumprod([\n                      for (i = idx(path2,e=-2)) let(\n                          vec1 = i==0? UP : unit(path2[i]-path2[i-1], UP),\n                          vec2 = unit(path2[i+1]-path2[i], UP)\n                      ) rot(from=vec1,to=vec2)\n                  ]);\n\n                  sides = [\n                      for (i = idx(path2,e=-2))\n                      quantup(segs(max(widths[i],widths[i+1])/2),4)\n                  ];\n\n                  // Straight segments\n                  setcolor(color) {\n                      for (i = idx(path2,e=-2)) {\n                          dist = norm(path2[i+1] - path2[i]);\n                          w1 = widths[i]/2;\n                          w2 = widths[i+1]/2;\n                          $fn = sides[i];\n                          translate(path2[i]) {\n                              multmatrix(rotmats[i]) {\n                                  cylinder(r1=w1, r2=w2, h=dist, center=false);\n                              }\n                          }\n                      }\n                  }\n\n                  // Joints\n                  setcolor(joint_color) {\n                      for (i = [1:1:len(path2)-2]) {\n                          $fn = sides[i];\n                          translate(path2[i]) {\n                              if (joints != undef && joints != \"round\") {\n                                  joint_shape = _shape_path(\n                                      joints, width[i],\n                                      joint_width,\n                                      joint_length,\n                                      joint_extent\n                                  );\n                                  multmatrix(rotmats[i] * xrot(180)) {\n                                      $fn = sides[i];\n                                      if (is_undef(joint_angle)) {\n                                          rotate_extrude(convexity=convexity) {\n                                              right_half(planar=true) {\n                                                  polygon(joint_shape);\n                                              }\n                                          }\n                                      } else {\n                                          rotate([90,0,joint_angle]) {\n                                              linear_extrude(height=max(widths[i],0.001), center=true, convexity=convexity) {\n                                                  polygon(joint_shape);\n                                              }\n                                          }\n                                      }\n                                  }\n                              } else {\n                                  corner = select(path2,i-1,i+1);\n                                  axis = vector_axis(corner);\n                                  ang = vector_angle(corner);\n                                  if (!approx(ang,0)) {\n                                      frame_map(x=path2[i-1]-path2[i], z=-axis) {\n                                          zrot(90-0.5) {\n                                              rotate_extrude(angle=180-ang+1) {\n                                                  arc(d=widths[i], start=-90, angle=180);\n                                              }\n                                          }\n                                      }\n                                  }\n                              }\n                          }\n                      }\n                  }\n                  if (!closed){\n                    // Endcap1\n                    setcolor(endcap_color1) {\n                        translate(path[0]) {\n                            multmatrix(rotmats[0] * xrot(180)) {\n                                $fn = sides[0];\n                                if (is_undef(endcap_angle1)) {\n                                    rotate_extrude(convexity=convexity) {\n                                        right_half(planar=true) {\n                                            polygon(endcap_shape1);\n                                        }\n                                    }\n                                } else {\n                                    rotate([90,0,endcap_angle1]) {\n                                        linear_extrude(height=max(widths[0],0.001), center=true, convexity=convexity) {\n                                            polygon(endcap_shape1);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    // Endcap2\n                    setcolor(endcap_color2) {\n                        translate(last(path)) {\n                            multmatrix(last(rotmats)) {\n                                $fn = last(sides);\n                                if (is_undef(endcap_angle2)) {\n                                    rotate_extrude(convexity=convexity) {\n                                        right_half(planar=true) {\n                                            polygon(endcap_shape2);\n                                        }\n                                    }\n                                } else {\n                                    rotate([90,0,endcap_angle2]) {\n                                        linear_extrude(height=max(last(widths),0.001), center=true, convexity=convexity) {\n                                            polygon(endcap_shape2);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                  }\n              }\n          }\n      }\n      union();\n    }\n}\n\n\n// Function&Module: dashed_stroke()\n// Synopsis: Draws a dashed line along a path or region boundry.\n// SynTags: Geom, PathList\n// Topics: Paths, Drawing Tools\n// See Also: stroke(), path_cut()\n// Usage: As a Module\n//   dashed_stroke(path, dashpat, [width=], [closed=]);\n// Usage: As a Function\n//   dashes = dashed_stroke(path, dashpat, [closed=]);\n// Description:\n//   Given a path (or region) and a dash pattern, creates a dashed line that follows that\n//   path or region boundary with the given dash pattern.\n//   - When called as a function, returns a list of dash sub-paths.\n//   - When called as a module, draws all those subpaths using `stroke()`.\n//   .\n//   When called as a module the dash pattern is multiplied by the line width.  When called as\n//   a function the dash pattern applies as you specify it.  \n// Arguments:\n//   path = The path or region to subdivide into dashes.\n//   dashpat = A list of alternating dash lengths and space lengths for the dash pattern.  This will be scaled by the width of the line.\n//   ---\n//   width = The width of the dashed line to draw.  Module only.  Default: 1\n//   closed = If true, treat path as a closed polygon.  Default: false\n//   fit = If true, shrink or stretch the dash pattern so that the path ends ofter a logical dash.  Default: true\n//   roundcaps = (Module only) If true, draws dashes with rounded caps.  This often looks better.  Default: true\n//   mindash = (Function only) Specifies the minimal dash length to return at the end of a path when fit is false.  Default: 0.5\n// Example(2D): Open Path\n//   path = [for (a=[-180:10:180]) [a/3,20*sin(a)]];\n//   dashed_stroke(path, [3,2], width=1);\n// Example(2D): Closed Polygon\n//   path = circle(d=100,$fn=72);\n//   dashpat = [10,2, 3,2, 3,2];\n//   dashed_stroke(path, dashpat, width=1, closed=true);\n// Example(FlatSpin,VPD=250): 3D Dashed Path\n//   path = [for (a=[-180:5:180]) [a/3, 20*cos(3*a), 20*sin(3*a)]];\n//   dashed_stroke(path, [3,2], width=1);\nfunction dashed_stroke(path, dashpat=[3,3], closed=false, fit=true, mindash=0.5) =\n    is_region(path) ? [\n        for (p = path)\n        each dashed_stroke(p, dashpat, closed=true, fit=fit)\n    ] : \n    let(\n        path = closed? list_wrap(path) : path,\n        dashpat = len(dashpat)%2==0? dashpat : concat(dashpat,[0]),\n        plen = path_length(path),\n        dlen = sum(dashpat),\n        doff = cumsum(dashpat),\n        freps = plen / dlen,\n        reps = max(1, fit? round(freps) : floor(freps)),\n        tlen = !fit? plen :\n            reps * dlen + (closed? 0 : dashpat[0]),\n        sc = plen / tlen,\n        cuts = [\n            for (i = [0:1:reps], off = doff*sc)\n              let (x = i*dlen*sc + off)\n              if (x > 0 && x < plen-EPSILON) x\n        ],\n        dashes = path_cut(path, cuts, closed=false),\n        dcnt = len(dashes),\n        evens = [\n            for (i = idx(dashes))\n            if (i % 2 == 0)\n            let( dash = dashes[i] )\n            if (i < dcnt-1 || path_length(dash) > mindash)\n            dashes[i]\n        ]\n    ) evens;\n\n\nmodule dashed_stroke(path, dashpat=[3,3], width=1, closed=false, fit=true, roundcaps=false) {\n    no_children($children);\n    segs = dashed_stroke(path, dashpat=dashpat*width, closed=closed, fit=fit, mindash=0.5*width);\n    for (seg = segs)\n        stroke(seg, width=width, endcaps=roundcaps? \"round\" : false);\n}\n\n\n\n// Section: Computing paths\n\n// Function&Module: arc()\n// Synopsis: Draws a 2D pie-slice or returns 2D or 3D path forming an arc.\n// SynTags: Geom, Path\n// Topics: Paths (2D), Paths (3D), Shapes (2D), Path Generators\n// See Also: pie_slice(), stroke(), ring()\n//\n// Usage: 2D arc from 0\u00ba to `angle` degrees.\n//   path=arc(n, r|d=, angle);\n// Usage: 2D arc from START to END degrees.\n//   path=arc(n, r|d=, angle=[START,END]);\n// Usage: 2D arc from `start` to `start+angle` degrees.\n//   path=arc(n, r|d=, start=, angle=);\n// Usage: 2D circle segment by `width` and `thickness`, starting and ending on the X axis.\n//   path=arc(n, width=, thickness=);\n// Usage: Shortest 2D or 3D arc around centerpoint `cp`, starting at P0 and ending on the vector pointing from `cp` to `P1`.\n//   path=arc(n, cp=, points=[P0,P1], [long=], [cw=], [ccw=]);\n// Usage: 2D or 3D arc, starting at `P0`, passing through `P1` and ending at `P2`.\n//   path=arc(n, points=[P0,P1,P2]);\n// Usage: 2D or 3D arc, fron tangent point on segment `[P0,P1]` to the tangent point on segment `[P1,P2]`.\n//   path=arc(n, corner=[P0,P1,P2], r=);\n// Usage: Create a wedge using any other arc parameters\n//   path=arc(wedge=true,...)\n// Usage: as module\n//   arc(...) [ATTACHMENTS];\n// Description:\n//   If called as a function, returns a 2D or 3D path forming an arc.  If `wedge` is true, the centerpoint of the arc appears as the first point in the result.\n//   If called as a module, creates a 2D arc polygon or pie slice shape.\n// Arguments:\n//   n = Number of vertices to form the arc curve from.\n//   r = Radius of the arc.\n//   angle = If a scalar, specifies the end angle in degrees (relative to start parameter).  If a vector of two scalars, specifies start and end angles.\n//   ---\n//   d = Diameter of the arc.\n//   cp = Centerpoint of arc.\n//   points = Points on the arc.\n//   corner = A path of two segments to fit an arc tangent to.\n//   long = if given with cp and points takes the long arc instead of the default short arc.  Default: false\n//   cw = if given with cp and 2 points takes the arc in the clockwise direction.  Default: false\n//   ccw = if given with cp and 2 points takes the arc in the counter-clockwise direction.  Default: false\n//   width = If given with `thickness`, arc starts and ends on X axis, to make a circle segment.\n//   thickness = If given with `width`, arc starts and ends on X axis, to make a circle segment.\n//   start = Start angle of arc.  Default: 0\n//   wedge = If true, include centerpoint `cp` in output to form pie slice shape.  Default: false\n//   endpoint = If false exclude the last point (function only).  Default: true\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  (Module only) Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  (Module only) Default: `0`\n// Examples(2D):\n//   arc(n=4, r=30, angle=30, wedge=true);\n//   arc(r=30, angle=30, wedge=true);\n//   arc(d=60, angle=30, wedge=true);\n//   arc(d=60, angle=120);\n//   arc(d=60, angle=120, wedge=true);\n//   arc(r=30, angle=[75,135], wedge=true);\n//   arc(r=30, start=45, angle=75, wedge=true);\n//   arc(width=60, thickness=20);\n//   arc(cp=[-10,5], points=[[20,10],[0,35]], wedge=true);\n//   arc(points=[[30,-5],[20,10],[-10,20]], wedge=true);\n// Example(2D): Fit to three points.\n//   arc(points=[[5,30],[-10,-10],[30,5]], wedge=true);\n// Example(2D):\n//   path = arc(points=[[5,30],[-10,-10],[30,5]], wedge=true);\n//   stroke(closed=true, path);\n// Example(FlatSpin,VPD=175):\n//   path = arc(points=[[0,30,0],[0,0,30],[30,0,0]]);\n//   stroke(path, dots=true, dots_color=\"blue\");\n// Example(2D): Fit to a corner.\n//   pts = [[0,40], [-40,-10], [30,0]];\n//   path = arc(corner=pts, r=20);\n//   stroke(pts, endcaps=\"arrow2\");\n//   stroke(path, endcap2=\"arrow2\", color=\"blue\");\nfunction arc(n, r, angle, d, cp, points, corner, width, thickness, start, wedge=false, long=false, cw=false, ccw=false, endpoint=true) =\n    assert(is_bool(endpoint))\n    !endpoint ?\n        assert(!wedge, \"endpoint cannot be false if wedge is true\")\n        list_head(arc(u_add(n,1),r,angle,d,cp,points,corner,width,thickness,start,wedge,long,cw,ccw,true))\n  :\n    assert(is_undef(start) || is_def(angle), \"start requires angle\")\n    assert(is_undef(angle) || !any_defined([thickness,width,points,corner]), \"Cannot give angle with points, corner, width or thickness\")\n    assert(is_undef(n) || (is_integer(n) && n>=2), \"Number of points must be an integer 2 or larger\")\n    assert(is_undef(points) || is_path(points, [2,3]), \"Points must be a list of 2d or 3d points\")\n    assert((is_def(points) && len(points)==2) || !any([cw,ccw,long]), \"cw, ccw, and long are only allowed when points is a list of length 2\")\n    // First try for 2D arc specified by width and thickness\n    is_def(width) && is_def(thickness)? \n        assert(!any_defined([r,cp,points,angle,start]),\"Conflicting or invalid parameters to arc\")\n        assert(width>0, \"Width must be postive\")\n        assert(thickness>0, \"Thickness must be positive\")\n        arc(n,points=[[width/2,0], [0,thickness], [-width/2,0]],wedge=wedge)\n  : is_def(angle)? \n        let(\n            parmok = !any_defined([points,width,thickness]) &&\n                ((is_vector(angle,2) && is_undef(start)) || is_finite(angle))\n        )\n        assert(parmok,\"Invalid parameters in arc\")\n        let(\n            cp = first_defined([cp,[0,0]]),\n            start = is_def(start)? start : is_vector(angle) ? angle[0] : 0,\n            angle = is_vector(angle)? angle[1]-angle[0] : angle,\n            r = get_radius(r=r, d=d)\n        )\n        assert(is_vector(cp,2),\"Centerpoint must be a 2d vector\")\n        assert(angle!=0, \"Arc has zero length\")\n        assert(is_def(r) && r>0, \"Arc radius invalid\")\n        let(\n            n = is_def(n) ? n : max(3, ceil(segs(r)*abs(angle)/360)),\n            arcpoints = [for(i=[0:n-1]) let(theta = start + i*angle/(n-1)) r*[cos(theta),sin(theta)]+cp],\n            extra = wedge? [cp] : []\n        )\n        concat(extra,arcpoints)\n  : is_def(corner)? \n        assert(is_path(corner,[2,3]) && len(corner)==3,str(\"Point list is invalid\"))\n        assert(is_undef(cp) && !any([long,cw,ccw]), \"Cannot use cp, long, cw, or ccw with corner\")\n        // Arc is 3D, so transform corner to 2D and make a recursive call, then remap back to 3D\n        len(corner[0]) == 3? (\n            let(\n                plane = [corner[2], corner[0], corner[1]],\n                points2d = project_plane(plane, corner)\n            )\n            lift_plane(plane,arc(n,corner=points2d,wedge=wedge,long=long))\n        ) :\n        assert(is_path(corner) && len(corner) == 3)\n        let(col = is_collinear(corner[0],corner[1],corner[2]))\n        assert(!col, \"Collinear inputs do not define an arc\")\n        let( r = get_radius(r=r, d=d) )\n        assert(is_finite(r) && r>0, \"Must specify r= or d= when corner= is given.\")\n        let(\n            ci = circle_2tangents(r, corner[0], corner[1], corner[2], tangents=true),\n            cp = ci[0], nrm = ci[1], tp1 = ci[2], tp2 = ci[3],\n            dir = det2([corner[1]-corner[0],corner[2]-corner[1]]) > 0,\n            corner = dir? [tp1,tp2] : [tp2,tp1],\n            theta_start = atan2(corner[0].y-cp.y, corner[0].x-cp.x),\n            theta_end = atan2(corner[1].y-cp.y, corner[1].x-cp.x),\n            angle = posmod(theta_end-theta_start, 360),\n            arcpts = arc(n,cp=cp,r=r,start=theta_start,angle=angle,wedge=wedge)\n        )\n        dir ? arcpts : wedge ? reverse_polygon(arcpts) : reverse(arcpts)\n  : assert(is_def(points), \"Arc not specified: must give points, angle, or width and thickness\")\n    assert(is_path(points,[2,3]),\"Point list is invalid\")\n         // If arc is 3D, transform points to 2D and make a recursive call, then remap back to 3D\n    len(points[0]) == 3? \n        assert(!(cw || ccw), \"(Counter)clockwise isn't meaningful in 3d, so `cw` and `ccw` must be false\")\n        assert(is_undef(cp) || is_vector(cp,3),\"points are 3d so cp must be 3d\")\n        let(\n            plane = [is_def(cp) ? cp : points[2], points[0], points[1]],\n            center2d = is_def(cp) ? project_plane(plane,cp) : undef,\n            points2d = project_plane(plane, points)\n        )\n        lift_plane(plane,arc(n,cp=center2d,points=points2d,wedge=wedge,long=long))\n  : len(points)==2?  \n        // Arc defined by center plus two points, will have radius defined by center and points[0]\n        // and extent defined by direction of point[1] from the center\n        assert(is_vector(cp,2), \"Centerpoint is required when points has length 2 and it must be a 2d vector\")\n        assert(len(points)==2, \"When pointlist has length 3 centerpoint is not allowed\")\n        assert(points[0]!=points[1], \"Arc endpoints are equal\")\n        assert(cp!=points[0]&&cp!=points[1], \"Centerpoint equals an arc endpoint\")\n        assert(num_true([long,cw,ccw])<=1, str(\"Only one of `long`, `cw` and `ccw` can be true\",cw,ccw,long))\n        let(    \n            angle = vector_angle(points[0], cp, points[1]),\n            v1 = points[0]-cp,\n            v2 = points[1]-cp,\n            prelim_dir = sign(det2([v1,v2])),  // z component of cross product\n            dir = prelim_dir != 0 ? prelim_dir :\n                assert(cw || ccw, \"Collinear inputs don't define a unique arc\")\n                1,\n            r = norm(v1),\n            final_angle = long || (ccw && dir<0) || (cw && dir>0) ?\n                -dir*(360-angle) :\n                dir*angle,\n            sa = atan2(v1.y,v1.x)\n        )\n        arc(n,cp=cp,r=r,start=sa,angle=final_angle,wedge=wedge)\n  : // Final case is arc passing through three points, starting at point[0] and ending at point[3]\n        let(col = is_collinear(points[0],points[1],points[2]))\n        assert(!col, \"Collinear inputs do not define an arc\")\n        let(\n            cp = line_intersection(_normal_segment(points[0],points[1]),_normal_segment(points[1],points[2])),\n            // select order to be counterclockwise\n            dir = det2([points[1]-points[0],points[2]-points[1]]) > 0,\n            points = dir? select(points,[0,2]) : select(points,[2,0]),\n            r = norm(points[0]-cp),\n            theta_start = atan2(points[0].y-cp.y, points[0].x-cp.x),\n            theta_end = atan2(points[1].y-cp.y, points[1].x-cp.x),\n            angle = posmod(theta_end-theta_start, 360),\n            arcpts = arc(n,cp=cp,r=r,start=theta_start,angle=angle,wedge=wedge)\n        )\n        dir ? arcpts : wedge?reverse_polygon(arcpts):reverse(arcpts);\n\n\nmodule arc(n, r, angle, d, cp, points, corner, width, thickness, start, wedge=false, anchor=CENTER, spin=0)\n{\n    path = arc(n=n, r=r, angle=angle, d=d, cp=cp, points=points, corner=corner, width=width, thickness=thickness, start=start, wedge=wedge);\n    attachable(anchor,spin, two_d=true, path=path, extent=false) {\n        polygon(path);\n        children();\n    }\n}\n\n\n// Function: catenary()\n// Synopsis: Returns a 2D Catenary chain or arch path.\n// SynTags: Path\n// Topics: Paths\n// See Also: circle(), stroke()\n// Usage:\n//   path = catenary(width, droop=|angle=, n=);\n// Description:\n//   Returns a 2D Catenary path, which is the path a chain held at both ends will take.\n//   The path will have the endpoints at `[\u00b1width/2, 0]`, and the middle of the path will droop\n//   towards Y- if the given droop= or angle= is positive.  It will droop towards Y+ if the\n//   droop= or angle= is negative.  You *must* specify one of droop= or angle=.\n// Arguments:\n//   width = The straight-line distance between the endpoints of the path.\n//   droop = If given, specifies the height difference between the endpoints and the hanging middle of the path.  If given a negative value, returns an arch *above* the Y axis.\n//   n = The number of points to return in the path.  Default: 100\n//   ---\n//   angle = If given, specifies the angle that the path will droop by at the endpoints.  If given a negative value, returns an arch *above* the Y axis.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  (Module only) Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  (Module only) Default: `0`\n// Example(2D): By Droop\n//   stroke(catenary(100, droop=30));\n// Example(2D): By Angle\n//   stroke(catenary(100, angle=30));\n// Example(2D): Upwards Arch by Angle\n//   stroke(catenary(100, angle=30));\n// Example(2D): Upwards Arch by Height Delta\n//   stroke(catenary(100, droop=-30));\n// Example(2D): Specifying Vertex Count\n//   stroke(catenary(100, angle=-85, n=11), dots=\"dot\");\n// Example: Sweeping a Catenary Path\n//   path = xrot(90, p=path3d(catenary(100, droop=20, n=41)));\n//   path_sweep(circle(r=1.5, $fn=24), path);\nfunction catenary(width, droop, n=100, angle) =\n    assert(one_defined([droop, angle],\"droop,angle\"))\n    let(\n        sgn = is_undef(droop)? sign(angle) : sign(droop),\n        droop = droop==undef? undef : abs(droop),\n        angle = angle==undef? undef : abs(angle)\n    )\n    assert(is_finite(width) && width>0, \"Bad width= value.\")\n    assert(is_integer(n) && n>0, \"Bad n= value.  Must be a positive integer.\")\n    assert(is_undef(droop) || is_finite(droop), \"Bad droop= value.\")\n    assert(is_undef(angle) || (is_finite(angle) && angle != 0 && abs(angle) < 90), \"Bad angle= value.\")\n    let(\n        catlup_fn = is_undef(droop)\n          ? function(x) let(\n                p1 = [x-0.001, cosh(x-0.001)-1],\n                p2 = [x+0.001, cosh(x+0.001)-1],\n                delta = p2-p1,\n                ang = atan2(delta.y, delta.x)\n            ) ang\n          : function(x) (cosh(x)-1)/x,\n        binsearch_fn = function(targ,x=0,inc=4)\n            inc < 1e-9? lookup(targ,[[catlup_fn(x),x],[catlup_fn(x+inc),x+inc]]) :\n            catlup_fn(x+inc) > targ? binsearch_fn(targ,x,inc/2) :\n            binsearch_fn(targ,x+inc,inc),\n        scx = is_undef(droop)? binsearch_fn(angle) :\n            binsearch_fn(droop / (width/2)),\n        sc = width/2 / scx,\n        droop = !is_undef(droop)? droop : (cosh(scx)-1) * sc,\n        path = [\n            for (x = lerpn(-scx,scx,n))\n            let(\n                xval = x * sc,\n                yval = approx(abs(x),scx)? 0 :\n                    (cosh(x)-1) * sc - droop\n            )\n            [xval, yval]\n        ],\n        out = sgn>0? path : yflip(p=path)\n    ) out;\n\n\nmodule catenary(width, droop, n=100, angle, anchor=CTR, spin=0) {\n    path = catenary(width=width, droop=droop, n=n, angle=angle);\n    attachable(anchor,spin, two_d=true, path=path, extent=true) {\n        polygon(path);\n        children();\n    }\n}\n\n\n// Function: helix()\n// Synopsis: Creates a 2d spiral or 3d helical path.\n// SynTags: Path\n// Topics: Path Generators, Paths, Drawing Tools\n// See Also: pie_slice(), stroke(), thread_helix(), path_sweep()\n//\n// Usage:\n//   path = helix(l|h, [turns=], [angle=], r=|r1=|r2=, d=|d1=|d2=);\n// Description:\n//   Returns a 3D helical path on a cone, including the degerate case of flat spirals.\n//   You can specify start and end radii.  You can give the length, the helix angle, or the number of turns: two\n//   of these three parameters define the helix.  For a flat helix you must give length 0 and a turn count.\n//   Helix will be right handed if turns is positive and left handed if it is negative.\n//   The angle is calculateld based on the radius at the base of the helix.\n// Arguments:\n//   h/l = Height/length of helix, zero for a flat spiral\n//   ---\n//   turns = Number of turns in helix, positive for right handed\n//   angle = helix angle\n//   r = Radius of helix\n//   r1 = Radius of bottom of helix\n//   r2 = Radius of top of helix\n//   d = Diameter of helix\n//   d1 = Diameter of bottom of helix\n//   d2 = Diameter of top of helix\n// Example(3D):\n//   stroke(helix(turns=2.5, h=100, r=50), dots=true, dots_color=\"blue\");\n// Example(3D):  Helix that turns the other way\n//   stroke(helix(turns=-2.5, h=100, r=50), dots=true, dots_color=\"blue\");\n// Example(3D): Flat helix (note points are still 3d)\n//   stroke(helix(h=0,r1=50,r2=25,l=0, turns=4));\nmodule helix(l,h,turns,angle, r, r1, r2, d, d1, d2) {no_module();}\nfunction helix(l,h,turns,angle, r, r1, r2, d, d1, d2)=\n    let(\n        r1=get_radius(r=r,r1=r1,d=d,d1=d1,dflt=1),\n        r2=get_radius(r=r,r1=r2,d=d,d1=d2,dflt=1),\n        length = first_defined([l,h])\n    )\n    assert(num_defined([length,turns,angle])==2,\"Must define exactly two of l/h, turns, and angle\")\n    assert(is_undef(angle) || length!=0, \"Cannot give length 0 with an angle\")\n    let(\n        // length advances dz for each turn\n        dz = is_def(angle) && length!=0 ? 2*PI*r1*tan(angle) : length/abs(turns),\n\n        maxtheta = is_def(turns) ? 360*turns : 360*length/dz,\n        N = segs(max(r1,r2))\n    )\n    [for(theta=lerpn(0,maxtheta, max(3,ceil(abs(maxtheta)*N/360))))\n       let(R=lerp(r1,r2,theta/maxtheta))\n       [R*cos(theta), R*sin(theta), abs(theta)/360 * dz]];\n\n\nfunction _normal_segment(p1,p2) =\n    let(center = (p1+p2)/2)\n    [center, center + norm(p1-p2)/2 * line_normal(p1,p2)];\n\n\n// Function: turtle()\n// Synopsis: Uses [turtle graphics](https://en.wikipedia.org/wiki/Turtle_graphics) to generate a 2D path.\n// SynTags: Path\n// Topics: Shapes (2D), Path Generators (2D), Mini-Language\n// See Also: turtle3d(), stroke(), path_sweep()\n// Usage:\n//   path = turtle(commands, [state], [full_state=], [repeat=])\n// Description:\n//   Use a sequence of [turtle graphics]{https://en.wikipedia.org/wiki/Turtle_graphics} commands to generate a path.  The parameter `commands` is a list of\n//   turtle commands and optional parameters for each command.  The turtle state has a position, movement direction,\n//   movement distance, and default turn angle.  If you do not give `state` as input then the turtle starts at the\n//   origin, pointed along the positive x axis with a movement distance of 1.  By default, `turtle` returns just\n//   the computed turtle path.  If you set `full_state` to true then it instead returns the full turtle state.\n//   You can invoke `turtle` again with this full state to continue the turtle path where you left off.\n//   .\n//   The turtle state is a list with three entries: the path constructed so far, the current step as a 2-vector, the current default angle,\n//   and the current arcsteps setting.  \n//   .\n//   Commands     | Arguments          | What it does\n//   ------------ | ------------------ | -------------------------------\n//   \"move\"       | [dist]             | Move turtle scale*dist units in the turtle direction.  Default dist=1.  \n//   \"xmove\"      | [dist]             | Move turtle scale*dist units in the x direction. Default dist=1.  Does not change turtle direction.\n//   \"ymove\"      | [dist]             | Move turtle scale*dist units in the y direction. Default dist=1.  Does not change turtle direction.\n//   \"xymove\"     | vector             | Move turtle by the specified vector.  Does not change turtle direction. \n//   \"untilx\"     | xtarget            | Move turtle in turtle direction until x==xtarget.  Produces an error if xtarget is not reachable.\n//   \"untily\"     | ytarget            | Move turtle in turtle direction until y==ytarget.  Produces an error if ytarget is not reachable.\n//   \"jump\"       | point              | Move the turtle to the specified point\n//   \"xjump\"      | x                  | Move the turtle's x position to the specified value\n//   \"yjump       | y                  | Move the turtle's y position to the specified value\n//   \"turn\"       | [angle]            | Turn turtle direction by specified angle, or the turtle's default turn angle.  The default angle starts at 90.\n//   \"left\"       | [angle]            | Same as \"turn\"\n//   \"right\"      | [angle]            | Same as \"turn\", -angle\n//   \"angle\"      | angle              | Set the default turn angle.\n//   \"setdir\"     | dir                | Set turtle direction.  The parameter `dir` can be an angle or a vector.\n//   \"length\"     | length             | Change the turtle move distance to `length`\n//   \"scale\"      | factor             | Multiply turtle move distance by `factor`\n//   \"addlength\"  | length             | Add `length` to the turtle move distance\n//   \"repeat\"     | count, commands    | Repeats a list of commands `count` times.\n//   \"arcleft\"    | radius, [angle]    | Draw an arc from the current position toward the left at the specified radius and angle.  The turtle turns by `angle`.  A negative angle draws the arc to the right instead of the left, and leaves the turtle facing right.  A negative radius draws the arc to the right but leaves the turtle facing left.  \n//   \"arcright\"   | radius, [angle]    | Draw an arc from the current position toward the right at the specified radius and angle\n//   \"arcleftto\"  | radius, angle      | Draw an arc at the given radius turning toward the left until reaching the specified absolute angle.  \n//   \"arcrightto\" | radius, angle      | Draw an arc at the given radius turning toward the right until reaching the specified absolute angle.  \n//   \"arcsteps\"   | count              | Specifies the number of segments to use for drawing arcs.  If you set it to zero then the standard `$fn`, `$fa` and `$fs` variables define the number of segments.  \n//\n// Arguments:\n//   commands = List of turtle commands\n//   state = Starting turtle state (from previous call) or starting point.  Default: start at the origin, pointing right.\n//   ---\n//   full_state = If true return the full turtle state for continuing the path in subsequent turtle calls.  Default: false\n//   repeat = Number of times to repeat the command list.  Default: 1\n//\n// Example(2D): Simple rectangle\n//   path = turtle([\"xmove\",3, \"ymove\", \"xmove\",-3, \"ymove\",-1]);\n//   stroke(path,width=.1);\n// Example(2D): Pentagon\n//   path=turtle([\"angle\",360/5,\"move\",\"turn\",\"move\",\"turn\",\"move\",\"turn\",\"move\"]);\n//   stroke(path,width=.1,closed=true);\n// Example(2D): Pentagon using the repeat argument\n//   path=turtle([\"move\",\"turn\",360/5],repeat=5);\n//   stroke(path,width=.1,closed=true);\n// Example(2D): Pentagon using the repeat turtle command, setting the turn angle\n//   path=turtle([\"angle\",360/5,\"repeat\",5,[\"move\",\"turn\"]]);\n//   stroke(path,width=.1,closed=true);\n// Example(2D): Pentagram\n//   path = turtle([\"move\",\"left\",144], repeat=4);\n//   stroke(path,width=.05,closed=true);\n// Example(2D): Sawtooth path\n//   path = turtle([\n//       \"turn\", 55,\n//       \"untily\", 2,\n//       \"turn\", -55-90,\n//       \"untily\", 0,\n//       \"turn\", 55+90,\n//       \"untily\", 2.5,\n//       \"turn\", -55-90,\n//       \"untily\", 0,\n//       \"turn\", 55+90,\n//       \"untily\", 3,\n//       \"turn\", -55-90,\n//       \"untily\", 0\n//   ]);\n//   stroke(path, width=.1);\n// Example(2D): Simpler way to draw the sawtooth.  The direction of the turtle is preserved when executing \"yjump\".\n//   path = turtle([\n//       \"turn\", 55,\n//       \"untily\", 2,\n//       \"yjump\", 0,\n//       \"untily\", 2.5,\n//       \"yjump\", 0,\n//       \"untily\", 3,\n//       \"yjump\", 0,\n//   ]);\n//   stroke(path, width=.1);\n// Example(2DMed): square spiral\n//   path = turtle([\"move\",\"left\",\"addlength\",1],repeat=50);\n//   stroke(path,width=.2);\n// Example(2DMed): pentagonal spiral\n//   path = turtle([\"move\",\"left\",360/5,\"addlength\",1],repeat=50);\n//   stroke(path,width=.7);\n// Example(2DMed): yet another spiral, without using `repeat`\n//   path = turtle(concat([\"angle\",71],flatten(repeat([\"move\",\"left\",\"addlength\",1],50))));\n//   stroke(path,width=.7);\n// Example(2DMed): The previous spiral grows linearly and eventually intersects itself.  This one grows geometrically and does not.\n//   path = turtle([\"move\",\"left\",71,\"scale\",1.05],repeat=50);\n//   stroke(path,width=.15);\n// Example(2D): Koch Snowflake\n//   function koch_unit(depth) =\n//       depth==0 ? [\"move\"] :\n//       concat(\n//           koch_unit(depth-1),\n//           [\"right\"],\n//           koch_unit(depth-1),\n//           [\"left\",\"left\"],\n//           koch_unit(depth-1),\n//           [\"right\"],\n//           koch_unit(depth-1)\n//       );\n//   koch=concat([\"angle\",60,\"repeat\",3],[concat(koch_unit(3),[\"left\",\"left\"])]);\n//   polygon(turtle(koch));\nmodule turtle(commands, state=[[[0,0]],[1,0],90,0], full_state=false, repeat=1) {no_module();}\nfunction turtle(commands, state=[[[0,0]],[1,0],90,0], full_state=false, repeat=1) =\n    let( state = is_vector(state) ? [[state],[1,0],90,0] : state )\n        repeat == 1?\n            _turtle(commands,state,full_state) :\n            _turtle_repeat(commands, state, full_state, repeat);\n\nfunction _turtle_repeat(commands, state, full_state, repeat) =\n    repeat==1?\n        _turtle(commands,state,full_state) :\n        _turtle_repeat(commands, _turtle(commands, state, true), full_state, repeat-1);\n\nfunction _turtle_command_len(commands, index) =\n    let( one_or_two_arg = [\"arcleft\",\"arcright\", \"arcleftto\", \"arcrightto\"] )\n    commands[index] == \"repeat\"? 3 :   // Repeat command requires 2 args\n    // For these, the first arg is required, second arg is present if it is not a string\n    in_list(commands[index], one_or_two_arg) && len(commands)>index+2 && !is_string(commands[index+2]) ? 3 :  \n    is_string(commands[index+1])? 1 :  // If 2nd item is a string it's must be a new command\n    2;                                 // Otherwise we have command and arg\n\nfunction _turtle(commands, state, full_state, index=0) =\n    index < len(commands) ?\n    _turtle(commands,\n            _turtle_command(commands[index],commands[index+1],commands[index+2],state,index),\n            full_state,\n            index+_turtle_command_len(commands,index)\n        ) :\n        ( full_state ? state : state[0] );\n\n// Turtle state: state = [path, step_vector, default angle, default arcsteps]\n\nfunction _turtle_command(command, parm, parm2, state, index) =\n    command == \"repeat\"?\n        assert(is_num(parm),str(\"\\\"repeat\\\" command requires a numeric repeat count at index \",index))\n        assert(is_list(parm2),str(\"\\\"repeat\\\" command requires a command list parameter at index \",index))\n        _turtle_repeat(parm2, state, true, parm) :\n    let(\n        path = 0,\n        step=1,\n        angle=2,\n        arcsteps=3,\n        parm = !is_string(parm) ? parm : undef,\n        parm2 = !is_string(parm2) ? parm2 : undef,\n        needvec = [\"jump\", \"xymove\"],\n        neednum = [\"untilx\",\"untily\",\"xjump\",\"yjump\",\"angle\",\"length\",\"scale\",\"addlength\"],\n        needeither = [\"setdir\"],\n        chvec = !in_list(command,needvec) || is_vector(parm,2),\n        chnum = !in_list(command,neednum) || is_num(parm),\n        vec_or_num = !in_list(command,needeither) || (is_num(parm) || is_vector(parm,2)),\n        lastpt = last(state[path])\n    )\n    assert(chvec,str(\"\\\"\",command,\"\\\" requires a vector parameter at index \",index))\n    assert(chnum,str(\"\\\"\",command,\"\\\" requires a numeric parameter at index \",index))\n    assert(vec_or_num,str(\"\\\"\",command,\"\\\" requires a vector or numeric parameter at index \",index))\n\n    command==\"move\" ? list_set(state, path, concat(state[path],[default(parm,1)*state[step]+lastpt])) :\n    command==\"untilx\" ? (\n        let(\n            int = line_intersection([lastpt,lastpt+state[step]], [[parm,0],[parm,1]]),\n            xgood = sign(state[step].x) == sign(int.x-lastpt.x)\n        )\n        assert(xgood,str(\"\\\"untilx\\\" never reaches desired goal at index \",index))\n        list_set(state,path,concat(state[path],[int]))\n    ) :\n    command==\"untily\" ? (\n        let(\n            int = line_intersection([lastpt,lastpt+state[step]], [[0,parm],[1,parm]]),\n            ygood = is_def(int) && sign(state[step].y) == sign(int.y-lastpt.y)\n        )\n        assert(ygood,str(\"\\\"untily\\\" never reaches desired goal at index \",index))\n        list_set(state,path,concat(state[path],[int]))\n    ) :\n    command==\"xmove\" ? list_set(state, path, concat(state[path],[default(parm,1)*norm(state[step])*[1,0]+lastpt])):\n    command==\"ymove\" ? list_set(state, path, concat(state[path],[default(parm,1)*norm(state[step])*[0,1]+lastpt])):\n        command==\"xymove\" ? list_set(state, path, concat(state[path], [lastpt+parm])):\n    command==\"jump\" ?  list_set(state, path, concat(state[path],[parm])):\n    command==\"xjump\" ? list_set(state, path, concat(state[path],[[parm,lastpt.y]])):\n    command==\"yjump\" ? list_set(state, path, concat(state[path],[[lastpt.x,parm]])):\n    command==\"turn\" || command==\"left\" ? list_set(state, step, rot(default(parm,state[angle]),p=state[step])) :\n    command==\"right\" ? list_set(state, step, rot(-default(parm,state[angle]),p=state[step])) :\n    command==\"angle\" ? list_set(state, angle, parm) :\n    command==\"setdir\" ? (\n        is_vector(parm) ?\n            list_set(state, step, norm(state[step]) * unit(parm)) :\n            list_set(state, step, norm(state[step]) * [cos(parm),sin(parm)])\n    ) :\n    command==\"length\" ? list_set(state, step, parm*unit(state[step])) :\n    command==\"scale\" ?  list_set(state, step, parm*state[step]) :\n    command==\"addlength\" ?  list_set(state, step, state[step]+unit(state[step])*parm) :\n    command==\"arcsteps\" ? list_set(state, arcsteps, parm) :\n    command==\"arcleft\" || command==\"arcright\" ?\n        assert(is_num(parm),str(\"\\\"\",command,\"\\\" command requires a numeric radius value at index \",index))  \n        let(\n            myangle = default(parm2,state[angle]),\n            lrsign = command==\"arcleft\" ? 1 : -1,\n            radius = parm*sign(myangle),\n            center = lastpt + lrsign*radius*line_normal([0,0],state[step]),\n            steps = state[arcsteps]==0 ? segs(abs(radius)) : state[arcsteps], \n            arcpath = myangle == 0 || radius == 0 ? [] : arc(\n                steps,\n                points = [\n                    lastpt,\n                    rot(cp=center, p=lastpt, a=sign(parm)*lrsign*myangle/2),\n                    rot(cp=center, p=lastpt, a=sign(parm)*lrsign*myangle)\n                ]\n            )\n        )\n        list_set(\n            state, [path,step], [\n                concat(state[path], list_tail(arcpath)),\n                rot(lrsign * myangle,p=state[step])\n            ]\n        ) :\n    command==\"arcleftto\" || command==\"arcrightto\" ?\n        assert(is_num(parm),str(\"\\\"\",command,\"\\\" command requires a numeric radius value at index \",index))\n        assert(is_num(parm2),str(\"\\\"\",command,\"\\\" command requires a numeric angle value at index \",index))\n        let(\n            radius = parm,\n            lrsign = command==\"arcleftto\" ? 1 : -1,\n            center = lastpt + lrsign*radius*line_normal([0,0],state[step]),\n            steps = state[arcsteps]==0 ? segs(abs(radius)) : state[arcsteps],\n            start_angle = posmod(atan2(state[step].y, state[step].x),360),\n            end_angle = posmod(parm2,360),\n            delta_angle =  -start_angle + (lrsign * end_angle < lrsign*start_angle ? end_angle+lrsign*360 : end_angle),\n            arcpath = delta_angle == 0 || radius==0 ? [] : arc(\n                steps,\n                points = [\n                    lastpt,\n                    rot(cp=center, p=lastpt, a=sign(radius)*delta_angle/2),\n                    rot(cp=center, p=lastpt, a=sign(radius)*delta_angle)\n                ]\n            )\n        )\n        list_set(\n            state, [path,step], [\n                concat(state[path], list_tail(arcpath)),\n                rot(delta_angle,p=state[step])\n            ]\n        ) :\n    assert(false,str(\"Unknown turtle command \\\"\",command,\"\\\" at index\",index))\n    [];\n\n\n// Section: Debugging polygons\n\n// Module: debug_polygon()\n// Synopsis: Draws an annotated polygon.\n// SynTags: Geom\n// Topics: Shapes (2D)\n// See Also: debug_vnf(), debug_bezier()\n//\n// Usage:\n//   debug_polygon(points, paths, [vertices=], [edges=], [convexity=], [size=]);\n// Description:\n//   A drop-in replacement for `polygon()` that renders and labels the path points and\n//   edges.  The start of each path is marked with a blue circle and the end with a pink diamond.\n//   You can suppress the display of vertex or edge labeling using the `vertices` and `edges` arguments.\n// Arguments:\n//   points = The array of 2D polygon vertices.\n//   paths = The path connections between the vertices.\n//   ---\n//   vertices = if true display vertex labels and start/end markers.  Default: true\n//   edges = if true display edge labels.  Default: true\n//   convexity = The max number of walls a ray can pass through the given polygon paths.\n//   size = The base size of the line and labels.\n// Example(Big2D):\n//   debug_polygon(\n//       points=concat(\n//           regular_ngon(or=10, n=8),\n//           regular_ngon(or=8, n=8)\n//       ),\n//       paths=[\n//           [for (i=[0:7]) i],\n//           [for (i=[15:-1:8]) i]\n//       ]\n//   );\nmodule debug_polygon(points, paths, vertices=true, edges=true, convexity=2, size=1)\n{\n    no_children($children);\n    paths = is_undef(paths)? [count(points)] :\n        is_num(paths[0])? [paths] :\n        paths;\n    echo(points=points);\n    echo(paths=paths);\n    linear_extrude(height=0.01, convexity=convexity, center=true) {\n        polygon(points=points, paths=paths, convexity=convexity);\n    }\n    dups = vector_search(points, EPSILON, points);\n    \n    if (vertices) color(\"red\") {\n        for (ind=dups){\n            numstr = str_join([for(i=ind) str(i)],\",\");\n            up(0.2) {\n                translate(points[ind[0]]) {\n                    linear_extrude(height=0.1, convexity=10, center=true) {\n                        text(text=numstr, size=size, halign=\"center\", valign=\"center\");\n                    }\n                }\n            }\n        }\n    }\n    if (edges)\n    for (j = [0:1:len(paths)-1]) {\n        path = paths[j];\n        if (vertices){\n            translate(points[path[0]]) {\n                color(\"cyan\") up(0.1) cylinder(d=size*1.5, h=0.01, center=false, $fn=12);\n            }\n            translate(points[path[len(path)-1]]) {\n                color(\"pink\") up(0.11) cylinder(d=size*1.5, h=0.01, center=false, $fn=4);\n            }\n        }\n        for (i = [0:1:len(path)-1]) {\n            midpt = (points[path[i]] + points[path[(i+1)%len(path)]])/2;\n            color(\"blue\") {\n                up(0.2) {\n                    translate(midpt) {\n                        linear_extrude(height=0.1, convexity=10, center=true) {\n                            text(text=str(chr(65+j),i), size=size/2, halign=\"center\", valign=\"center\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-14", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: fnliterals.scad\n//   Handlers for function literals, and Function literal generators.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/fnliterals.scad>\n// FileGroup: Data Management\n// FileSummary: Function Literal Algorithms, and factories for generating function literals for builtin functions.\n// DefineHeader(Table;Headers=Positional|Definition||Named|Definition): FunctionLiteral Args\n//////////////////////////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Function Literal Algorithms\n\n\n// Function: map()\n// Synopsis: Applies a function to each item in a list.\n// Topics: Function Literals, Looping\n// See Also: filter(), reduce(), accumulate(), while(), for_n()\n// Usage:\n//   lst = map(func, list);\n//   lst = map(function (x) x+1, list);\n// Description:\n//   Applies the function `func` to all items in `list`, returning the list of results.\n//   In pseudo-code, this is effectively:\n//   ```\n//   function map(func,list):\n//       out = [];\n//       foreach item in list:\n//           append func(item) to out;\n//       return out;\n//   ```\n// Arguments:\n//   func = The function of signature (x) to evaluate for each item in `list`.\n//   list = The input list.\n// Example:\n//   func = function(x) x*x;\n//   echo(map(func, [1,2,3,4]));\n//   // ECHO: [1,4,9,16]\n// Example:\n//   path = star(n=5,step=2,d=100);\n//   seglens = map(function (p) norm(p[1]-p[0]), pair(path,wrap=true));\nfunction map(func, list) =\n    assert(is_function(func))\n    assert(is_list(list))\n    [for (x=list) func(x)];\n\n\n// Function: filter()\n// Synopsis: Returns just the list items which the given function returns true for.\n// Topics: Function Literals, Looping, Filters\n// See Also: map(), reduce(), accumulate(), while(), for_n(), find_all()\n// Usage:\n//   lst = filter(func, list);\n//   lst = filter(function (x) x>1, list);\n// Description:\n//   Returns all items in `list` that the function `func` returns true for.\n//   In pseudo-code, this is effectively:\n//   ```\n//   function filter(func,list):\n//       out = [];\n//       foreach item in list:\n//           if func(item) is true:\n//               append item to out;\n//       return out;\n//   ```\n// Arguments:\n//   func = The function of signature `function (x)` to evaluate for each item in `list`.\n//   list = The input list.\n// Example:\n//   func = function(x) x>5;\n//   echo(filter(func, [3,4,5,6,7]));\n//   // ECHO: [6,7]\nfunction filter(func, list) =\n    assert(is_function(func))\n    assert(is_list(list))\n    [for (x=list) if (func(x)) x];\n\n\n// Function: reduce()\n// Synopsis: Applies a 2-arg function cumulatively to the items of a list, returning the final result.\n// Topics: Function Literals, Looping\n// See Also: map(), filter(), accumulate(), while(), for_n()\n// Usage:\n//   res = reduce(func, list, [init]);\n//   res = reduce(function (a,b) a+b, list, <init=);\n// Description:\n//   First the accumulator is set to the value in `init`.  Then, for each item in `list`, the function\n//   in `func` is called with the accumulator and that list item, and the result is stored in the\n//   acumulator for the next iteration.  Once all list items have been processed, the value in the\n//   accumulator is returned.  Ie: `reduce(function (a,b) a+b, list)` is the equivalent of `sum(list)`.\n//   In pseduo-code, this is effectively:\n//   ```\n//   function reduce(func, list, init=0):\n//       x = init;\n//       foreach item in list:\n//           x = func(x, item);\n//       return x;\n//   ```\n// Arguments:\n//   func = The function of signature `function (x)` to evaluate for each item in `list`.\n//   list = The input list.\n//   init = The starting value for the accumulator.  Default: 0\n// Example: Re-Implement sum()\n//   x = reduce(f_add(),[3,4,5]);  // Returns: 12\n// Example: Re-Implement product()\n//   x = reduce(f_mul(),[3,4,5]);  // Returns: 60\n// Example: Re-Implement all()\n//   x = reduce(f_and(),[true,true,true]);   // Returns: true\n//   y = reduce(f_and(),[true,false,true]);  // Returns: false\n// Example: Re-Implement any()\n//   x = reduce(f_or(),[false,false,false]); // Returns: false\n//   y = reduce(f_or(),[true,false,true]);   // Returns: true\nfunction reduce(func, list, init=0) =\n    assert(is_function(func))\n    assert(is_list(list))\n    let(\n        l = len(list),\n        a = function (x,i) i<l? a(func(x,list[i]), i+1) : x\n    ) a(init,0);\n\n\n// Function: accumulate()\n// Synopsis: Applies a 2-arg function cumulatively to the items of a list, returning a list of every result.\n// Topics: Function Literals, Looping\n// See Also: map(), filter(), reduce(), while(), for_n()\n// Usage:\n//   res = accumulate(func, list, [init]);\n//   res = accumulate(function (a,b) a+b, list, [init=]);\n// Description:\n//   First the accumulator is set to the value in `init`.  Then, for each item in `list`, the function\n//   in `func` is called with the accumulator and that list item, and the result is stored in the\n//   acumulator for the next iteration.  That value is also appended to the output list.  Once all\n//   list items have been processed, the list of accumulator values is returned.\n//   In pseduo-code, this is effectively:\n//   ```\n//   function accumulate(func, list, init=0):\n//       out = []\n//       x = init;\n//       foreach item in list:\n//           x = func(x, item);\n//           append x to out;\n//       return out;\n//   ```\n// Arguments:\n//   func = The function of signature `function (a,b)` to evaluate for each item in `list`.  Default: `f_add()`\n//   list = The input list.\n//   init = The starting value for the accumulator.  Default: 0\n// Example: Reimplement cumsum()\n//   echo(accumulate(function (a,b) a+b, [3,4,5],0));  // ECHO: [3,7,12]\n// Example: Reimplement cumprod()\n//   echo(accumulate(f_mul(),[3,4,5],1)); // ECHO: [3,12,60,360]\nfunction accumulate(func, list, init=0) =\n    assert(is_function(func))\n    assert(is_list(list))\n    let(\n        l = len(list),\n        a = function (x, i, out)\n            i >= l ? out :\n            let( x=func(x,list[i]) )\n            a(x, i+1, [each out, x])\n    ) a(init, 0, []);\n\n\n// Function: while()\n// Synopsis: While a `cond` function returns true, iteratively calls a work function, returning the final result.\n// Topics: Function Literals, Looping, Iteration\n// See Also: map(), filter(), reduce(), accumulate(), while(), for_n()\n// Usage:\n//   x = while(init, cond, func);\n// Description:\n//   Repeatedly calls the function literals in `cond` and `func` until the `cond` call returns false.\n//   Both `cond` and `func` have the signature `function (i,x)`. The variable `i` is passed the iteration\n//   number, starting with 0.  On the first iteration, the variable `x` is given by `init`.  On subsequent\n//   iterations, `x` is given by the results of the previous call to `func`.  Returns the resulting `x` of\n//   the final iteration.  In pseudo-code, this is effectively:\n//   ```\n//   function while(init, cond, func):\n//       x = init;\n//       i = 0;\n//       while cond(i, x):\n//           x = func(i, x);\n//           i = i + 1;\n//       return x;\n//   ```\n// Arguments:\n//   init = The initial value for `x`.\n//   cond = A function literal with signature `function (i,x)`, called to determine if the loop should continue.  Returns true if the loop should continue.\n//   func = A function literal with signature `function (i,x)`, called on each iteration.  The returned value is passed as `x` on the next iteration.\n// Example:\n//   fibs = while(\n//       init = [1,1],\n//       cond = function (i,x) select(x,-1)<25,\n//       func = function (i,x) concat(x, [sum(select(x,-2,-1))])\n//   );  // Returns: [1,1,2,3,5,8,13,21]\nfunction while(init, cond, func) =\n    assert(is_function(cond))\n    assert(is_function(func))\n    let( a = function(x,i) cond(i,x) ? a(func(i,x),i+1) : x )\n    a(init,0);\n\n\n// Function: for_n()\n// Synopsis: Iteratively calls a work function `n` times, returning the final result.\n// Topics: Function Literals, Looping, Iteration\n// See Also: map(), filter(), reduce(), accumulate(), while()\n// Usage:\n//   x = for_n(n, init, func);\n// Description:\n//   Given the function literal `func`, with the signature `function (i,x)`, repeatedly calls it `n` times.\n//   If `n` is given as a scalar, the `i` value will traverse the range `[0:1:n-1]`, one value per call.\n//   If `n` is given as a range, the `i` value will traverse the given range, one value per call.\n//   The `x` value for the first  iteration is given in `init`, and in all subsequent iterations `x` will be the result of the previous call.\n//   In pseudo-code, this is effectively:\n//   ```\n//   function for_n(n, init, func):\n//       x = init;\n//       if is_range(n):\n//           iterate i over range n:\n//               x = func(i,x);\n//       else:\n//           iterate i from 0 to n-1 by 1:\n//               x = func(i,x);\n//       return x;\n//   ```\n// Arguments:\n//   n = The number of iterations to perform, or, if given as a range, the range to traverse.\n//   init = The initial value to pass as `x` to the function in `func`.\n//   func = The function literal to call, with signature `function (i,x)`.\n// Example:\n//   fib = function(n) for_n(\n//       n, [],\n//       function(i,x) x? [x[1], x[0]+x[1]] : [0,1]\n//   )[1];\nfunction for_n(n,init,func) =\n    assert(is_finite(n))\n    assert(is_function(func))\n    let(\n        n = is_num(n)? [0:1:n-1] : n,\n        a = function(x,i) i <= n[2]? a(func(i,x), i+n[1]) : x\n    )\n    a(init, n[0]);\n\n\n// Function: find_all()\n// Synopsis: Returns the indices of all items in a list that a given function returns true for.\n// Topics: Function Literals, Looping, Filters\n// See Also: find_all(), reduce(), find_first(), binsearch()\n// Usage:\n//   indices = find_all(func, list);\n//   indices = find_all(function (x) x>1, list);\n// Description:\n//   Returns the indices of all items in `list` that the function `func` returns true for.\n//   In pseudo-code, this is effectively:\n//   ```\n//   function find_all(func,list):\n//       out = [];\n//       foreach item in list:\n//           if func(item) is true:\n//               append item index to out;\n//       return out;\n//   ```\n// Arguments:\n//   func = The function of signature `function (x)` to evaluate for each item in `list`.\n//   list = The input list.\n// Example:\n//   func = function(x) x>5;\n//   echo(find_all(func, [3,4,5,6,7]));\n//   // ECHO: [3,4]\nfunction find_all(func, list) =\n    assert(is_function(func))\n    assert(is_list(list))\n    [for (indexnum=idx(list)) if (func(list[indexnum])) indexnum];\n\n\n// Function: find_first()\n// Synopsis: Returns the index of the first item in a list, after `start`, that a given function returns true for.\n// Topics: Function Literals, Searching\n// See Also: find_all(), filter(), binsearch(), find_all()\n// Usage:\n//   idx = find_first(func, list, [start=]);\n// Description:\n//   Finds the index of the first item in `list`, after index `start`,  which the function literal in `func` will return true for.\n//   The signature of the function literal in `func` is `function (x)`, and it is expected to return true when the\n//   value compares as matching.  It should return false otherwise.  If you need to find *all* matching items in the\n//   list, you should use {{find_all()}} instead.\n// Arguments:\n//   func = The function literal to use to check each item in `list`.  Expects the signature `function (x)`, and a boolean return value.\n//   list = The list to search.\n//   ---\n//   start = The first item to check.\n// Example:\n//   data = [8,5,3,7,4,2,9];\n//   echo(find_first(f_lte(4), data));\n//   // ECHO: 2\n// Example:\n//   data = [8,5,3,7,4,2,9];\n//   echo(find_first(f_lte(4), data, start=3));\n//   // ECHO: 4\nfunction find_first(func, list, start=0) =\n    assert(is_function(func))\n    assert(is_list(list))\n    assert(is_finite(start))\n    let(\n        listlen = len(list),\n        _find_first = function(indexnum) (\n            indexnum >= listlen? undef :\n            func(list[indexnum])? indexnum :\n            _find_first(indexnum+1)\n        )\n    )\n    _find_first(start);\n\n\n// Function: binsearch()\n// Synopsis: Does a binary search of a sorted list to find the index of a given value.\n// Topics: Function Literals, Data Structures, Searching\n// See Also: map(), filter(), reduce(), accumulate(), hashmap(), find_all(), find_first()\n// Usage:\n//   idx = binsearch(key,list, [cmp]);\n// Description:\n//   Searches a sorted list for an entry with the given key, using a binary search strategy.\n//   Returns the index of the matching item found.  If none found, returns undef.\n// Arguments:\n//   key = The key to look for.\n//   list = The list of items to search through.\n//   idx = If given, the index of the item sublists to use as the item key.\n//   cmp = The comparator function literal to use.  Default: `f_cmp()`\n// Example:\n//   items = unique(rands(0,100,10000));\n//   idx = binsearch(44, items);\n// Example:\n//   items = unique(rands(0,100,10000));\n//   idx = binsearch(44, items, cmp=function(a,b) a-b);\n// Example:\n//   items = [for (i=[32:126]) [chr(i), i]];\n//   idx = binsearch(\"G\", items, idx=0);\nfunction binsearch(key, list, idx, cmp=f_cmp()) =\n    let(\n        a = function(s,e)\n            let(\n                p = floor((s+e)/2),\n                ikey = is_undef(idx)? list[p] : list[p][idx],\n                c = cmp(ikey,key)\n            )\n            c == 0? p :\n            c > 0? (p == s? undef : a(s, p-1)) :\n            (p == e? undef : a(p+1, e))\n    ) a(0,len(list)-1);\n\n\n// Function: simple_hash()\n// Synopsis: Returns an integer hash of a given value.\n// Topics: Function Literals, Hashing, Data Structures\n// See Also: hashmap()\n// Usage:\n//   hx = simple_hash(x);\n// Description:\n//   Given an arbitrary value, returns the integer hash value for it.\n// Arguments:\n//   x = The value to get the simple hash value  of.\n// Example:\n//   x = simple_hash(\"Foobar\");\n//   x = simple_hash([[10,20],[-5,3]]);\nfunction simple_hash(x) =\n    let( m = 0.5 * (sqrt(5) - 1) )\n    is_num(x)? floor(m*x*256) :\n    is_list(x)? let(\n        l = len(x),\n        a = function(i,v) i>=l? v : a(i+1, m*v + simple_hash(x[i]))\n    ) floor(a(0,0)*4096) : let(\n        s = str(x),\n        l = len(s),\n        a = function(i,v) i>=l? v : a(i+1, m*v + ord(s[i]))\n    ) floor(a(0,0)*4096);\n\n\n// Function: hashmap()\n// Synopsis: Creates a hashmap manipulation function.\n// Topics: Function Literals, Data Structures, Hashing\n// See Also: simple_hash()\n// Usage: Creating an Empty HashMap.\n//   hm = hashmap([hashsize=]);\n// Usage: Creating a Populated HashMap.\n//   hm = hashmap(items=KEYVAL_LIST, [hashsize=]);\n// Usage: Adding an Entry\n//   hm2 = hm(key, val);\n// Usage: Adding Multiple Entries\n//   hm2 = hm(additems=KEYVAL_LIST);\n// Usage: Removing an Entry\n//   hm2 = hm(del=KEY);\n// Usage: Fetching a Value\n//   x = hm(key);\n// Usage: Iterating a HashMap\n//   for (kv=hm()) let(k=kv[0], v=kv[1]) ...\n// Description:\n//   This is a factory function for creating hashmap data structure functions.  You can use a hashmap\n//   to store large amounts of [key,value] data.  At around 4000 items, this becomes faster than using\n//   `search()` through the list.\n// Arguments:\n//   ---\n//   hashsize = The number of hashtable buckets to form.\n//   items = A list of [key,value] pairs to initialize the hashmap with.\n// FunctionLiteral Args:\n//   k = The key name.\n//   v = The value to store with the key.\n//   ---\n//   del = If given the key of an item to delete, makes a new hashmap with that item removed.\n//   additems = If given a list of [key,val] pairs, makes a new hashmap with the items added.\n// Example:\n//   hm = hashmap(items=[for (i=[0:9999]) [str(\"foo\",i),i]]);\n//   a = hm(\"foo37\");  // Returns: 37\n//   hm2 = hm(\"Blah\", 39);  // Adds entry \"Blah\" with val 39.\n//   b = hm2(\"Blah\");  // Returns: 39\n//   hm3 = hm2(additems=[[\"bar\",39],[\"qux\",21]]);  // Adds \"bar\" and \"qux\"\n//   hm4 = hm3(del=\"Blah\");  // Deletes entry \"Blah\".\n//   for (kv = hm4()) {  // Iterates over all key/value pairs.\n//      echo(key=kv[0], val=kv[1]);\n//   }\nfunction hashmap(hashsize=127,items,table) =\n    let(\n        table = !is_undef(table)? table : [for (i=[0:1:hashsize-1]) []]\n    )\n    items != undef? hashmap(hashsize=hashsize, table=table)(additems=items) :\n    function(k,v,del,additems)\n        additems!=undef? let(\n            hashes = [for (item = additems) simple_hash(item[0]) % hashsize],\n            grouped = list_pad(group_data(hashes, additems), hashsize, []),\n            table = [for (i=idx(table)) concat(table[i],grouped[i])]\n        ) hashmap(hashsize=hashsize, table=table) :\n        del!=undef? let(\n            bnum = simple_hash(del) % hashsize,\n            bucket = [for (item=table[bnum]) if (item[0]!=del) item],\n            table = [for (i=idx(table)) i==bnum? bucket : table[i]]\n        ) hashmap(hashsize=hashsize, table=table) :\n        k==undef && v==undef? [for (bucket=table, item=bucket) item] :\n        let(\n            bnum = simple_hash(k) % hashsize,\n            bucket = table[bnum],\n            fnd = search([k], bucket)\n        )\n        k!=undef && v==undef? (fnd==[]? undef : bucket[fnd[0]][1]) :\n        let(\n            newtable = [\n                for (i=idx(table))\n                i!=bnum? table[i] :\n                !fnd? [[k,v], each bucket] :\n                [[k,v], for (j=idx(bucket)) if (j!=fnd[0]) bucket[i]]\n            ]\n        ) hashmap(hashsize=hashsize, table=newtable);\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Function Meta-Generators\n\n\n// Function: f_1arg()\n// Synopsis: Creates a factory for a 2-arg function literal, where you can optionally pre-fill the arg.\n// Topics: Function Literals\n// See Also: f_2arg(), f_3arg()\n// Usage:\n//   fn = f_1arg(func);\n// Description:\n//   Takes a function literal that accepts one argument, and returns a function\n//   literal factory that can be used to pre-fill out that argument with a constant.\n// Example:\n//   f_str = f_1arg(function(a) str(a));\n//   fn_str = f_str();   // = function(a) str(a);\n//   fn_str3 = f_str(3); // = function() str(3);\nfunction f_1arg(target_func) =\n    function(a)\n        a==undef? function(x) target_func(x) :\n        function() target_func(a);\n\n\n// Function: f_2arg()\n// Synopsis: Creates a factory for a 2-arg function literal, where you can optionally pre-fill the args.\n// Topics: Function Literals\n// See Also: f_1arg(), f_3arg()\n// Usage:\n//   fn = f_2arg(target_func);\n// Description:\n//   Takes a function literal that accepts two arguments, and returns a function\n//   literal factory that can be used to pre-fill out one or both of those arguments\n//   with a constant.\n// Example:\n//   f_lt = f_2arg(function(a,b) a<b);\n//   fn_lt = f_lt();      // = function(a,b) a<b;\n//   fn_3lt = f_lt(3);    // = function(b) 3<b;\n//   fn_3lt = f_lt(a=3);  // = function(b) 3<b;\n//   fn_lt3 = f_lt(b=3);  // = function(a) a<3;\n//   fn_3lt4 = f_lt(3,4); // = function() 3<4;\nfunction f_2arg(target_func) =\n    function(a,b)\n        a==undef && b==undef? function(x,y) target_func(x,y) :\n        a==undef? function(x) target_func(x,b) :\n        b==undef? function(x) target_func(a,x) :\n        function() target_func(a,b);\n\n\n// Function: f_2arg_simple()\n// Synopsis: Creates a factory for a 2-arg function literal, where you can optionally pre-fill the args.\n// Topics: Function Literals\n// See Also: f_1arg(), f_3arg()\n// Usage:\n//   fn = f_2arg_simple(target_func);\n// Description:\n//   Takes a function literal that accepts two arguments, and returns a function\n//   literal factory that can be used to pre-fill out one or both of those arguments\n//   with a constant.  When given a single argument, fills out the segond function\n//   argument with a constant.\n// Example:\n//   f_lt = f_2arg_simple(function(a,b) a<b);\n//   fn_lt = f_lt();       // = function(a,b) a<b;\n//   fn_lt3 = f_lt(3);     // = function(a) a<3;\n//   fn_3lt4 = f_lt(3,4);  // = function() 3<4;\nfunction f_2arg_simple(target_func) =\n    function(a,b)\n        a==undef && b==undef? function(x,y) target_func(x,y) :\n        b==undef? function(x) target_func(x,a) :\n        function() target_func(a,b);\n\n\n// Function: f_3arg()\n// Synopsis: Creates a factory for a 3-arg function literal, where you can optionally pre-fill the args.\n// Topics: Function Literals\n// See Also: f_1arg(), f_2arg()\n// Usage:\n//   fn = f_3arg(target_func);\n// Description:\n//   Takes a function literal that accepts three arguments, and returns a function\n//   literal factory that can be used to pre-fill out some or all of those arguments\n//   with a constant.\n// Example:\n//   p1 = [10,4]; p2 = [3,7];\n//   f_va = f_3arg(function(a,b,c) vector_angle(a,b,c));\n//   fn_va = f_va();       // = function(a,b,c) vector_angle(a,b,c);\n//   fn_va2 = f_lt(c=p1);  // = function(a,b) vector_angle(a,b,p1);\n//   fn_va3 = f_lt(a=p2);  // = function(a,c) vector_angle(a,p2,c);\n//   fn_va4 = f_lt(a=p1,c=p2); // = function() vector_angle(p1,b,p2);\nfunction f_3arg(target_func) =\n    function(a,b,c)\n        a==undef && b==undef && c==undef? function(x,y,z) target_func(x,y,z) :\n        a==undef && b==undef? function(x,y) target_func(x,y,c) :\n        a==undef && c==undef? function(x,y) target_func(x,b,y) :\n        b==undef && c==undef? function(x,y) target_func(a,x,y) :\n        a==undef? function(x) target_func(x,b,c) :\n        b==undef? function(x) target_func(a,x,c) :\n        c==undef? function(x) target_func(a,b,x) :\n        function() target_func(a,b,c);\n\n\n// Function: ival()\n// Synopsis: Generates a function with signature `(i,x)` that calls `func(i)`\n// Topics: Function Literals\n// See Also: f_1arg(), f_2arg(), f_3arg(), ival(), xval()\n// Usage:\n//   newfunc = ival(func);\n// Description:\n//   Wraps a single-argument function literal so that it can take two arguments,\n//   passing the first argument along to the wrapped function.\n// Arguments:\n//   target_func = The function of signature (x) to wrap.\n// FunctionLiteral Args:\n//   a = The argument that will be passed through.\n//   b = The argumen that will be discarded.\n// Example:\n//   x = while(0, ival(f_lt(5)), xval(f_add(1)));\nfunction ival(target_func) = function(a,b) target_func(a);\n\n\n// Function: xval()\n// Synopsis: Generates a function with signature `(i,x)` that calls `func(x)`\n// Topics: Function Literals\n// See Also: f_1arg(), f_2arg(), f_3arg(), ival(), xval()\n// Usage:\n//   newfunc = xval(func);\n// Description:\n//   Wraps a single-argument function literal so that it can take two arguments,\n//   passing the first argument along to the wrapped function.\n// Arguments:\n//   target_func = The function of signature (x) to wrap.\n// FunctionLiteral Args:\n//   a = The argument that will be passed through.\n//   b = The argumen that will be discarded.\n// Example:\n//   x = while(0, ival(f_lt(5)), xval(f_add(1)));\nfunction xval(target_func) = function(a,b) target_func(b);\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Comparator Generators\n\n\n// Function: f_cmp()\n// Synopsis: Returns a function to compare values.\n// Topics: Function Literals, Comparators\n// See Also: f_cmp(), f_gt(), f_lt(), f_gte(), f_lte(), f_eq(), f_neq(), f_approx(), f_napprox()\n// Usage:\n//   fn = f_cmp();\n//   fn = f_cmp(b);\n//   fn = f_cmp(a,b);\n// Description:\n//   A factory that generates function literals that compare `a` and `b`, where one or\n//   both arguments can be replaced with constants.  If `a` and `b` are equal, the function\n//   literal will return 0.  If a<b then -1 is returned.  If a>b then 1 is returned.\n// Example:\n//   fn_cmp = f_cmp();       // = function(a,b) a==b?0: a>b?1: -1;\n//   fn_cmp3 = f_cmp(3);     // = function(a) a==3?0: a>3?1: -1;\n//   fn_3cmp4 = f_cmp(3,4);  // = function() 3==4?0: 3>4?1: -1;\nfunction f_cmp(a,b) = f_2arg_simple(function (a,b) a==b?0: a>b?1: -1)(a,b);\n\n\n// Function: f_gt()\n// Synopsis: Returns a function to compare if `a` is greater than `b`.\n// Topics: Function Literals, Comparators\n// See Also: f_cmp(), f_gt(), f_lt(), f_gte(), f_lte(), f_eq(), f_neq(), f_approx(), f_napprox()\n// Usage:\n//   fn = f_gt();\n//   fn = f_gt(b);\n//   fn = f_gt(a,b);\n// Description:\n//   A factory that generates function literals based on `a > b`, where one\n//   or both of the arguments can be replaced with constants.\n// Example:\n//   fn_gt = f_gt();       // = function(a,b) a>b;\n//   fn_gt3 = f_gt(3);     // = function(a) a>3;\n//   fn_3gt4 = f_gt(3,4);  // = function() 3>4;\nfunction f_gt(a,b) = f_2arg_simple(function (a,b) a>b)(a,b);\n\n\n// Function: f_lt()\n// Synopsis: Returns a function to compare if `a` is less than `b`.\n// Topics: Function Literals, Comparators\n// See Also: f_cmp(), f_gt(), f_lt(), f_gte(), f_lte(), f_eq(), f_neq(), f_approx(), f_napprox()\n// Usage:\n//   fn = f_lt();\n//   fn = f_lt(b);\n//   fn = f_lt(a,b);\n// Description:\n//   A factory that generates function literals based on `a < b`, where one\n//   or both of the arguments can be replaced with constants.\n// Example:\n//   fn_lt = f_lt();       // = function(a,b) a<b;\n//   fn_lt3 = f_lt(3);     // = function(a) a<3;\n//   fn_3lt4 = f_lt(3,4);  // = function() 3<4;\nfunction f_lt(a,b) = f_2arg_simple(function (a,b) a<b)(a,b);\n\n\n// Function: f_gte()\n// Synopsis: Returns a function to compare if `a` is greater than or equal to `b`.\n// Topics: Function Literals, Comparators\n// See Also: f_cmp(), f_gt(), f_lt(), f_gte(), f_lte(), f_eq(), f_neq(), f_approx(), f_napprox()\n// Usage:\n//   fn = f_gte();\n//   fn = f_gte(b);\n//   fn = f_gte(a,b);\n// Description:\n//   A factory that generates function literals based on `a >= b`, where one\n//   or both of the arguments can be replaced with constants.\n// Example:\n//   fn_gte = f_gte();       // = function(a,b) a>=b;\n//   fn_gte3 = f_gte(3);     // = function(a) a>=3;\n//   fn_3gte4 = f_gte(3,4);  // = function() 3>=4;\nfunction f_gte(a,b) = f_2arg_simple(function (a,b) a>=b)(a,b);\n\n\n// Function: f_lte()\n// Synopsis: Returns a function to compare if `a` is less than or equal to `b`.\n// Topics: Function Literals, Comparators\n// See Also: f_cmp(), f_gt(), f_lt(), f_gte(), f_lte(), f_eq(), f_neq(), f_approx(), f_napprox()\n// Usage:\n//   fn = f_lte();\n//   fn = f_lte(b);\n//   fn = f_lte(a,b);\n// Description:\n//   A factory that generates function literals based on `a <= b`, where\n//   one or both arguments can be replaced with constants.\n// Example:\n//   fn_lte = f_lte();       // = function(a,b) a<=b;\n//   fn_lte3 = f_lte(3);     // = function(a) a<=3;\n//   fn_3lte4 = f_lte(3,4);  // = function() 3<=4;\nfunction f_lte(a,b) = f_2arg_simple(function (a,b) a<=b)(a,b);\n\n\n// Function: f_eq()\n// Synopsis: Returns a function to compare if `a` is exactly equal to `b`.\n// Topics: Function Literals, Comparators\n// See Also: f_cmp(), f_gt(), f_lt(), f_gte(), f_lte(), f_eq(), f_neq(), f_approx(), f_napprox()\n// Usage:\n//   fn = f_eq();\n//   fn = f_eq(b);\n//   fn = f_eq(a,b);\n// Description:\n//   A factory that generates function literals based on `a == b`, where\n//   one or both arguments can be replaced with constants.\n// Example:\n//   fn_eq = f_eq();       // = function(a,b) a==b;\n//   fn_eq3 = f_eq(3);     // = function(a) a==3;\n//   fn_3eq4 = f_eq(3,4);  // = function() 3==4;\nfunction f_eq(a,b) = f_2arg_simple(function (a,b) a==b)(a,b);\n\n\n// Function: f_neq()\n// Synopsis: Returns a function to compare if `a` is not exactly equal to `b`.\n// Topics: Function Literals, Comparators\n// See Also: f_cmp(), f_gt(), f_lt(), f_gte(), f_lte(), f_eq(), f_neq(), f_approx(), f_napprox()\n// Usage:\n//   fn = f_neq();\n//   fn = f_neq(b);\n//   fn = f_neq(a,b);\n// Description:\n//   A factory that generates function literals based on `a != b`, where\n//   one or both arguments can be replaced with constants.\n// Example:\n//   fn_neq = f_neq();       // = function(a,b) a!=b;\n//   fn_neq3 = f_neq(3);     // = function(a) a!=3;\n//   fn_3neq4 = f_neq(3,4);  // = function() 3!=4;\nfunction f_neq(a,b) = f_2arg_simple(function (a,b) a!=b)(a,b);\n\n\n// Function: f_approx()\n// Synopsis: Returns a function to compare if `a` is approximately equal to `b`.\n// Topics: Function Literals, Comparators\n// See Also: f_cmp(), f_gt(), f_lt(), f_gte(), f_lte(), f_eq(), f_neq(), f_approx(), f_napprox()\n// Usage:\n//   fn = f_approx();\n//   fn = f_approx(b);\n//   fn = f_approx(a,b);\n// Description:\n//   A factory that generates function literals based on `approx(a,b)`, where\n//   one or both arguments can be replaced with constants.\n// Example:\n//   fn_approx = f_approx();       // = function(a,b) approx(a,b);\n//   fn_approx3 = f_approx(3);     // = function(a) approx(a,3);\n//   fn_3approx4 = f_approx(3,4);  // = function() approx(3,4);\nfunction f_approx(a,b) = f_2arg_simple(function (a,b) approx(a,b))(a,b);\n\n\n// Function: f_napprox()\n// Synopsis: Returns a function to compare if `a` is not approximately equal to `b`.\n// Topics: Function Literals, Comparators\n// See Also: f_cmp(), f_gt(), f_lt(), f_gte(), f_lte(), f_eq(), f_neq(), f_approx(), f_napprox()\n// Usage:\n//   fn = f_napprox();\n//   fn = f_napprox(b);\n//   fn = f_napprox(a,b);\n// Description:\n//   A factory that generates function literals based on `!approx(a,b)`, where\n//   one or both arguments can be replaced with constants.\n// Example:\n//   fn_napprox = f_napprox();       // = function(a,b) napprox(a,b);\n//   fn_napprox3 = f_napprox(3);     // = function(a) napprox(a,3);\n//   fn_3napprox4 = f_napprox(3,4);  // = function() napprox(3,4);\nfunction f_napprox(a,b) = f_2arg_simple(function (a,b) !approx(a,b))(a,b);\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Logic Operators\n\n\n// Function: f_or()\n// Synopsis: Returns a function to check if either `a` or `b` is true.\n// Topics: Function Literals, Logic, Boolean Operations\n// See Also: f_or(), f_and(), f_nor(), f_nand(), f_xor(), f_not()\n// Usage:\n//   fn = f_or();\n//   fn = f_or(a=);\n//   fn = f_or(b=);\n//   fn = f_or(a=,b=);\n// Description:\n//   A factory that generates function literals based on `a || b`, where\n//   either or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_or(a,b) = f_2arg(function(a,b) (a || b))(a,b);\n\n\n// Function: f_and()\n// Synopsis: Returns a function to check if both `a` and `b` are true.\n// Topics: Function Literals, Logic, Boolean Operations\n// See Also: f_or(), f_and(), f_nor(), f_nand(), f_xor(), f_not()\n// Usage:\n//   fn = f_and();\n//   fn = f_and(a=);\n//   fn = f_and(b=);\n//   fn = f_and(a=,b=);\n// Description:\n//   A factory that generates function literals based on `a && b`, where\n//   either or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_and(a,b) = f_2arg(function(a,b) (a && b))(a,b);\n\n\n// Function: f_nor()\n// Synopsis: Returns a function to check if neither `a` nor `b` are true.\n// Topics: Function Literals, Logic, Boolean Operations\n// See Also: f_or(), f_and(), f_nor(), f_nand(), f_xor(), f_not()\n// Usage:\n//   fn = f_nor();\n//   fn = f_nor(a=);\n//   fn = f_nor(b=);\n//   fn = f_nor(a=,b=);\n// Description:\n//   A factory that generates function literals based on `!(a || b)`, where\n//   either or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_nor(a,b) = f_2arg(function(a,b) !(a || b))(a,b);\n\n\n// Function: f_nand()\n// Synopsis: Returns a function to check if `a` and `b` are not both true.\n// Topics: Function Literals, Logic, Boolean Operations\n// See Also: f_or(), f_and(), f_nor(), f_nand(), f_xor(), f_not()\n// Usage:\n//   fn = f_nand();\n//   fn = f_nand(a=);\n//   fn = f_nand(b=);\n//   fn = f_nand(a=,b=);\n// Description:\n//   A factory that generates function literals based on `!(a && b)`, where\n//   either or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_nand(a,b) = f_2arg(function(a,b) !(a && b))(a,b);\n\n\n// Function: f_xor()\n// Synopsis: Returns a function to check if either `a` or `b`, but not both, are true.\n// Topics: Function Literals, Logic, Boolean Operations\n// See Also: f_or(), f_and(), f_nor(), f_nand(), f_xor(), f_not()\n// Usage:\n//   fn = f_xor();\n//   fn = f_xor(a=);\n//   fn = f_xor(b);\n//   fn = f_xor(a=,b=);\n// Description:\n//   A factory that generates function literals based on `(!a && b) || (a && !b)`, where\n//   either or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_xor(a,b) = f_2arg(function(a,b) (!a && b) || (a && !b))(a,b);\n\n\n// Function: f_not()\n// Synopsis: Returns a function to check if `a` is not true.\n// Topics: Function Literals, Logic, Boolean Operations\n// See Also: f_or(), f_and(), f_nor(), f_nand(), f_xor(), f_not()\n// Usage:\n//   fn = f_not();\n//   fn = f_not(a);\n// Description:\n//   A factory that generates function literals based on `!a`, where the `a`\n//   argument can be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_not(a) = f_1arg(function(a) !a)(a);\n\n\n// Function: f_even()\n// Synopsis: Returns a function to check if `a` is an even number.\n// Topics: Function Literals, Math Operators\n// See Also: f_even(), f_odd()\n// Usage:\n//   fn = f_even();\n//   fn = f_even(a);\n// Description:\n//   A factory that generates function literals based on `a % 2 == 0`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\n// Example:\n//   l2 = filter(f_even(), [3,4,5,6,7,8]);  // Returns: [4,6,8]\nfunction f_even(a) = f_1arg(function(a) a % 2 == 0)(a);\n\n\n// Function: f_odd()\n// Synopsis: Returns a function to check if `a` is an odd number.\n// Topics: Function Literals, Math Operators\n// See Also: f_even(), f_odd()\n// Usage:\n//   fn = f_odd();\n//   fn = f_odd(a);\n// Description:\n//   A factory that generates function literals based on `a % 2 != 0`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\n// Example:\n//   l2 = filter(f_odd(), [3,4,5,6,7,8]);  // Returns: [3,5,7]\nfunction f_odd(a) = f_1arg(function(a) a % 2 != 0)(a);\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Math Operators\n\n\n// Function: f_add()\n// Synopsis: Returns a function to add `a` and `b`.\n// Topics: Function Literals, Math Operators\n// See Also: f_add(), f_sub(), f_mul(), f_div(), f_mod(), f_pow(), f_neg()\n// Usage:\n//   fn = f_add();\n//   fn = f_add(a=);\n//   fn = f_add(b);\n//   fn = f_add(a=,b=);\n// Description:\n//   A factory that generates function literals based on `a + b`, where either\n//   or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_add(a,b) = f_2arg(function(a,b) a + b)(a,b);\n\n\n// Function: f_sub()\n// Synopsis: Returns a function to subtract `a` from `b`.\n// Topics: Function Literals, Math Operators\n// See Also: f_add(), f_sub(), f_mul(), f_div(), f_mod(), f_pow(), f_neg()\n// Usage:\n//   fn = f_sub();\n//   fn = f_sub(a=);\n//   fn = f_sub(b);\n//   fn = f_sub(a=,b=);\n// Description:\n//   A factory that generates function literals based on `a - b`, where either\n//   or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_sub(a,b) = f_2arg(function(a,b) a - b)(a,b);\n\n\n// Function: f_mul()\n// Synopsis: Returns a function to multiply `a` by `b`.\n// Topics: Function Literals, Math Operators\n// See Also: f_add(), f_sub(), f_mul(), f_div(), f_mod(), f_pow(), f_neg()\n// Usage:\n//   fn = f_mul();\n//   fn = f_mul(a=);\n//   fn = f_mul(b);\n//   fn = f_mul(a=,b=);\n// Description:\n//   A factory that generates function literals based on `a * b`, where either\n//   or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_mul(a,b) = f_2arg(function(a,b) a * b)(a,b);\n\n\n// Function: f_div()\n// Synopsis: Returns a function to divide `a` by `b`.\n// Topics: Function Literals, Math Operators\n// See Also: f_add(), f_sub(), f_mul(), f_div(), f_mod(), f_pow(), f_neg()\n// Usage:\n//   fn = f_div();\n//   fn = f_div(a=);\n//   fn = f_div(b);\n//   fn = f_div(a=,b=);\n// Description:\n//   A factory that generates function literals based on `a / b`, where either\n//   or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_div(a,b) = f_2arg(function(a,b) a / b)(a,b);\n\n\n// Function: f_mod()\n// Synopsis: Returns a function to calculate the modulo of `a` divided by `b`.\n// Topics: Function Literals, Math Operators\n// See Also: f_add(), f_sub(), f_mul(), f_div(), f_mod(), f_pow(), f_neg()\n// Usage:\n//   fn = f_mod();\n//   fn = f_mod(a=);\n//   fn = f_mod(b);\n//   fn = f_mod(a=,b=);\n// Description:\n//   A factory that generates function literals based on `a % b`, where either\n//   or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_mod(a,b) = f_2arg(function(a,b) a % b)(a,b);\n\n\n// Function: f_pow()\n// Synopsis: Returns a function to calculate `a` to the power of `b`.\n// Topics: Function Literals, Math Operators\n// See Also: f_add(), f_sub(), f_mul(), f_div(), f_mod(), f_pow(), f_neg()\n// Usage:\n//   fn = f_pow();\n//   fn = f_pow(a=);\n//   fn = f_pow(b);\n//   fn = f_pow(a=,b=);\n// Description:\n//   A factory that generates function literals based on `pow(a,b)`, where either\n//   or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_pow(a,b) = f_2arg(function(a,b) pow(a,b))(a,b);\n\n\n// Function: f_neg()\n// Synopsis: Returns a function to calculate `-a`\n// Topics: Function Literals, Math Operators\n// See Also: f_add(), f_sub(), f_mul(), f_div(), f_mod(), f_pow(), f_neg()\n// Usage:\n//   fn = f_neg();\n//   fn = f_neg(a);\n// Description:\n//   A factory that generates function literals based on `-a`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_neg(a) = f_1arg(function(a) -a)(a);\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Min/Max Operators\n\n\n// Function: f_min()\n// Synopsis: Returns a function to calculate the minimum value of a list.\n// Topics: Function Literals, Math Operators\n// See Also: f_min(), f_max(), f_min2(), f_max2(), f_min3(), f_max3()\n// Usage:\n//   fn = f_min();\n//   fn = f_min(a);\n// Description:\n//   A factory that generates function literals based on `min(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_min(a) = f_1arg(function(a) min(a))(a);\n\n\n// Function: f_max()\n// Synopsis: Returns a function to calculate the maximum value of a list.\n// Topics: Function Literals, Math Operators\n// See Also: f_min(), f_max(), f_min2(), f_max2(), f_min3(), f_max3()\n// Usage:\n//   fn = f_max();\n//   fn = f_max(a);\n// Description:\n//   A factory that generates function literals based on `max(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_max(a) = f_1arg(function(a) max(a))(a);\n\n\n// Function: f_min2()\n// Synopsis: Returns a function to calculate the minimum of two values.\n// Topics: Function Literals, Math Operators\n// See Also: f_min(), f_max(), f_min2(), f_max2(), f_min3(), f_max3()\n// Usage:\n//   fn = f_min2();\n//   fn = f_min2(a=);\n//   fn = f_min2(b);\n//   fn = f_min2(a=,b=);\n// Description:\n//   A factory that generates function literals based on `min(a,b)`, where either\n//   or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_min2(a,b) = f_2arg(function(a,b) min(a,b))(a,b);\n\n\n// Function: f_max2()\n// Synopsis: Returns a function to calculate the maximum of two values.\n// Topics: Function Literals, Math Operators\n// See Also: f_min(), f_max(), f_min2(), f_max2(), f_min3(), f_max3()\n// Usage:\n//   fn = f_max2();\n//   fn = f_max2(a=);\n//   fn = f_max2(b);\n//   fn = f_max2(a=,b=);\n// Description:\n//   A factory that generates function literals based on `max(a,b)`, where either\n//   or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_max2(a,b) = f_2arg(function(a,b) max(a,b))(a,b);\n\n\n// Function: f_min3()\n// Synopsis: Returns a function to calculate the minimum of three values.\n// Topics: Function Literals, Math Operators\n// See Also: f_min(), f_max(), f_min2(), f_max2(), f_min3(), f_max3()\n// Usage:\n//   fn = f_min3();\n//   fn = f_min3(a=);\n//   fn = f_min3(b=);\n//   fn = f_min3(c=);\n//   fn = f_min3(a=,b=);\n//   fn = f_min3(b=,c=);\n//   fn = f_min3(a=,c=);\n//   fn = f_min3(a=,b=,c=);\n// Description:\n//   A factory that generates function literals based on `min(a,b,c)`, where any\n//   or all of the `a`, `b`, or`c` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\n//   c = If given, replaces the third argument.\nfunction f_min3(a,b,c) = f_3arg(function(a,b,c) min(a,b,c))(a,b,c);\n\n\n// Function: f_max3()\n// Synopsis: Returns a function to calculate the maximum of three values.\n// Topics: Function Literals, Math Operators\n// See Also: f_min(), f_max(), f_min2(), f_max2(), f_min3(), f_max3()\n// Usage:\n//   fn = f_max3();\n//   fn = f_max3(a=);\n//   fn = f_max3(b=);\n//   fn = f_max3(c=);\n//   fn = f_max3(a=,b=);\n//   fn = f_max3(b=,c=);\n//   fn = f_max3(a=,c=);\n//   fn = f_max3(a=,b=,c=);\n// Description:\n//   A factory that generates function literals based on `min(a,b,c)`, where any\n//   or all of the `a`, `b`, or`c` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\n//   c = If given, replaces the third argument.\nfunction f_max3(a,b,c) = f_3arg(function(a,b,c) max(a,b,c))(a,b,c);\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Trigonometry Operators\n\n\n// Function: f_sin()\n// Synopsis: Returns a function to calculate the sine of a value.\n// Topics: Function Literals, Math Operators\n// See Also: f_sin(), f_cos(), f_tan(), f_asin(), f_acos(), f_atan(), f_atan2()\n// Usage:\n//   fn = f_sin();\n//   fn = f_sin(a);\n// Description:\n//   A factory that generates function literals based on `sin(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_sin(a)  = f_1arg(function(a) sin(a))(a);\n\n\n// Function: f_cos()\n// Synopsis: Returns a function to calculate the cosine of a value.\n// Topics: Function Literals, Math Operators\n// See Also: f_sin(), f_cos(), f_tan(), f_asin(), f_acos(), f_atan(), f_atan2()\n// Usage:\n//   fn = f_cos();\n//   fn = f_cos(a);\n// Description:\n//   A factory that generates function literals based on `cos(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_cos(a)  = f_1arg(function(a) cos(a))(a);\n\n\n// Function: f_tan()\n// Synopsis: Returns a function to calculate the tangent of a value.\n// Topics: Function Literals, Math Operators\n// See Also: f_sin(), f_cos(), f_tan(), f_asin(), f_acos(), f_atan(), f_atan2()\n// Usage:\n//   fn = f_tan();\n//   fn = f_tan(a);\n// Description:\n//   A factory that generates function literals based on `tan(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_tan(a)  = f_1arg(function(a) tan(a))(a);\n\n\n// Function: f_asin()\n// Synopsis: Returns a function to calculate the arcsine of a value.\n// Topics: Function Literals, Math Operators\n// See Also: f_sin(), f_cos(), f_tan(), f_asin(), f_acos(), f_atan(), f_atan2()\n// Usage:\n//   fn = f_asin();\n//   fn = f_asin(a);\n// Description:\n//   A factory that generates function literals based on `asin(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_asin(a) = f_1arg(function(a) asin(a))(a);\n\n\n// Function: f_acos()\n// Synopsis: Returns a function to calculate the arccosine of a value.\n// Topics: Function Literals, Math Operators\n// See Also: f_sin(), f_cos(), f_tan(), f_asin(), f_acos(), f_atan(), f_atan2()\n// Usage:\n//   fn = f_acos();\n//   fn = f_acos(a);\n// Description:\n//   A factory that generates function literals based on `acos(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_acos(a) = f_1arg(function(a) acos(a))(a);\n\n\n// Function: f_atan()\n// Synopsis: Returns a function to calculate the arctangent of a value.\n// Topics: Function Literals, Math Operators\n// See Also: f_sin(), f_cos(), f_tan(), f_asin(), f_acos(), f_atan(), f_atan2()\n// Usage:\n//   fn = f_atan();\n//   fn = f_atan(a);\n// Description:\n//   A factory that generates function literals based on `atan(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_atan(a) = f_1arg(function(a) atan(a))(a);\n\n\n// Function: f_atan2()\n// Synopsis: Returns a function to calculate the arctangent of `y` and `x`\n// Topics: Function Literals, Math Operators\n// See Also: f_sin(), f_cos(), f_tan(), f_asin(), f_acos(), f_atan(), f_atan2()\n// Usage:\n//   fn = f_atan2();\n//   fn = f_atan2(a=);\n//   fn = f_atan2(b);\n//   fn = f_atan2(a=,b=);\n// Description:\n//   A factory that generates function literals based on `atan2(a,b)`, where either\n//   or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_atan2(a,b) = f_2arg(function(a,b) atan2(a,b))(a,b);\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: String Operators\n\n\n// Function: f_len()\n// Synopsis: Returns a function to calculate the length of a string or list.\n// Topics: Function Literals, String Operators\n// See Also: f_len(), f_chr(), f_ord(), f_str(), f_str2(), f_str3()\n// Usage:\n//   fn = f_len();\n//   fn = f_len(a);\n// Description:\n//   A factory that generates function literals based on `len(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_len(a) = f_1arg(function(a) len(a))(a);\n\n\n// Function: f_chr()\n// Synopsis: Returns a function to get a string character from its ordinal number.\n// Topics: Function Literals, String Operators\n// See Also: f_len(), f_chr(), f_ord(), f_str(), f_str2(), f_str3()\n// Usage:\n//   fn = f_chr();\n//   fn = f_chr(a);\n// Description:\n//   A factory that generates function literals based on `chr(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_chr(a) = f_1arg(function(a) chr(a))(a);\n\n\n// Function: f_ord()\n// Synopsis: Returns a function to get the ordinal number of a string character.\n// Topics: Function Literals, String Operators\n// See Also: f_len(), f_chr(), f_ord(), f_str(), f_str2(), f_str3()\n// Usage:\n//   fn = f_ord();\n//   fn = f_ord(a);\n// Description:\n//   A factory that generates function literals based on `ord(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_ord(a) = f_1arg(function(a) ord(a))(a);\n\n\n// Function: f_str()\n// Synopsis: Returns a function to get the string representation of an arbitrary value.\n// Topics: Function Literals, String Operators\n// See Also: f_len(), f_chr(), f_ord(), f_str(), f_str2(), f_str3()\n// Usage:\n//   fn = f_str();\n//   fn = f_str(a);\n// Description:\n//   A factory that generates function literals based on `str(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_str(a) = f_1arg(function(a) str(a))(a);\n\n\n// Function: f_str2()\n// Synopsis: Returns a function to concatenate the string representations of two arbitrary values.\n// Topics: Function Literals, String Operators\n// See Also: f_len(), f_chr(), f_ord(), f_str(), f_str2(), f_str3()\n// Usage:\n//   fn = f_str2();\n//   fn = f_str2(a=);\n//   fn = f_str2(b);\n//   fn = f_str2(a=,b=);\n// Description:\n//   A factory that generates function literals based on `str(a,b)`, where either\n//   or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_str2(a,b) = f_2arg(function(a,b) str(a,b))(a,b);\n\n\n// Function: f_str3()\n// Synopsis: Returns a function to concatenate the string representations of three arbitrary values.\n// Topics: Function Literals, Math Operators\n// See Also: f_len(), f_chr(), f_ord(), f_str(), f_str2(), f_str3()\n// Usage:\n//   fn = f_str3();\n//   fn = f_str3(a=);\n//   fn = f_str3(b=);\n//   fn = f_str3(c=);\n//   fn = f_str3(a=,b=);\n//   fn = f_str3(b=,c=);\n//   fn = f_str3(a=,c=);\n//   fn = f_str3(a=,b=,c=);\n// Description:\n//   A factory that generates function literals based on `str(a,b,c)`, where any\n//   or all of the `a`, `b`, or`c` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\n//   c = If given, replaces the third argument.\nfunction f_str3(a,b,c) = f_3arg(function(a,b,c) str(a,b,c))(a,b,c);\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Miscellaneous Operators\n\n\n// Function: f_floor()\n// Synopsis: Returns a function to calculate the integer floor of a given number.\n// Topics: Function Literals, Math Operators\n// See Also: f_floor(), f_ceil(), f_round()\n// Usage:\n//   fn = f_floor();\n//   fn = f_floor(a);\n// Description:\n//   A factory that generates function literals based on `floor(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_floor(a) = f_1arg(function(a) floor(a))(a);\n\n\n// Function: f_round()\n// Synopsis: Returns a function to calculate the integer rounding of a given number.\n// Topics: Function Literals, Math Operators\n// See Also: f_floor(), f_ceil(), f_round()\n// Usage:\n//   fn = f_round();\n//   fn = f_round(a);\n// Description:\n//   A factory that generates function literals based on `round(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_round(a) = f_1arg(function(a) round(a))(a);\n\n\n// Function: f_ceil()\n// Synopsis: Returns a function to calculate the integer ceiling of a given number.\n// Topics: Function Literals, Math Operators\n// See Also: f_floor(), f_ceil(), f_round()\n// Usage:\n//   fn = f_ceil();\n//   fn = f_ceil(a);\n// Description:\n//   A factory that generates function literals based on `ceil(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_ceil(a)  = f_1arg(function(a) ceil(a))(a);\n\n\n// Function: f_abs()\n// Synopsis: Returns a function to calculate the absolute value of a given number.\n// Topics: Function Literals, Math Operators\n// See Also: f_abs(), f_sign(), f_ln(), f_log(), f_exp(), f_sqr(), f_sqrt()\n// Usage:\n//   fn = f_abs();\n//   fn = f_abs(a);\n// Description:\n//   A factory that generates function literals based on `abs(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_abs(a)   = f_1arg(function(a) abs(a))(a);\n\n\n// Function: f_sign()\n// Synopsis: Returns a function to calculate the sign of a given number.\n// Topics: Function Literals, Math Operators\n// See Also: f_abs(), f_sign(), f_ln(), f_log(), f_exp(), f_sqr(), f_sqrt()\n// Usage:\n//   fn = f_sign();\n//   fn = f_sign(a);\n// Description:\n//   A factory that generates function literals based on `sign(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_sign(a)  = f_1arg(function(a) sign(a))(a);\n\n\n// Function: f_ln()\n// Synopsis: Returns a function to calculate the natural logarithm of a given number.\n// Topics: Function Literals, Math Operators\n// See Also: f_abs(), f_sign(), f_ln(), f_log(), f_exp(), f_sqr(), f_sqrt()\n// Usage:\n//   fn = f_ln();\n//   fn = f_ln(a);\n// Description:\n//   A factory that generates function literals based on `ln(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_ln(a)    = f_1arg(function(a) ln(a))(a);\n\n\n// Function: f_log()\n// Synopsis: Returns a function to calculate the base 10 logarithm of a given number.\n// Topics: Function Literals, Math Operators\n// See Also: f_abs(), f_sign(), f_ln(), f_log(), f_exp(), f_sqr(), f_sqrt()\n// Usage:\n//   fn = f_log();\n//   fn = f_log(a);\n// Description:\n//   A factory that generates function literals based on `log(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_log(a)   = f_1arg(function(a) log(a))(a);\n\n\n// Function: f_exp()\n// Synopsis: Returns a function to calculate the natural exponent of a given number.\n// Topics: Function Literals, Math Operators\n// See Also: f_abs(), f_sign(), f_ln(), f_log(), f_exp(), f_sqr(), f_sqrt()\n// Usage:\n//   fn = f_exp();\n//   fn = f_exp(a);\n// Description:\n//   A factory that generates function literals based on `exp(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_exp(a)   = f_1arg(function(a) exp(a))(a);\n\n\n// Function: f_sqr()\n// Synopsis: Returns a function to calculate the square of a given number.\n// Topics: Function Literals, Math Operators\n// See Also: f_abs(), f_sign(), f_ln(), f_log(), f_exp(), f_sqr(), f_sqrt()\n// Usage:\n//   fn = f_sqr();\n//   fn = f_sqr(a);\n// Description:\n//   A factory that generates function literals based on `a*a`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_sqr(a)   = f_1arg(function(a) a*a)(a);\n\n\n// Function: f_sqrt()\n// Synopsis: Returns a function to calculate the square root of a given number.\n// Topics: Function Literals, Math Operators\n// See Also: f_abs(), f_sign(), f_ln(), f_log(), f_exp(), f_sqr(), f_sqrt()\n// Usage:\n//   fn = f_sqrt();\n//   fn = f_sqrt(a);\n// Description:\n//   A factory that generates function literals based on `sqrt(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_sqrt(a)  = f_1arg(function(a) sqrt(a))(a);\n\n\n// Function: f_norm()\n// Synopsis: Returns a function to calculate the norm of a given vector.\n// Topics: Function Literals, Vectors\n// See Also: f_norm(), f_abs(), f_sign(), f_cross()\n// Usage:\n//   fn = f_norm();\n//   fn = f_norm(a);\n// Description:\n//   A factory that generates function literals based on `norm(a)`, where the `a`\n//   argument can optionally be replaced with a constant.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_norm(a)  = f_1arg(function(a) norm(a))(a);\n\n\n// Function: f_cross()\n// Synopsis: Returns a function to calculate the norm of a given vector.\n// Topics: Function Literals, Vectors\n// See Also: f_norm(), f_abs(), f_sign(), f_cross()\n// Usage:\n//   fn = f_cross();\n//   fn = f_cross(a=);\n//   fn = f_cross(b);\n//   fn = f_cross(a=,b=);\n// Description:\n//   A factory that generates function literals based on `str(a,b)`, where either\n//   or both of the `a` or `b` arguments can be replaced with constants.\n// Arguments:\n//   a = If given, replaces the first argument.\n//   b = If given, replaces the second argument.\nfunction f_cross(a,b) = f_2arg(function(a,b) cross(a,b))(a,b);\n\n\n// Section: Type Queries\n\n// Function: f_is_def()\n// Synopsis: Returns a function to determine if a value is not `undef`.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_def();\n// Description:\n//   A factory that returns function literals equivalent to `is_def(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_def(a) = f_1arg(function (a) is_def(a))(a);\n\n\n// Function: f_is_undef()\n// Synopsis: Returns a function to determine if a value is `undef`.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_bool(), f_is_num(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_undef();\n// Description:\n//   A factory that returns function literals equivalent to `is_undef(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_undef(a) = f_1arg(function (a) is_undef(a))(a);\n\n\n// Function: f_is_bool()\n// Synopsis: Returns a function to determine if a value is a boolean.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_num(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_bool();\n// Description:\n//   A factory that returns function literals equivalent to `is_bool(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_bool(a) = f_1arg(function (a) is_bool(a))(a);\n\n\n// Function: f_is_num()\n// Synopsis: Returns a function to determine if a value is a number.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_num();\n// Description:\n//   A factory that returns function literals equivalent to `is_num(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_num(a) = f_1arg(function (a) is_num(a))(a);\n\n\n// Function: f_is_int()\n// Synopsis: Returns a function to determine if a value is an integer number.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_int();\n// Description:\n//   A factory that returns function literals equivalent to `is_int(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_int(a) = f_1arg(function (a) is_int(a))(a);\n\n\n// Function: f_is_nan()\n// Synopsis: Returns a function to determine if a value is a number type that is Not a Number (NaN).\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_int(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_nan();\n// Description:\n//   A factory that returns function literals equivalent to `is_nan(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_nan(a) = f_1arg(function (a) is_nan(a))(a);\n\n\n// Function: f_is_finite()\n// Synopsis: Returns a function to determine if a value is a number type that is finite.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_int(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_finite();\n// Description:\n//   A factory that returns function literals equivalent to `is_finite(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_finite(a) = f_1arg(function (a) is_finite(a))(a);\n\n\n// Function: f_is_string()\n// Synopsis: Returns a function to determine if a value is a string.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_int(), f_is_list()\n// Usage:\n//   fn = f_is_string();\n// Description:\n//   A factory that returns function literals equivalent to `is_string(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_string(a) = f_1arg(function (a) is_string(a))(a);\n\n\n// Function: f_is_list()\n// Synopsis: Returns a function to determine if a value is a list.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_int(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_list();\n// Description:\n//   A factory that returns function literals equivalent to `is_list(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_list(a) = f_1arg(function (a) is_list(a))(a);\n\n\n// Function: f_is_range()\n// Synopsis: Returns a function to determine if a value is a range.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_int(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_range();\n// Description:\n//   A factory that returns function literals equivalent to `is_range(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_range(a) = f_1arg(function (a) is_range(a))(a);\n\n\n// Function: f_is_function()\n// Synopsis: Returns a function to determine if a value is a function literal.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_int(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_function();\n// Description:\n//   A factory that returns function literals equivalent to `is_function(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_function(a) = f_1arg(function (a) is_function(a))(a);\n\n\n// Function: f_is_vector()\n// Synopsis: Returns a function to determine if a value is a list of numbers.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_int(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_vector();\n// Description:\n//   A factory that returns function literals equivalent to `is_vector(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_vector(a,b) = f_2arg(function (a,b) is_vector(a,b))(a,b);\n\n\n// Function: f_is_path()\n// Synopsis: Returns a function to determine if a value is a Path (a list of points).\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_int(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_path();\n// Description:\n//   A factory that returns function literals equivalent to `is_path(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_path(a,b) = f_2arg(function (a,b) is_path(a,b))(a,b);\n\n\n// Function: f_is_region()\n// Synopsis: Returns a function to determine if a value is a Region (a list of Paths).\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_int(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_region();\n// Description:\n//   A factory that returns function literals equivalent to `is_region(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_region(a) = f_1arg(function (a) is_region(a))(a);\n\n\n// Function: f_is_vnf()\n// Synopsis: Returns a function to determine if a value is a VNF structure.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_int(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_vnf();\n// Description:\n//   A factory that returns function literals equivalent to `is_vnf(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_vnf(a) = f_1arg(function (a) is_vnf(a))(a);\n\n\n// Function: f_is_patch()\n// Synopsis: Returns a function to determine if a value is a Bezier Patch structure.\n// Topics: Function Literals, Type Queries\n// See Also: f_is_undef(), f_is_bool(), f_is_num(), f_is_int(), f_is_string(), f_is_list()\n// Usage:\n//   fn = f_is_patch();\n// Description:\n//   A factory that returns function literals equivalent to `is_patch(a)`.\n// Arguments:\n//   a = If given, replaces the argument.\nfunction f_is_patch(a) = f_1arg(function (a) is_patch(a))(a);\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-15", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////////////////////////////\n// LibFile: gears.scad\n//   Spur Gears, Bevel Gears, Racks, Worms and Worm Gears.\n//   Inspired by code by Leemon Baird, 2011, Leemon@Leemon.com\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/gears.scad>\n// FileGroup: Parts\n// FileSummary: Gears, racks, worms, and worm gears.\n//////////////////////////////////////////////////////////////////////////////////////////////\n\n\n_GEAR_PITCH = 5;\n_GEAR_HELICAL = 0;\n_GEAR_THICKNESS = 10;\n_GEAR_PA = 20;\n\n\n$parent_gear_type = undef;\n$parent_gear_pitch = undef;\n$parent_gear_teeth = undef;\n$parent_gear_pa = undef;\n$parent_gear_helical = undef;\n$parent_gear_thickness = undef;\n$parent_gear_dir = undef;\n$parent_gear_travel = 0;\n\n\nfunction _inherit_gear_param(name, val, pval, dflt, invert=false) =\n    is_undef(val)\n      ? is_undef(pval)\n        ? dflt\n        : (invert?-1:1)*pval\n      : is_undef(pval)\n        ? assert(is_finite(val), str(\"Invalid \",name,\" value: \",val))\n          val\n        : (invert?-1:1)*val;\n\n\nfunction _inherit_gear_pitch(fname,pitch,circ_pitch,diam_pitch,mod,warn=true) =\n    pitch != undef?\n        assert(is_finite(pitch) && pitch>0)\n        warn? echo(str(\n            \"WARNING: The use of the argument pitch= in \", fname,\n            \" is deprecated.  Please use circ_pitch= instead.\"\n        )) pitch : pitch :\n    circ_pitch != undef?\n        assert(is_finite(circ_pitch) && circ_pitch>0)\n        circ_pitch :\n    diam_pitch != undef?\n        assert(is_finite(diam_pitch) && diam_pitch>0)\n        circular_pitch(diam_pitch=diam_pitch) :\n    mod != undef?\n        assert(is_finite(mod) && mod>0)\n        circular_pitch(mod=mod) :\n    $parent_gear_pitch != undef? $parent_gear_pitch :\n    5;\n\nfunction _inherit_gear_pa(pressure_angle) =\n    _inherit_gear_param(\"pressure_angle\", pressure_angle, $parent_gear_pa, dflt=20);\n\nfunction _inherit_gear_helical(helical,invert=false) =\n    _inherit_gear_param(\"helical\", helical, $parent_gear_helical, dflt=0, invert=invert);\n\nfunction _inherit_gear_thickness(thickness,dflt=10) =\n    _inherit_gear_param(\"thickness\", thickness, $parent_gear_thickness, dflt=dflt);\n\n\n// Section: Quick Introduction to Gears\n//   This section gives a quick overview of gears with a focus on the information you need\n//   to know to understand the gear parameters and create some gears.  The topic of gears is very complex and highly technical and\n//   this section provides the minimal information needed for gear making.  If you want more information about the\n//   details of gears, consult the references below, which are the ones that we consulted when writing the library code.\n//   - Tec Science\n//       * [Involute Gears](https://www.tec-science.com/mechanical-power-transmission/involute-gear/geometry-of-involute-gears/)\n//       * [Gear engagement](https://www.tec-science.com/mechanical-power-transmission/involute-gear/meshing-line-action-contact-pitch-circle-law/)\n//       * [Gears meshing with racks](https://www.tec-science.com/mechanical-power-transmission/involute-gear/rack-meshing/)\n//       * [Gear undercutting](https://www.tec-science.com/mechanical-power-transmission/involute-gear/undercut/)\n//       * [Profile shifting](https://www.tec-science.com/mechanical-power-transmission/involute-gear/profile-shift/)\n//       * [Detailed gear calculations](https://www.tec-science.com/mechanical-power-transmission/involute-gear/calculation-of-involute-gears/)\n//       * [Worm drive](https://www.tec-science.com/mechanical-power-transmission/gear-types/worms-and-worm-gears/)\n//       * [Bevel gears](https://www.tec-science.com/mechanical-power-transmission/gear-types/bevel-gears/)\n//   - SDPSI (A long document covering a variety of gear types and gear calculations)\n//       * [Elements of Gear Technology](https://www.sdp-si.com/resources/elements-of-metric-gear-technology/index.php)\n//   - Drivetrain Hub (A collection of \"notebooks\" on some gear topics)\n//       * [Gear Geometry, Strength, Tooling and Mechanics](https://drivetrainhub.com/notebooks/#toc)\n//   - Crown Face Gears\n//       * [Crown Gearboxes](https://mag.ebmpapst.com/en/industries/drives/crown-gearboxes-efficiency-energy-savings-decentralized-drive-technology_14834/)\n//       * [Crown gear pressure angle](https://mag.ebmpapst.com/en/industries/drives/the-formula-for-the-pressure-angle_14624/)\n//       * [Face Gears: Geometry and Strength](https://www.geartechnology.com/ext/resources/issues/0107x/kissling.pdf)\n\n// Subsection: Involute Spur Gears\n// The simplest gear form is the involute spur gear, which is an extrusion of a two dimensional form.\n// Figure(3D,Med,NoAxes,VPT=[4.62654,-1.10349,0.281802],VPR=[55,0,25],VPD=236.957): Involute Spur Gear\n//   spur_gear(mod=5,teeth=18,pressure_angle=20,thickness=25,shaft_diam=15);\n// Continues:\n//   The term \"involute\" refers to the shape of the teeth:  the curves of the teeth are involutes of circles, \n//   which are curves that optimize gear performance.\n// Figure(2D,Med,NoAxes,VPT=[8,74,0],VPR=[0,0,0],VPD=150): The three marked circles are key references on gear teeth.  The pitch circle, which is roughly in the middle of the teeth, is the reference used to define the pitch of teeth on the gear.  The pressure angle is the angle the tooth makes with the pitch circle.  In this example, the pressure angle is 20 degrees as shown by the red lines.  \n//   $fn=128;\n//   intersection(){\n//     spur_gear2d(mod=5,teeth=30,pressure_angle=20);\n//     back(82)rect([45, 20],anchor=BACK);\n//   }\n//   color(\"black\"){\n//     stroke(arc(r=_root_radius(mod=5,teeth=30),angle=[70,110]),width=.25);\n//     stroke(arc(r=pitch_radius(mod=5,teeth=30),angle=[70,110]),width=.25);\n//     stroke(arc(r=outer_radius(mod=5,teeth=30),angle=[70,110]),width=.25);\n//     back(63.5)right(24.2)text(\"root circle\",size=2.5);\n//     back(69.5)right(26.5)text(\"pitch circle\",size=2.5);\n//     back(74)right(28)text(\"outer circle\",size=2.5);    \n//   }  \n//   base = _base_radius(mod=5, teeth=30);\n//   pitchpt = pitch_radius(mod=5, teeth=30);\n//   color(\"red\"){\n//     zrot(87-360/30) zrot(20,cp=[pitchpt,0]) stroke([[base-5,0],[base+15,0]], width=0.25);\n//     zrot(87-360/30) stroke([[pitchpt,0],[pitchpt+11,0]], width=0.25);\n//     right(8.3) back(74) zrot(87-360/30) zrot(10,cp=[pitchpt,0]) stroke(arc(angle=[0,20],r=10.5),endcaps=\"arrow2\",width=.25);\n//     back(84) right(13) text(\"pressure angle\",size=2.5);\n//   }\n// Continues:\n//   The size of the teeth can be specified as the circular pitch, the distance along the pitch circle\n//   from the start of one tooth to the start of the text tooth.  The circular pitch can be computed as\n//   `PI*d/teeth` where `d` is the diameter of the pitch circle and `teeth` is the number of teeth on the gear.\n//   This simply divides up the pitch circle into the specified number of teeth.  However, the customary\n//   way to specify metric gears is using the module, ratio of the diameter of the gear to the number of teeth: `m=d/teeth`.\n//   The module is hence the circular pitch divided by a factor of \u03c0.  A third way to specify gear sizes is the diametral pitch,\n//   which is the number of teeth that fit on a gear with a diameter of one inch, or \u03c0 times the number of teeth per inch.\n//   Note that for the module or circular pitch, larger values make larger teeth,\n//   but for the diametral pitch, the opposite is true.  Throughout this library, module and circular pitch\n//   are specified basic OpenSCAD units, so if you work in millimeters and want to give circular pitch in inches, be\n//   sure to multiply by `INCH`.  The diametral pitch is given based on inches under the assumption that OpenSCAD units are millimeters.\n//   .\n//   Note that there is no direct way to specify the size of a gear.  The diameter of a gear depends on its tooth count\n//   and tooth size.  If you want a gear with a particular diameter you can get close by seeting the module to `d/teeth`,\n//   but that specifies the pitch circle, so the gear teeth will have a somewhat larger radius.  You should **not**\n//   apply scale() to gears.  Always change their size by adjusting the tooth size parameters.  \n//   .\n//   Basic gears as shown above will mesh when their pitch circles are tangent.\n//   The critical requirements for two gears to mesh are that\n//   - The teeth are the same size\n//   - The pressure angles are identical\n//   .\n//   Increasing pressure angle makes the tooth stronger, increases power transmission, and can reduce tooth interference for\n//   gears with a small number of teeth, but it also increases gear wear and meshing noise.  Higher pressure angles also\n//   increase the force that tries to push the gears apart, and hence the load on the gear axles.  The current standard pressure\n//   angle is 20 degrees.  It replaces an old 14.5 degree standard.  \n// Figure(2D,Med,NoAxes): Teeth of the same size with different pressure angles.  Note that 20 deg is the industry standard. \n//   pang = [30,20,14.5];\n//   ycopies(n=3, spacing=25){\n//     intersection(){\n//       spur_gear2d(mod=5, teeth=30, pressure_angle=pang[$idx]);\n//       back(82) rect([45,20], anchor=BACK);\n//     }\n//     back(68) right(26) text(str(pang[$idx]), size=6.5);\n//   }\n// Continues:\n//   In order for the gear teeth to fit together, and to allow space for lubricant, the valleys of the teeth\n//   are made deeper by the `clearance` distance.  This defaults to `module/4`.  \n// Figure(2D,Med,NoAxes,VPT=[5.62512,-1.33268,-0.0144912],VPR=[0,0,0],VPD=126): The clearance is extra space at the tooth valley that separates the tooth tip (in green) from the tooth valley below it.  \n//   intersection(){\n//     rack2d(mod=5, teeth=10, bottom=15, pressure_angle=14.5);\n//     rect([35,20]);\n//   }  \n//   color(\"lightgreen\")render()\n//   intersection(){\n//      back(gear_dist(mod=5, teeth1=146, teeth2=0 ,profile_shift1=0))\n//          spur_gear2d(mod=5, teeth=146, profile_shift=0, pressure_angle=14.5);\n//      rect([45,20]);\n//   }   \n//   color(\"black\") {\n//       stroke([[-10,-5],[20,-5]], width=.25);\n//       stroke([[-10,-6.2],[20,-6.2]], width=.25);\n//       fwd(6.4) right(22) text(\"clearance\", size=2.5);\n//   }    \n// Continues:\n//   Another clearance requirement can present a serious problem when the number of teeth is low.  As the gear rotates, the\n//   teeth may interfere with each other.  This may require undercutting the gear teeth to create space, which weakens the teeth.\n//   Is is best to avoid gears with very small numbers of teeth when possible.  \n// Figure(2D,Med,NoAxes,VPT=[0.042845,6.5338,-0.0144912],VPR=[0,0,0],VPD=126):  The green gear with only five teeth has a severe undercut, which weakens its teeth.  This undercut is necessary to avoid interference with the teeth from the other gear during rotation.  Note that the yellow rack tooth is deep into the undercut space.\n//   ang=16;\n//   rack2d(mod=5, teeth=3, bottom=15, pressure_angle=14.5, rounding=0);\n//   left(2*PI*pitch_radius(mod=5, teeth=5)*ang/360)\n//   color(\"lightgreen\")\n//     back(gear_dist(mod=5, teeth1=5, profile_shift1=0, teeth2=0))\n//       zrot(ang)\n//         spur_gear2d(mod=5, teeth=5, clearance=.00001, profile_shift=0, pressure_angle=14.5, shaft_diam=5);\n\n// Subsection: Corrected Gears and Profile Shifting\n//   A solution to the problem of undercutting is to use profile shifting.  Profile shifting uses a different portion of the\n//   involute curve to form the gear teeth, and this adjustment to the tooth form can eliminate undercutting, while\n//   still allowing the gear to mesh with unmodified gears.  Profile shifting\n//   changes the diameter at which the gear meshes so it no longer meshes at the pitch circle.  \n//   A profile shift of `x`\n//   will increase the mesh distance by approximately `x*m` where `m` is the gear module.  The exact adjustment,\n//   which you compute with {{gear_dist()}}, is a complex calculation that depends on the profile shifts of both meshing gears.  This means that profile shifting\n//   can also be used to fine tune the spacing between gears.  When the gear has many teeth a negative profile shift may\n//   be able to bring the gears slightly closer together, while still avoiding undercutting.\n//   Profile shifting also changes the effective pressure angle of the gear engagement.  \n//   .\n//   The minimum number of teeth to avoid undercutting is 17 for a pressure angle of 20, but it is 32 for a pressure\n//   angle of 14.5 degrees.  It can be computed as `2/(sin(alpha))^2` where `alpha` is the pressure angle.\n//   By default, the gear modules produce corrected gears.  You can override this by specifying the profile shift\n//   yourself.  A small undercut may be acceptable, for example: a rule of thumb indicates that gears as small as 14\n//   teeth are OK with a 20 degree pressure angle, because the undercut is too small to weaken the teeth significantly.  \n// Figure(2D,Med,NoAxes,VPT=[1.33179,10.6532,-0.0144912],VPR=[0,0,0],VPD=155.556): Basic five tooth gear form on the left.  Corrected gear with profile shifting on the right.  The profile shifted teeth lack the weak undercut section.  The axis of the corrected gear is shifted away from the mating rack.\n//   $fn=32;\n//   ang1=-20;\n//   ang2=20;\n//   color(\"blue\")\n//   left(2*PI*pitch_radius(mod=5, teeth=5)*ang1/360)\n//   left(3*5*PI/2)\n//     back(gear_dist(mod=5,teeth1=5,profile_shift1=0,teeth2=0,pressure_angle=14.5))\n//       zrot(ang1)\n//          spur_gear2d(mod=5, teeth=5, profile_shift=0, pressure_angle=14.5, shaft_diam=2);\n//   color(\"green\")\n//   left(2*PI*pitch_radius(mod=5, teeth=5)*ang2/360)\n//   right(3*5*PI/2)\n//     back(gear_dist(mod=5, teeth1=5, teeth2=0,pressure_angle=14.5))\n//       zrot(ang2)\n//         spur_gear2d(mod=5, teeth=5, pressure_angle=14.5, shaft_diam=2);\n//   rack2d(teeth=4, bottom=15, mod=5, pressure_angle=14.5);\n// Continues:\n//   Profile shifting brings with it another complication: in order to maintain the specified clearance, the tips of the\n//   gear teeth need to be shortened.  The shortening factor depends on characteristics of both gears, so it cannot\n//   be automatically incorporated.  (Consider the situation where one gear mates with multiple other gears.)  With modest\n//   profile shifts, you can probably ignore this adjustment, but with more extreme profile shifts, it may be important.\n//   You can compute the shortening parameter using {{gear_shorten()}}.  Note that the actual shortening distance is obtained\n//   by scaling the shortening factor by the gear's module.  \n// Figure(2D,Big,NoAxes,VPT=[55.8861,-4.31463,8.09832],VPR=[0,0,0],VPD=325.228): With large profile shifts the teeth need to be shortened or they don't have clearance in the valleys of the teeth in the meshing gear.  \n//   teeth1=25;\n//   teeth2=19;\n//   mod=4;\n//   ps1 = 0.75;\n//   ps2 = 0.75;\n//   d = gear_dist(mod=mod, teeth1,teeth2,0,ps1,ps2);\n//   color(\"lightblue\")\n//     spur_gear2d(mod=mod,teeth=teeth1,profile_shift=ps1,gear_spin=-90);\n//   right(d)\n//     spur_gear2d(mod=mod,teeth=teeth2,profile_shift=ps2,gear_spin=-90);\n//   right(9)stroke([[1.3*d/2,0],[d/2+4,0]], endcap2=\"arrow2\",color=\"black\");\n//   fwd(2)right(d/2+25)color(\"black\"){back(4)text(\"No clearance\",size=6);\n//                           fwd(4)text(\"at tooth tip\",size=6);}\n// Figure(2D,Big,NoAxes,VPT=[55.8861,-4.31463,8.09832],VPR=[0,0,0],VPD=325.228): Applying the correct shortening factor restores the clearance to its set value.  \n//   teeth1=25;\n//   teeth2=19;\n//   mod=4;\n//   ps1 = 0.75;\n//   ps2 = 0.75;\n//   d = gear_dist(mod=mod, teeth1,teeth2,0,ps1,ps2);\n//   shorten=gear_shorten(teeth1,teeth2,0,ps1,ps2);\n//   color(\"lightblue\")\n//     spur_gear2d(mod=mod,teeth=teeth1,profile_shift=ps1,shorten=shorten,gear_spin=-90);\n//   right(d)\n//     spur_gear2d(mod=mod,teeth=teeth2,profile_shift=ps2,shorten=shorten,gear_spin=-90);\n//   right(9)stroke([[1.3*d/2,0],[d/2+4,0]], endcap2=\"arrow2\",color=\"black\");\n//   fwd(2)right(d/2+25)color(\"black\"){back(4)text(\"Normal\",size=6);\n//                           fwd(4)text(\"Clearance\",size=6);}\n// Subsection: Helical Gears\n//   Helicals gears are a modification of spur gears.  They can replace spur gears in any application.  The teeth are cut\n//   following a slanted, helical path.  The angled teeth engage more gradually than spur gear teeth, so they run more smoothly\n//   and quietly.  A disadvantage of helical gears is that they have thrust along the axis of the gear that must be \n//   accomodated.  Helical gears also have more sliding friction between the meshing teeth compared to spur gears. \n// Figure(3D,Med,NoAxes,VPT=[3.5641,-7.03148,4.86523],VPR=[62.7,0,29.2],VPD=263.285): A Helical Gear\n//   spur_gear(mod=5,teeth=18,pressure_angle=20,thickness=35,helical=-29,shaft_diam=15,slices=15);\n// Continues:\n//   Helical gears have the same compatibility requirements as spur gears, with the additional requirement that\n//   the helical angles must be opposite each other, so a gear with a helical angle of 35 must mesh with one\n//   that has an angle of \u221235.  The industry convention refers to these as left-handed and right handed.  In\n//   this library, positive helical angles produce a left handed gear and negative angles produce a right handed gear.\n// Figure(3D,Med,NoAxes,VPT=[73.6023,-29.9518,-12.535],VPR=[76,0,1.2],VPD=610): Left and right handed helical gears at 35 degrees.\n//   spur_gear(mod=5, teeth=20, helical=35, thickness=70,slices=15);\n//   right(150)\n//   spur_gear(mod=5, teeth=20, helical=-35, thickness=70,slices=15);\n//   down(22)\n//   left(60)\n//   fwd(220)\n//   rot($vpr)\n//   color(\"black\")text3d(\"left handed    right handed\",size=18);\n//   down(52)\n//   left(55)\n//   fwd(220)\n//   rot($vpr)\n//   color(\"black\")text3d(\"helical=35     helical=\u221235\",size=18);\n// Continues:\n//   The pitch circle of a helical gear is larger compared to a spur gear\n//   by the cosine of the helical angle, so you cannot simply drop helical gears in to replace spur gears without\n//   making other adjustments.  This dependence does allow you to make \n//   make much bigger spacing adjustments than are possible with profile shifting\u2014without changing the tooth count.\n//   The {{gear_dist()}} function will also compute the appropriate gear spacing for helical gears.\n//   The effective pressure angle of helical gears is larger than the nominal pressure angle.  This can make it possible\n//   to avoid undercutting without having to use profile shifting, so smaller tooth count gears can be more effective\n//   using the helical form. \n// Figure(Anim,Med,Frames=10,NoAxes,VPT=[43.8006,15.9214,3.52727],VPR=[62.3,0,20.3],VPD=446.129): Meshing compatible helical gears\n//   zrot($t*360/18)\n//     spur_gear(mod=5, teeth=18, pressure_angle=20, thickness=25, helical=-29, shaft_diam=15);\n//   right(gear_dist(mod=5, teeth1=18, teeth2=18, helical=29))\n//     zrot(360/18/2)\n//       zrot(-$t*360/18)\n//         spur_gear(mod=5, teeth=18, pressure_angle=20, thickness=25, helical=29, shaft_diam=15);\n// Continues:\n//   Helical gears can mesh in a second manner that is different from spur gears: they can turn on skew, or crossed axes.  These are also\n//   sometimes called \"screw gears\".  The general requirement for two non-profile-shifted helical gears to mesh is that the angle \n//   between the gears' axes must equal the sum of the helical angles of the two gears, thus for parallel axes, the helical\n//   angles must sum to zero.  If helical gears are profile shifted, then in addition to adjusting the distance between the\n//   gears, a small adjustment in the angle is needed, so profile shifted gears won't mesh exactly at the sum of their angles.\n//   The calculation for gear spacing is different for skew axis gears than for parallel gears, so you do this using {{gear_dist_skew()}},\n//   and if you use profile shifting, then you can compute the angle using {{gear_skew_angle()}}. \n// Figure(Anim,Med,NoAxes,Frames=10,VPT=[44.765,6.09492,-3.01199],VPR=[55.7,0,33.2],VPD=401.289): Two helical gears meshing with axes at a 45 degree angle\n//   dist = gear_dist_skew(mod=5, teeth1=18, teeth2=18, helical1=22.5,helical2=22.5);\n//    axiscolor=\"darkgray\";\n//      down(10)color(axiscolor) cyl(d=15, l=145);\n//       zrot($t*360/18)\n//              color(\"lightblue\")spur_gear(mod=5,teeth=18,pressure_angle=20,thickness=25,helical=22.5,shaft_diam=15);\n//   right(dist)\n//       xrot(45) {color(axiscolor)cyl(d=15,l=85);\n//           zrot(360/18/2)\n//               zrot(-$t*360/18)\n//                   spur_gear(mod=5,teeth=18,pressure_angle=20,thickness=25,helical=22.5,shaft_diam=15);}\n// Subsection: Herringbone Gears\n//   The herringbone gear is made from two stacked helical gears with opposite angles.  This design addresses the problem\n//   of axial forces that afflict helical gears by having one section that slopes to the\n//   right and another that slopes to the left.  Herringbone gears also have the advantage of being self-aligning.\n// Figure(3D,Med,NoAxes,VPT=[3.5641,-7.03148,4.86523],VPR=[62.7,0,29.2],VPD=263.285): A herringbone gear\n//   spur_gear(mod=5, teeth=16, pressure_angle=20, thickness=35, helical=-20, herringbone=true, shaft_diam=15);\n// Subsection: Ring Gears (Internal Gears)\n//   A ring gear (or internal gear) is a gear where the teeth are on the inside of a circle.  Such gears must be mated\n//   to a regular (external) gear, which rotates around the inside.\n// Figure(2D,Med,NoAxes,VPT=[0.491171,1.07815,0.495977],VPR=[0,0,0],VPD=292.705): A interior or ring gear (yellow) with a mating spur gear (blue)\n//   teeth1=18;\n//   teeth2=30;\n//   ps1=undef;\n//   ps2=auto_profile_shift(teeth=teeth1);\n//   mod=3;\n//   d = gear_dist(mod=mod, teeth1=teeth1, teeth2=teeth2,profile_shift1=ps1, profile_shift2=ps2,helical=0, internal2=true);\n//   ang = 0;\n//     ring_gear2d(mod=mod, teeth=teeth2,profile_shift=ps2,helical=0,backing=4);\n//     zrot(ang*360/teeth2)\n//     color(\"lightblue\")\n//     fwd(d)\n//        spur_gear2d(mod=mod, teeth=teeth1, profile_shift=ps1,gear_spin=-ang*360/teeth1,helical=0);\n// Continues:\n//    Ring gears are subject to all the usual mesh requirements: the teeth must be the same size, the pressure angles must\n//    match and they must have opposite helical angles.  The {{gear_dist()}} function can give the center separation of\n//    a ring gear and its mating spur gear.  Ring gears have additional complications that tend to arise when the number of\n//    teeth is small or the teeth counts of the ring gear and spur gear are too close together.  The mating spur gear must\n//    have few enough teeth so that the teeth don't interfere on the other side of the ring.  Very small spur gears can interfere\n//    on the tips of the ring gear's teeth.  \n// Figure(2D,Med,NoAxes,VPT=[-1.16111,0.0525612,0.495977],VPR=[0,0,0],VPD=213.382): The red regions show interference between the two gears: the 18 tooth spur gear does not fit inside the 20 tooth ring gear. \n//    teeth1=18;\n//    teeth2=20;\n//    ps1=undef;\n//    ps2=auto_profile_shift(teeth=teeth1);\n//    mod=3;\n//    d = gear_dist(mod=mod, teeth1=teeth1, teeth2=teeth2,profile_shift1=ps1, profile_shift2=ps2,helical=0, internal2=true);\n//    ang = 0;\n//    color_overlaps(){\n//      ring_gear2d(mod=mod, teeth=teeth2,profile_shift=ps2,helical=0,backing=4);\n//      zrot(ang*360/teeth2)\n//      fwd(d)\n//         spur_gear2d(mod=mod, teeth=teeth1, profile_shift=ps1,gear_spin=-ang*360/teeth1,helical=0);\n//    }\n// Figure(2D,Big,NoAxes,VPT=[10.8821,-26.1226,-0.0685569],VPD=43.9335,VPR=[0,0,16.8]): Interference at teeth tips, shown in red, with a 5 tooth and 19 tooth gear.  \n//    $fn=128;\n//    teeth1=5;\n//    teeth2=19;\n//    ps1=0;\n//    ps2=0;\n//    mod=3;\n//    d = gear_dist(mod=mod, teeth1=teeth1, teeth2=teeth2,profile_shift1=ps1, profile_shift2=ps2,helical=0, internal2=true);\n//    ang = 1;\n//    color_overlaps(){\n//      ring_gear2d(mod=mod, teeth=teeth2,profile_shift=ps2,helical=0,backing=4);\n//      zrot(ang*360/teeth2)\n//      fwd(d)\n//         spur_gear2d(mod=mod, teeth=teeth1, profile_shift=ps1,gear_spin=-ang*360/teeth1,helical=0);\n//    }\n// Continues:\n//    The tooth tip interference can often be controlled using profile shifting of the ring gear, but another requirement is\n//    that the profile shift of the ring gear must be at least as big as the profile shift of the mated spur gear.  In order\n//    to ensure that this condition holds, you may need to use {{auto_profile_shift()}} to find the profile shift that is\n//    automatically applied to the spur gear you want to use.\n// Figure(2D,Med,VPT=[4.02885,-46.6334,1.23363],VPR=[0,0,6.3],VPD=75.2671,NoAxes): Ring gear without profile shifting doesn't have room for the fat profile shifted teeth of the 5-tooth spur gear, with overlaps shown in red.  \n//    $fn=128;\n//    teeth1=5;\n//    teeth2=35;\n//    ps1=undef;\n//    ps2=0;\n//    mod=3;\n//    d=45-.7;\n//    ang = .5;\n//    color_overlaps(){\n//      ring_gear2d(mod=mod, teeth=teeth2,profile_shift=ps2,helical=0,backing=4);\n//      zrot(ang*360/teeth2)\n//      fwd(d)\n//         spur_gear2d(mod=mod, teeth=teeth1, profile_shift=ps1,gear_spin=-ang*360/teeth1,helical=0);\n//    }\n// Figure(2D,Med,VPT=[9.87969,-45.6706,0.60448],VPD=82.6686,VPR=[0,0,11],NoAxes): When the ring gear is profile shifted to match the spur gear, then the gears mesh without interference.  \n//    $fn=128;\n//    teeth1=5;\n//    teeth2=35;\n//    ps1=undef;\n//    ps2=auto_profile_shift(teeth=teeth1);\n//    mod=3;\n//    d = gear_dist(mod=mod, teeth1=teeth1, teeth2=teeth2,profile_shift1=ps1, profile_shift2=ps2,helical=0, internal2=true);\n//    ang = .5;\n//    color_overlaps(){\n//      ring_gear2d(mod=mod, teeth=teeth2,profile_shift=ps2,helical=0,backing=4);\n//      zrot(ang*360/teeth2)\n//      fwd(d)\n//         spur_gear2d(mod=mod, teeth=teeth1, profile_shift=ps1,gear_spin=-ang*360/teeth1,helical=0);\n//    }\n// Figure(3D,Med,NoAxes,VPT=[2.48983,2.10149,0.658081],VPR=[70.4,0,123],VPD=237.091): A helical ring gear (yellow) mating with the compatible spur gear (blue)\n//    $fn=128;\n//    teeth1=18;\n//    teeth2=30;\n//    ps1=undef;\n//    ps2=auto_profile_shift(teeth=teeth1);\n//    mod=3;\n//    d = gear_dist(mod=mod, teeth1=teeth1, teeth2=teeth2,profile_shift1=ps1, profile_shift2=ps2,helical=30, internal2=true);\n//    ang = 0;\n//      ring_gear(mod=mod, teeth=teeth2,profile_shift=ps2,backing=4,helical=30,thickness=15);\n//      zrot(ang*360/teeth2)\n//      color(\"lightblue\")\n//      fwd(d)\n//         spur_gear(mod=mod, teeth=teeth1, profile_shift=ps1,gear_spin=-ang*360/teeth1,helical=-30,thickness=15);\n// Subsection: Worm Drive\n//   A worm drive is a gear system for connecting skew shafts at 90 degrees.  They offer higher load capacity compared to\n//   crossed helical gears.  The assembly is driven by the \"worm\", which is a gear that resembles a screw.\n//   Like a screw, it can have one, or several starts.  These starts correspond to teeth on a helical gear;\n//   in fact, the worm can be regarded as a type of helical gear at a very extreme angle, where the teeth wrap\n//   around the gear.  The worm mates with the \"worm gear\" which is also called the \"worm wheel\".  The worm gear\n//   resembles a helical gear at a very slight angle.\n// Figure(3D,Med,NoAxes,VPT=[38.1941,-7.67869,7.95996],VPR=[56.4,0,25],VPD=361.364):  Worm drive assembly, with worm on the left and worm gear (worm wheel) on the right.  When the worm turns its screwing action drives the worm gear.  \n//   starts=2;\n//   ps=0;\n//   dist_ba=0;\n//   gear_ba=0;\n//     worm(\n//          d=44, // mate_teeth=30,\n//          circ_pitch=3*PI,\n//          starts=starts,orient=BACK);\n//   right(worm_dist(d=44,mod=3,teeth=30, starts=starts,profile_shift=ps,backlash=dist_ba))\n//     zrot(360/30*.5) \n//       worm_gear(\n//          circ_pitch=3*PI, \n//          teeth=30,\n//          worm_diam=44,profile_shift=ps,\n//          worm_starts=starts,backlash=gear_ba);\n// Continues:\n//   A close look at the worm gear reveals that it differs significantly from a helical or spur gear.\n//   This gear is an \"enveloping\" gear, which is designed to follow the curved profile of the worm,\n//   resulting in much better contact between the teeth of the worm and the teeth of the worm gear.\n//   The worm shown above is a cylindrical worm, which is the most common type.\n//   It is possible to design the worm to follow the curved shape of its mated gear, resulting\n//   in an enveloping (also called \"globoid\") worm.  This type of worm makes better contact with\n//   the worm gear, but is less often used due to manufacturing complexity and consequent expense.  \n// Figure(3D,Big,NoAxes,VPT=[0,0,0],VPR=[192,0,180],VPD=172.84): A cylindrical worm appears on the left in green.  Note it's straight sides.  The enveloping (globoid) worm gears appears on the right in green.  Note that its sides curve so several teeth can mate with the worm gear, and it requires a complex tooth form\n//   tilt=20;\n//   starts=1;\n//   ps=0;\n//   pa=27;\n//   dist_ba=0;\n//   gear_ba=0;\n//   xdistribute(spacing=25){\n//      xflip()yrot(-tilt)  \n//      union(){\n//       color(\"lightgreen\")\n//         xrot(90) \n//         zrot(-90)\n//         enveloping_worm(     mate_teeth=60,$fn=128,\n//             d=14, pressure_angle=pa,  mod=3/2,\n//             starts=starts);\n//        right(worm_dist(d=14,mod=3/2,teeth=60, starts=starts,profile_shift=ps,backlash=dist_ba,pressure_angle=pa))\n//          zrot(360/30*.25)\n//            worm_gear(\n//             mod=3/2,pressure_angle=pa,\n//             teeth=60,crowning=0,\n//             worm_diam=14,profile_shift=ps,\n//             worm_starts=starts,backlash=gear_ba);\n//      }\n//      yrot(-tilt)\n//      union(){\n//       color(\"lightgreen\")\n//         xrot(90) \n//         zrot(-90)\n//                                worm(l=43, $fn=128,\n//             d=14, pressure_angle=pa, left_handed=true,\n//             mod=3/2,//circ_pitch=3*PI/2,\n//             starts=starts);\n//        right(worm_dist(d=14,mod=3/2,teeth=60, starts=starts,profile_shift=ps,backlash=dist_ba,pressure_angle=pa))\n//          zrot(360/30*.25)\n//            worm_gear(\n//             mod=3/2,pressure_angle=pa,\n//             teeth=60,crowning=0,left_handed=true,\n//             worm_diam=14,profile_shift=ps,\n//             worm_starts=starts,backlash=gear_ba);\n//      }  \n//   }\n// Continues:\n//   As usual, a proper mesh requires that the pressure angles match and the teeth of the worm and worm gear\n//   are the same size.  Additionally the worm gear must be constructed to match the diameter of the worm\n//   and the number of starts on the worm.  Note that the number of starts changes the angle at of the \n//   teeth on the worm, and hence requires a change to the angle of teeth on the worm gear.  \n//   Of course an enveloping worm needs to know the diameter of the worm gear; you provide this\n//   information indirectly by giving the number of teeth on the worm gear.\n//   The {{worm_dist()}} function will give the correct center spacing for the worm from its mating worm gear.  \n//   .  \n//   Worm drives are often \"self-locking\", which means that torque transmission can occur only from the worm to the worm gear,\n//   so they must be driven by the worm.  Self-locking results from the small lead angle of the worm threads, which produces\n//   high frictional forces at contact.  A multi-start worm has a higher lead angle and as a result is less likely\n//   to be self-locking, so a multi-start worm can be chosen to avoid self-locking.\n//   Since self-locking is associated with friction, self-locking drives have lower efficiency,\n//   usually less than 50%.  Worm drive efficiency can exceed 90% if self-locking is not required.  One consideration\n//   with self-locking systems is that if the worm gear moves a large mass and the drive is suddenly shut off, the\n//   worm wheel is still trying to move due to inertia, which can create large loads that fracture the worm.\n//   In such cases, the worm cannot be stopped abruptly but must rotate a little further (called \"over travel\")\n//   after switching off the drive.\n// Subsection: Bevel Gears\n//   Bevel gearing is another way of dealing with intersecting gear shafts.  For bevel gears, the teeth centers lie on\n//   the surface of an imaginary cone, which is the \"pitch cone\" of the bevel gear.  Two bevel gears can mesh when their pitch cone\n//   apexes coincide and the cones touch along their length.  The teeth of bevel gears shrink as they get closer to the center of the gear.\n//   Tooth dimensions and pitch diameter (the base of the pitch cone) are referenced to the outer end of the teeth.\n//   Note that the pitch radius, computed the same was as for other gears, gives the radius of the pitch cone's base.  \n//   Bevel gears can be made with straight teeth, analogous to spur gears, and with the\n//   same disadvantage of sudden full contact that is noisy.  Spiral teeth are analogous to helical\n//   teeth on cylindrical gears: the teeth engage gradually and smoothly, transmitting motion more smoothly\n//   and quietly.  Also like helical gears, they have the disadvantage of introducing axial forces, and\n//   usually they can only operate in one rotation direction.  \n//   A third type of tooth is the zerol tooth, which has curved teeth like the spiral teeth,\n//   but with a zero angle.  These share advantages of straight teeth and spiral teeth: they are quiet like\n//   straight teeth but they lack the axial thrust of spiral gears, and they can operate in both directions.\n//   They are also reportedly stronger than either spiral or bevel gears.\n// Figure(3D,Med,VPT=[-5.10228,-3.09311,3.06426],VPR=[67.6,0,131.9],VPD=237.091,NoAxes): Straight tooth bevel gear with 45 degree angled teeth.  To get a gear like this you must specify a spiral angle of zero and a cutter radius of zero.  This gear would mate with a copy of itself and would change direction of rotation without changing the rotation rate. \n//   bevel_gear(mod=3,teeth=35,mate_teeth=35,face_width=20,spiral=0,cutter_radius=0);\n// Figure(3D,Med,VPT=[-5.10228,-3.09311,3.06426],VPR=[67.6,0,131.9],VPD=237.091,NoAxes): Straight tooth bevel gear with 45 degree angled teeth.  A gear like this has a positive spiral angle, which determines how sloped the teeth are and a positive cutter radius, which determines how curved the teeth are.  \n//   bevel_gear(mod=3,teeth=35,mate_teeth=35,face_width=20,slices=12);\n// Figure(3D,Med,VPT=[-5.10228,-3.09311,3.06426],VPR=[67.6,0,131.9],VPD=237.091,NoAxes): Zerol tooth bevel gear with 45 degree angled teeth.  A gear like this has a spiral angle of zero, but a positive cutter radius, which determines how curved the teeth are.  \n//   bevel_gear(mod=3,teeth=35,mate_teeth=35,face_width=20,spiral=0,slices=12);\n// Continues:\n//   Bevel gears have demanding requirements for successful mating of two gears.  Of course the tooth size\n//   and pressure angle must match.  But beyond that, their pitch cones have to meet at their points.\n//   This means that if you specify the tooth counts\n//   of two gears and the desired shaft angle, then that information completely determines the pitch cones, and hence\n//   the geometry of the gear.  You cannot simply mate two arbitary gears that have the same tooth size\n//   and pressure angle like you can with helical gears: the gears must be designed in pairs to work together.\n//   .\n//   It is most common to design bevel gears so operate with their shafts at 90 degree angles, but\n//   this is not required, and you can design pairs of bevel gears for any desired shaft angle.\n//   Note, however, that some shaft angles may result in extreme bevel gear configurations.  \n// Figure(3D,Med,NoAxes,VPT=[-1.42254,-1.98925,13.5702],VPR=[76,0,145],VPD=263.435): Two zerol bevel gears mated with shafts at 90 degrees.  \n//   bevel_gear(mod=3,teeth=35,face_width=undef,spiral=0,mate_teeth=15,backing=3);\n//   cyl(h=28,d=3,$fn=16,anchor=BOT);\n//   color(\"lightblue\")left(pitch_radius(mod=3,teeth=35))up(pitch_radius(mod=3,teeth=15))\n//   yrot(90){zrot(360/15/2)bevel_gear(mod=3,teeth=15,face_width=undef,spiral=0,right_handed=true,mate_teeth=35);\n//             cyl(h=57,d=3,$fn=16,anchor=BOT);}\n// Figure(3D,Med,NoAxes,VPT=[2.01253,-0.673328,8.98056],VPD=263.435,VPR=[79.5,0,68.6]): Two zerol bevel gears mated with shafts at a 115.38 deg angle.  This is a planar bevel gear.  The axes intersect on the pitch base of the yellow gear.  If the blue gear is tipped slightly more its shaft will intersect the shaft of the yellow gear underneath that gear's pitch base, indicating an impossible angle for a normal bevel gear at this pair of teeth counts.\n//   ang=acos(-15/35);\n//   bevel_gear(mod=3,35,15,ang,spiral=0,face_width=undef,backing=5,anchor=\"apex\")   \n//     cyl(h=25,d=3,$fn=16,anchor=BOT);\n//   color(\"lightblue\")\n//   xrot(ang)\n//   bevel_gear(mod=3,15,35,ang,spiral=0,face_width=undef,right_handed=true,anchor=\"apex\")\n//     cyl(h=70,d=3,$fn=16,anchor=BOT);\n// Continues:\n//   In the above figure you can see a flat bevel gear.  Such a bevel gear is called a planar bevel gear or\n//   sometimes also a crown gear.  The latter term may be confusing because it also refers to a similar looking\n//   but very different type of gear that is described below.  A planar bevel gear can only mate with another\n//   compatible bevel gear.  It has a degenerate cone with its apex on the gear itself, so the mating pinion gear cannot\n//   mate at a 90 degree angle because if it did, its cone could not meet the center of the planar bevel gear.\n//   If you request a larger shaft angle, the teeth of the bevel gear will tilt inward, producing an internal bevel gear.\n//   Gears with this design are rarely used.  The mate of an interior gear is always an exterior gear.  \n// Figure(Med,VPT=[-1.07698,0.67915,-2.25898],VPD=263.435,VPR=[69.7,0,49.3],NoAxes): Internal bevel gear (yellow) mated to an external bevel gear (blue) to achieve a 135 degree shaft angle.  \n//   ang=135;\n//   bevel_gear(mod=3,35,15,ang,spiral=0,cone_backing=false);\n//      down(15)cyl(h=40,d=3,$fn=16,anchor=BOT);\n//   color(\"lightblue\")\n//     back(pitch_radius(mod=3,teeth=35)+pitch_radius(mod=3,teeth=15))\n//     xrot(ang,cp=[0,-pitch_radius(mod=3,teeth=15),0]){\n//         bevel_gear(mod=3,15,35,ang,right_handed=true,spiral=0);\n//               cyl(h=40,d=3,$fn=16,anchor=BOT);\n//     }\n// Subsection: Crown Gears (Face Gears)\n//   Crown gears, sometimes called Face Crown Gears or just Face Gears, are gears with teeth pointing straight up so\n//   the gear resembles a crown.  This type of gear is not the same as a bevel gear with vertical teeth, which would mate\n//   to another bevel gear.  A crown gear mates to a spur gear at a ninety degree angle.  A feature of the crown gear assembly\n//   is that the spur gear can shift along its axis without affecting the mesh.  \n// Figure(2D,Med,NoAxes,VPT=[-2.19006,-1.67419,-4.49379],VPR=[67.6,0,131.9],VPD=113.4): A Crown or Face gear with its mating spur gear in blue.  \n//   crown_gear(mod=1, teeth=32, backing=3, face_width=7);\n//   color(\"lightblue\")\n//   back(pitch_radius(mod=1,teeth=32)+7/2)\n//     up(gear_dist(mod=1,teeth1=0,teeth2=9))spur_gear(mod=1, teeth=9,orient=BACK,thickness=7,gear_spin=360/9/2);\n// Continues:\n//   When constructing a crown gear you need to make it with the same given pressure and and tooth size as\n//   the spur gear you wish to mate to it.  However, the teeth of a crown gear have pressure angle that varies\n//   along the width of the tooth.  The vertical separation of the spur gear from the crown gear is given\n//   by {{gear_dist()}} where you treat the crown gear as a rack.  The inner radius of the teeth on the\n//   crown gear is the pitch radius determined by the gear's tooth size and number of teeth.  The face width\n//   of a crown gear is limited by geometry, so if you make it too large you will get an error.\n//   .\n//   Note that the geometry of these crown gears is tricky and not well documented by sources we have found.\n//   If you know something about crown gears that could improve the implementation, please open an issue\n//   on github.  \n// Section: Backlash (Fitting Real Gears Together)\n//   You may have noticed that the example gears shown fit together perfectly, making contact on both sides of\n//   the teeth.  Real gears need space between the teeth to prevent the gears from jamming, to provide space\n//   for lubricant, and to provide allowance for fabrication error.  This space is called backlash.  Excessive backlash\n//   is undesirable, especially if the drive reverses frequently.\n//   .\n//   Backlash can be introduced in two ways.  One is to make the teeth narrower, so the gaps between the teeth are\n//   larger than the teeth.  Alternatively, you can move the gears farther apart than their ideal spacing.\n//   Backlash can be measured in several different ways.  The gear modules in this library accept a backlash\n//   parameter which specifies backlash as a circular distance at the pitch circle.  The modules narrow\n//   the teeth by the amount specified, which means the spaces between the teeth grow larger.  Of course, if you apply\n//   backlash to both gears then the total backlash in the system is the combined amount from both gears.\n//   Usually it is best to apply backlash symmetrically to both gears, but if one gear is very small it may\n//   be better to place the backlash entirely on the larger gear to avoid weakening the teeth of the small gear.  \n// Figure(2D,Big,VPT=[4.5244,64.112,0.0383045],VPR=[0,0,0],VPD=48.517,NoAxes): Backlash narrows the teeth by the specified length along the pitch circle.  Below the ideal gear appears in the lighter color and the darker color shows the same gear with a very large backlash, which appears with half of the backlash on either side of the tooth.  \n//   teeth1=20;\n//   mod=5;\n//   r1 = pitch_radius(mod=mod,teeth=teeth1,helical=40);\n//   bang=4/(2*PI*r1) * 360 ;\n//   zrot(-180/teeth1*.5){\n//   color(\"white\")\n//   dashed_stroke(arc(r=r1, n=30, angle=[80,110]), width=.05);\n//     spur_gear2d(mod=mod, teeth=teeth1,backlash=0+.5*0,profile_shift=\"auto\",gear_spin=180/teeth1*.5,helical=40);\n//   %spur_gear2d(mod=mod, teeth=teeth1,backlash=4+.5*0,profile_shift=\"auto\",gear_spin=180/teeth1*.5,helical=40);\n//   color(\"black\")stroke(arc(n=32,r=r1,angle=[90+bang/2,90]),width=.1,endcaps=\"arrow2\");\n//   }    \n//   color(\"black\")back(r1+.25)right(5.5)text(\"backlash/2\",size=1);\n// Figure(2D,Med,VPT=[0.532987,50.0891,0.0383045],VPR=[0,0,0],VPD=53.9078): Here two gears appear together with a more reasonable backlash applied to both gears. Again the lighter color shows the ideal gears and the darker shade shows the gear with backlash.  Note that in this example, backlash is present on both of the meshing gears, so the total backlash of the system is the combined backlash from both gears.\n//   teeth1=20;teeth2=33;\n//   mod=5;\n//   ha=0;\n//   r1 = pitch_radius(mod=mod,teeth=teeth1,helical=ha);\n//   r2=pitch_radius(mod=mod,teeth=teeth2,helical=ha);\n//   bang=4/(2*PI*r1) * 360 ;\n//   \n//   back(r1+pitch_radius(mod=mod,teeth=teeth2,helical=ha)){\n//      spur_gear2d(mod=mod, teeth=teeth2,backlash=.5*0,helical=ha,gear_spin=-180/teeth2/2);\n//      %spur_gear2d(mod=mod, teeth=teeth2,backlash=1,helical=ha,gear_spin=-180/teeth2/2);\n//      }\n//   {\n//     spur_gear2d(mod=mod, teeth=teeth1,backlash=0+.5*0,profile_shift=0,gear_spin=180/teeth1*.5,helical=ha);\n//   %spur_gear2d(mod=mod, teeth=teeth1,backlash=1+.5*0,profile_shift=0,gear_spin=180/teeth1*.5,helical=ha);\n//   *color(\"white\"){\n//     dashed_stroke(arc(r=r1, n=30, angle=[80,110]), width=.05);\n//     back(r1+r2)\n//        dashed_stroke(arc(r=r2, n=30, angle=[-80,-110]), width=.05);\n//   }\n//   //color(\"black\")stroke(arc(n=32,r=r1,angle=[90+bang/2,90]),width=.1,endcaps=\"arrow2\");\n//   }\n// Figure(2D,Med,VPT=[0.532987,50.0891,0.0383045],VPR=[0,0,0],VPD=53.9078): Here the same gears as in the previous figure appear with backlash applied using the `backlash` parameter to {{gear_dist()}} to shift them apart.  The original ideal gears are in the lighter shade and the darker colored gears have been separated to create the backlash.  \n//   teeth1=20;teeth2=33;\n//   mod=5;\n//   ha=0;\n//   r1 = pitch_radius(mod=mod,teeth=teeth1,helical=ha);\n//   r2 = pitch_radius(mod=mod,teeth=teeth2,helical=ha);\n//   bang=4/(2*PI*r1) * 360 ;\n//   shift = 1 * cos(ha)/2/tan(20);\n//   back(r1+pitch_radius(mod=mod,teeth=teeth2,helical=ha)){\n//      zrot(-180/teeth2/2){\n//      %back(shift)spur_gear2d(mod=mod, teeth=teeth2,backlash=0,helical=ha);\n//      spur_gear2d(mod=mod, teeth=teeth2,backlash=0,helical=ha);\n//      }\n//      }\n//   zrot(180/teeth1*.5){\n//     %fwd(shift)spur_gear2d(mod=mod, teeth=teeth1,backlash=0+.5*0,profile_shift=0,helical=ha);     \n//     spur_gear2d(mod=mod, teeth=teeth1,backlash=0,profile_shift=0,helical=ha);\n//   }  \n\n// Section: Gears\n\n// Function&Module: spur_gear()\n// Synopsis: Creates a spur gear, helical gear, or internal ring gear.\n// SynTags: Geom, VNF\n// Topics: Gears, Parts\n// See Also: rack(), spur_gear(), spur_gear2d(), bevel_gear()\n// Usage: As a Module\n//   spur_gear(circ_pitch, teeth, [thickness], [helical=], [pressure_angle=], [profile_shift=], [backlash=], [shaft_diam=], [hide=], [clearance=], [slices=], [internal=], [herringbone=]) [ATTACHMENTS];\n//   spur_gear(mod=|diam_pitch=, teeth=, [thickness=], ...) [ATTACHMENTS];\n// Usage: As a Function\n//   vnf = spur_gear(circ_pitch, teeth, [thickness], ...);\n//   vnf = spur_gear(mod=|diam_pitch=, teeth=, [thickness=], ...);\n// Description:\n//   Creates a involute spur gear, helical gear, herringbone gear, or a mask for an internal ring gear.\n//   For more information about gears, see [A Quick Introduction to Gears](gears.scad#section-a-quick-introduction-to-gears).\n//   You must specify the teeth size using either `mod=`, `circ_pitch=` or `diam_pitch=`, and you\n//   must give the number of teeth of the gear.   Spur gears have straight teeth and\n//   mesh together on parallel shafts without creating any axial thrust.  The teeth engage suddenly across their\n//   entire width, creating stress and noise.  Helical gears have angled teeth and engage more gradually, so they\n//   run more smoothly and quietly, however they do produce thrust along the gear axis.  This can be\n//   circumvented using herringbone or double helical gears, which have no axial thrust and also self-align.\n//   Helical gears can mesh along shafts that are not parallel, where the angle between the shafts is\n//   the sum of the helical angles of the two gears.\n//   .\n//   The module creates the gear in the XY plane, centered on the origin, with one tooth centered on the positive Y axis.\n//   In order for two gears to mesh they must have the same tooth size and `pressure_angle`, and\n//   generally the helical angles should be of opposite sign.  \n//   The usual pressure angle (and default) is 20 degrees.  Another common value is 14.5 degrees.\n//   Ideally the teeth count of two meshing gears will be relatively prime because this ensures that\n//   every tooth on one gear will meet every tooth on the other, creating even wear.\n//   .\n//   The \"pitch circle\" of the gear is a reference circle where the circular pitch is defined that\n//   is used to construct the gear.  It runs approximately through the centers of the teeth.  \n//   Two basic gears will mesh when their pitch circles are tangent.  Anchoring for these gears is\n//   done on the pitch circle by default, so basic gears can be meshed using anchoring.\n//   However, when a gear has a small number of teeth, the basic gear form will result in undercutting,\n//   which weakens the teeth.  To avoid this, profile shifting is automatically applied and in this\n//   case, the distance between the gears is a complicated calculation and must be determined using {{gear_dist()}}.  \n//   If you wish to override this correction, you can use `profile_shift=0`, or set it to a specific\n//   value like 0.5.  Another complication with profile shifted gears is that the tips may be too long,\n//   which can eat into the clearance space.  To address this problem you can use the `shorten` parameter,\n//   which you can compute using {{gear_shorten()}}.\n//   .\n//   Helical gears can mesh with skew or crossed axes, a configuration sometimes called \"screw gears\".  \n//   Without profile shifting, that angle is the  sum of the helical angles.\n//   With profile shifting it is slightly different and is given by {{gear_skew_angle()}}.\n//   These gears still mesh on the pitch circle when they are not profile shifted, but the correction to\n//   gear separation for a proper mesh of profile shifted gears is different for skew gears and is\n//   computed using {{gear_dist_skew()}}. \n//   .\n//   To create space for gears to mesh in practice you will need to set a positive value for backlash, or\n//   use the `backlash` argument to {{gear_dist()}}.  \n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   teeth = Total number of teeth around the entire perimeter\n//   thickness = Thickness of gear.  Default: 10 \n//   ---\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   helical = Teeth spiral around the gear at this angle, positive for left handed, negative for right handed.  Default: 0\n//   herringbone = If true, and helical is set, creates a herringbone gear.  Default: False\n//   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees.  Default: 20\n//   profile_shift = Profile shift factor x.  Default: \"auto\"\n//   shorten = Shorten gear tips by the module times this value.  Needed for large profile shifted gears.  Default: 0\n//   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle.  Default: 0\n//   shaft_diam = Diameter of the hole in the center.  Default: 0 (no shaft hole)\n//   hide = Number of teeth to delete to make this only a fraction of a circle.  Default: 0\n//   gear_spin = Rotate gear and children around the gear center, regardless of how gear is anchored.  Default: 0\n//   clearance = Clearance gap at the bottom of the inter-tooth valleys.  Default: mod/4\n//   slices = Number of vertical layers to divide gear into.  Useful for refining gears with `helical`.\n//   internal = If true, create a mask for difference()ing from something else.\n//   atype = Set to \"root\", \"tip\" or \"pitch\" to determine anchoring circle.  Default: \"pitch\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   If internal is true then the default tag is \"remove\"\n// Anchor Types:\n//   root = anchor on the root circle\n//   pitch = anchor on the pitch circle (default)\n//   tip = anchor on the tip circle\n// Example: Spur Gear\n//   spur_gear(circ_pitch=5, teeth=20, thickness=8, shaft_diam=5);\n// Example: Metric Gear\n//   spur_gear(mod=2, teeth=20, thickness=8, shaft_diam=5);\n// Example: Helical Gear\n//   spur_gear(\n//       circ_pitch=5, teeth=20, thickness=10,\n//       shaft_diam=5, helical=-30, slices=12,\n//       $fa=1, $fs=1\n//   );\n// Example: Herringbone Gear\n//   spur_gear(\n//       circ_pitch=5, teeth=20, thickness=10, shaft_diam=5,\n//       helical=30, herringbone=true, slices=5\n//   );\n// Example(Med,VPT=[-0.0213774,2.42972,-0.2709],VPR=[36.1,0,20.1],VPD=74.3596): Effects of Profile Shifting.\n//   circ_pitch=5; teeth=7; thick=10; shaft=5; strokewidth=0.2;\n//   pr = pitch_radius(circ_pitch, teeth);\n//   left(10) {\n//       profile_shift = 0;\n//       d = gear_dist(circ_pitch=circ_pitch,teeth,0,profile_shift1=profile_shift);\n//       back(d) spur_gear(circ_pitch, teeth, thick, shaft, profile_shift=profile_shift);\n//       rack(circ_pitch, teeth=3, thickness=thick, orient=BACK);\n//       color(\"black\") up(thick/2) linear_extrude(height=0.1) {\n//           back(d) dashed_stroke(circle(r=pr), width=strokewidth, closed=true);\n//           dashed_stroke([[-7.5,0],[7.5,0]], width=strokewidth);\n//       }\n//   }\n//   right(10) {\n//       profile_shift = 0.59;\n//       d = gear_dist(circ_pitch=circ_pitch,teeth,0,profile_shift1=profile_shift);\n//       back(d) spur_gear(circ_pitch, teeth, thick, shaft, profile_shift=profile_shift);\n//       rack(circ_pitch, teeth=3, thickness=thick, orient=BACK);\n//       color(\"black\") up(thick/2) linear_extrude(height=0.1) {\n//           back(d)\n//               dashed_stroke(circle(r=pr), width=strokewidth, closed=true);\n//           dashed_stroke([[-7.5,0],[7.5,0]], width=strokewidth);\n//       }\n//   }\n// Example(Anim,Med,NoAxes,Frames=8,VPT=[0,30,0],VPR=[0,0,0],VPD=300): Assembly of Gears\n//   $fn=12;\n//   n1 = 11; //red gear number of teeth\n//   n2 = 20; //green gear\n//   n3 = 6;  //blue gear\n//   n4 = 16; //orange gear\n//   n5 = 9;  //gray rack\n//   circ_pitch = 9; //all meshing gears need the same `circ_pitch` (and the same `pressure_angle`)\n//   thickness    = 6;\n//   hole         = 3;\n//   rack_base    = 12;\n//   d12 = gear_dist(circ_pitch=circ_pitch,teeth1=n1,teeth2=n2);\n//   d13 = gear_dist(circ_pitch=circ_pitch,teeth1=n1,teeth2=n3);\n//   d14 = gear_dist(circ_pitch=circ_pitch,teeth1=n1,teeth2=n4);\n//   d1r = gear_dist(circ_pitch=circ_pitch,teeth1=n1,teeth2=0);\n//   a1 =  $t * 360 / n1;\n//   a2 = -$t * 360 / n2 + 180/n2;\n//   a3 = -$t * 360 / n3 - 3*90/n3;\n//   a4 = -$t * 360 / n4 - 3.5*180/n4;\n//   color(\"#f77\")              zrot(a1) spur_gear(circ_pitch,n1,thickness,hole);\n//   color(\"#7f7\") back(d12)  zrot(a2) spur_gear(circ_pitch,n2,thickness,hole);\n//   color(\"#77f\") right(d13) zrot(a3) spur_gear(circ_pitch,n3,thickness,hole);\n//   color(\"#fc7\") left(d14)  zrot(a4) spur_gear(circ_pitch,n4,thickness,hole,hide=n4-3);\n//   color(\"#ccc\") fwd(d1r) right(circ_pitch*$t)\n//       rack(pitch=circ_pitch,teeth=n5,thickness=thickness,width=rack_base,anchor=CENTER,orient=BACK);\n// Example(NoAxes,VPT=[1.13489,-4.48517,1.04995],VPR=[55,0,25],VPD=139.921): Helical gears meshing with non-parallel shafts\n//   ang1 = 30;\n//   ang2 = 10;\n//   circ_pitch = 5;\n//   n = 20;\n//   dist = gear_dist_skew(\n//      circ_pitch=circ_pitch,\n//      teeth1=n, teeth2=n,\n//      helical1=ang1, helical2=ang2);\n//   left(dist/2) spur_gear(\n//          circ_pitch, teeth=n, thickness=10,\n//          shaft_diam=5, helical=ang1, slices=12,\n//          gear_spin=-90\n//      );\n//   right(dist/2)\n//   xrot(ang1+ang2)\n//   spur_gear(\n//          circ_pitch=circ_pitch, teeth=n, thickness=10,\n//          shaft_diam=5, helical=ang2, slices=12,\n//          gear_spin=90-180/n\n//      );\n// Example(Anim,Big,NoAxes,Frames=36,VPT=[0,0,0],VPR=[55,0,25],VPD=220): Planetary Gear Assembly\n//   $fn=128;\n//   rteeth=56; pteeth=16; cteeth=24;\n//   circ_pitch=5; thick=10; pa=20;\n//   gd = gear_dist(circ_pitch=circ_pitch, cteeth, pteeth);\n//   ring_gear(\n//       circ_pitch=circ_pitch,\n//       teeth=rteeth,\n//       thickness=thick,\n//       pressure_angle=pa);\n//   for (a=[0:3]) {\n//       zrot($t*90+a*90) back(gd) {\n//           color(\"green\")\n//           spur_gear(\n//               circ_pitch=circ_pitch,\n//               teeth=pteeth,\n//               thickness=thick,\n//               shaft_diam=5,\n//               pressure_angle=pa,\n//               spin=-$t*90*rteeth/pteeth);\n//       }\n//   }\n//   color(\"orange\")\n//   zrot($t*90*rteeth/cteeth+$t*90+180/cteeth)\n//   spur_gear(\n//       circ_pitch=circ_pitch,\n//       teeth=cteeth,\n//       thickness=thick,\n//       shaft_diam=5,\n//       pressure_angle=pa);\n\nfunction spur_gear(\n    circ_pitch,\n    teeth,\n    thickness,\n    shaft_diam = 0,\n    hide = 0,\n    pressure_angle,\n    clearance,\n    backlash = 0.0,\n    helical,\n    interior,\n    internal,\n    profile_shift=\"auto\",\n    slices,\n    herringbone=false,\n    shorten=0,\n    diam_pitch,\n    mod,\n    pitch,\n    gear_spin = 0,\n    atype = \"pitch\", \n    anchor = CENTER,\n    spin = 0,\n    orient = UP\n) =\n    let(  \n        dummy = !is_undef(interior) ? echo(\"In spur_gear(), the argument 'interior=' has been deprecated, and may be removed in the future.  Please use 'internal=' instead.\"):0,\n        internal = first_defined([internal,interior,false]),\n        circ_pitch = _inherit_gear_pitch(\"spur_gear()\", pitch, circ_pitch, diam_pitch, mod),\n        PA = _inherit_gear_pa(pressure_angle),\n        helical = _inherit_gear_helical(helical, invert=!internal),\n        thickness = _inherit_gear_thickness(thickness)\n    )\n    assert(is_integer(teeth) && teeth>3)\n    assert(is_finite(thickness) && thickness>0)\n    assert(is_finite(shaft_diam) && shaft_diam>=0)\n    assert(is_integer(hide) && hide>=0 && hide<teeth)\n    assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n    assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n    assert(is_finite(backlash) && backlash>=0)\n    assert(is_finite(helical) && abs(helical)<90)\n    assert(is_bool(herringbone))\n    assert(slices==undef || (is_integer(slices) && slices>0))\n    assert(is_finite(gear_spin))\n    let(\n        profile_shift = auto_profile_shift(teeth,PA,helical,profile_shift=profile_shift),\n        pr = pitch_radius(circ_pitch, teeth, helical),\n        or = outer_radius(circ_pitch, teeth, helical=helical, profile_shift=profile_shift, internal=internal,shorten=shorten),\n        rr = _root_radius(circ_pitch, teeth, clearance, profile_shift=profile_shift, internal=internal),\n        anchor_rad = atype==\"pitch\" ? pr\n                   : atype==\"tip\" ? or\n                   : atype==\"root\" ? rr\n                   : assert(false,\"atype must be one of \\\"root\\\", \\\"tip\\\" or \\\"pitch\\\"\"),\n        circum = 2 * PI * pr,\n        twist = 360*thickness*tan(helical)/circum,\n        slices = default(slices, ceil(twist/360*segs(pr)+1)),\n        rgn = spur_gear2d(\n                circ_pitch = circ_pitch,\n                teeth = teeth,\n                pressure_angle = PA,\n                hide = hide,\n                helical = helical,\n                clearance = clearance,\n                backlash = backlash,\n                internal = internal,\n                shorten = shorten,\n                profile_shift = profile_shift,\n                shaft_diam = shaft_diam\n            ),\n        rvnf = herringbone\n          ? zrot(twist/2, p=linear_sweep(rgn, height=thickness, twist=twist, slices=slices, center=true))\n          : let(\n                wall_vnf = linear_sweep(rgn, height=thickness/2, twist=twist/2, slices=ceil(slices/2), center=false, caps=false),\n                cap_vnf = vnf_from_region(rgn, transform=up(thickness/2)*zrot(twist/2))\n            )\n            vnf_join([\n                wall_vnf, zflip(p=wall_vnf),\n                cap_vnf,  zflip(p=cap_vnf),\n            ]),\n        vnf = zrot(gear_spin, p=rvnf)\n    ) reorient(anchor,spin,orient, h=thickness, r=anchor_rad, p=vnf);\n\n\nmodule spur_gear(\n    circ_pitch,\n    teeth,\n    thickness,\n    shaft_diam = 0,\n    hide = 0,\n    pressure_angle,\n    clearance,\n    backlash = 0.0,\n    helical,\n    internal,\n    interior,\n    profile_shift=\"auto\",\n    slices,\n    herringbone=false,\n    shorten=0,\n    pitch,\n    diam_pitch,\n    mod,\n    atype=\"pitch\",\n    gear_spin = 0,\n    anchor = CENTER,\n    spin = 0,\n    orient = UP\n) {\n    dummy = !is_undef(interior) ? echo(\"In spur_gear(), the argument 'interior=' has been deprecated, and may be removed in the future.  Please use 'internal=' instead.\"):0;\n    internal = first_defined([internal,interior,false]);\n    circ_pitch = _inherit_gear_pitch(\"spur_gear()\", pitch, circ_pitch, diam_pitch, mod);\n    PA = _inherit_gear_pa(pressure_angle);\n    helical = _inherit_gear_helical(helical, invert=!internal);\n    thickness = _inherit_gear_thickness(thickness);\n    checks =\n        assert(is_integer(teeth) && teeth>3)\n        assert(is_finite(thickness) && thickness>0)\n        assert(is_finite(shaft_diam) && shaft_diam>=0)\n        assert(is_integer(hide) && hide>=0 && hide<teeth)\n        assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n        assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n        assert(is_finite(backlash) && backlash>=0)\n        assert(is_finite(helical) && abs(helical)<90)\n        assert(is_bool(herringbone))\n        assert(slices==undef || (is_integer(slices) && slices>0))\n        assert(is_finite(gear_spin));\n    profile_shift = auto_profile_shift(teeth,PA,helical,profile_shift=profile_shift);\n    pr = pitch_radius(circ_pitch, teeth, helical);\n    or = outer_radius(circ_pitch, teeth, helical=helical, profile_shift=profile_shift, internal=internal,shorten=shorten);\n    rr = _root_radius(circ_pitch, teeth, clearance, profile_shift=profile_shift, internal=internal);\n    anchor_rad = atype==\"pitch\" ? pr\n               : atype==\"tip\" ? or\n               : atype==\"root\" ? rr\n               : assert(false,\"atype must be one of \\\"root\\\", \\\"tip\\\" or \\\"pitch\\\"\");\n    circum = 2 * PI * pr;\n    twist = 360*thickness*tan(helical)/circum;\n    slices = default(slices, ceil(twist/360*segs(pr)+1));\n    default_tag(\"remove\", internal) {\n        attachable(anchor,spin,orient, r=anchor_rad, l=thickness) {\n            zrot(gear_spin)\n            if (herringbone) {\n                zflip_copy() down(0.01)\n                linear_extrude(\n                    height=thickness/2+0.01, center=false,\n                    twist=twist/2, slices=ceil(slices/2),\n                    convexity=teeth/2\n                ) {\n                    spur_gear2d(\n                        circ_pitch = circ_pitch,\n                        teeth = teeth,\n                        pressure_angle = PA,\n                        hide = hide,\n                        helical = helical,\n                        clearance = clearance,\n                        backlash = backlash,\n                        internal = internal,\n                        shorten = shorten, \n                        profile_shift = profile_shift,\n                        shaft_diam = shaft_diam\n                    );\n                }\n            } else {\n                zrot(twist/2)\n                linear_extrude(\n                    height=thickness, center=true,\n                    twist=twist, slices=slices,\n                    convexity=teeth/2\n                ) {\n                    spur_gear2d(\n                        circ_pitch = circ_pitch,\n                        teeth = teeth,\n                        pressure_angle = PA,\n                        hide = hide,\n                        helical = helical,\n                        clearance = clearance,\n                        backlash = backlash,\n                        internal = internal,\n                        profile_shift = profile_shift,\n                        shaft_diam = shaft_diam\n                    );\n                }\n            }\n            union() {\n                $parent_gear_type = \"spur\";\n                $parent_gear_pitch = circ_pitch;\n                $parent_gear_teeth = teeth;\n                $parent_gear_pa = PA;\n                $parent_gear_helical = helical;\n                $parent_gear_thickness = thickness;\n                union() children();\n            }\n        }\n    }\n}\n\n\n// Function&Module: spur_gear2d()\n// Synopsis: Creates a 2D spur gear or internal ring gear.\n// SynTags: Geom, Region\n// Topics: Gears, Parts\n// See Also: rack(), spur_gear(), spur_gear2d(), bevel_gear()\n// Usage: As Module\n//   spur_gear2d(circ_pitch, teeth, [pressure_angle=], [profile_shift=], [shorten=], [hide=], [shaft_diam=], [clearance=], [backlash=], [internal=]) [ATTACHMENTS];\n//   spur_gear2d(mod=|diam_pitch=, teeth=, [pressure_angle=], [profile_shift=], [shorten=], [hide=], [shaft_diam=], [clearance=], [backlash=], [internal=]) [ATTACHMENTS];\n// Usage: As Function\n//   rgn = spur_gear2d(circ_pitch, teeth, [pressure_angle=], [profile_shift=], [shorten=], [hide=], [shaft_diam=], [clearance=], [backlash=], [internal=]);\n//   rgn = spur_gear2d(mod=, teeth=, [pressure_angle=], [profile_shift=], [shorten=], [hide=], [shaft_diam=], [clearance=], [backlash=], [internal=]);\n// Description:\n//   Creates a 2D involute spur gear, or a mask for an internal ring gear.\n//   For more information about gears, see [A Quick Introduction to Gears](gears.scad#section-a-quick-introduction-to-gears).\n//   You must specify the teeth size using either `mod=`, `circ_pitch=` or `diam_pitch=`, and you\n//   must give the number of teeth.  \n//   .\n//   The module creates the gear in centered on the origin, with one tooth centered on the positive Y axis.\n//   In order for two gears to mesh they must have the same tooth size and `pressure_angle`\n//   The usual pressure angle (and default) is 20 degrees.  Another common value is 14.5 degrees.\n//   Ideally the teeth count of two meshing gears will be relatively prime because this ensures that\n//   every tooth on one gear will meet every tooth on the other, creating even wear.\n//   .\n//   The \"pitch circle\" of the gear is a reference circle where the circular pitch is defined that\n//   is used to construct the gear.  It runs approximately through the centers of the teeth.  \n//   Two basic gears will mesh when their pitch circles are tangent.  Anchoring for these gears is\n//   done on the pitch circle by default, so basic gears can be meshed using anchoring.\n//   However, when a gear has a small number of teeth, the basic gear form will result in undercutting,\n//   which weakens the teeth.  To avoid this, profile shifting is automatically applied and in this\n//   case, the distance between the gears is a complicated calculation and must be determined using {{gear_dist()}}.  \n//   If you wish to override this correction, you can use `profile_shift=0`, or set it to a specific\n//   value like 0.5.  Another complication with profile shifted gears is that the tips may be too long,\n//   which can eat into the clearance space.  To address this problem you can use the `shorten` parameter,\n//   which you can compute using {{gear_shorten()}}.\n//   .\n//   To create space for gears to mesh in practice you will need to set a positive value for backlash, or\n//   use the `backlash` argument to {{gear_dist()}}.  \n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   teeth = Total number of teeth around the spur gear.\n//   ---\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees.\n//   profile_shift = Profile shift factor x.  Default: \"auto\"\n//   shorten = Shorten gear tips by the module times this value.  Needed for large profile shifted gears.  Default: 0\n//   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle.  Default: 0\n//   helical = Adjust teeth form (stretch out the teeth) to give the cross section of a gear with this helical angle.  Default: 0\n//   hide = Number of teeth to delete to make this only a fraction of a circle\n//   gear_spin = Rotate gear and children around the gear center, regardless of how gear is anchored.  Default: 0\n//   clearance = Gap between top of a tooth on one gear and bottom of valley on a meshing gear.  Default: mod/4\n//   internal = If true, create a mask for difference()ing from something else.\n//   shaft_diam = If given, the diameter of the central shaft hole.\n//   atype = Set to \"root\", \"tip\" or \"pitch\" to determine anchoring circle.  Default: \"pitch\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Side Effects:\n//   If internal is true then the default tag is \"remove\"\n// Anchor Types:\n//   root = anchor on the root circle\n//   pitch = anchor on the pitch circle (default)\n//   tip = anchor on the tip circle\n// Example(2D): Typical Gear Shape\n//   spur_gear2d(circ_pitch=5, teeth=20, shaft_diam=5);\n// Example(2D): By Metric Module\n//   spur_gear2d(mod=2, teeth=20, shaft_diam=5);\n// Example(2D): By Imperial Gear Pitch\n//   spur_gear2d(diam_pitch=10, teeth=20, shaft_diam=5);\n// Example(2D): Lower Pressure Angle\n//   spur_gear2d(circ_pitch=5, teeth=20, pressure_angle=14);\n// Example(2D): Partial Gear\n//   spur_gear2d(circ_pitch=5, teeth=20, hide=15, pressure_angle=20);\n// Example(2D,Med,VPT=[0.151988,3.93719,1.04995],VPR=[0,0,0],VPD=74.3596): Effects of Profile Shifting.\n//   circ_pitch=5; teeth=7; shaft=5; strokewidth=0.2;\n//   module the_gear(profile_shift=0) {\n//       $fn=72;\n//       pr = pitch_radius(circ_pitch,teeth);\n//       mr = gear_dist(circ_pitch=circ_pitch,teeth,profile_shift1=profile_shift,teeth2=0);\n//       back(mr) {\n//           spur_gear2d(circ_pitch, teeth, shaft_diam=shaft, profile_shift=profile_shift);\n//           up(0.1) color(\"black\")\n//               dashed_stroke(circle(r=pr), width=strokewidth, closed=true);\n//       }\n//   }\n//   module the_rack() {\n//       $fn=72;\n//       rack2d(circ_pitch, teeth=3);\n//       up(0.1) color(\"black\")\n//           dashed_stroke([[-7.5,0],[7.5,0]], width=strokewidth);\n//   }\n//   left(10) { the_gear(0); the_rack(); }\n//   right(10) { the_gear(0.59); the_rack(); }\n// Example(2D): Planetary Gear Assembly\n//   rteeth=56; pteeth=16; cteeth=24;\n//   circ_pitch=5; pa=20;\n//   gd = gear_dist(circ_pitch=circ_pitch, cteeth,pteeth);\n//   ring_gear2d(\n//       circ_pitch=circ_pitch,\n//       teeth=rteeth,\n//       pressure_angle=pa);\n//   for (a=[0:3]) {\n//       zrot(a*90) back(gd) {\n//           color(\"green\")\n//           spur_gear2d(\n//               circ_pitch=circ_pitch,\n//               teeth=pteeth,\n//               pressure_angle=pa);\n//       }\n//   }\n//   color(\"orange\")\n//     zrot(180/cteeth)\n//       spur_gear2d(\n//           circ_pitch=circ_pitch,\n//           teeth=cteeth,\n//           pressure_angle=pa);\n// Example(2D): Called as a Function\n//   rgn = spur_gear2d(circ_pitch=8, teeth=16, shaft_diam=5);\n//   region(rgn);\n\nfunction spur_gear2d(\n    circ_pitch,\n    teeth,\n    hide = 0,\n    pressure_angle,\n    clearance,\n    backlash = 0.0,\n    internal,\n    interior,\n    profile_shift=\"auto\",\n    helical,\n    shaft_diam = 0,\n    shorten = 0, \n    pitch,\n    diam_pitch,\n    mod,\n    gear_spin = 0,\n    atype=\"pitch\", \n    anchor = CENTER,\n    spin = 0\n) = let(\n        dummy = !is_undef(interior) ? echo(\"In spur_gear2d(), the argument 'interior=' has been deprecated, and may be removed in the future.  Please use 'internal=' instead.\"):0,\n        internal = first_defined([internal,interior,false]),\n        circ_pitch = _inherit_gear_pitch(\"spur_gear2d()\", pitch, circ_pitch, diam_pitch, mod),\n        PA = _inherit_gear_pa(pressure_angle),\n        helical = _inherit_gear_helical(helical, invert=!internal)\n    )\n    assert(is_integer(teeth) && teeth>3)\n    assert(is_finite(shaft_diam) && shaft_diam>=0)\n    assert(is_integer(hide) && hide>=0 && hide<teeth)\n    assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n    assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n    assert(is_finite(backlash) && backlash>=0)\n    assert(is_finite(helical) && abs(helical)<90)\n    assert(is_finite(gear_spin))\n    let(\n        profile_shift = auto_profile_shift(teeth,PA,helical,profile_shift=profile_shift),\n        pr = pitch_radius(circ_pitch, teeth, helical=helical),\n        or = outer_radius(circ_pitch, teeth, helical=helical, profile_shift=profile_shift, internal=internal,shorten=shorten),\n        rr = _root_radius(circ_pitch, teeth, clearance, profile_shift=profile_shift, internal=internal),\n        anchor_rad = atype==\"pitch\" ? pr\n                   : atype==\"tip\" ? or\n                   : atype==\"root\" ? rr\n                   : assert(false,\"atype must be one of \\\"root\\\", \\\"tip\\\" or \\\"pitch\\\"\"),\n        tooth = _gear_tooth_profile(\n                circ_pitch=circ_pitch,\n                teeth=teeth,\n                pressure_angle=PA,\n                clearance=clearance,\n                backlash=backlash,\n                profile_shift=profile_shift,\n                helical=helical,\n                shorten=shorten,\n                internal=internal\n            ),\n        perim = [\n            for (i = [0:1:teeth-1-hide])\n                each zrot(-i*360/teeth+gear_spin, p=tooth),\n            if (hide>0) [0,0],\n        ],\n        rgn = [\n            list_unwrap(deduplicate(perim)),\n            if (shaft_diam>0 && !hide)\n                reverse(circle(d=shaft_diam, $fn=max(16,segs(shaft_diam/2)))),\n        ]\n    ) reorient(anchor,spin, two_d=true, r=anchor_rad, p=rgn);\n\n\nmodule spur_gear2d(\n    circ_pitch,\n    teeth,\n    hide = 0,\n    pressure_angle,\n    clearance,\n    backlash = 0.0,\n    internal,\n    interior,\n    profile_shift=\"auto\",\n    helical,\n    shorten = 0, \n    shaft_diam = 0,\n    pitch,\n    diam_pitch,\n    mod,\n    gear_spin = 0,\n    atype=\"pitch\",\n    anchor = CENTER,\n    spin = 0\n) {\n    dummy = !is_undef(interior) ? echo(\"In spur_gear2d(), the argument 'interior=' has been deprecated, and may be removed in the future.  Please use 'internal=' instead.\"):0;\n    internal = first_defined([internal,interior,false]);\n    circ_pitch = _inherit_gear_pitch(\"spur_gear2d()\", pitch, circ_pitch, diam_pitch, mod);\n    PA = _inherit_gear_pa(pressure_angle);\n    helical = _inherit_gear_helical(helical, invert=!internal);\n    checks =\n        assert(is_integer(teeth) && teeth>3)\n        assert(is_finite(shaft_diam) && shaft_diam>=0)\n        assert(is_integer(hide) && hide>=0 && hide<teeth)\n        assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n        assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n        assert(is_finite(backlash) && backlash>=0)\n        assert(is_finite(helical) && abs(helical)<90)\n        assert(is_finite(gear_spin));\n    profile_shift = auto_profile_shift(teeth,PA,helical,profile_shift=profile_shift);\n    rgn = spur_gear2d(\n        circ_pitch = circ_pitch,\n        teeth = teeth,\n        hide = hide,\n        pressure_angle = PA,\n        clearance = clearance,\n        helical = helical,\n        backlash = backlash,\n        profile_shift = profile_shift,\n        internal = internal,\n        shorten = shorten, \n        shaft_diam = shaft_diam\n    );\n    pr = pitch_radius(circ_pitch, teeth, helical=helical);\n    or = outer_radius(circ_pitch, teeth, helical=helical, profile_shift=profile_shift, internal=internal,shorten=shorten);\n    rr = _root_radius(circ_pitch, teeth, clearance, profile_shift=profile_shift, internal=internal);\n    anchor_rad = atype==\"pitch\" ? pr\n               : atype==\"tip\" ? or\n               : atype==\"root\" ? rr\n               : assert(false,\"atype must be one of \\\"root\\\", \\\"tip\\\" or \\\"pitch\\\"\");\n    attachable(anchor,spin, two_d=true, r=anchor_rad) {\n        zrot(gear_spin) region(rgn);\n        union() {\n            $parent_gear_type = \"spur2D\";\n            $parent_gear_pitch = circ_pitch;\n            $parent_gear_teeth = teeth;\n            $parent_gear_pa = PA;\n            $parent_gear_helical = helical;\n            $parent_gear_thickness = 0;\n            union() children();\n        }\n    }\n}\n\n\n// Module: ring_gear()\n// Synopsis: Creates a 3D ring gear.\n// SynTags: Geom\n// Topics: Gears, Parts\n// See Also: rack(), ring_gear2d(), spur_gear(), spur_gear2d(), bevel_gear()\n// Usage:\n//   ring_gear(circ_pitch, teeth, thickness, [backing|od=|or=|width=], [pressure_angle=], [helical=], [herringbone=], [profile_shift=], [clearance=], [backlash=]) [ATTACHMENTS];\n//   ring_gear(mod=, teeth=, thickness=, [backing=|od=|or=|width=], [pressure_angle=], [helical=], [herringbone=], [profile_shift=], [clearance=], [backlash=]) [ATTACHMENTS];\n//   ring_gear(diam_pitch=, teeth=, thickness=, [backing=|od=|or=|width=], [pressure_angle=], [helical=], [herringbone=], [profile_shift=], [clearance=], [backlash=]) [ATTACHMENTS];\n// Description:\n//   Creates a 3D involute ring gear.\n//   Meshing gears must have the same tooth size, pressure angle and helical angle as usual.\n//   Additionally, you must have more teeth on an internal gear than its mating external gear, and\n//   the profile shift on the ring gear must be at least as big as the profile shift on the mating gear.\n//   You may need to use {{auto_profile_shift()}} to find this value if your mating gear has a small number of teeth.\n//   The gear spacing is given by {{gear_dist()}}.\n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   teeth = Total number of teeth around the spur gear.\n//   thickness = Thickness of ring gear\n//   backing = The width of the ring gear backing.  Default: height of teeth\n//   ---\n//   od = outer diameter of the ring\n//   or = outer radius of the ring\n//   width = width of the ring, measuring from tips of teeth to outside of ring.  \n//   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees.\n//   helical = The angle of the rack teeth away from perpendicular to the gear axis of rotation.  Stretches out the tooth shapes.  Used to match helical spur gear pinions.  Default: 0\n//   herringbone = If true, and helical is set, creates a herringbone gear.\n//   profile_shift = Profile shift factor x for tooth profile.  Default: 0\n//   clearance = Gap between top of a tooth on one gear and bottom of valley on a meshing gear (in millimeters)\n//   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   mod = The module of the gear (pitch diameter / teeth)\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   ring_gear(circ_pitch=5, teeth=48, thickness=10);\n// Example: Adjusting Backing\n//   ring_gear(circ_pitch=5, teeth=48, thickness=10, backing=30);\n// Example(Med): Adjusting Pressure Angle\n//   ring_gear(circ_pitch=5, teeth=48, thickness=10, pressure_angle=28);\n// Example(Med): Tooth Profile Shifting\n//   ring_gear(circ_pitch=5, teeth=48, thickness=10, profile_shift=0.5);\n// Example(Med): Helical Ring Gear\n//   ring_gear(circ_pitch=5, teeth=48, thickness=15, helical=30);\n// Example(Med): Herringbone Ring Gear\n//   ring_gear(circ_pitch=5, teeth=48, thickness=30, helical=30, herringbone=true);\n\nmodule ring_gear(\n    circ_pitch,\n    teeth,\n    thickness = 10,\n    backing,\n    pressure_angle,\n    helical,\n    herringbone = false,\n    profile_shift=0,\n    clearance,\n    backlash = 0.0,\n    or,od,width,\n    pitch,\n    diam_pitch,\n    mod,\n    slices,\n    gear_spin = 0,\n    anchor = CENTER,\n    atype = \"pitch\",\n    spin = 0,\n    orient = UP\n) {\n    circ_pitch = _inherit_gear_pitch(\"ring_gear()\",pitch, circ_pitch, diam_pitch, mod);\n    PA = _inherit_gear_pa(pressure_angle);\n    helical = _inherit_gear_helical(helical);       //Maybe broken???\n    thickness = _inherit_gear_thickness(thickness);\n    checks =\n        assert(in_list(atype,[\"outside\",\"pitch\"]))\n        assert(is_finite(profile_shift), \"Profile shift for ring gears must be numerical\")\n        assert(is_integer(teeth) && teeth>3)\n        assert(is_finite(thickness) && thickness>0)\n        assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n        assert(is_finite(helical) && abs(helical)<90)\n        assert(is_bool(herringbone))\n        assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n        assert(is_finite(backlash) && backlash>=0)\n        assert(slices==undef || (is_integer(slices) && slices>0))\n        assert(num_defined([backing,or,od,width])<=1, \"Cannot define more than one of backing, or, od and width\")\n        assert(is_finite(gear_spin));\n    pr = pitch_radius(circ_pitch, teeth, helical=helical);\n    ar = outer_radius(circ_pitch, teeth, helical=helical, profile_shift=profile_shift, internal=true);\n    rr=_root_radius(circ_pitch, teeth, clearance, profile_shift=profile_shift, internal=true);\n    or = is_def(or) ?\n            assert(is_finite(or) && or>ar, \"or is invalid or too small for teeth\")\n            or\n       : is_def(od) ?\n            assert(is_finite(od) && od>2*ar, \"od is invalid or too small for teeth\")\n            od/2\n       : is_def(width) ?\n            assert(is_finite(width) && width>ar-rr, \"width is invalid or too small for teeth\")\n            rr+width\n       : is_def(backing) ?\n            assert(all_positive([backing]), \"backing must be a positive value\")\n            ar+backing\n       : 2*ar - rr;    // default case\n    circum = 2 * PI * pr;\n    twist = 360*thickness*tan(-helical)/circum;\n    slices = default(slices, ceil(twist/360*segs(pr)+1));\n    attachable(anchor,spin,orient, h=thickness, r=atype==\"outside\"?or:pr) {\n        zrot(gear_spin)\n        if (herringbone) {\n            zflip_copy() down(0.01)\n            linear_extrude(height=thickness/2, center=false, twist=twist/2, slices=ceil(slices/2), convexity=teeth/4) {\n                difference() {\n                    circle(r=or);\n                    spur_gear2d(\n                        circ_pitch = circ_pitch,\n                        teeth = teeth,\n                        pressure_angle = PA,\n                        helical = helical,\n                        clearance = clearance,\n                        backlash = backlash,\n                        profile_shift = profile_shift,\n                        internal = true\n                    );\n                }\n            }\n        } else {\n            zrot(twist/2)\n            linear_extrude(height=thickness,center=true, twist=twist, convexity=teeth/4) {\n                difference() {\n                    circle(r=or);\n                    spur_gear2d(\n                        circ_pitch = circ_pitch,\n                        teeth = teeth,\n                        pressure_angle = PA,\n                        helical = helical,\n                        clearance = clearance,\n                        backlash = backlash,\n                        profile_shift = profile_shift,\n                        internal = true\n                    );\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: ring_gear2d()\n// Synopsis: Creates a 2D ring gear.\n// SynTags: Geom\n// Topics: Gears, Parts\n// See Also: rack(), spur_gear(), spur_gear2d(), bevel_gear()\n// Usage:\n//   ring_gear2d(circ_pitch, teeth, [backing|od=|or=|width=], [pressure_angle=], [helical=], [profile_shift=], [clearance=], [backlash=]) [ATTACHMENTS];\n//   ring_gear2d(mod=, teeth=, [backing=|od=|or=|width=], [pressure_angle=], [helical=], [profile_shift=], [clearance=], [backlash=]) [ATTACHMENTS];\n//   ring_gear2d(diam_pitch=, teeth=, [backing=|od=|or=|width=], [pressure_angle=], [helical=], [profile_shift=], [clearance=], [backlash=]) [ATTACHMENTS];\n// Description:\n//   Creates a 2D involute ring gear.  \n//   Meshing gears must have the same tooth size, pressure angle and helical angle as usual.\n//   Additionally, you must have more teeth on an internal gear than its mating external gear, and\n//   the profile shift on the ring gear must be at least as big as the profile shift on the mating gear.\n//   You may need to use {{auto_profile_shift()}} to find this value if your mating gear has a small number of teeth.\n//   The gear spacing is given by {{gear_dist()}}.\n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   teeth = Total number of teeth around the spur gear.\n//   backing = The width of the ring gear backing.  Default: height of teeth\n//   ---\n//   od = outer diameter of the ring\n//   or = outer radius of the ring\n//   width = width of the ring, measuring from tips of teeth to outside of ring.  \n//   helical = The angle of the rack teeth away from perpendicular to the gear axis of rotation.  Stretches out the tooth shapes.  Used to match helical spur gear pinions.  Default: 0\n//   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees.\n//   profile_shift = Profile shift factor x for tooth profile.  Default: 0\n//   clearance = Gap between top of a tooth on one gear and bottom of valley on a meshing gear (in millimeters)\n//   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   mod = The module of the gear (pitch diameter / teeth)\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Anchor Types:\n//   pitch = anchor on the pitch circle (default)\n//   outside = outside edge of the gear\n// Example(2D,Big):  Meshing a ring gear with a spur gear\n//   circ_pitch=5; teeth1=50; teeth2=18;\n//   dist = gear_dist(circ_pitch=circ_pitch, teeth1, teeth2, internal1=true);\n//   ring_gear2d(circ_pitch=circ_pitch, teeth=teeth1);\n//   color(\"lightblue\")back(dist)\n//     spur_gear2d(circ_pitch=circ_pitch, teeth=teeth2);\n// Example(2D,Med,VPT=[-0.117844,-0.439102,-0.372203],VPR=[0,0,0],VPD=192.044): Meshing a ring gear with an auto-profile-shifted spur gear:\n//   teeth1=7;    teeth2=15;\n//   ps1=undef;     // Allow auto profile shifting for first gear\n//   ps2=auto_profile_shift(teeth=teeth1);\n//   mod=3;\n//   d = gear_dist(mod=mod, teeth1=teeth1, teeth2=teeth2, profile_shift1=ps1, profile_shift2=ps2, internal2=true);\n//   ring_gear2d(mod=mod, teeth=teeth2,profile_shift=ps2);\n//   color(\"lightblue\") fwd(d)\n//      spur_gear2d(mod=mod, teeth=teeth1, profile_shift=ps1);\n\nmodule ring_gear2d(\n    circ_pitch,\n    teeth,\n    backing,\n    pressure_angle,\n    helical,\n    profile_shift=0,\n    clearance,\n    backlash = 0.0,\n    or,od,width,\n    pitch,\n    diam_pitch,\n    mod,\n    atype=\"pitch\",\n    gear_spin = 0,shorten=0,\n    anchor = CENTER,\n    spin = 0\n) {\n    \n    circ_pitch = _inherit_gear_pitch(\"ring_gear2d()\",pitch, circ_pitch, diam_pitch, mod);\n    PA = _inherit_gear_pa(pressure_angle);\n    helical = _inherit_gear_helical(helical);\n    checks =\n        assert(in_list(atype,[\"outside\",\"pitch\"]))\n        assert(is_finite(profile_shift), \"Profile shift for ring gears must be numerical\")\n        assert(is_integer(teeth) && teeth>3)\n        assert(num_defined([backing,or,od,width])<=1, \"Cannot define more than one of backing, or, od and width\")\n        assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n        assert(is_finite(helical) && abs(helical)<90)\n        assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n        assert(is_finite(backlash) && backlash>=0)\n        assert(is_finite(gear_spin));\n    pr = pitch_radius(circ_pitch, teeth, helical=helical);\n    ar = outer_radius(circ_pitch, teeth, helical=helical, profile_shift=profile_shift, internal=true);\n    rr=_root_radius(circ_pitch, teeth, clearance, profile_shift=profile_shift, internal=true);\n    or = is_def(or) ?\n            assert(is_finite(or) && or>ar, \"or is invalid or too small for teeth\")\n            or\n       : is_def(od) ?\n            assert(is_finite(od) && od>2*ar, \"od is invalid or too small for teeth\")\n            od/2\n       : is_def(width) ?\n            assert(is_finite(width) && width>ar-rr, \"width is invalid or too small for teeth\")\n            rr+width\n       : is_def(backing) ?\n            assert(all_positive([backing]), \"backing must be a positive value\")\n            ar+backing\n       : 2*ar - rr;    // default case\n    attachable(anchor,spin, two_d=true, r=atype==\"pitch\"?pr:or) {\n        zrot(gear_spin)\n        difference() {\n            circle(r=or);\n            spur_gear2d(\n                circ_pitch = circ_pitch,\n                teeth = teeth,\n                pressure_angle = PA,\n                helical = helical,\n                clearance = clearance,\n                backlash = backlash,shorten=shorten,\n                profile_shift = profile_shift,\n                internal = true \n            );\n        }\n        children();\n    }\n}\n\n\n\n\n// Function&Module: rack()\n// Synopsis: Creates a straight or helical gear rack.\n// SynTags: Geom, VNF\n// Topics: Gears, Parts\n// See Also: rack2d(), spur_gear(), spur_gear2d(), bevel_gear()\n// Usage: As a Module\n//   rack(pitch, teeth, thickness, [base|bottom=|width=], [helical=], [pressure_angle=], [backlash=], [clearance=]) [ATTACHMENTS];\n//   rack(mod=, teeth=, thickness=, [base=|bottom=|width=], [helical=], [pressure_angle=], [backlash]=, [clearance=]) [ATTACHMENTS];\n// Usage: As a Function\n//   vnf = rack(pitch, teeth, thickness, [base|bottom=|width=], [helical=], [pressure_angle=], [backlash=], [clearance=]);\n//   vnf = rack(mod=, teeth=, thickness=, [base=|bottom=|width=], [helical=], [pressure_angle=], [backlash=], [clearance=]);\n// Description:\n//   This is used to create a 3D rack, which is a linear bar with teeth that a gear can roll along.\n//   A rack can mesh with any gear that has the same `pitch` and `pressure_angle`.  A helical rack meshes with a gear with the opposite\n//   helical angle.   \n//   When called as a function, returns a 3D [VNF](vnf.scad) for the rack.\n//   When called as a module, creates a 3D rack shape.\n//   .\n//   By default the rack has a backing whose height is equal to the height of the teeth.  You can specify a different backing size\n//   or you can specify the total width of the rack (from the bottom of the rack to tooth tips) or the\n//   bottom point of the rack, which is the distance from the pitch line to the bottom of the rack.\n//   .\n//   The rack appears oriented with\n//   its teeth pointed UP, so to mesh with gears in the XY plane, use `orient=BACK` or `orient=FWD` and apply any desired rotation.  \n//   The pitch line of the rack is aligned with the x axis, the TOP anchors are at the tips of the teeth and the BOTTOM anchors at\n//   the bottom of the backing.  Note that for helical racks the corner anchors still point at 45 degr angles.  \n// Arguments:\n//   pitch = The pitch, or distance between teeth centers along the rack. Matches up with circular pitch on a spur gear.  Default: 5\n//   teeth = Total number of teeth along the rack.  Default: 20\n//   thickness = Thickness of rack.  Default: 5\n//   backing = Distance from bottom of rack to the roots of the rack's teeth.  (Alternative to bottom or width.)  Default: height of rack teeth\n//   ---\n//   bottom = Distance from rack's pitch line (the x-axis) to the bottom of the rack.  (Alternative to backing or width)\n//   width = Distance from base of rack to tips of teeth (alternative to bottom and backing).\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   helical = The angle of the rack teeth away from perpendicular to the rack length.  Used to match helical spur gear pinions.  Default: 0\n//   herringbone = If true, and helical is set, creates a herringbone rack.\n//   profile_shift = Profile shift factor x.  Default: 0\n//   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees.  Default: 20\n//   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle.  Default: 0\n//   clearance = Clearance gap at the bottom of the inter-tooth valleys.  Default: module/4\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Extra Anchors:\n//   \"root\" = At the base of the teeth, at the center of rack.\n//   \"root-left\" = At the base of the teeth, at the left end of the rack.\n//   \"root-right\" = At the base of the teeth, at the right end of the rack.\n//   \"root-back\" = At the base of the teeth, at the back of the rack.\n//   \"root-front\" = At the base of the teeth, at the front of the rack.\n// Example(NoScales,VPR=[60,0,325],VPD=130):\n//   rack(pitch=5, teeth=10, thickness=5);\n// Example(NoScales,VPT=[0.317577,3.42688,7.83665],VPR=[27.7,0,359.8],VPD=139.921): Rack for Helical Gear\n//   rack(pitch=5, teeth=10, thickness=5, backing=5, helical=30);\n// Example(NoScales): Metric Rack, oriented BACK to align with a gear in default orientation.  With profile shifting set to zero the gears mesh at their pitch circles.  \n//   rack(mod=2, teeth=10, thickness=5, bottom=5, pressure_angle=14.5,orient=BACK);\n//   color(\"red\") spur_gear(mod=2, teeth=18, thickness=5, pressure_angle=14.5,anchor=FRONT,profile_shift=0);\n// Example(NoScales): Orienting the rack to the right using {zrot()}.  In this case the gear has automatic profile shifting so we must use {{gear_dist()}} to correctly position the gear.  \n//   zrot(-90)rack(mod=2, teeth=6, thickness=5, bottom=5, pressure_angle=14.5,orient=BACK);\n//   color(\"red\")\n//    right(gear_dist(mod=2,0,12,pressure_angle=14.5))\n//      spur_gear(mod=2, teeth=12, thickness=5, pressure_angle=14.5);\n// Example(NoScales,Anim,VPT=[0,0,12],VPD=100,Frames=18): Rack and Pinion with helical teeth\n//   teeth1 = 16; teeth2 = 16;\n//   pitch = 5; thick = 5; helical = 30;\n//   pr = pitch_radius(pitch, teeth2, helical=helical);\n//   pos = 3*(1-2*abs($t-1/2))-1.5;\n//   right(pr*2*PI/teeth2*pos)\n//       rack(pitch, teeth1, thickness=thick, helical=helical);\n//   up(pr)\n//       spur_gear(\n//           pitch, teeth2,\n//           thickness = thick,\n//           helical = -helical,\n//           shaft_diam = 5,\n//           orient = BACK,\n//           gear_spin = 180-pos*360/teeth2);\n// Example(NoAxes,VPT=[-7.10396,-9.70691,3.50121],VPR=[60.2,0,325],VPD=213.262): Skew axis helical gear and rack engagement.\n//    mod=5; teeth=8; helical1=17.5; helical2=22.5;\n//    d = gear_dist_skew(mod=mod, teeth, 0, helical1,helical2);\n//    rack(mod=mod, teeth=5, thickness=30, helical=helical2, orient=FWD);\n//    color(\"lightblue\")\n//      yrot(-helical1-helical2) fwd(d)\n//      spur_gear(mod=mod, teeth=teeth, helical=helical1, gear_spin=180/teeth, thickness=30);\n\nmodule rack(\n    pitch,\n    teeth,\n    thickness,\n    backing,\n    width, bottom,\n    pressure_angle,\n    backlash = 0.0,\n    clearance,\n    helical,\n    herringbone = false,\n    profile_shift = 0,\n    gear_travel = 0,\n    circ_pitch,\n    diam_pitch,\n    mod,\n    anchor = CENTER,\n    spin = 0,\n    orient = UP\n) {\n    pitch = _inherit_gear_pitch(\"rack()\",pitch, circ_pitch, diam_pitch, mod, warn=false);\n    PA = _inherit_gear_pa(pressure_angle);\n    helical = _inherit_gear_helical(helical);\n    thickness = _inherit_gear_thickness(thickness);\n    checks=\n        assert(is_integer(teeth) && teeth>0)\n        assert(is_finite(thickness) && thickness>0)\n        assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n        assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n        assert(is_finite(backlash) && backlash>=0)\n        assert(is_finite(helical) && abs(helical)<90)\n        assert(is_bool(herringbone))\n        assert(is_finite(profile_shift))\n        assert(is_finite(gear_travel));\n    trans_pitch = pitch / cos(helical);\n    a = _adendum(pitch, profile_shift);\n    d = _dedendum(pitch, clearance, profile_shift);\n    bottom = is_def(bottom) ?\n                 assert(is_finite(bottom) && bottom>d, \"bottom is invalid or too small for teeth\")\n                 bottom\n           : is_def(width) ?\n                 assert(is_finite(width) && width>a+d, \"width is invalid or too small for teeth\")\n                 width - a\n           : is_def(backing) ?\n                 assert(all_positive([backing]), \"backing must be a positive value\")\n                 backing+d\n           : 2*d+a;  // default case\n    l = teeth * trans_pitch;\n    anchors = [\n        named_anchor(\"root\",        [0,0,-d],            BACK),\n        named_anchor(\"root-left\",   [-l/2,0,-d],         LEFT),\n        named_anchor(\"root-right\",  [ l/2,0,-d],         RIGHT),\n        named_anchor(\"root-front\",  [0,-thickness/2,-d], FWD),\n        named_anchor(\"root-back\",   [0, thickness/2,-d], BACK),\n    ];\n    endfix = sin(helical)*thickness/2;\n    override = function(anchor)\n        anchor.z==1 ? [ [anchor.x*l/2-endfix*anchor.y,anchor.y*thickness/2,a], undef, undef]\n      : anchor.x!=0 ? [ [anchor.x*l/2-endfix*anchor.y,anchor.y*thickness/2,anchor.z*bottom], undef,undef]\n      :               undef;\n    size = [l, thickness, 2*bottom];\n    attachable(anchor,spin,orient, size=size, anchors=anchors, override=override) {\n        right(gear_travel)\n        xrot(90) {\n            if (herringbone) {\n                zflip_copy()\n                skew(axz=-helical) \n                linear_extrude(height=thickness/2, center=false, convexity=teeth*2) {\n                    rack2d(\n                        pitch = pitch,\n                        teeth = teeth,\n                        bottom = bottom,\n                        pressure_angle = PA,\n                        backlash = backlash,\n                        clearance = clearance,\n                        helical = helical,\n                        profile_shift = profile_shift\n                    );\n                }\n            } else {\n                skew(axz=helical)\n                linear_extrude(height=thickness, center=true, convexity=teeth*2) {\n                    rack2d(\n                        pitch = pitch,\n                        teeth = teeth,\n                        bottom = bottom,\n                        pressure_angle = PA,\n                        backlash = backlash,\n                        clearance = clearance,\n                        helical = helical,\n                        profile_shift = profile_shift\n                    );\n                }\n            }\n        }\n        children();\n    }\n}\n\n\nfunction rack(\n    pitch,\n    teeth,\n    thickness,\n    backing, bottom, width, \n    pressure_angle,\n    backlash = 0.0,\n    clearance,\n    helical,\n    herringbone = false,\n    profile_shift = 0,\n    circ_pitch,\n    diam_pitch,\n    mod,\n    gear_travel = 0,\n    anchor = CENTER,\n    spin = 0,\n    orient = UP\n) =\n    let(\n        pitch = _inherit_gear_pitch(\"rack()\",pitch, circ_pitch, diam_pitch, mod, warn=false),\n        PA = _inherit_gear_pa(pressure_angle),\n        helical = _inherit_gear_helical(helical),\n        thickness = _inherit_gear_thickness(thickness)\n    )\n    assert(is_integer(teeth) && teeth>0)\n    assert(is_finite(thickness) && thickness>0)\n    assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n    assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n    assert(is_finite(backlash) && backlash>=0)\n    assert(is_finite(helical) && abs(helical)<90)\n    assert(is_bool(herringbone))\n    assert(is_finite(profile_shift))\n    assert(is_finite(gear_travel))\n    let(\n        trans_pitch = pitch / cos(helical),\n        a = _adendum(pitch, profile_shift),\n        d = _dedendum(pitch, clearance, profile_shift),\n        bottom = is_def(bottom) ?\n                     assert(is_finite(bottom) && bottom>d, \"bottom is invalid or too small for teeth\")\n                     bottom\n               : is_def(width) ?\n                     assert(is_finite(width) && width>a+d, \"width is invalid or too small for teeth\")\n                     width - a\n               : is_def(backing) ?\n                     assert(all_positive([backing]), \"backing must be a positive value\")\n                     backing+d\n               : 2*d+a,  // default case\n        l = teeth * trans_pitch,\n        path = rack2d(\n            pitch = pitch,\n            teeth = teeth,\n            bottom = bottom,\n            pressure_angle = PA,\n            backlash = backlash,\n            clearance = clearance,\n            helical = helical,\n            profile_shift = profile_shift\n        ),\n        vnf = herringbone\n          ? sweep(path, [\n                left(adj_ang_to_opp(thickness/2,helical)) *\n                    back(thickness/2) * xrot(90),\n                xrot(90),\n                left(adj_ang_to_opp(thickness/2,helical)) *\n                    fwd(thickness/2) * xrot(90),\n            ], style=\"alt\", orient=FWD)\n          : skew(axy=-helical, p=linear_sweep(path, height=thickness, anchor=\"origin\", orient=FWD)),\n        out = right(gear_travel, p=vnf),\n        size = [l, thickness, 2*bottom],\n        anchors = [\n            named_anchor(\"tip\",         [0,0,a],             BACK),\n            named_anchor(\"tip-left\",    [-l/2,0,a],          LEFT),\n            named_anchor(\"tip-right\",   [ l/2,0,a],          RIGHT),\n            named_anchor(\"tip-front\",   [0,-thickness/2,a],  DOWN),\n            named_anchor(\"tip-back\",    [0, thickness/2,a],  UP),\n            named_anchor(\"root\",        [0,0,-d],            BACK),\n            named_anchor(\"root-left\",   [-l/2,0,-d],         LEFT),\n            named_anchor(\"root-right\",  [ l/2,0,-d],         RIGHT),\n            named_anchor(\"root-front\",  [0,-thickness/2,-d], DOWN),\n            named_anchor(\"root-back\",   [0, thickness/2,-d], UP),\n        ]\n    ) reorient(anchor,spin,orient, size=size, anchors=anchors, p=out);\n\n\n\n\n// Function&Module: rack2d()\n// Synopsis: Creates a 2D gear rack.\n// SynTags: Geom, Path\n// Topics: Gears, Parts\n// See Also: rack(), spur_gear(), spur_gear2d(), bevel_gear()\n// Usage: As a Module\n//   rack2d(pitch, teeth, [base|bottom=|width=], [pressure_angle=], [backlash=], [clearance=]) [ATTACHMENTS];\n//   rack2d(mod=, teeth=, [base=|bottom=|width=], [pressure_angle=], [backlash=], [clearance=]) [ATTACHMENTS];\n// Usage: As a Function\n//   path = rack2d(pitch, teeth, [base|bottom=|width=], [pressure_angle=], [backlash=], [clearance=]);\n//   path = rack2d(mod=, teeth=, [base=|bottom=|width=], [pressure_angle=], [backlash=], [clearance=]);\n// Description:\n//   Create a 2D rack, a linear bar with teeth that a gear can roll along.\n//   A rack can mesh with any spur gear or helical gear that has the same `pitch` and `pressure_angle`.  \n//   When called as a function, returns a 2D path for the outline of the rack.\n//   When called as a module, creates a 2D rack shape.\n//   .\n//   By default the rack has a backing whose height is equal to the height of the teeth.  You can specify a different backing size\n//   or you can specify the total width of the rack (from the bottom of the rack to tooth tips) or the\n//   bottom point of the rack, which is the distance from the pitch line to the bottom of the rack.\n//   .\n//   The rack appears with its pitch line on top of the x axis.  The BACK anchor refers to the tips of the teeth and the FRONT\n//   anchor refers to the front of the backing.  You can use named anchors to access the roots of the teeth.  \n// Arguments:\n//   pitch = The pitch, or distance between teeth centers along the rack. Matches up with circular pitch on a spur gear.  Default: 5\n//   teeth = Total number of teeth along the rack\n//   backing = Distance from bottom of rack to the roots of the rack's teeth.  (Alternative to bottom or width.)  Default: height of rack teeth\n//   ---\n//   bottom = Distance from rack's pitch line (the x-axis) to the bottom of the rack.  (Alternative to backing or width)\n//   width = Distance from base of rack to tips of teeth (alternative to bottom and backing).\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   helical = The angle of the rack teeth away from perpendicular to the rack length.  Stretches out the tooth shapes.  Used to match helical spur gear pinions.  Default: 0\n//   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees.\n//   profile_shift = Profile shift factor x for tooth shape.  Default: 0\n//   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle\n//   clearance = Clearance gap at the bottom of the inter-tooth valleys.  Default: module/4\n//   gear_travel = The distance the rack should be moved by linearly.  Default: 0\n//   rounding = If true, rack tips and valleys are slightly rounded.  Default: true\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Extra Anchors:\n//   \"root\" = At the height of the teeth, at the center of rack.\n//   \"root-left\" = At the height of the teeth, at the left end of the rack.\n//   \"root-right\" = At the height of the teeth, at the right end of the rack.\n// Example(2D):\n//   rack2d(pitch=5, teeth=10);\n// Example(2D): Called as a Function\n//   path = rack2d(pitch=8, teeth=8, pressure_angle=25);\n//   polygon(path);\n\nfunction rack2d(\n    pitch,\n    teeth,\n    backing,\n    pressure_angle,\n    backlash = 0,\n    clearance,\n    helical,\n    profile_shift = 0,\n    circ_pitch,\n    diam_pitch,\n    mod,\n    width, bottom,\n    gear_travel = 0,\n    rounding = true,\n    anchor = CENTER,\n    spin = 0\n) = let(\n        pitch = _inherit_gear_pitch(\"rack2d()\",pitch, circ_pitch, diam_pitch, mod, warn=false),\n        PA = _inherit_gear_pa(pressure_angle),\n        helical = _inherit_gear_helical(helical),\n        mod = module_value(circ_pitch=pitch)\n    )\n    assert(is_integer(teeth) && teeth>0)\n    assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n    assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n    assert(is_finite(backlash) && backlash>=0)\n    assert(is_finite(helical) && abs(helical)<90)\n    assert(is_finite(gear_travel))\n    assert(num_defined([width,backing,bottom])<=1, \"Can define only one of width, backing and bottom\")\n    let(\n        adendum = _adendum(pitch, profile_shift),\n        dedendum = _dedendum(pitch, clearance, profile_shift),\n        clear = default(clearance, 0.25 * mod),\n        bottom = is_def(bottom) ?\n                     assert(is_finite(bottom) && bottom>dedendum, \"bottom is invalid or too small for teeth\")\n                     bottom\n               : is_def(width) ?\n                     assert(is_finite(width) && width>adendum+dedendum, \"width is invalid or too small for teeth\")\n                     width - adendum\n               : is_def(backing) ?\n                     assert(all_positive([backing]), \"backing must be a positive value\")\n                     backing+dedendum\n               : 2*dedendum+adendum  // default case\n    )\n    let(\n        trans_pitch = pitch / cos(helical),\n        trans_pa = atan(tan(PA)/cos(helical)),\n        tthick = trans_pitch/PI * (PI/2 + 2*profile_shift * tan(PA)) - backlash,\n        l = teeth * trans_pitch,\n        ax = ang_adj_to_opp(trans_pa, adendum),\n        dx = dedendum*tan(trans_pa),\n        poff = tthick/2,\n        tooth = [\n            [-trans_pitch/2, -dedendum],\n            if (rounding) each arc(n=4, r=clear, corner=[\n                [-trans_pitch/2, -dedendum],\n                [-poff-dx, -dedendum],\n                [-poff+ax, +adendum],\n            ]) else [-poff-dx, -dedendum],\n            if (rounding) each arc(n=4, r=trans_pitch/16, corner=[\n                [-poff-dx, -dedendum],\n                [-poff+ax, +adendum],\n                [+poff-ax, +adendum],\n            ]) else [-poff+ax, +adendum],\n            if (rounding) each arc(n=4, r=trans_pitch/16, corner=[\n                [-poff+ax, +adendum],\n                [+poff-ax, +adendum],\n                [+poff+dx, -dedendum],\n            ]) else [+poff-ax, +adendum],\n            if (rounding) each arc(n=4, r=clear, corner=[\n                [+poff-ax, +adendum],\n                [+poff+dx, -dedendum],\n                [+trans_pitch/2, -dedendum],\n            ]) else [+poff+dx, -dedendum],\n            [+trans_pitch/2, -dedendum],\n        ],\n        path2 = [\n            for(m = xcopies(trans_pitch,n=teeth))\n                each apply(m,tooth)\n        ],\n        path = right(gear_travel, p=[\n            [path2[0].x, -bottom],\n            each path2,\n            [last(path2).x, -bottom],\n        ]),\n        size=[l,2*bottom],\n        anchors = [\n            named_anchor(\"root\",        [   0,-dedendum,0],  BACK),\n            named_anchor(\"root-left\",   [-l/2,-dedendum,0],  LEFT),\n            named_anchor(\"root-right\",  [ l/2,-dedendum,0],  RIGHT),\n        ],\n        override = [\n           [[0,1] , [[0,adendum]]],\n           [[1,1] , [[l/2,adendum]]],\n           [[-1,1] , [[-l/2,adendum]]],\n        ]\n    ) reorient(anchor,spin, two_d=true, size=size, anchors=anchors, override=override, p=path);\n\n\n\nmodule rack2d(\n    pitch,\n    teeth,\n    backing,\n    width, bottom,\n    pressure_angle,\n    backlash = 0,\n    clearance,\n    helical,\n    profile_shift = 0,\n    gear_travel = 0,\n    circ_pitch,\n    diam_pitch,\n    mod,\n    rounding = true, \n    anchor = CENTER,\n    spin = 0\n) {\n    pitch = _inherit_gear_pitch(\"rack2d()\",pitch, circ_pitch, diam_pitch, mod, warn=false);\n    PA = _inherit_gear_pa(pressure_angle);\n    helical = _inherit_gear_helical(helical);\n    checks =\n        assert(is_integer(teeth) && teeth>0)\n        assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n        assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n        assert(is_finite(backlash) && backlash>=0)\n        assert(is_finite(helical) && abs(helical)<90)\n        assert(is_finite(gear_travel))\n        assert(num_defined([width,backing,bottom])<=1, \"Can define only one of width, backing and bottom\");\n    trans_pitch = pitch / cos(helical);\n    a = _adendum(pitch, profile_shift);\n    d = _dedendum(pitch, clearance, profile_shift);\n    bottom = is_def(bottom) ?\n                 assert(is_finite(bottom) && bottom>d, \"bottom is invalid or too small for teeth\")\n                 bottom\n           : is_def(width) ?\n                 assert(is_finite(width) && width>a+d, \"width is invalid or too small for teeth\")\n                 width - a\n           : is_def(backing) ?\n                 assert(all_positive([backing]), \"backing must be a positive value\")\n                 backing+d\n           : 2*d+a;  // default case\n    l = teeth * trans_pitch;\n    path = rack2d(\n        pitch = pitch,\n        teeth = teeth,\n        bottom=bottom, \n        pressure_angle = PA,\n        backlash = backlash,\n        clearance = clearance,\n        helical = helical,\n        rounding=rounding, \n        profile_shift= profile_shift\n    );\n    size = [l, 2*bottom];\n    anchors = [\n        named_anchor(\"root\",        [   0,-d,0],  BACK),\n        named_anchor(\"root-left\",   [-l/2,-d,0],  LEFT),\n        named_anchor(\"root-right\",  [ l/2,-d,0],  RIGHT),\n    ];\n    override = [\n       [[0,1] , [[0,a]]],\n       [[1,1] , [[l/2,a]]],\n       [[-1,1] , [[-l/2,a]]],\n    ];\n    attachable(anchor,spin, two_d=true, size=size, anchors=anchors, override=override) {\n        right(gear_travel) polygon(path);\n        children();\n    }\n}\n\n\n\n// Function&Module: crown_gear()\n// Synopsis: Creates a crown gear that can mesh with a spur gear.\n// SynTags: Geom, VNF\n// Topics: Gears, Parts\n// See Also: rack(), rack2d(), spur_gear(), spur_gear2d(), bevel_pitch_angle(), bevel_gear()\n// Usage: As a Module\n//   crown_gear(circ_pitch, teeth, backing, face_width, [pressure_angle=], [clearance=], [backlash=], [profile_shift=], [slices=]);\n//   crown_gear(diam_pitch=, teeth=, backing=, face_width=, [pressure_angle=], [clearance=], [backlash=], [profile_shift=], [slices=]);\n//   crown_gear(mod=, teeth=, backing=, face_width=, [pressure_angle=], [clearance=], [backlash=], [profile_shift=], [slices=]);\n// Usage: As a Function\n//   vnf = crown_gear(circ_pitch, teeth, backing, face_width, [pressure_angle=], [clearance=], [backlash=], [profile_shift=], [slices=]);\n//   vnf = crown_gear(diam_pitch=, teeth=, backing=, face_width=, [pressure_angle=], [clearance=], [backlash=], [profile_shift=], [slices=]);\n//   vnf = crown_gear(mod=, teeth=, backing=, face_width=, [pressure_angle=], [clearance=], [backlash=], [profile_shift=], [slices=]);\n// Description:\n//   Creates a crown gear.  The module `crown_gear()` gives a crown gear, with reasonable defaults\n//   for all the parameters.  Normally, you should just choose the first 4 parameters, and let the\n//   rest be default values.\n//   .\n//   The module `crown_gear()` gives a crown gear in the XY plane, centered on the origin, with one tooth\n//   centered on the positive Y axis.  The crown gear will have the pitch circle of the teeth at Z=0 by default.\n//   The inner radius of the crown teeth can be calculated with the `pitch_radius()` function, and the outer\n//   radius of the teeth is `face_width=` more than that.\n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.  Default: 5\n//   teeth = Total number of teeth around the entire perimeter.  Default: 20\n//   backing = Distance from base of crown gear to roots of teeth (alternative to bottom and thickness).\n//   face_width = Width of the toothed surface, from inside radius to outside.  Default: 5\n//   ---\n//   bottom = Distance from crown's pitch plane (Z=0) to the bottom of the crown gear.  (Alternative to backing or thickness)\n//   thickness = Distance from base of crown gear to tips of teeth (alternative to bottom and backing).\n//   pitch_angle = Angle of beveled gear face.  Default: 45\n//   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees. Default: 20\n//   clearance = Clearance gap at the bottom of the inter-tooth valleys.  Default: module/4\n//   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle.  Default: 0\n//   slices = Number of vertical layers to divide gear into.  Useful for refining gears with `spiral`.  Default: 1\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   mod = The module of the gear (pitch diameter / teeth)\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   crown_gear(mod=1, teeth=40, backing=3, face_width=5, pressure_angle=20);\n// Example:\n//   mod=1; cteeth=40; pteeth=17; backing=3; PA=20; face=5;\n//   cpr = pitch_radius(mod=mod, teeth=cteeth);\n//   ppr = pitch_radius(mod=mod, teeth=pteeth);\n//   crown_gear(mod=mod, teeth=cteeth, backing=backing,\n//       face_width=face, pressure_angle=PA);\n//   back(cpr+face/2)\n//     up(ppr)\n//       spur_gear(mod=mod, teeth=pteeth,\n//           pressure_angle=PA, thickness=face,\n//           orient=BACK, gear_spin=180/pteeth,\n//           profile_shift=0);\n\nfunction crown_gear(\n    circ_pitch,\n    teeth,\n    backing,\n    face_width=5,\n    pressure_angle=20,\n    clearance,\n    backlash=0,\n    profile_shift=0,\n    slices=10,\n    bottom,\n    thickness,\n    diam_pitch,\n    pitch,\n    mod,\n    gear_spin=0,\n    anchor=CTR,\n    spin=0,\n    orient=UP\n) = let(\n        pitch = _inherit_gear_pitch(\"crown_gear()\", pitch, circ_pitch, diam_pitch, mod, warn=false),\n        PA = _inherit_gear_pa(pressure_angle)\n    )\n    assert(is_integer(teeth) && teeth>0)\n    assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n    assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n    assert(is_finite(backlash) && backlash>=0)\n    assert(is_finite(gear_spin))\n    assert(num_defined([thickness,backing,bottom])<=1, \"Can define only one of thickness, backing and bottom\")\n    let(\n        a = _adendum(pitch, profile_shift),\n        d = _dedendum(pitch, clearance, profile_shift),\n        bottom = is_def(bottom) ?\n                     assert(is_finite(bottom) && bottom>d, \"bottom is invalid or too small for teeth\")\n                     bottom\n               : is_def(thickness) ?\n                     assert(is_finite(thickness) && thickness>a+d, \"thickness is invalid or too small for teeth\")\n                     thickness - a\n               : is_def(backing) ?\n                     assert(all_positive([backing]), \"backing must be a positive value\")\n                     backing+d\n               : 2*d+a,  // default case\n        mod = module_value(circ_pitch=pitch),\n        ir = mod * teeth / 2,\n        or = ir + face_width,\n        profiles = [\n            for (slice = [0:1:slices-1])\n            let(\n                u = slice / (slices-1),\n                r = or - u*face_width,\n                wpa = acos(ir * cos(PA) / r),\n                profile = select(\n                    rack2d(\n                        mod=mod, teeth=1,\n                        pressure_angle=wpa,\n                        clearance=clearance,\n                        backlash=backlash,\n                        profile_shift=profile_shift,\n                        rounding=false\n                    ), 2, -3\n                ),\n                delta = profile[1] - profile[0],\n                slope = delta.y / delta.x,\n                C = profile[0].y - slope * profile[0].x,\n                profile2 = profile[1].x > 0\n                  ? [profile[0], [0,C], [0,C], profile[3]]\n                  : profile,\n                m = back(r) * xrot(90),\n                tooth = apply(m, path3d(profile2)),\n                rpitch = pitch * r / ir\n            )\n            assert(profile[3].x <= rpitch/2, \"face_width is too wide for the given gear geometry.  Either decrease face_width, or increase the module or tooth count.\")\n            [\n                for (i = [0:1:teeth-1])\n                let(a = gear_spin - i * 360 / teeth) \n                each zrot(a, p=tooth)\n            ]\n        ],\n        rows = [\n            [for (p=profiles[0]) [p.x,p.y,-bottom]],\n            each profiles,\n            [for (p=last(profiles)) [p.x,p.y,last(profiles)[0].z]],\n        ],\n        vnf = vnf_vertex_array(rows, col_wrap=true, caps=true)\n    ) reorient(anchor,spin,orient, r=or, h=2*bottom, p=vnf);\n\n\nmodule crown_gear(\n    circ_pitch,\n    teeth,\n    backing,\n    face_width=10,\n    pressure_angle=20,\n    clearance,\n    backlash=0,\n    profile_shift=0,\n    slices=10,\n    bottom,\n    thickness,\n    diam_pitch,\n    pitch,\n    mod,\n    gear_spin=0,\n    anchor=CTR,\n    spin=0,\n    orient=UP\n) {\n    pitch = _inherit_gear_pitch(\"crown_gear()\", pitch, circ_pitch, diam_pitch, mod, warn=false);\n    PA = _inherit_gear_pa(pressure_angle);\n    checks =\n        assert(is_integer(teeth) && teeth>0)\n        assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n        assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n        assert(is_finite(backlash) && backlash>=0)\n        assert(is_finite(gear_spin))\n        assert(num_defined([thickness,backing,bottom])<=1, \"Can define only one of width, backing and bottom\")\n        ;\n    pr = pitch_radius(circ_pitch=pitch, teeth=teeth);\n    a = _adendum(pitch, profile_shift);\n    d = _dedendum(pitch, clearance, profile_shift);\n    bottom = is_def(bottom) ?\n                 assert(is_finite(bottom) && bottom>d, \"bottom is invalid or too small for teeth\")\n                 bottom\n           : is_def(thickness) ?\n                 assert(is_finite(thickness) && thickness>a+d, \"thickness is invalid or too small for teeth\")\n                 thickness - a\n           : is_def(backing) ?\n                 assert(all_positive([backing]), \"backing must be a positive value\")\n                 backing+d\n           : 2*d+a;  // default case\n    vnf = crown_gear(\n        circ_pitch=pitch,\n        teeth=teeth,\n        bottom=bottom,\n        face_width=face_width,\n        pressure_angle=PA,\n        clearance=clearance,\n        backlash=backlash,\n        profile_shift=profile_shift,\n        slices=slices,\n        gear_spin=gear_spin\n    );\n    attachable(anchor,spin,orient, r=pr+face_width, h=2*bottom) {\n        vnf_polyhedron(vnf, convexity=teeth/2);\n        children();\n    }\n}\n\n\n// Function&Module: bevel_gear()\n// Synopsis: Creates a straight, zerol, or spiral bevel gear.\n// SynTags: Geom, VNF\n// Topics: Gears, Parts\n// See Also: rack(), rack2d(), spur_gear(), spur_gear2d(), bevel_pitch_angle(), bevel_gear()\n// Usage: As a Module\n//   gear_dist(mod=|diam_pitch=|circ_pitch=, teeth, mate_teeth, [shaft_angle], [shaft_diam], [face_width=], [hide=], [spiral=], [cutter_radius=], [right_handed=], [pressure_angle=], [backing=|thickness=|bottom=], [cone_backing=], [backlash=], [slices=], [internal=], [gear_spin=], ...) [ATTACHMENTS];\n// Usage: As a Function\n//   vnf = gear_dist(mod=|diam_pitch=|circ_pitch=, teeth, mate_teeth, [shaft_angle], [face_width=], [hide=], [spiral=], [cutter_radius=], [right_handed=], [pressure_angle=], , [backing=|thickness=|bottom=], [cone_backing=], [backlash=], [slices=], [internal=], [gear_spin=], ...);\n// Description:\n//   Creates a spiral, zerol, or straight bevel gear.  In straight bevel gear sets, when each tooth\n//   engages it inpacts the corresponding tooth.  The abrupt tooth engagement causes impact stress\n//   which makes them more prone to breakage.  Spiral bevel gears have teeth formed along spirals so\n//   they engage more gradually, resulting in a less abrupt transfer of force, so they are quieter\n//   in operation and less likely to break.\n//   .\n//   Bevel gears must be created in mated pairs to work together at a chosen shaft angle.  You therefore\n//   must specify both the number of teeth on the gear and the number of teeth on its mating gear.\n//   Additional requirements for bevel gears to mesh are that they share the same\n//   tooth size and the same pressure angle and they must be of opposite handedness.\n//   The pressure angle controls how much the teeth bulge at their\n//   sides and is almost always 20 degrees for standard bevel gears.  The ratio of `teeth` for two meshing gears\n//   gives how many times one will make a full\n//   revolution when the the other makes one full revolution.  If the two numbers are coprime (i.e.\n//   are not both divisible by the same number greater than 1), then every tooth on one gear will meet\n//   every tooth on the other, for more even wear.  So relatively prime numbers of teeth are good.\n//   .\n//   The gear appears centered on the origin, with one tooth\n//   centered on the positive Y axis.  The base of the pitch cone (the \"pitchbase\") will lie in the XY plane.  This is\n//   the natural position: in order to mesh the mating gear must be positioned so their pitch bases are tangent.\n//   The apexes of the pitch cones must coincide.\n//   . \n//   By default backing will be added to ensure\n//   that the center of the gear (where there are no teeth) is at least half the face width in thickness.\n//   You can change this using the `backing`, `thickness` or `bottom` parameters.  The backing appears with\n//   a conical shape, extended the sloped edges of the teeth.  You can set `cone_backing=false` if your application\n//   requires cylindrical backing.  \n// Arguments:\n//   teeth = Number of teeth on the gear\n//   mate_teeth = Number of teeth on the gear that will mate to this gear\n//   shaft_angle = Angle between the shafts of the two gears.  Default: 90\n//   --\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   backing = Distance from bottom of bevel gear to bottom corner of teeth (Alternative to bottom or thickness).  Default: 0 if the gear is thick enough (see above)\n//   bottom = Distance from bevel gear's pitch base to the bottom of the bevel gear.  (Alternative to backing or thickness)\n//   thickness = Thickness of bevel gear at the center, where there are no teeth.  (Alternative to backing or bottom). \n//   cone_backing = If true backing extends conical shape of the gear; otherwise backing is an attached cylinder.  Default: true\n//   face_width = Width of teeth.  Default: minimum of one third the cone distance and 10*module\n//   shaft_diam = Diameter of the hole in the center, or zero for no hole.  (Module only.)  Default: 0\n//   hide = Number of teeth to delete to make this only a fraction of a circle.  Default: 0\n//   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees. Default: 20\n//   clearance = Clearance gap at the bottom of the inter-tooth valleys.  Default: module/4\n//   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle.  Default: 0\n//   spiral = The base angle for spiral teeth.  If zero the teeth will be zerol or straight.  Default: 35\n//   cutter_radius = Radius of spiral arc for teeth.  If 0, then gear will have straight teeth.  Default: face_width/2/cos(spiral)\n//   right_handed = If true, the gear returned will have a right-handed teeth.  Default: false \n//   slices = Number of vertical layers to divide gear into.  Useful for refining gears with `spiral`.  Default: 1\n//   gear_spin = Rotate gear and children around the gear center, regardless of how gear is anchored.  Default: 0\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: \"pitchbase\"\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Extra Anchors:\n//   \"pitchbase\" = With the base of the pitch cone in the XY plane, centered at the origin.  This is the natural height for the gear, and the default anchor.\n//   \"apex\" = At the pitch cone apex for the bevel gear.\n//   \"flattop\" = At the top of the flat top of the bevel gear.\n// Example(NoAxes): Bevel Gear with zerol teeth\n//   bevel_gear(\n//       circ_pitch=5, teeth=36, mate_teeth=36,\n//       shaft_diam=5, spiral=0\n//   );\n// Example(NoAxes): Spiral Beveled Gear and Pinion.  Note conical backing added to the yellow gear to prevent it from being thin.\n//   t1 = 16; t2 = 28;\n//   color(\"lightblue\")bevel_gear(\n//       circ_pitch=5, teeth=t1, mate_teeth=t2,\n//       slices=12, anchor=\"apex\", orient=FWD\n//   );\n//   bevel_gear(\n//       circ_pitch=5, teeth=t2, mate_teeth=t1, right_handed=true,\n//       slices=12, anchor=\"apex\", backing=3, spin=180/t2\n//   );\n// Example(Anim,Frames=4,VPD=175,NoAxes): Manual Spacing of Pinion and Gear.  Here conical backing has been turned off.  \n//   t1 = 14; t2 = 28; circ_pitch=5;\n//   color(\"lightblue\")back(pitch_radius(circ_pitch, t2)) {\n//     yrot($t*360/t1)\n//     bevel_gear(\n//       circ_pitch=circ_pitch, teeth=t1, mate_teeth=t2, shaft_diam=5,\n//       slices=12, orient=FWD\n//     );\n//   }\n//   down(pitch_radius(circ_pitch, t1)) {\n//     zrot($t*360/t2)\n//     bevel_gear(\n//       circ_pitch=circ_pitch, teeth=t2, mate_teeth=t1, right_handed=true,\n//       shaft_diam=5, slices=12, backing=3, spin=180/t2, cone_backing=false\n//     );\n//   }\n// Example(NoAxes,VPT=[24.4306,-9.20912,-29.3331],VPD=292.705,VPR=[71.8,0,62.5]): Bevel gears at a non right angle, positioned by aligning the pitch cone apexes.  \n//   ang=65;\n//   bevel_gear(mod=3,35,15,ang,spiral=0,backing=5,anchor=\"apex\")   \n//     cyl(h=48,d=3,$fn=16,anchor=BOT);\n//   color(\"lightblue\")\n//   xrot(ang)\n//     bevel_gear(mod=3,15,35,ang,spiral=0,right_handed=true,anchor=\"apex\")\n//       cyl(h=65,d=3,$fn=16,anchor=BOT);\n// Example(VPT=[6.39483,26.2195,8.93229],VPD=192.044,VPR=[76.7,0,63.3],NoAxes): At this extreme 135 degree angle the yellow gear has internal teeth.  This is a rare configuration.  \n//   ang=135;\n//   bevel_gear(mod=3,35,15,ang);   \n//   color(\"lightblue\")\n//     back(pitch_radius(mod=3,teeth=35)+pitch_radius(mod=3,teeth=15))\n//     xrot(ang,cp=[0,-pitch_radius(mod=3,teeth=15),0])\n//         bevel_gear(mod=3,15,35,ang,right_handed=true);       \nfunction bevel_gear(\n    teeth,\n    mate_teeth,\n    shaft_angle=90,\n    backing,thickness,bottom,\n    face_width,\n    pressure_angle = 20,\n    clearance,\n    backlash = 0.0,\n    cutter_radius,\n    spiral = 35,\n    right_handed = false,\n    slices = 5,\n    cone_backing = true,\n    pitch,\n    circ_pitch,\n    diam_pitch,\n    mod,\n    anchor = \"pitchbase\",\n    spin = 0,\n    gear_spin = 0, \n    orient = UP,\n    _return_anchors = false\n) = assert(all_integer([teeth,mate_teeth]) && teeth>=3 && mate_teeth>=3, \"Must give teeth and mate_teeth, integers greater than or equal to 3\")\n    assert(all_nonnegative([spiral]), \"spiral must be nonnegative\")\n    assert(is_undef(cutter_radius) || all_nonnegative([cutter_radius]), \"cutter_radius must be nonnegative\")\n    assert(is_finite(shaft_angle) && shaft_angle>0 && shaft_angle<180,\"shaft_angle must be strictly between 0 and 180\")  \n    let(\n        circ_pitch = _inherit_gear_pitch(\"bevel_gear()\",pitch, circ_pitch, diam_pitch, mod),\n        PA = _inherit_gear_pa(pressure_angle),\n        spiral = _inherit_gear_helical(spiral),\n        slices = cutter_radius==0? 1 : slices,\n        pitch_angle = posmod(atan(sin(shaft_angle)/((mate_teeth/teeth)+cos(shaft_angle))),180),\n        pr = pitch_radius(circ_pitch, teeth),\n        rr = _root_radius(circ_pitch, teeth, clearance),\n        pitchoff = (pr-rr) * sin(pitch_angle),\n        ocone_rad = pitch_angle<90 ? opp_ang_to_hyp(pr, pitch_angle)\n                                   : opp_ang_to_hyp(pitch_radius(circ_pitch,mate_teeth), shaft_angle-pitch_angle),\n        default_face_width = min(ocone_rad/3, 10*module_value(circ_pitch)),\n        face_width = _inherit_gear_thickness(face_width,dflt=default_face_width),\n        icone_rad = ocone_rad - face_width,\n        \n        cutter_radius = is_undef(cutter_radius) ? face_width * 2 / cos(spiral)\n                      : cutter_radius==0? face_width*100\n                      : cutter_radius,\n        midpr = (icone_rad + ocone_rad) / 2,\n        radcp = [0, midpr] + polar_to_xy(cutter_radius, 180+spiral),\n        angC1 = law_of_cosines(a=cutter_radius, b=norm(radcp), c=ocone_rad),\n        angC2 = law_of_cosines(a=cutter_radius, b=norm(radcp), c=icone_rad),\n        radcpang = v_theta(radcp),\n        sang = radcpang - (180-angC1),\n        eang = radcpang - (180-angC2),\n        profile = reverse(_gear_tooth_profile(\n            circ_pitch = circ_pitch,\n            teeth = teeth,\n            pressure_angle = PA,\n            clearance = clearance,\n            backlash = backlash,\n            center = true\n        )),\n        verts1 = [\n            for (v = lerpn(0,1,slices+1)) let(\n                p = radcp + polar_to_xy(cutter_radius, lerp(sang,eang,v)),\n                ang = v_theta(p)-90,\n                dist = norm(p)\n            ) [\n                let(\n                    u = dist / ocone_rad,\n                    m = up((1-u) * pr / tan(pitch_angle)) *\n                        up(pitchoff) *\n                        zrot(ang/sin(pitch_angle)) *\n                        back(u * pr) *\n                        xrot(pitch_angle) *\n                        scale(u)\n                )\n                for (tooth=[0:1:teeth-1])\n                each apply(xflip() * zrot(360*tooth/teeth) * m, path3d(profile))\n            ]\n        ],\n        botz = verts1[0][0].z,      // bottom of center\n        topz = last(verts1)[0].z,   // top of center\n        ctr_thickness = topz - botz,  \n        vertices = [for (x=verts1) reverse(x)],\n        sides_vnf = vnf_vertex_array(vertices, caps=false, col_wrap=true, reverse=true),\n        top_verts = last(vertices),\n        bot_verts = vertices[0],\n        gear_pts = len(top_verts),\n        face_pts = gear_pts / teeth,\n        minbacking = -min(0,ctr_thickness),  \n        backing = is_def(backing) ?\n                      assert(all_nonnegative([backing]), \"backing must be a non-negative value\")\n                      assert(ctr_thickness>0 || backing>0, \"internal gears require backing>0\")\n                      backing-min(0,ctr_thickness)\n                : is_def(thickness) ?\n                      let(thick_OK=is_finite(thickness) && (thickness>abs(ctr_thickness) || (thickness==ctr_thickness && ctr_thickness>0)))\n                      assert(thick_OK, str(\"thickness is invalid or too small for teeth; thickness must be larger than \",abs(ctr_thickness)))\n                      thickness-ctr_thickness\n                : is_def(bottom)?\n                    assert(is_finite(bottom) && bottom-pitchoff>minbacking,\n                           str(\"bottom is invalid or too small for teeth, must exceed \",minbacking+pitchoff))\n                    bottom-pitchoff\n                : ctr_thickness>face_width/2 ? 0\n                : -ctr_thickness+face_width/2,\n        cpz = (topz + botz - backing) / 2,\n        teeth_top_faces =[\n            for (i=[0:1:teeth-1], j=[0:1:(face_pts/2)-1]) each [\n                [i*face_pts+j, (i+1)*face_pts-j-1, (i+1)*face_pts-j-2],\n                [i*face_pts+j, (i+1)*face_pts-j-2, i*face_pts+j+1]\n            ]\n        ],\n        flat_top_faces = [    \n            for (i=[0:1:teeth-1]) each [\n                [gear_pts, (i+1)*face_pts-1, i*face_pts],\n                [gear_pts, ((i+1)%teeth)*face_pts, (i+1)*face_pts-1]\n            ]\n        ],\n        backing_vert = backing==0? []\n                     : !cone_backing ? down(backing,[for(i=[0:1:teeth-1]) each( [bot_verts[i*face_pts], bot_verts[(i+1)*face_pts-1]])])\n                     : let(\n                           factor = tan(pitch_angle-90)*backing\n                       )\n                       [for(i=[0:1:teeth-1]) let(\n                           A = bot_verts[i*face_pts],\n                           B = bot_verts[(i+1)*face_pts-1],\n                           adjA = point3d(factor*unit(point2d(A)),-backing),\n                           adjB = point3d(factor*unit(point2d(B)),-backing)\n                       )\n                       each [ A+adjA, B+adjB]],\n        shift = len(bot_verts),\n        backing_bot_faces = backing==0? flat_top_faces\n                          :[for (i=idx(backing_vert))\n                               [shift+len(backing_vert), shift+(i+1)%len(backing_vert),shift+i]\n                            ],\n        backing_side_faces = backing==0 ? []\n                         : [\n                             for (i=[0:1:teeth-1]) \n                               each [\n                                     [shift+2*i,shift+(2*i+1),(i+1)*face_pts-1],\n                                     [shift+2*i+1,shift+2*((i+1)%teeth), ((i+1)%teeth)*face_pts],\n                                     [(i+1)*face_pts-1, i*face_pts, shift+2*i],\n                                     [((i+1)%teeth)*face_pts, (i+1)*face_pts-1, shift+2*i+1]\n                               ]              \n                           ],\n        vnf1 = vnf_join([\n            [\n                [each top_verts, [0,0,top_verts[0].z]],\n                concat(teeth_top_faces, flat_top_faces)\n            ],\n            [\n                [each bot_verts,each backing_vert, [0,0,bot_verts[0].z-backing]   ],\n                [for (x=concat(teeth_top_faces,backing_bot_faces,backing_side_faces)) reverse(x)]\n            ],\n            sides_vnf\n        ]),\n        lvnf = right_handed? vnf1 : xflip(p=vnf1),\n        vnf = zrot(gear_spin,down(cpz, p=lvnf)),\n        anchors = [\n            named_anchor(\"pitchbase\", [0,0,pitchoff-ctr_thickness/2+backing/2]),\n            named_anchor(\"flattop\", [0,0,ctr_thickness/2+backing/2]),\n            named_anchor(\"apex\", [0,0,hyp_ang_to_opp(pitch_angle<90?ocone_rad:icone_rad,90-pitch_angle)+pitchoff-ctr_thickness/2+backing/2])\n        ],\n        final_vnf = reorient(anchor,spin,orient, vnf=vnf, extent=true, anchors=anchors, p=vnf)\n    )\n    _return_anchors==false ? final_vnf\n                        : [final_vnf, anchors, ctr_thickness+backing];\n\n\nmodule bevel_gear(\n    teeth,\n    mate_teeth,\n    shaft_angle=90,\n    bottom,backing,thickness,cone_backing=true,\n    face_width,\n    shaft_diam = 0,\n    pressure_angle = 20,\n    clearance = undef,\n    backlash = 0.0,\n    cutter_radius,\n    spiral = 35,\n    right_handed = false,\n    slices = 5,\n    pitch,\n    diam_pitch,\n    circ_pitch,\n    mod,\n    anchor = \"pitchbase\",\n    spin = 0,\n    gear_spin=0, \n    orient = UP\n) {\n    vnf_anchors = bevel_gear(\n        circ_pitch = circ_pitch, mod=mod, diam_pitch=diam_pitch, \n        teeth = teeth,\n        mate_teeth = mate_teeth,\n        shaft_angle=shaft_angle,\n        bottom=bottom,thickness=thickness,backing=backing,cone_backing=cone_backing,\n        face_width = face_width,\n        pressure_angle = pressure_angle,\n        clearance = clearance,\n        backlash = backlash,\n        cutter_radius = cutter_radius,\n        spiral = spiral,\n        right_handed = right_handed,\n        slices = slices,\n        anchor=CENTER,\n        gear_spin=gear_spin,\n        _return_anchors=true\n    );\n    vnf=vnf_anchors[0];\n    anchors=vnf_anchors[1];\n    thickness = vnf_anchors[2];\n    attachable(anchor,spin,orient, vnf=vnf, extent=true, anchors=anchors) {        \n        difference() {\n           vnf_polyhedron(vnf, convexity=teeth/2);\n           if (shaft_diam > 0)\n               cylinder(h=2*thickness, r=shaft_diam/2, center=true, $fn=max(12,segs(shaft_diam/2)));\n        }\n        children();\n    }\n}\n\n\n// Function&Module: worm()\n// Synopsis: Creates a worm that will mate with a worm gear.\n// SynTags: Geom, VNF\n// Topics: Gears, Parts\n// See Also: worm(), worm_gear(), rack(), rack2d(), spur_gear(), spur_gear2d(), bevel_pitch_angle(), bevel_gear()\n// Usage: As a Module\n//   worm(circ_pitch, d, l, [starts=], [left_handed=], [pressure_angle=], [backlash=], [clearance=]);\n//   worm(mod=, d=, l=, [starts=], [left_handed=], [pressure_angle=], [backlash=], [clearance=]);\n// Usage: As a Function\n//   vnf = worm(circ_pitch, d, l, [starts=], [left_handed=], [pressure_angle=], [backlash=], [clearance=]);\n//   vnf = worm(mod=, d=, l=, [starts=], [left_handed=], [pressure_angle=], [backlash=], [clearance=]);\n// Description:\n//   Creates a worm shape that can be matched to a worm gear.\n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.  Default: 5\n//   d = The diameter of the worm.  Default: 30\n//   l = The length of the worm.  Default: 100\n//   starts = The number of lead starts.  Default: 1\n//   left_handed = If true, the gear returned will have a left-handed spiral.  Default: false\n//   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees. Default: 20\n//   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle.  Default: 0\n//   clearance = Clearance gap at the bottom of the inter-tooth valleys.  Default: module/4\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   mod = The module of the gear (pitch diameter / teeth)\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   worm(circ_pitch=8, d=30, l=50, $fn=72);\n// Example: Multiple Starts.\n//   worm(circ_pitch=8, d=30, l=50, starts=3, $fn=72);\n// Example: Left Handed\n//   worm(circ_pitch=8, d=30, l=50, starts=3, left_handed=true, $fn=72);\n// Example: Called as Function\n//   vnf = worm(circ_pitch=8, d=35, l=50, starts=2, left_handed=true, pressure_angle=20, $fn=72);\n//   vnf_polyhedron(vnf);\n\nfunction worm(\n    circ_pitch,\n    d=30, l=100,\n    starts=1,\n    left_handed=false,\n    pressure_angle,\n    backlash=0,\n    clearance,\n    diam_pitch,\n    mod,\n    pitch,\n    gear_spin=0,\n    anchor=CENTER,\n    spin=0,\n    orient=UP\n) =\n    let(\n        circ_pitch = _inherit_gear_pitch(\"worm()\", pitch, circ_pitch, diam_pitch, mod),\n        PA = _inherit_gear_pa(pressure_angle)\n    )\n    assert(is_integer(starts) && starts>0)\n    assert(is_finite(l) && l>0)\n    //assert(is_finite(shaft_diam) && shaft_diam>=0)\n    assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n    assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n    assert(is_finite(backlash) && backlash>=0)\n    assert(is_bool(left_handed))\n    assert(is_finite(gear_spin))\n    let(\n        helical = asin(starts * circ_pitch / PI / d),\n        trans_pitch = circ_pitch / cos(helical),\n        tooth = xflip(\n            p=select(rack2d(\n                pitch=circ_pitch,\n                teeth=1,\n                pressure_angle=PA,\n                clearance=clearance,\n                backlash=backlash,\n                helical=helical,\n                profile_shift=0\n            ), 1, -2)\n        ),\n        rack_profile = [\n            for (t = xcopies(trans_pitch, n=2*ceil(l/trans_pitch)+1))\n                each apply(t, tooth)\n        ],\n        steps = max(36, segs(d/2)),\n        step = 360 / steps,\n        zsteps = ceil(l / trans_pitch / starts * steps),\n        zstep = l / zsteps,\n        profiles = [\n            for (j = [0:1:zsteps]) [\n                for (i = [0:1:steps-1]) let(\n                    u = i / steps - 0.5,\n                    ang = 360 * (1 - u) + 90,\n                    z = j*zstep - l/2,\n                    zoff = trans_pitch * starts * u,\n                    h = lookup(z+zoff, rack_profile)\n                )\n                cylindrical_to_xyz(d/2+h, ang, z)\n            ]\n        ],\n        vnf1 = vnf_vertex_array(profiles, caps=true, col_wrap=true, style=\"alt\"),\n        m = product([\n            zrot(gear_spin),\n            if (left_handed) xflip(),\n        ]),\n        vnf = apply(m, vnf1)\n    ) reorient(anchor,spin,orient, d=d, l=l, p=vnf);\n\n\nmodule worm(\n    circ_pitch,\n    d=15, l=100,\n    starts=1,\n    left_handed=false,\n    pressure_angle,\n    backlash=0,\n    clearance,\n    pitch,\n    diam_pitch,\n    mod,\n    gear_spin=0,\n    anchor=CENTER,\n    spin=0,\n    orient=UP\n) {\n    circ_pitch = _inherit_gear_pitch(\"worm()\", pitch, circ_pitch, diam_pitch, mod);\n    PA = _inherit_gear_pa(pressure_angle);\n    checks =\n        assert(is_integer(starts) && starts>0)\n        assert(is_finite(l) && l>0)\n        //assert(is_finite(shaft_diam) && shaft_diam>=0)\n        assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n        assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n        assert(is_finite(backlash) && backlash>=0)\n        assert(is_bool(left_handed))\n        assert(is_finite(gear_spin));\n    helical = asin(starts * circ_pitch / PI / d);\n    trans_pitch = circ_pitch / cos(helical);\n    vnf = worm(\n        circ_pitch=circ_pitch,\n        starts=starts,\n        d=d, l=l,\n        left_handed=left_handed,\n        pressure_angle=PA,\n        backlash=backlash,\n        clearance=clearance,\n        mod=mod\n    );\n    attachable(anchor,spin,orient, d=d, l=l) {\n        zrot(gear_spin) vnf_polyhedron(vnf, convexity=ceil(l/trans_pitch)*2);\n        children();\n    }\n}\n\n\n// Function&Module: enveloping_worm()\n// Synopsis: Creates a double-enveloping worm that will mate with a worm gear.\n// SynTags: Geom, VNF\n// Topics: Gears, Parts\n// See Also: worm(), worm_gear(), rack(), rack2d(), spur_gear(), spur_gear2d(), bevel_pitch_angle(), bevel_gear()\n// Usage: As a Module\n//   enveloping_worm(circ_pitch, mate_teeth, d, [left_handed=], [starts=], [arc=], [pressure_angle=]);\n//   enveloping_worm(mod=, mate_teeth=, d=, [left_handed=], [starts=], [arc=], [pressure_angle=]);\n//   enveloping_worm(diam_pitch=, mate_teeth=, d=, [left_handed=], [starts=], [arc=], [pressure_angle=]);\n// Usage: As a Function\n//   vnf = enveloping_worm(circ_pitch, mate_teeth, d, [left_handed=], [starts=], [arc=], [pressure_angle=]);\n//   vnf = enveloping_worm(mod=, mate_teeth=, d=, [left_handed=], [starts=], [arc=], [pressure_angle=]);\n//   vnf = enveloping_worm(diam_pitch=, mate_teeth=, d=, [left_handed=], [starts=], [arc=], [pressure_angle=]);\n// Description:\n//   Creates a double-enveloping worm shape that can be matched to a worm gear.\n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.  Default: 5\n//   mate_teeth = The number of teeth in the mated worm gear.\n//   d = The pitch diameter of the worm at its middle.\n//   left_handed = If true, the gear returned will have a left-handed spiral.  Default: false\n//   ---\n//   starts = The number of lead starts.  Default: 1\n//   arc = Arc angle of the mated worm gear to envelop.  Default: `2 * pressure_angle`\n//   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees. Default: 20\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   mod = The module of the gear (pitch diameter / teeth)\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   enveloping_worm(circ_pitch=8, mate_teeth=45, d=30, $fn=72);\n// Example: Multiple Starts.\n//   enveloping_worm(circ_pitch=8, mate_teeth=33, d=30, starts=3, $fn=72);\n// Example: Left Handed\n//   enveloping_worm(circ_pitch=8, mate_teeth=33, d=30, starts=3, left_handed=true, $fn=72);\n// Example: Called as Function\n//   vnf = enveloping_worm(circ_pitch=8, mate_teeth=37, d=35, starts=2, left_handed=true, pressure_angle=20, $fn=72);\n//   vnf_polyhedron(vnf);\n\nfunction enveloping_worm(\n    circ_pitch,\n    mate_teeth,\n    d,\n    left_handed=false,\n    starts=1,\n    arc,\n    pressure_angle,\n    gear_spin=0,\n    rounding=true,\n    taper=true,\n    diam_pitch,\n    mod,\n    pitch,\n    anchor=CTR,\n    spin=0,\n    orient=UP\n) =\n    let(\n        circ_pitch = _inherit_gear_pitch(\"worm_gear()\", pitch, circ_pitch, diam_pitch, mod),\n        pressure_angle = _inherit_gear_pa(pressure_angle),\n        arc = default(arc, 2*pressure_angle)\n    )\n    assert(is_integer(mate_teeth) && mate_teeth>10)\n    assert(is_finite(d) && d>0)\n    assert(is_bool(left_handed))\n    assert(is_integer(starts) && starts>0)\n    assert(is_finite(arc) && arc>10 && arc<=2*pressure_angle)\n    assert(is_finite(gear_spin))\n    let(\n        hsteps = segs(d/2),\n        vsteps = hsteps,\n        helical = asin(starts * circ_pitch / PI / d),\n        pr = pitch_radius(circ_pitch, mate_teeth, helical=helical),\n        taper_table = taper\n          ? [\n                [-180, 0],\n                [-arc/2, 0],\n                [-arc/2*0.85, 0.75],\n                [-arc/2*0.8, 0.93],\n                [-arc/2*0.75, 1],\n                [+arc/2*0.75, 1],\n                [+arc/2*0.8, 0.93],\n                [+arc/2*0.85, 0.75],\n                [+arc/2, 0],\n                [+180, 0],\n            ]\n          : [\n                [-180, 0],\n                [-arc/2-0.00001, 0],\n                [-arc/2, 1],\n                [+arc/2, 1],\n                [+arc/2+0.00001, 0],\n                [+180, 0],\n            ],\n        tarc = 360 / mate_teeth,\n        rteeth = quantup(ceil(mate_teeth*arc/360),2)+1+2*starts,\n        rack_path = select(\n            rack2d(\n                circ_pitch, rteeth,\n                pressure_angle=pressure_angle,\n                rounding=rounding, spin=90\n            ),\n            1,-2\n        ),\n        adendum = _adendum(circ_pitch, profile_shift=0),\n        m1 = yscale(360/(circ_pitch*mate_teeth)) * left(adendum),\n        rows = [\n            for (i = [0:1:hsteps-1]) let(\n                u = i / hsteps,\n                theta = (1-u) * 360,\n                m2 = back(circ_pitch*starts*u),\n                polars = [\n                    for (p=apply(m1*m2, rack_path))\n                    if(p.y>=-arc-tarc && p.y<=arc+tarc)\n                    [pr+p.x*lookup(p.y,taper_table)+adendum, p.y]\n                ],\n                rpolars = mirror([-1,1],p=polars)\n            ) [\n                for (j = [0:1:vsteps-1]) let(\n                    v = j / (vsteps-1),\n                    phi = (v-0.5) * arc,\n                    minor_r = lookup(phi, rpolars),\n                    xy = [d/2+pr,0] + polar_to_xy(minor_r,180-phi),\n                    xyz = xrot(90,p=point3d(xy))\n                ) zrot(theta, p=xyz)\n            ]\n        ],\n        ys = column(flatten(rows),1),\n        miny = min(ys),\n        maxy = max(ys),\n        vnf1 = vnf_vertex_array(transpose(rows), col_wrap=true, caps=true),\n        m = product([\n            zrot(gear_spin),\n            if (!left_handed) xflip(),\n            zrot(90),\n        ]),\n        vnf = apply(m, vnf1)\n    ) reorient(anchor,spin,orient, d=d, l=maxy-miny, p=vnf);\n\n\nmodule enveloping_worm(\n    circ_pitch,\n    mate_teeth,\n    d,\n    left_handed=false,\n    starts=1,\n    arc,\n    pressure_angle=20,\n    gear_spin=0,\n    rounding=true,\n    taper=true,\n    diam_pitch,\n    mod,\n    pitch,\n    anchor=CTR,\n    spin=0,\n    orient=UP\n) {\n    vnf = enveloping_worm(\n        mate_teeth=mate_teeth,\n        d=d,\n        left_handed=left_handed,\n        starts=starts,\n        arc=arc,\n        pressure_angle=pressure_angle,\n        gear_spin=gear_spin,\n        rounding=rounding,\n        taper=taper,\n        circ_pitch=circ_pitch,\n        diam_pitch=diam_pitch,\n        mod=mod,\n        pitch=pitch\n    );\n    bounds = pointlist_bounds(vnf[0]);\n    delta = bounds[1] - bounds[0];\n    attachable(anchor,spin,orient, d=max(delta.x,delta.y), l=delta.z) {\n        vnf_polyhedron(vnf, convexity=mate_teeth);\n        children();\n    }\n}\n\n// Function&Module: worm_gear()\n// Synopsis: Creates a worm gear that will mate with a worm.\n// SynTags: Geom, VNF\n// Topics: Gears, Parts\n// See Also: worm(), worm_gear(), rack(), rack2d(), spur_gear(), spur_gear2d(), bevel_pitch_angle(), bevel_gear()\n// Usage: As a Module\n//   worm_gear(circ_pitch, teeth, worm_diam, [worm_starts=], [worm_arc=], [crowning=], [left_handed=], [pressure_angle=], [backlash=], [clearance=], [slices=], [shaft_diam=]) [ATTACHMENTS];\n//   worm_gear(mod=, teeth=, worm_diam=, [worm_starts=], [worm_arc=], [crowning=], [left_handed=], [pressure_angle=], [backlash=], [clearance=], [slices=], [shaft_diam=]) [ATTACHMENTS];\n// Usage: As a Function\n//   vnf = worm_gear(circ_pitch, teeth, worm_diam, [worm_starts=], [worm_arc=], [crowning=], [left_handed=], [pressure_angle=], [backlash=], [clearance=], [slices=]);\n//   vnf = worm_gear(mod=, teeth=, worm_diam=, [worm_starts=], [worm_arc=], [crowning=], [left_handed=], [pressure_angle=], [backlash=], [clearance=], [slices=]);\n// Description:\n//   Creates a worm gear to match with a worm.\n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.  Default: 5\n//   teeth = Total number of teeth along the rack.  Default: 30\n//   worm_diam = The pitch diameter of the worm gear to match to.  Default: 30\n//   worm_starts = The number of lead starts on the worm gear to match to.  Default: 1\n//   worm_arc = The arc of the worm to mate with, in degrees. Default: 45 degrees\n//   crowning = The amount to oversize the virtual hobbing cutter used to make the teeth, to add a slight crowning to the teeth to make them fit the work easier.  Default: 1\n//   left_handed = If true, the gear returned will have a left-handed spiral.  Default: false\n//   pressure_angle = Controls how straight or bulged the tooth sides are. In degrees. Default: 20\n//   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle.  Default: 0\n//   clearance = Clearance gap at the bottom of the inter-tooth valleys.  Default: module/4\n//   profile_shift = Profile shift factor x.  Default: \"auto\"\n//   slices = The number of vertical slices to refine the curve of the worm throat.  Default: 10\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   mod = The module of the gear (pitch diameter / teeth)\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example: Right-Handed\n//   worm_gear(circ_pitch=5, teeth=36, worm_diam=30, worm_starts=1);\n// Example: Left-Handed\n//   worm_gear(circ_pitch=5, teeth=36, worm_diam=30, worm_starts=1, left_handed=true);\n// Example: Multiple Starts\n//   worm_gear(circ_pitch=5, teeth=36, worm_diam=30, worm_starts=4);\n// Example: Metric Worm Gear\n//   worm_gear(mod=2, teeth=32, worm_diam=30, worm_starts=1);\n// Example(Anim,Frames=4,FrameMS=125,VPD=220,VPT=[-15,0,0]): Meshing Worm and Gear\n//   $fn=36;\n//   circ_pitch = 5; starts = 4;\n//   worm_diam = 30; worm_length = 50;\n//   gear_teeth=36;\n//   right(worm_diam/2)\n//     yrot($t*360/starts)\n//       worm(\n//          d=worm_diam,\n//          l=worm_length,\n//          circ_pitch=circ_pitch,\n//          starts=starts,\n//          orient=BACK);\n//   left(pitch_radius(circ_pitch, gear_teeth))\n//     zrot(-$t*360/gear_teeth)\n//       worm_gear(\n//          circ_pitch=circ_pitch,\n//          teeth=gear_teeth,\n//          worm_diam=worm_diam,\n//          worm_starts=starts);\n// Example: Meshing Worm and Gear Metricly\n//   $fn = 72;\n//   modulus = 2; starts = 3;\n//   worm_diam = 30; worm_length = 50;\n//   gear_teeth=36;\n//   right(worm_diam/2)\n//       worm(d=worm_diam, l=worm_length, mod=modulus, starts=starts, orient=BACK);\n//   left(pitch_radius(mod=modulus, teeth=gear_teeth))\n//       worm_gear(mod=modulus, teeth=gear_teeth, worm_diam=worm_diam, worm_starts=starts);\n// Example: Called as Function\n//   vnf = worm_gear(circ_pitch=8, teeth=30, worm_diam=30, worm_starts=1);\n//   vnf_polyhedron(vnf);\n\nfunction worm_gear(\n    circ_pitch,\n    teeth,\n    worm_diam,\n    worm_starts=1,\n    worm_arc=45,\n    crowning=0.1,\n    left_handed=false,\n    pressure_angle,\n    backlash=0,\n    clearance,\n    profile_shift=\"auto\",\n    slices=10,\n    gear_spin=0,\n    pitch,\n    diam_pitch,\n    mod,\n    get_thickness=false,\n    anchor=CTR,\n    spin=0,\n    orient=UP\n) =\n    let(\n        circ_pitch = _inherit_gear_pitch(\"worm_gear()\", pitch, circ_pitch, diam_pitch, mod),\n        PA = _inherit_gear_pa(pressure_angle),\n        profile_shift = auto_profile_shift(teeth,PA,profile_shift=profile_shift)\n    )\n    assert(is_finite(worm_diam) && worm_diam>0)\n    assert(is_integer(teeth) && teeth>7)\n    assert(is_finite(worm_arc) && worm_arc>0 && worm_arc <= 60)\n    assert(is_integer(worm_starts) && worm_starts>0)\n    assert(is_bool(left_handed))\n    assert(is_finite(backlash))\n    assert(is_finite(crowning) && crowning>=0)\n    assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n    assert(is_finite(profile_shift))\n    let(\n        gear_arc = 2 * PA,\n        helical = asin(worm_starts * circ_pitch / PI / worm_diam),\n        full_tooth = apply(\n            zrot(90) * scale(0.99),\n            _gear_tooth_profile(\n                circ_pitch, teeth=teeth,\n                pressure_angle=PA,\n                profile_shift=-profile_shift,\n                clearance=clearance,\n                helical=helical,\n                center=true\n            )\n        ),\n        ftl = len(full_tooth),\n        tooth_half1 = (select(full_tooth, 0, ftl/2-1)),\n        tooth_half2 = (select(full_tooth, ftl/2, -1)),\n        tang = 360 / teeth,\n        rteeth = quantdn(teeth * gear_arc / 360, 2) / 2 + 0.5,\n        pr = pitch_radius(circ_pitch, teeth, helical=helical),\n        oslices = slices * 4,\n        rows = [\n            for (data = [[tooth_half1,1], [tooth_half2,-1]])\n            let (\n                tooth_half = data[0],\n                dir = data[1]\n            )\n            for (pt = tooth_half) [\n                for (i = [0:1:oslices])\n                let (\n                    u = i / oslices,\n                    w_ang = worm_arc * (u - 0.5),\n                    g_ang_delta = w_ang/360 * tang * worm_starts * (left_handed?1:-1),\n                    m = zrot(dir*rteeth*tang+g_ang_delta, cp=[worm_diam/2+pr,0,0]) *\n                        left(crowning) *\n                        yrot(w_ang) *\n                        right(worm_diam/2+crowning) *\n                        zrot(-dir*rteeth*tang+g_ang_delta, cp=[pr,0,0]) *\n                        xrot(180)\n                ) apply(m, point3d(pt))\n            ]\n        ],\n        midrow = len(rows)/2,\n        goodcols = [\n            for (i = idx(rows[0]))\n            let(\n                p1 = rows[midrow-1][i],\n                p2 = rows[midrow][i]\n            )\n            if (p1.y > p2.y) i\n        ],\n        dowarn = goodcols[0]==0? 0 : echo(\"Worm gear tooth arc reduced to fit.\"),\n        truncrows = [for (row = rows) [ for (i=goodcols) row[i] ] ],\n        zs = column(flatten(truncrows),2),\n        minz = min(zs),\n        maxz = max(zs),\n        zmax = max(abs(minz), abs(maxz))+0.05,\n        twang1 = v_theta(truncrows[0][0]),\n        twang2 = v_theta(last(truncrows[0])),\n        twang = modang(twang1 - twang2) / (maxz-minz),\n        resampled_rows = [for (row = truncrows) resample_path(row, n=slices, keep_corners=30, closed=false)],\n        tooth_rows = [\n            for (row = resampled_rows) [\n                zrot(twang*(zmax-row[0].z), p=[row[0].x, row[0].y, zmax]),\n                each row,\n                zrot(twang*(-zmax-last(row).z), p=[last(row).x, last(row).y, -zmax]),\n            ],\n        ]\n    )\n    get_thickness? zmax*2 :\n    let(\n        gear_rows = [\n            for (i = [0:1:teeth-1])\n            let(\n                m = zrot(i*tang) *\n                    back(pr) *\n                    zrot(-90) *\n                    left(worm_diam/2)\n            )\n            for (row = tooth_rows)\n            apply(m, row)\n        ],\n        vnf1 = vnf_vertex_array(transpose(gear_rows), col_wrap=true, caps=true),\n        vnf = apply(zrot(gear_spin), vnf1)\n    ) reorient(anchor,spin,orient, r=pr, h=2*zmax, p=vnf);\n\n\nmodule worm_gear(\n    circ_pitch,\n    teeth,\n    worm_diam,\n    worm_starts = 1,\n    worm_arc = 45,\n    crowning = 0.1,\n    left_handed = false,\n    pressure_angle,\n    backlash = 0,\n    clearance,\n    profile_shift=\"auto\",\n    slices = 10,\n    shaft_diam = 0,\n    gear_spin=0,\n    pitch,\n    diam_pitch,\n    mod,\n    anchor = CENTER,\n    spin = 0,\n    orient = UP\n) {\n    circ_pitch = _inherit_gear_pitch(\"worm_gear()\", pitch, circ_pitch, diam_pitch, mod);\n    PA = _inherit_gear_pa(pressure_angle);\n    profile_shift = auto_profile_shift(teeth,PA,profile_shift=profile_shift);\n    checks =\n        assert(is_integer(teeth) && teeth>10)\n        assert(is_finite(worm_diam) && worm_diam>0)\n        assert(is_integer(worm_starts) && worm_starts>0)\n        assert(is_finite(worm_arc) && worm_arc>0 && worm_arc<90)\n        assert(is_finite(crowning) && crowning>=0)\n        assert(is_bool(left_handed))\n        assert(is_finite(PA) && PA>=0 && PA<90, \"Bad pressure_angle value.\")\n        assert(clearance==undef || (is_finite(clearance) && clearance>=0))\n        assert(is_finite(backlash) && backlash>=0)\n        assert(is_finite(shaft_diam) && shaft_diam>=0)\n        assert(slices==undef || (is_integer(slices) && slices>0))\n        assert(is_finite(profile_shift) && abs(profile_shift)<1)\n        assert(is_finite(gear_spin));\n    helical = asin(worm_starts * circ_pitch / PI / worm_diam);\n    pr = pitch_radius(circ_pitch, teeth, helical);\n    vnf = worm_gear(\n        circ_pitch = circ_pitch,\n        teeth = teeth,\n        worm_diam = worm_diam,\n        worm_starts = worm_starts,\n        worm_arc = worm_arc,\n        crowning = crowning,\n        left_handed = left_handed,\n        pressure_angle = PA,\n        backlash = backlash,\n        clearance = clearance,\n        profile_shift = profile_shift,\n        slices = slices\n    );\n    thickness = pointlist_bounds(vnf[0])[1].z;\n    attachable(anchor,spin,orient, r=pr, l=thickness) {\n        zrot(gear_spin)\n        difference() {\n            vnf_polyhedron(vnf, convexity=teeth/2);\n            if (shaft_diam > 0) {\n                cylinder(h=2*thickness+1, r=shaft_diam/2, center=true, $fn=max(12,segs(shaft_diam/2)));\n            }\n        }\n        children();\n    }\n}\n\n\n\n\n/// Function: _gear_tooth_profile()\n/// Usage: As Function\n///   path = _gear_tooth_profile(pitch, teeth, [pressure_angle], [clearance], [backlash], [internal]);\n/// Topics: Gears\n/// See Also: spur_gear2d()\n/// Description:\n///   When called as a function, returns the 2D profile path for an individual gear tooth.\n///   When called as a module, creates the 2D profile shape for an individual gear tooth.\n/// Arguments:\n///   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n///   teeth = Total number of teeth on the spur gear that this is a tooth for.\n///   pressure_angle = Pressure Angle.  Controls how straight or bulged the tooth sides are. In degrees.\n///   clearance = Gap between top of a tooth on one gear and bottom of valley on a meshing gear (in millimeters)\n///   backlash = Gap between two meshing teeth, in the direction along the circumference of the pitch circle\n///   internal = If true, create a mask for difference()ing from something else.\n///   center = If true, centers the pitch circle of the tooth profile at the origin.  Default: false.\n///   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n///   mod = The module of the gear (pitch diameter / teeth)\n/// Example(2D):\n///   _gear_tooth_profile(circ_pitch=5, teeth=20, pressure_angle=20);\n/// Example(2D): Metric Gear Tooth\n///   _gear_tooth_profile(mod=2, teeth=20, pressure_angle=20);\n/// Example(2D):\n///   _gear_tooth_profile(\n///       circ_pitch=5, teeth=20, pressure_angle=20\n///   );\n/// Example(2D): As a function\n///   path = _gear_tooth_profile(\n///       circ_pitch=5, teeth=20, pressure_angle=20\n///   );\n///   stroke(path, width=0.1);\n\nfunction _gear_tooth_profile(\n    circ_pitch,\n    teeth,\n    pressure_angle = 20,\n    clearance,\n    backlash = 0.0,\n    helical = 0,\n    internal = false,\n    profile_shift = 0.0,\n    shorten = 0, \n    mod,\n    diam_pitch,\n    pitch,\n    center = false\n) = let(\n    // Calculate a point on the involute curve, by angle.\n    _involute = function(base_r,a)\n        let(b=a*PI/180) base_r * [cos(a)+b*sin(a), sin(a)-b*cos(a)],\n\n    steps = 16,\n    circ_pitch = circular_pitch(pitch=pitch, circ_pitch=circ_pitch, diam_pitch=diam_pitch, mod=mod),\n    mod = module_value(circ_pitch=circ_pitch),\n    clear = default(clearance, 0.25 * mod),\n\n    // Calculate the important circle radii\n    arad = outer_radius(circ_pitch, teeth, helical=helical, profile_shift=profile_shift, internal=internal, shorten=shorten),\n    prad = pitch_radius(circ_pitch, teeth, helical=helical),\n    brad = _base_radius(circ_pitch, teeth, pressure_angle, helical=helical),\n    rrad = _root_radius(circ_pitch, teeth, clearance, helical=helical, profile_shift=profile_shift, internal=internal),\n    srad = max(rrad,brad),\n    tthick = circ_pitch/PI / cos(helical) * (PI/2 + 2*profile_shift * tan(pressure_angle)) + (internal?backlash:-backlash),\n    tang = tthick / prad / 2 * 180 / PI,\n\n    // Generate a lookup table for the involute curve angles, by radius\n    involute_lup = [\n        for (i=[0:5:arad/PI/brad*360])\n            let(\n                xy = _involute(brad,i),\n                pol = xy_to_polar(xy)\n            )\n            if (pol.x <= arad * 1.1)\n            [pol.x, 90-pol.y]\n    ],\n\n    // Generate reverse lookup table for involute radii, by angle\n    involute_rlup = mirror([-1,1],p=involute_lup), // swaps X and Y columns.\n\n    a_ang = lookup(arad, involute_lup),\n    p_ang = lookup(prad, involute_lup),\n    b_ang = lookup(brad, involute_lup),\n    r_ang = lookup(rrad, involute_lup),\n    s_ang = lookup(srad, involute_lup),\n    soff = tang + (b_ang - p_ang),\n    ma_rad = min(arad, lookup(90-soff+0.05*360/teeth/2, involute_rlup)),\n    ma_ang = lookup(ma_rad, involute_lup),\n    cap_steps = ceil((ma_ang + soff - 90) / 5),\n    cap_step = (ma_ang + soff - 90) / cap_steps,\n    ax = circ_pitch/4 - ang_adj_to_opp(pressure_angle, circ_pitch/PI),\n\n    // Calculate the undercut a meshing rack might carve out of this tooth.\n    undercut = [\n        for (a=[atan2(ax,rrad):-1:-90])\n        let(\n            bx = -a/360 * 2*PI*prad,\n            x = bx + ax,\n            y = prad - circ_pitch/PI + profile_shift*circ_pitch/PI,\n            pol = xy_to_polar(x,y)\n        )\n        if (pol.x < arad*1.05)\n        [pol.x, pol.y-a+180/teeth]\n    ],\n    uc_min = min_index(column(undercut,0)),\n\n    // Generate a fast lookup table for the undercut.\n    undercut_lup = [for (i=idx(undercut)) if (i>=uc_min) undercut[i]],\n\n    // The u values to use when generating the tooth.\n    us = [for (i=[0:1:steps*2]) i/steps/2],\n\n    // Find top of undercut.\n    undercut_max = max([\n        0,\n        for (u = us) let(\n            r = lerp(rrad, ma_rad, u),\n            a1 = lookup(r, involute_lup) + soff,\n            a2 = lookup(r, undercut_lup),\n            a = internal || r < undercut_lup[0].x? a1 : min(a1,a2),\n            b = internal || r < undercut_lup[0].x? false : a1>a2\n        ) if(a<90+180/teeth && b) r\n    ]),\n\n    // Generate the left half of the tooth.\n    tooth_half_raw = deduplicate([\n        for (u = us)\n            let(\n                r = lerp(rrad, ma_rad, u),\n                a1 = lookup(r, involute_lup) + soff,\n                a2 = lookup(r, undercut_lup),\n                a = internal || r < undercut_lup[0].x? a1 : min(a1,a2)\n            )\n            if ( internal || r > (rrad+clear) )\n            if (!internal || r < (ma_rad-clear) )\n            if (a < 90+180/teeth)\n            polar_to_xy(r, a),\n        if (!internal)\n            for (i=[0:1:cap_steps-1]) let(\n                a = ma_ang + soff - i * (cap_step-1)\n            ) polar_to_xy(ma_rad, a),\n    ]),\n\n    // Round out the clearance valley\n    rcircum = 2 * PI * (internal? ma_rad : rrad),\n    rpart = (180/teeth-tang)/360,\n    round_r = min(clear, rcircum*rpart),\n    line1 = internal\n          ? select(tooth_half_raw,-2,-1)\n          : select(tooth_half_raw,0,1),\n    line2 = internal\n          ? [[0,ma_rad],[-1,ma_rad]]\n          : zrot(180/teeth, p=[[0,rrad],[1,rrad]]),\n    isect_pt = line_intersection(line1,line2),\n    rcorner = internal\n      ? [last(line1), isect_pt, line2[0]]\n      : [line2[0], isect_pt, line1[0]],\n    rounded_tooth_half = deduplicate([\n        if (!internal && round_r>0) each arc(n=8, r=round_r, corner=rcorner),\n        if (!internal && round_r<=0) isect_pt,\n        each tooth_half_raw,\n        if (internal && round_r>0) each arc(n=8, r=round_r, corner=rcorner),\n        if (internal && round_r<=0) isect,\n    ]),\n\n    // Strip \"jaggies\" if found.\n    strip_left = function(path,i)\n        i > len(path)? [] :\n        norm(path[i]) >= undercut_max? [for (j=idx(path)) if(j>=i) path[j]] :\n        let(\n            angs = [\n                for (j=[i+1:1:len(path)-1]) let(\n                    p = path[i],\n                    np = path[j],\n                    r = norm(np),\n                    a = v_theta(np-p)\n                ) if(r<undercut_max) a\n            ],\n            mti = !angs? 0 : min_index(angs),\n            out = concat([path[i]], strip_left(path, i + mti + 1))\n        ) out,\n    tooth_half = !undercut_max? rounded_tooth_half :\n        strip_left(rounded_tooth_half, 0),\n\n    // Mirror the tooth to complete it.\n    full_tooth = deduplicate([\n        each tooth_half,\n        each reverse(xflip(tooth_half)),\n    ]),\n\n    // Reduce number of vertices.\n    tooth = path_merge_collinear(\n        resample_path(full_tooth, n=ceil(2*steps), keep_corners=30, closed=false)\n    ),\n\n    out = center? fwd(prad, p=tooth) : tooth\n) out;\n\n\n// Section: Gear Assemblies\n\n// Function: planetary_gears()\n// Synopsis: Calculate teeth counts and angles for planetary gear assembly with specified ratio.\n// Usage:\n//   gear_data = planetary_gears(mod=|circ_pitch=|diam_pitch=, n, max_teeth, ring_carrier=|carrier_ring=|sun_carrier=|carrier_sun=|sun_ring=|ring_sun=, [helical=], [gear_spin=]);\n// Description:\n//   Calculates a planetary gear assembly that approximates a desired transmission ratio.  A planetary gear assembly can be regarded as having three\n//   elements: the outer ring gear, the central sun gear, and a carrier that holds several planet gears, which fit between the sun and ring.\n//   The transmission ratio of a planetary gear assembly depends on which element is fixed and which ones are considered the input and output shafts.\n//   The fixed element can be the ring gear, the sun gear, or the carrier, and then you specify the desired ratio between the other two.\n//   You must also specify a maximum number of teeth on the ring gear.  The function calculates the best approximation to your desired\n//   transmission ratio under that constraint: a large enough increase in the allowed number of teeth will yield a more accurate approximation.  Note that the planet gears\n//   appear uniformly spaced around the sun gear, but this uniformity is often only approximate.  Exact uniformity occurs when teeth_sun+teeth_ring\n//   is a multiple of the number of planet gears.\n//   .\n//   You specify the desired ratio using one of six parameters that identify which ratio you want to specify, and which is the driven element.\n//   Each different ratio is limited to certain bounds.  For the case of the fixed carrier system, the sun and ring rotate in opposite directions.\n//   This is sometimes indicated by a negative transmission ratio.  For these cases you can give a positive or negative value.  \n//   .\n//   The return is a list of entries that describe the elements of the planetary assembly.  The list entries are:\n//   - [\"sun\", teeth, profile_shift, spin]\n//   - [\"ring\", teeth, profile_shift, spin]\n//   - [\"planets\", teeth, profile_shift, spins, positions, angles]\n//   - [\"ratio\", realized_ratio]\n//   .\n//   The sun and ring gear are assumed to be placed at the origin.  The planet gears are placed at the list of positions.  The gears all\n//   have a spin in degrees.  The planets list also includes the angular position of each planet in the `angles` list.\n//   One of the planets always appears on the X+ axis when `gear_spin` is zero.  The final list entry gives the realized ratio of\n//   the assembly, so you can determine how closely it approaches your desired ratio.  This will always be a positive value.  \n//   .\n//   The sun gear appears by default with a tooth pointing on the Y+ axis with no spin, so if gear_spin is not used then the sun gear spin will\n//   always be zero.  If you set `gear_spin` then the drive gear for the ratio you specified will be rotated by the specified angle and all\n//   of the other gears will be rotated appropriately.\n//   .\n//   The computation of planetary gear assembles is about determining the teeth counts on the sun, ring and planet gears,\n//   and the angular positions of the planet gears.\n//   The tooth size or helical angle are needed only for determining proper profile shifting and for determining the\n//   gear positions for the profiled shifted gears.  To control the size of the assembly, do a planetary calculation\n//   with a module of 1 and then scale the module to produce the required gear dimensions.  Remember, you should never\n//   use `scale()` on gears; change their size by scaling the module or one of the other tooth size parameters.  \n// Arguments:\n//   n = Number of planetary gears\n//   max_teeth = maximum number of teeth allowed on the ring gear\n//   ---\n//   mod = The module of the gear, pitch diameter divided by tooth count. \n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   circ_pitch = distance between teeth centers around the pitch circle.\n//   ring_carrier = set ring/carrier ratio to this value in a ring driven system, must be between 1 and 2\n//   carrier_ring = set carrier/ring ratio to this value in a carrier driven system, must be between 1/2 and 1\n//   sun_carrier = set sun/carrier ratio to this value in a sun driven system, must be larger than 2\n//   carrier_sun = set carrier/sun ratio to this value in a carrier driven system, must be smaller than 1/2\n//   ring_sun = set ring/sun ratio to this value in a ring driven system, must have absolute value larger than 1\n//   sun_ring = set sun/ring ratio to this value in a sun driven system, must have absolute value smaller than 1\n//   helical = create gears with specified helical angle.  Default: 0\n//   gear_spin = rotate the driven gear by this number of degrees.  Default:0\n// Example(2D,NoAxes,Anim,Frames=90,FrameMS=30,VPT=[-0.875705,-0.110537,-66.3877],VPR=[0,0,0],VPD=102,Med): In this example we request a ring/carrier ratio of 1.341 and the system produced has a ratio of 4/3.  The sun is fixed, the input is carried by the ring, and the carrier, shown as the blue triangle, is the output, rotating approximately in accordance with the requested ratio.  \n//   mod=1;\n//   gear_data = planetary_gears(mod=mod, n=3, max_teeth=28, ring_carrier=1.341, gear_spin=4/3*360/3*$t);\n//   ring_gear2d(mod=mod, teeth=gear_data[1][1], profile_shift=gear_data[1][2], gear_spin=gear_data[1][3],backing=2);\n//   stroke(gear_data[2][4],closed=true,color=\"blue\",width=2);\n//     spur_gear2d(mod=mod, teeth=gear_data[0][1], profile_shift=gear_data[0][2], gear_spin=gear_data[0][3]);  //sun\n//   color(\"red\")move_copies(gear_data[2][4])\n//     spur_gear2d(mod=mod, teeth=gear_data[2][1], profile_shift=gear_data[2][2], gear_spin=gear_data[2][3][$idx]);\n// Example(2D,Med,NoAxes,Anim,FrameMS=60,Frames=90,VPT=[-0.125033,0.508151,-66.3877],VPR=[0,0,0],VPD=192.044): In this example we request a sun/carrier ratio of 3.6 and get exactly that ratio.  The carrier shown as the blue pentagon moves very slowly as the central sun turns.  The ring is fixed.  \n//   mod=1;\n//   gear_data = planetary_gears(mod=mod, n=5, max_teeth=70, sun_carrier=3.6, gear_spin=3.6*360/5*$t);\n//   ring_gear2d(mod=mod, teeth=gear_data[1][1], profile_shift=gear_data[1][2], gear_spin=gear_data[1][3],backing=2);\n//   stroke(gear_data[2][4],closed=true,color=\"blue\");\n//   color(\"gold\")\n//     spur_gear2d(mod=mod, teeth=gear_data[0][1], profile_shift=gear_data[0][2], gear_spin=gear_data[0][3]);  //sun\n//   color(\"red\")move_copies(gear_data[2][4])\n//       spur_gear2d(mod=mod, teeth=gear_data[2][1], profile_shift=gear_data[2][2], gear_spin=gear_data[2][3][$idx]);\n// Example(3D,Med,NoAxes,Anim,Frames=7,FrameMS=50,VPT=[0.128673,0.24149,0.651451],VPR=[38.5,0,21],VPD=222.648): Here we request a sun/ring ratio of 3 and it is exactly achieved.  The carrier, shown in blue, is fixed.  This example is shown with helical gears.  It is important to remember to flip the sign of the helical angle for the planet gears.  \n//   $fn=81;\n//   mod=1;\n//   helical=25;\n//   gear_data = planetary_gears(mod=mod, n=4, max_teeth=82, sun_ring=3, helical=helical,gear_spin=360/27*$t);\n//   ring_gear(mod=mod, teeth=gear_data[1][1], profile_shift=gear_data[1][2], helical=helical, gear_spin=gear_data[1][3],backing=4,thickness=7);\n//   color(\"blue\"){\n//       move_copies(gear_data[2][4]) cyl(h=12,d=4);\n//       down(9)linear_extrude(height=3)scale(1.2)polygon(gear_data[2][4]);\n//   }    \n//   spur_gear(mod=mod, teeth=gear_data[0][1], profile_shift=gear_data[0][2], helical=helical, gear_spin=gear_data[0][3]);  //sun\n//   color(\"red\")move_copies(gear_data[2][4])\n//       spur_gear(mod=mod, teeth=gear_data[2][1], profile_shift=gear_data[2][2], helical=-helical, gear_spin=gear_data[2][3][$idx]);\nfunction planetary_gears(n, max_teeth, helical=0, circ_pitch, mod, diam_pitch,\n                         ring_carrier, carrier_ring, sun_carrier, carrier_sun, sun_ring, ring_sun,\n                         gear_spin=0) =\n    let(\n        mod = module_value(mod=mod,circ_pitch=circ_pitch,diam_pitch=diam_pitch),\n        dummy = one_defined([ring_carrier,carrier_ring,sun_carrier,carrier_sun,sun_ring,ring_sun],\n                            \"ring_carrier,carrier_ring,sun_carrier,carrier_sun,sun_ring,ring_sun\"),\n        // ratio is between the sun and ring \n        ratio = is_def(ring_carrier) ? assert(is_finite(ring_carrier) && ring_carrier>1 && ring_carrier<2, \"ring/carrier ratio must be between 1 and 2\")\n                                       ring_carrier - 1\n              : is_def(carrier_ring) ? assert(is_finite(carrier_ring) && carrier_ring>1/2 && carrier_ring<1, \"carrier/ring ratio must be between 1/2 and 1\")\n                                       1/carrier_ring - 1\n              : is_def(sun_carrier) ?  assert(is_finite(sun_carrier) && sun_carrier>2, \"sun/carrier ratio must be larger than 2\")\n                                       1/(sun_carrier-1)\n              : is_def(carrier_sun) ?  assert(is_finite(carrier_sun) && carrier_sun<1/2, \"carrier/sun ratio must be smaller than 1/2\")\n                                       1/(1/carrier_sun-1)\n              : is_def(sun_ring) ?     assert(is_finite(sun_ring) && abs(sun_ring)>1, \"abs(sun/ring) ratio must be larger than 1\")\n                                       1/abs(sun_ring)\n              : /*is_def(ring_sun)*/   assert(is_finite(ring_sun) && abs(ring_sun)<1, \"abs(ring/sun) ratio must be smaller than 1\")\n                                       abs(ring_sun),\n        pq = rational_approx(ratio, max_teeth),\n        factor = floor(max_teeth/pq[1]),\n        temp_z_sun = factor*pq[0],\n        temp_z_ring = factor*pq[1],\n        z_sun = temp_z_sun%2==0 ? temp_z_sun+1 : temp_z_sun,\n        z_ring = temp_z_ring%2==0 ? min(temp_z_ring+1, max_teeth-(max_teeth%2==0?1:0)) : temp_z_ring,\n        z_planet = (z_ring-z_sun)/2\n    )\n    assert(z_planet==floor(z_planet),\"Planets have non-integer teeth count!  Algorithm failed.\")\n    let(\n        d12 = gear_dist(mod=mod,z_sun,z_planet,helical),\n        ps_sun = auto_profile_shift(teeth=z_sun,helical=helical),\n        ps_planet = auto_profile_shift(teeth=z_planet,helical=helical),\n        ps_ring = ps_sun+2*ps_planet,\n        ring_spin = ring_sun || ring_carrier ? gear_spin\n                  : sun_ring ? -gear_spin*z_sun/z_ring\n                  : carrier_ring ? gear_spin*(z_ring+z_sun)/z_ring\n                  : 0,\n        planet_rot = ring_carrier ? gear_spin*z_ring/(z_ring+z_sun)\n                   : carrier_sun || carrier_ring ? gear_spin\n                   : sun_carrier ? gear_spin*z_sun/(z_ring+z_sun)\n                   : carrier_ring ? gear_spin*z_ring/(z_ring+z_sun)\n                   : 0,\n        sun_spin = ring_sun ? -gear_spin*z_ring/z_sun\n                 : sun_ring || sun_carrier ? gear_spin\n                 : carrier_sun ? (z_ring+z_sun)*gear_spin/z_sun\n                 : 0,\n        planet_spin = -sun_spin*z_sun/z_planet,\n\n        quant = 360/(z_sun+z_ring),\n        planet_angles = [for (uang=lerpn(0,360,n,endpoint=false)) quant(uang,quant)+planet_rot],\n        planet_pos = [for(ang=planet_angles) d12*[cos(ang),sin(ang)]],\n        planet_spins = [for(ang=planet_angles) (z_sun/z_planet)*(ang-90)+90+ang+360/z_planet/2+planet_spin],\n\n        final_ratio = ring_carrier ? 1+z_sun/z_ring\n                    : carrier_ring ? 1/(1+z_sun/z_ring)\n                    : sun_carrier ? 1+z_ring/z_sun\n                    : carrier_sun ? 1/(1+z_ring/z_sun)\n                    : sun_ring ? z_ring/z_sun\n                    : /* ring_run */ z_sun/z_ring\n   )   \n   [  \n     [\"sun\", z_sun, ps_sun, sun_spin],\n     [\"ring\", z_ring, ps_ring, 360/z_ring/2 * (1-(z_sun%2))+ring_spin],\n     [\"planets\", z_planet, ps_planet, planet_spins, planet_pos, planet_angles],\n     [\"ratio\", final_ratio]\n   ];\n\n\n\n// Section: Computing Gear Dimensions\n//   These functions let the user find the derived dimensions of the gear.\n//   A gear fits within a circle of radius outer_radius, and two gears should have\n//   their centers separated by the sum of their pitch_radius.\n\n\n// Function: circular_pitch()\n// Synopsis: Returns tooth density expressed as \"circular pitch\".\n// Topics: Gears, Parts\n// See Also: spur_gear(), diametral_pitch(), circular_pitch(), module_value()\n// Usage:\n//   circ_pitch = circular_pitch(circ_pitch);\n//   circ_pitch = circular_pitch(mod=);\n//   circ_pitch = circular_pitch(diam_pitch=);\n// Description:\n//   Get tooth size expressed as \"circular pitch\", or the distance between teeth centers around the pitch circle.\n//   For example, an 11 tooth gear with a pitch circumference of 110 mm has a circular pitch of 110 mm /11, or 10 mm / tooth.\n//   Note that this calculation is does not depend on units for circ_pitch or mod, but the `diam_pitch` argument is based\n//   on inches and returns its value in millimeters.  \n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   ---\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n// Example(2D,Med,VPT=[0,31,0],VPR=[0,0,0],VPD=40):\n//   $fn=144;\n//   teeth=20;\n//   circ_pitch = circular_pitch(diam_pitch=8);\n//   pr = pitch_radius(circ_pitch, teeth);\n//   stroke(spur_gear2d(circ_pitch, teeth), width=0.1);\n//   color(\"cyan\")\n//       dashed_stroke(circle(r=pr), width=0.1);\n//   color(\"black\") {\n//       stroke(\n//           arc(r=pr, start=90+90/teeth, angle=-360/teeth),\n//           width=0.2, endcaps=\"arrow\");\n//       back(pr+1) right(3)\n//          zrot(30) text(\"Circular Pitch\", size=1);\n//   }\n// Example:\n//   circ_pitch1 = circular_pitch(circ_pitch=5);\n//   circ_pitch2 = circular_pitch(diam_pitch=12);\n//   circ_pitch3 = circular_pitch(mod=2);\n\nfunction circular_pitch(circ_pitch, mod, pitch, diam_pitch) =\n    assert(one_defined([pitch, mod, circ_pitch, diam_pitch], \"pitch,mod,circ_pitch,diam_pitch\"))\n    pitch != undef? assert(is_finite(pitch) && pitch>0) pitch :\n    circ_pitch != undef? assert(is_finite(circ_pitch) && circ_pitch>0) circ_pitch :\n    diam_pitch != undef? assert(is_finite(diam_pitch) && diam_pitch>0) PI / diam_pitch * INCH :\n    assert(is_finite(mod) && mod>0) mod * PI;\n\n\n// Function: diametral_pitch()\n// Synopsis: Returns tooth density expressed as \"diametral pitch\".\n// Topics: Gears, Parts\n// See Also: spur_gear(), diametral_pitch(), circular_pitch(), module_value()\n// Usage:\n//   dp = diametral_pitch(circ_pitch);\n//   dp = diametral_pitch(mod=);\n//   dp = diametral_pitch(diam_pitch=);\n// Description:\n//   Returns tooth density expressed as \"diametral pitch\", the number of teeth per inch of pitch diameter.\n//   For example, if you have a gear with 30 teeth, with a 1.5 inch pitch diameter, then you have a\n//   diametral pitch of 20 teeth/inch.\n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   ---\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n// Example:\n//   diam_pitch1 = diametral_pitch(mod=2);\n//   diam_pitch2 = diametral_pitch(circ_pitch=8);\n//   diam_pitch3 = diametral_pitch(diam_pitch=16);\n\nfunction diametral_pitch(circ_pitch, mod, pitch, diam_pitch) =\n    let( circ_pitch = circular_pitch(pitch, mod, circ_pitch, diam_pitch) )\n    PI / circ_pitch / INCH;\n\n\n// Function: module_value()\n// Synopsis: Returns tooth density expressed as \"module\"\n// Topics: Gears, Parts\n// See Also: spur_gear(), diametral_pitch(), circular_pitch(), module_value()\n// Usage:\n//   mod = module_value(circ_pitch);\n//   mod = module_value(mod=);\n//   mod = module_value(diam_pitch=);\n// Description:\n//   Get tooth size expressed as \"module\".  The module is the pitch\n//   diameter of the gear divided by the number of teeth on the gear.  For example, a gear with a pitch\n//   diameter of 40 mm, with 20 teeth on it will have a modulus of 2 mm.  For circ_pitch and mod this\n//   calculation does not depend on untis.  If you give diametral pitch, which is based on inputs, then\n//   the module is returned in millimeters.  \n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   ---\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n// Example:\n//   mod1 = module_value(circ_pitch=8);\n//   mod2 = module_value(mod=2);\n//   mod3 = module_value(diam_pitch=16);\n\nfunction module_value(circ_pitch, mod, pitch, diam_pitch) =\n    let( circ_pitch = circular_pitch(circ_pitch, mod, pitch, diam_pitch) )\n    circ_pitch / PI;\n\n\n/// Function: _adendum()\n/// Usage:\n///   ad = _adendum(circ_pitch, [profile_shift]);\n///   ad = _adendum(diam_pitch=, [profile_shift=]);\n///   ad = _adendum(mod=, [profile_shift=]);\n/// Topics: Gears\n/// Description:\n///   The height of the top of a gear tooth above the pitch radius circle.\n/// Arguments:\n///   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n///   profile_shift = Profile shift factor x.  Default: 0 \n///   ---\n///   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n///   mod = The module of the gear (pitch diameter / teeth)\n/// Example:\n///   ad = _adendum(circ_pitch=5);\n///   ad = _adendum(mod=2);\n/// Example(2D):\n///   circ_pitch = 5; teeth = 17;\n///   pr = pitch_radius(circ_pitch, teeth);\n///   adn = _adendum(circ_pitch=5);\n///   #spur_gear2d(circ_pitch=circ_pitch, teeth=teeth);\n///   color(\"black\") {\n///       stroke(circle(r=pr),width=0.1,closed=true);\n///       stroke(circle(r=pr+adn),width=0.1,closed=true);\n///   }\n\nfunction _adendum(\n    circ_pitch,\n    profile_shift=0,\n    shorten=0,\n    diam_pitch,\n    mod,\n    pitch\n) =\n    let( mod = module_value(circ_pitch, mod, pitch, diam_pitch) )\n    mod * (1 + profile_shift - shorten);\n\n\n\n/// Function: _dedendum()\n/// Usage:\n///   ddn = _dedendum(circ_pitch=, [clearance], [profile_shift]);\n///   ddn = _dedendum(diam_pitch=, [clearance=], [profile_shift=]);\n///   ddn = _dedendum(mod=, [clearance=], [profile_shift=]);\n/// Topics: Gears\n/// Description:\n///   The depth of the gear tooth valley, below the pitch radius.\n/// Arguments:\n///   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n///   clearance = If given, sets the clearance between meshing teeth.  Default: module/4\n///   profile_shift = Profile shift factor x.  Default: 0\n///   ---\n///   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n///   mod = The module of the gear (pitch diameter / teeth)\n///   shorten = amount to shorten tip \n/// Example:\n///   ddn = _dedendum(circ_pitch=5);\n///   ddn = _dedendum(mod=2);\n/// Example(2D):\n///   circ_pitch = 5; teeth = 17;\n///   pr = pitch_radius(circ_pitch, teeth);\n///   ddn = _dedendum(circ_pitch=5);\n///   #spur_gear2d(circ_pitch=circ_pitch, teeth=teeth);\n///   color(\"black\") {\n///       stroke(circle(r=pr),width=0.1,closed=true);\n///       stroke(circle(r=pr-ddn),width=0.1,closed=true);\n///   }\n\nfunction _dedendum(\n    circ_pitch,\n    clearance,\n    profile_shift=0,\n    diam_pitch,\n    mod,\n    pitch\n) = let(\n        mod = module_value(circ_pitch, mod, pitch, diam_pitch),\n        clearance = default(clearance, 0.25 * mod)\n    )\n    mod * (1 - profile_shift) + clearance;\n\n\n// Function: pitch_radius()\n// Synopsis: Returns the pitch radius for a gear.\n// Topics: Gears, Parts\n// See Also: spur_gear(), diametral_pitch(), circular_pitch(), module_value(), outer_radius()\n// Usage:\n//   pr = pitch_radius(pitch, teeth, [helical]);\n//   pr = pitch_radius(mod=, teeth=, [helical=]);\n// Description:\n//   Calculates the pitch radius for the gear.  Two mated gears will have their centers spaced apart\n//   by the sum of the two gear's pitch radii.\n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   teeth = The number of teeth on the gear.\n//   helical = The helical angle (from vertical) of the teeth on the gear.  Default: 0\n//   ---\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n// Example:\n//   pr = pitch_radius(circ_pitch=5, teeth=11);\n//   pr = pitch_radius(circ_pitch=5, teeth=11, helical=30);\n//   pr = pitch_radius(diam_pitch=10, teeth=11);\n//   pr = pitch_radius(mod=2, teeth=20);\n//   pr = pitch_radius(mod=2, teeth=20, helical=30);\n// Example(2D,Med,NoScales,VPT=[-0.20531,0.133721,0.658081],VPR=[0,0,0],VPD=82.6686):\n//   $fn=144;\n//   teeth=17; circ_pitch = 5;\n//   pr = pitch_radius(circ_pitch, teeth);\n//   stroke(spur_gear2d(circ_pitch, teeth), width=0.2);\n//   color(\"blue\") dashed_stroke(circle(r=pr), width=0.2);\n//   color(\"black\") {\n//       stroke([[0,0],polar_to_xy(pr,45)],\n//           endcaps=\"arrow\", width=0.3);\n//       fwd(1)\n//           text(\"Pitch Radius\", size=1.5,\n//               halign=\"center\", valign=\"top\");\n//   }\n\nfunction pitch_radius(\n    circ_pitch,\n    teeth,\n    helical=0,\n    mod,\n    diam_pitch,\n    pitch\n) =\n    let( circ_pitch = circular_pitch(pitch, mod, circ_pitch, diam_pitch) )\n    assert(is_finite(helical))\n    assert(is_finite(circ_pitch))\n    circ_pitch * teeth / PI / 2 / cos(helical);\n\n\n// Function: outer_radius()\n// Synopsis: Returns the outer radius for a gear.\n// Topics: Gears, Parts\n// See Also: spur_gear(), diametral_pitch(), circular_pitch(), module_value(), pitch_radius(), outer_radius()\n// Usage:\n//   or = outer_radius(circ_pitch, teeth, [helical=], [clearance=], [internal=], [profile_shift=], [shorten=]);\n//   or = outer_radius(mod=, teeth=, [helical=], [clearance=], [internal=], [profile_shift=], [shorten=]);\n//   or = outer_radius(diam_pitch=, teeth=, [helical=], [clearance=], [internal=], [profile_shift=], [shorten=]);\n// Description:\n//   Calculates the outer radius for the gear. The gear fits entirely within a cylinder of this radius, unless\n//   it has been strongly profile shifted, in which case it will be undersized due to tip clipping.\n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   teeth = The number of teeth on the gear.\n//   ---\n//   clearance = If given, sets the clearance between meshing teeth.  Default: module/4\n//   profile_shift = Profile shift factor x.  Default: \"auto\"\n//   pressure_angle = Pressure angle.  Default: 20\n//   helical = The helical angle (from vertical) of the teeth on the gear.  Default: 0\n//   shorten = Shortening factor, needed to maintain clearance with profile shifting.  Default: 0\n//   internal = If true, calculate for an internal gear.\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n// Example:\n//   or = outer_radius(circ_pitch=5, teeth=20);\n//   or = outer_radius(circ_pitch=5, teeth=20, helical=30);\n//   or = outer_radius(diam_pitch=10, teeth=17);\n//   or = outer_radius(mod=2, teeth=16);\n// Example(2D,Med,NoScales,VPT=[-0.20531,0.133721,0.658081],VPR=[0,0,0],VPD=82.6686):\n//   $fn=144;\n//   teeth=17; circ_pitch = 5;\n//   or = outer_radius(circ_pitch, teeth);\n//   stroke(spur_gear2d(circ_pitch, teeth), width=0.2);\n//   color(\"blue\") dashed_stroke(circle(r=or), width=0.2);\n//   color(\"black\") {\n//       stroke([[0,0],polar_to_xy(or,45)],\n//           endcaps=\"arrow\", width=0.3);\n//       fwd(1)\n//           text(\"Outer Radius\", size=1.5,\n//               halign=\"center\", valign=\"top\");\n//   }\n\nfunction outer_radius(circ_pitch, teeth, clearance, internal=false, helical=0, profile_shift=\"auto\", pressure_angle=20, shorten=0, mod, pitch, diam_pitch) =\n    let(\n       circ_pitch = circular_pitch(pitch, mod, circ_pitch, diam_pitch),\n       profile_shift = auto_profile_shift(teeth, pressure_angle, helical, profile_shift=profile_shift)\n    )\n    pitch_radius(circ_pitch, teeth, helical) + (\n        internal\n          ? _dedendum(circ_pitch, clearance, profile_shift=-profile_shift)\n          : _adendum(circ_pitch, profile_shift=profile_shift, shorten=shorten)\n    );\n\n\n/// Function: _root_radius()\n/// Usage:\n///   rr = _root_radius(circ_pitch, teeth, [helical], [clearance=], [internal=], [profile_shift=]);\n///   rr = _root_radius(diam_pitch=, teeth=, [helical=], [clearance=], [internal=], [profile_shift=]);\n///   rr = _root_radius(mod=, teeth=, [helical=], [clearance=], [internal=], [profile_shift=]);\n/// Topics: Gears\n/// Description:\n///   Calculates the root radius for the gear, at the base of the dedendum.  Does not apply auto profile shifting. \n/// Arguments:\n///   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n///   teeth = The number of teeth on the gear.\n///   ---\n///   clearance = If given, sets the clearance between meshing teeth.  Default: module/4\n///   internal = If true, calculate for an internal gear.\n///   helical = The helical angle (from vertical) of the teeth on the gear.  Default: 0\n///   profile_shift = Profile shift factor x.  Default:0\n///   mod = The module of the gear (pitch diameter / teeth)\n///   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n/// Example:\n///   rr = _root_radius(circ_pitch=5, teeth=11);\n///   rr = _root_radius(circ_pitch=5, teeth=16, helical=30);\n///   rr = _root_radius(diam_pitch=10, teeth=11);\n///   rr = _root_radius(mod=2, teeth=16);\n/// Example(2D):\n///   pr = _root_radius(circ_pitch=5, teeth=11);\n///   #spur_gear2d(pitch=5, teeth=11);\n///   color(\"black\")\n///       stroke(circle(r=pr),width=0.1,closed=true);\n\nfunction _root_radius(circ_pitch, teeth, clearance, internal=false, helical=0, profile_shift=0, diam_pitch, mod, pitch) =\n    let( circ_pitch = circular_pitch(pitch, mod, circ_pitch, diam_pitch) )\n    pitch_radius(circ_pitch, teeth, helical) - (\n        internal\n          ? _adendum(circ_pitch, profile_shift=-profile_shift)\n          : _dedendum(circ_pitch, clearance, profile_shift=profile_shift)\n    );\n\n\n/// Function: _base_radius()\n/// Usage:\n///   br = _base_radius(circ_pitch, teeth, [pressure_angle], [helical]);\n///   br = _base_radius(diam_pitch=, teeth=, [pressure_angle=], [helical=]);\n///   br = _base_radius(mod=, teeth=, [pressure_angle=], [helical=]);\n/// Topics: Gears\n/// Description:\n///   Get the base circle for involute teeth, at the base of the teeth.\n/// Arguments:\n///   pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n///   teeth = The number of teeth on the gear.\n///   pressure_angle = Pressure angle in degrees.  Controls how straight or bulged the tooth sides are.\n///   helical = The helical angle (from vertical) of the teeth on the gear.  Default: 0\n///   ---\n///   mod = The module of the gear (pitch diameter / teeth)\n///   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n/// Example:\n///   br = _base_radius(circ_pitch=5, teeth=20, pressure_angle=20);\n///   br = _base_radius(circ_pitch=5, teeth=20, pressure_angle=20, helical=30);\n///   br = _base_radius(diam_pitch=10, teeth=20, pressure_angle=20);\n///   br = _base_radius(mod=2, teeth=18, pressure_angle=20);\n/// Example(2D):\n///   pr = _base_radius(circ_pitch=5, teeth=11);\n///   #spur_gear2d(circ_pitch=5, teeth=11);\n///   color(\"black\")\n///       stroke(circle(r=pr),width=0.1,closed=true);\n\nfunction _base_radius(circ_pitch, teeth, pressure_angle=20, helical=0, diam_pitch, mod, pitch) =\n    let(\n        circ_pitch = circular_pitch(pitch, mod, circ_pitch, diam_pitch),\n        trans_pa = atan(tan(pressure_angle)/cos(helical))\n    )\n    pitch_radius(circ_pitch, teeth, helical) * cos(trans_pa);\n\n\n// Function: bevel_pitch_angle()\n// Synopsis: Returns the pitch cone angle for a bevel gear.\n// Topics: Gears, Parts\n// See Also: bevel_gear(), pitch_radius(), outer_radius()\n// Usage:\n//   ang = bevel_pitch_angle(teeth, mate_teeth, [drive_angle=]);\n// Description:\n//   Returns the correct pitch cone angle for a bevel gear with a given number of teeth, that is\n//   matched to another bevel gear with a (possibly different) number of teeth.\n// Arguments:\n//   teeth = Number of teeth that this gear has.\n//   mate_teeth = Number of teeth that the matching gear has.\n//   drive_angle = Angle between the drive shafts of each gear.  Default: 90\u00ba.\n// Example:\n//   ang = bevel_pitch_angle(teeth=18, mate_teeth=30);\n// Example(2D):\n//   t1 = 13; t2 = 19; pitch=5;\n//   pang = bevel_pitch_angle(teeth=t1, mate_teeth=t2, drive_angle=90);\n//   color(\"black\") {\n//       zrot_copies([0,pang])\n//           stroke([[0,0,0], [0,-20,0]],width=0.2);\n//       stroke(arc(r=3, angle=[270,270+pang]),width=0.2);\n//   }\n//   #bevel_gear(\n//       pitch=5, teeth=t1, mate_teeth=t2,\n//       spiral=0, cutter_radius=1000,\n//       slices=12, anchor=\"apex\", orient=BACK\n//   );\n\nfunction bevel_pitch_angle(teeth, mate_teeth, drive_angle=90) =\n    atan(sin(drive_angle)/((mate_teeth/teeth)+cos(drive_angle)));\n\n\n// Function: worm_gear_thickness()\n// Synopsis: Returns the thickness for a worm gear.\n// Topics: Gears, Parts\n// See Also: worm(), worm_gear(), pitch_radius(), outer_radius()\n// Usage:\n//   thick = worm_gear_thickness(pitch, teeth, worm_diam, [worm_arc=], [crowning=], [clearance=]);\n//   thick = worm_gear_thickness(mod=, teeth=, worm_diam=, [worm_arc=], [crowning=], [clearance=]);\n// Description:\n//   Calculate the thickness of the worm gear.\n// Arguments:\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.  Default: 5\n//   teeth = Total number of teeth along the rack.  Default: 30\n//   worm_diam = The pitch diameter of the worm gear to match to.  Default: 30\n//   ---\n//   worm_arc = The arc of the worm to mate with, in degrees. Default: 45 degrees\n//   pressure_angle = Pressure angle in degrees.  Controls how straight or bulged the tooth sides are.  Default: 20\u00ba\n//   crowning = The amount to oversize the virtual hobbing cutter used to make the teeth, to add a slight crowning to the teeth to make them fit the work easier.  Default: 1\n//   clearance = Clearance gap at the bottom of the inter-tooth valleys.  Default: module/4\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n// Example:\n//   thick = worm_gear_thickness(circ_pitch=5, teeth=36, worm_diam=30);\n//   thick = worm_gear_thickness(mod=2, teeth=28, worm_diam=25);\n// Example(2D):\n//   circ_pitch = 5;\n//   teeth = 17;\n//   worm_diam = 30;\n//   worm_starts = 2;\n//   worm_arc = 40;\n//   y = worm_gear_thickness(\n//       circ_pitch=circ_pitch,\n//       teeth=teeth,\n//       worm_diam=worm_diam,\n//       worm_arc=worm_arc\n//   );\n//   #worm_gear(\n//       circ_pitch=circ_pitch,\n//       teeth=teeth,\n//       worm_diam=worm_diam,\n//       worm_arc=worm_arc,\n//       worm_starts=worm_starts,\n//       orient=BACK\n//   );\n//   color(\"black\") {\n//       ycopies(y) stroke([[-25,0],[25,0]], width=0.5);\n//       stroke([[-20,-y/2],[-20,y/2]],width=0.5,endcaps=\"arrow\");\n//   }\n\nfunction worm_gear_thickness(\n    circ_pitch,\n    teeth,\n    worm_diam,\n    worm_arc=45,\n    pressure_angle=20,\n    crowning=0.1,\n    clearance,\n    diam_pitch,\n    mod,\n    pitch\n) = let(\n        circ_pitch = circular_pitch(pitch, mod, circ_pitch, diam_pitch),\n        thickness = worm_gear(\n            circ_pitch=circ_pitch,\n            teeth=teeth,\n            worm_diam=worm_diam,\n            worm_arc=worm_arc,\n            crowning=crowning,\n            pressure_angle=pressure_angle,\n            clearance=clearance,\n            get_thickness=true\n        )\n    ) thickness;\n\n\n// Function: worm_dist()\n// Synopsis: Returns the distance between a worm and a worm gear\n// Topics: Gears, Parts\n// See Also: worm(), worm_gear(), pitch_radius(), outer_radius()\n// Usage:\n//   dist = worm_dist(mod=|diam_pitch=|circ_pitch=, d, starts, teeth, [profile_shift], [pressure_angle=]);\n// Description:\n//   Calculate the distance between the centers of a worm and its mating worm gear, taking account\n//   possible profile shifting of the worm gear.\n// Arguments:\n//   d = diameter of worm\n//   starts = number of starts of worm\n//   teeth = number of teeth on worm gear\n//   profile_shift = profile shift of worm gear\n//   ---\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   pressure_angle = The pressure angle of the gear.\n//   backlash = Add extra space to produce a total of 2*backlash between the two gears. \n\nfunction worm_dist(d,starts,teeth,mod,profile_shift=0,diam_pitch,circ_pitch,pressure_angle=20,backlash=0) =\n  let(\n      mod = module_value(mod=mod,diam_pitch=diam_pitch,circ_pitch=circ_pitch),\n      lead_angle = asin(mod*starts/d),\n      pitch_diam = mod*teeth/cos(lead_angle)\n  )\n  (d+pitch_diam)/2 + profile_shift*mod\n//   + backlash * (cos(lead_angle)+cos(90-lead_angle)) / tan(pressure_angle);\n//    + backlash * cos(45-lead_angle) / tan(pressure_angle);\n     + backlash * cos(lead_angle) / tan(pressure_angle);\n\n\n\n// Function: gear_dist()\n// Synopsis: Returns the distance between two gear centers for spur gears or parallel axis helical gears.\n// Topics: Gears, Parts\n// See Also: worm(), worm_gear(), pitch_radius(), outer_radius()\n// Usage:\n//   dist = gear_dist(mod=|diam_pitch=|circ_pitch=, teeth1, teeth2, [helical], [profile_shift1], [profile_shift2], [pressure_angle=], [backlash=]);\n// Description:\n//   Calculate the distance between the centers of two spur gears gears or helical gears with parallel axes,\n//   taking into account profile shifting and helical angle.  You can give the helical angle as either positive or negative.  \n//   If you set one of the tooth counts to zero than that gear will be treated as a rack and the distance returned is the\n//   distance between the rack's pitch line and the gear's center.  If you set internal1 or internal2 to true then the\n//   specified gear is a ring gear;  the returned distance is still the distance between the centers of the gears.  Note that\n//   for a regular gear and ring gear to be compatible the ring gear must have more teeth and at least as much profile shift\n//   as the regular gear.\n//   .\n//   The backlash parameter computes the distance offset that produces a total backlash of `2*backlash` in the\n//   two gear mesh system.  This is equivalent to giving the same backlash argument to both gears.  \n// Arguments:\n//   teeth1 = Total number of teeth in the first gear.  If given 0, we assume this is a rack or worm.\n//   teeth2 = Total number of teeth in the second gear.  If given 0, we assume this is a rack or worm.\n//   helical = The value of the helical angle (from vertical) of the teeth on the two gears (either sign).  Default: 0\n//   profile_shift1 = Profile shift factor x for the first gear.  Default: 0\n//   profile_shift2 = Profile shift factor x for the second gear.  Default: 0\n//   --\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   internal1 = first gear is an internal (ring) gear.  Default: false\n//   internal2 = second gear is an internal (ring) gear.  Default: false\n//   pressure_angle = The pressure angle of the gear.\n//   backlash = Add extra space to produce a total of 2*backlash between the two gears. \n// Example(2D,NoAxes): Spur gears (with automatic profile shifting on both)\n//   circ_pitch=5; teeth1=7; teeth2=24;\n//   d = gear_dist(circ_pitch=circ_pitch, teeth1, teeth2);\n//   spur_gear2d(circ_pitch, teeth1, gear_spin=-90);\n//   right(d) spur_gear2d(circ_pitch, teeth2, gear_spin=90-180/teeth2);\n// Example(3D,NoAxes,Med,VPT=[23.9049,5.42594,-4.68026],VPR=[64.8,0,353.5],VPD=140): Helical gears (with auto profile shifting on one of the gears)\n//   circ_pitch=5; teeth1=7; teeth2=24; helical=37;\n//   d = gear_dist(circ_pitch=circ_pitch, teeth1, teeth2, helical);\n//   spur_gear(circ_pitch, teeth1, helical=helical, gear_spin=-90,slices=15);\n//   right(d) spur_gear(circ_pitch, teeth2, helical=-helical, gear_spin=-90-180/teeth2,slices=9);\n// Example(2D,NoAxes): Disable Auto Profile Shifting on the smaller gear\n//   circ_pitch=5; teeth1=7; teeth2=24;\n//   d = gear_dist(circ_pitch=circ_pitch, teeth1, teeth2, profile_shift1=0);\n//   spur_gear2d(circ_pitch, teeth1, profile_shift=0, gear_spin=-90);\n//   right(d) spur_gear2d(circ_pitch, teeth2, gear_spin=90-180/teeth2);\n// Example(2D,NoAxes): Manual Profile Shifting\n//   circ_pitch=5; teeth1=7; teeth2=24; ps1 = 0.5; ps2 = -0.2;\n//   d = gear_dist(circ_pitch=circ_pitch, teeth1, teeth2, profile_shift1=ps1, profile_shift2=ps2);\n//   spur_gear2d(circ_pitch, teeth1, profile_shift=ps1, gear_spin=-90);\n//   right(d) spur_gear2d(circ_pitch, teeth2, profile_shift=ps2, gear_spin=90-180/teeth2);\n// Example(2D,NoAxes): Profile shifted gear and a rack\n//   mod=3; teeth=8;\n//   d = gear_dist(mod=mod, teeth, 0);\n//   rack2d(mod=mod, teeth=5, bottom=9);\n//   back(d) spur_gear2d(mod=mod, teeth=teeth, gear_spin=180/teeth);\n// Example(3D,Med,NoAxes,VPT=[-0.0608489,1.3772,-3.68839],VPR=[63.4,0,29.7],VPD=113.336): Profile shifted helical gear and rack \n//   mod=3; teeth=8; helical=29;\n//   d = gear_dist(mod=mod, teeth, 0, helical);\n//   rack(mod=mod, teeth=5, helical=helical, orient=FWD);\n//   color(\"lightblue\")\n//     fwd(d) spur_gear(mod=mod, teeth=teeth, helical=-helical, gear_spin=180/teeth);\nfunction gear_dist(\n    teeth1,\n    teeth2,\n    helical=0,\n    profile_shift1,\n    profile_shift2,\n    internal1=false,\n    internal2=false,\n    backlash = 0,\n    pressure_angle=20,\n    diam_pitch,\n    circ_pitch,\n    mod\n) =\n    assert(all_nonnegative([teeth1,teeth2]),\"Must give nonnegative values for teeth\")\n    assert(teeth1>0 || teeth2>0, \"One of the teeth counts must be nonzero\")\n    assert(is_bool(internal1))\n    assert(is_bool(internal2))\n    assert(is_finite(helical))\n    assert(!(internal1&&internal2), \"Cannot specify both gears as internal\")\n    assert(!(internal1 || internal2) || (teeth1>0 && teeth2>0), \"Cannot specify internal gear with rack (zero tooth count)\")\n    let(\n        mod = module_value(mod=mod,circ_pitch= circ_pitch, diam_pitch=diam_pitch),\n        profile_shift1 = auto_profile_shift(teeth1,pressure_angle,helical,profile_shift=profile_shift1),\n        profile_shift2 = auto_profile_shift(teeth2,pressure_angle,helical,profile_shift=profile_shift2),\n        teeth1 = internal2? -teeth1 : teeth1,\n        teeth2 = internal1? -teeth2 : teeth2\n    )\n    assert(teeth1+teeth2>0, \"Internal gear must have more teeth than the mated external gear\")\n    let(\n        profile_shift1 = internal2? -profile_shift1 : profile_shift1,\n        profile_shift2 = internal1? -profile_shift2 : profile_shift2\n    )\n    assert(!(internal1||internal2) || profile_shift1+profile_shift2>=0, \"Internal gear must have profile shift equal or greater than mated external gear\")\n    teeth1==0 || teeth2==0? pitch_radius(mod=mod, teeth=teeth1+teeth2, helical=helical) + (profile_shift1+profile_shift2)*mod\n    :\n    let(\n        pa_eff = _working_pressure_angle(teeth1,profile_shift1,teeth2,profile_shift2,pressure_angle,helical),\n        pa_transv = atan(tan(pressure_angle)/cos(helical))\n    )\n    mod*(teeth1+teeth2)*cos(pa_transv)/cos(pa_eff)/cos(helical)/2\n        + (internal1||internal2?-1:1) * backlash*cos(helical)/tan(pressure_angle);\n\nfunction _invol(a) = tan(a) - a*PI/180;\n\nfunction _working_pressure_angle(teeth1,profile_shift1, teeth2, profile_shift2, pressure_angle, helical) =\n  let(\n      pressure_angle = atan(tan(pressure_angle)/cos(helical))\n  )\n  teeth1==0 || teeth2==0 ? pressure_angle\n  :\n  let(\n      rhs = 2*(profile_shift1+profile_shift2)/(teeth1+teeth2)*cos(helical)*tan(pressure_angle) + _invol(pressure_angle)\n  )\n  assert(rhs>0, \"Total profile shift is too small, so working pressure angle is negative, and no valid gear separation exists\")\n  let(\n      pa_eff = root_find(function (x) _invol(x)-rhs, 1, 75)\n  )\n  pa_eff;\n\n\n\n// Function: gear_dist_skew()\n// Usage:\n// Synopsis: Returns the distance between two helical gear centers with skew axes.  \n// Topics: Gears, Parts\n// See Also: gear_dist(), worm(), worm_gear(), pitch_radius(), outer_radius()\n// Usage:\n//   dist = gear_dist_skew(mod=|diam_pitch=|circ_pitch=, teeth1, teeth2, helical1, helical2, [profile_shift1], [profile_shift2], [pressure_angle=]\n// Description:\n//   Calculate the distance between two helical gears that mesh with non-parallel axes, taking into account\n//   profile shift and the helical angles.\n// Arguments:\n//   teeth1 = Total number of teeth in the first gear.  If given 0, we assume this is a rack or worm.\n//   teeth2 = Total number of teeth in the second gear.  If given 0, we assume this is a rack or worm.\n//   helical1 = The helical angle (from vertical) of the teeth on the first gear. \n//   helical1 = The helical angle (from vertical) of the teeth on the second gear.\n//   profile_shift1 = Profile shift factor x for the first gear.  Default: \"auto\"\n//   profile_shift2 = Profile shift factor x for the second gear.  Default: \"auto\"\n//   --\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   mod = The module of the gear (pitch diameter / teeth)\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   pressure_angle = The pressure angle of the gear.\n//   backlash = Add extra space to produce a total of 2*backlash between the two gears. \n// Example(3D,Med,NoAxes,VPT=[-0.302111,3.7924,-9.252],VPR=[55,0,25],VPD=155.556): Non-parallel Helical Gears (without any profile shifting)\n//   circ_pitch=5; teeth1=15; teeth2=24; ha1=45; ha2=30; thick=10;\n//   d = gear_dist_skew(circ_pitch=circ_pitch, teeth1, teeth2, helical1=ha1, helical2=ha2);\n//   left(d/2) spur_gear(circ_pitch, teeth1, helical=ha1, thickness=thick, gear_spin=-90);\n//   right(d/2) xrot(ha1+ha2) spur_gear(circ_pitch, teeth2, helical=ha2, thickness=thick, gear_spin=90-180/teeth2);\nfunction gear_dist_skew(teeth1,teeth2,helical1,helical2,profile_shift1,profile_shift2,pressure_angle=20,\n                        mod, circ_pitch, diam_pitch, backlash=0) =\n  assert(all_nonnegative([teeth1,teeth2]),\"Must give nonnegative values for teeth\")\n  assert(teeth1>0 || teeth2>0, \"One of the teeth counts must be nonzero\")\n  let(\n      profile_shift1 = auto_profile_shift(teeth1,pressure_angle,helical1,profile_shift=profile_shift1),\n      profile_shift2 = auto_profile_shift(teeth2,pressure_angle,helical2,profile_shift=profile_shift2),\n      mod = module_value(circ_pitch=circ_pitch, diam_pitch=diam_pitch, mod=mod)\n  )\n  teeth1==0 || teeth2==0? pitch_radius(mod=mod, teeth=teeth1+teeth2, helical=teeth1?helical1:helical2) + (profile_shift1+profile_shift2)*mod\n  :\n  let(\n      pa_normal_eff = _working_normal_pressure_angle_skew(teeth1,profile_shift1,helical1,teeth2,profile_shift2,helical2,pressure_angle),\n      dist_adj = 0.5*(teeth1/cos(helical1)^3+teeth2/cos(helical2)^3)*(cos(pressure_angle)/cos(pa_normal_eff)-1)\n  )\n  mod*(teeth1/2/cos(helical1)+teeth2/2/cos(helical2)+dist_adj)\n      // This expression is a guess based on finding the cross section where pressure angles match so that there is a single\n      // pressure angle to reference the movement by. \n      + backlash * cos((helical1-helical2)/2) / tan(pressure_angle);\n\n\nfunction _working_normal_pressure_angle_skew(teeth1,profile_shift1,helical1, teeth2, profile_shift2, helical2, pressure_angle) = \n  let(\n      inv = function(a) tan(a) + a*PI/180, \n      rhs = 2*(profile_shift1+profile_shift2)/(teeth1/cos(helical1)^3+teeth2/cos(helical2)^3)*tan(pressure_angle) + _invol(pressure_angle),\n      pa_eff_normal = root_find(function (x) _invol(x)-rhs, 5, 75)\n  )\n  pa_eff_normal;\n\n\n// Function: gear_skew_angle()\n// Usage:\n//   ang = gear_skew_angle(teeth1, teeth2, helical1, helical2, [profile_shift1], [profile_shift2], [pressure_angle=]\n// Synopsis: Returns corrected skew angle between two profile shifted helical gears.  \n// Description:\n//   Compute the correct skew angle between the axes of two profile shifted helical gears.  When profile shifting is zero, or when one of\n//   the gears is a rack, this angle is simply the sum of the helical angles of the two gears.  But with profile shifted gears, a small\n//   correction to the skew angle is needed for proper meshing.  \n// Arguments:\n//   teeth1 = Total number of teeth in the first gear.  If given 0, we assume this is a rack or worm.\n//   teeth2 = Total number of teeth in the second gear.  If given 0, we assume this is a rack or worm.\n//   helical1 = The helical angle (from vertical) of the teeth on the first gear. \n//   helical1 = The helical angle (from vertical) of the teeth on the second gear.\n//   profile_shift1 = Profile shift factor x for the first gear.  Default: \"auto\"\n//   profile_shift2 = Profile shift factor x for the second gear.  Default: \"auto\"\n//   --\n//   pressure_angle = The pressure angle of the gear.\n// Example(3D,Med,NoAxes,VPT=[-2.62091,2.01048,-1.31405],VPR=[55,0,25],VPD=74.4017): These gears are auto profile shifted and as a result, do not mesh at the sum of their helical angles, but at 2.5 degrees more.  \n//   circ_pitch=5; teeth1=12; teeth2=7; ha1=25; ha2=30; thick=10;\n//   d = gear_dist_skew(circ_pitch=circ_pitch, teeth1, teeth2, ha1, ha2);\n//   ang = gear_skew_angle(teeth1, teeth2, helical1=ha1, helical2=ha2);  // Returns 57.7\n//   left(d/2)\n//     spur_gear(circ_pitch, teeth1, helical=ha1, thickness=thick, gear_spin=-90);\n//   right(d/2) color(\"lightblue\")\n//     xrot(ang) spur_gear(circ_pitch, teeth2, helical=ha2, thickness=thick, gear_spin=90-180/teeth2);\n\nfunction gear_skew_angle(teeth1,teeth2,helical1,helical2,profile_shift1,profile_shift2,pressure_angle=20) =\n   assert(all_nonnegative([teeth1,teeth2]),\"Must give nonnegative values for teeth\")\n   assert(teeth1>0 || teeth2>0, \"One of the teeth counts must be nonzero\")\n   let(\n       mod = 1,  // This is independent of module size\n       profile_shift1 = auto_profile_shift(teeth1,pressure_angle,helical1,profile_shift=profile_shift1),\n       profile_shift2 = auto_profile_shift(teeth2,pressure_angle,helical2,profile_shift=profile_shift2)\n   )\n   profile_shift1==0 && profile_shift2==0 ? helical1+helical2\n : teeth1==0 || teeth2==0 ? helical1+helical2\n : let(\n        a = gear_dist_skew(mod=mod,teeth1,teeth2,helical1,helical2,profile_shift1,profile_shift2,pressure_angle=pressure_angle),\n        b = gear_dist_skew(mod=mod,teeth1,teeth2,helical1,helical2,0,0,pressure_angle=pressure_angle),\n        d1 = 2*pitch_radius(mod=mod,teeth=teeth1,helical=helical1),\n        d2 = 2*pitch_radius(mod=mod,teeth=teeth2,helical=helical2),\n        dw1 = 2*a*d1/(d1+d2),\n        dw2 = 2*a*d2/(d1+d2),\n        beta1 = atan(dw1/d1*tan(helical1)),\n        beta2 = atan(dw2/d2*tan(helical2))\n   )\n   beta1+beta2;\n\n\n// Function: get_profile_shift()\n// Usage:\n//   total_shift = get_profile_shift(mod=|diam_pitch=|circ_pitch=, desired, teeth1, teeth2, [helical], [pressure_angle=],\n// Synopsis: Returns total profile shift needed to achieve a desired spacing between two gears\n// Description:\n//   Compute the total profile shift, split between two gears, needed to place those gears with a specified separation.\n//   If the requested separation is too small, returns NaN.  Note that the profile shift returned may also be impractically\n//   large or small and does not necessarily lead to a valid gear configuration.  You will need to split the profile shift\n//   between the two gears.  Note that for helical gears, much more adjustment is available by modifying the helical angle.  \n// Arguments:\n//   desired = desired gear center separation\n//   teeth1 = number of teeth on first gear\n//   teeth2 = number of teeth on second gear\n//   helical = The helical angle (from vertical) of the teeth on the gear.  Default: 0\n//   ---\n//   mod = The module of the gear (pitch diameter / teeth)\n//   diam_pitch = The diametral pitch, or number of teeth per inch of pitch diameter.  Note that the diametral pitch is a completely different thing than the pitch diameter.\n//   circ_pitch = The circular pitch, the distance between teeth centers around the pitch circle.\n//   pressure_angle = normal pressure angle of gear teeth.  Default: 20\n// Example(2D,Med,NoAxes,VPT=[37.0558,0.626722,9.78411],VPR=[0,0,0],VPD=496): For a pair of module 4 gears with 19, and 37 teeth, the separation without profile shifting is 112.  Suppose we want it instead to be 115.  A positive profile shift, split evenly between the gears, achieves the goal, as shown by the red rectangle, with width 115.  \n//   teeth1=37;\n//   teeth2=19;\n//   mod=4;\n//   desired=115;\n//   pshift = get_profile_shift(desired,teeth1,teeth2,mod=mod);  // Returns 0.82\n//   ps1 = pshift/2;\n//   ps2 = pshift/2;\n//   shorten=gear_shorten(teeth1,teeth2,0,ps1,ps2);       // Returns 0.07\n//   d = gear_dist(mod=mod, teeth1,teeth2,0,ps1,ps2);\n//   spur_gear2d(mod=mod,teeth=teeth1,profile_shift=ps1,shorten=shorten,gear_spin=-90,shaft_diam=5);\n//   right(d)\n//     spur_gear2d(mod=mod,teeth=teeth2,profile_shift=ps2,shorten=shorten,gear_spin=-90,shaft_diam=5);\n//   stroke([rect([desired,40], anchor=LEFT)],color=\"red\");\n// Example(2D,Med,NoAxes,VPT=[37.0558,0.626722,9.78411],VPR=[0,0,0],VPD=496): For the same pair of module 4 gears with 19, and 37 teeth, suppose we want a closer spacing of 110 instead of 112.  A positive profile shift does the job, as shown by the red rectangle with width 110.  More of the negative shift is assigned to the large gear, to avoid undercutting the smaller gear.  \n//   teeth1=37;\n//   teeth2=19;\n//   mod=4;\n//   desired=110;\n//   pshift = get_profile_shift(desired,teeth1,teeth2,mod=mod);  // Returns -0.46\n//   ps1 = 0.8*pshift;\n//   ps2 = 0.2*pshift;\n//   shorten=gear_shorten(teeth1,teeth2,0,ps1,ps2);  // Returns 0.04\n//   d = gear_dist(mod=mod, teeth1,teeth2,0,ps1,ps2);\n//   spur_gear2d(mod=mod,teeth=teeth1,profile_shift=ps1,shorten=shorten,gear_spin=-90,shaft_diam=5);\n//   right(d)\n//     spur_gear2d(mod=mod,teeth=teeth2,profile_shift=ps2,shorten=shorten,gear_spin=-90,shaft_diam=5);\n//   stroke([rect([desired,40], anchor=LEFT)],color=\"red\");\nfunction get_profile_shift(desired,teeth1,teeth2,helical=0,pressure_angle=20,mod,diam_pitch,circ_pitch) =\n  let(\n       mod = module_value(mod=mod, circ_pitch=circ_pitch, diam_pitch=diam_pitch),\n       teethsum = teeth1+teeth2,\n       pressure_angle_trans = atan(tan(pressure_angle)/cos(helical)),\n       y = desired/mod - teethsum/2/cos(helical),\n       thing=teethsum*cos(pressure_angle_trans) / (teethsum+2*y*cos(helical)),\n       pa_eff = acos(teethsum*cos(pressure_angle_trans) / (teethsum+2*y*cos(helical)))\n  )\n  teethsum * (_invol(pa_eff)-_invol(pressure_angle_trans))/2/tan(pressure_angle);\n\n\n// Function: auto_profile_shift()\n// Synopsis: Returns the recommended profile shift for a gear.\n// Topics: Gears, Parts\n// See Also: worm(), worm_gear(), pitch_radius(), outer_radius()\n// Usage:\n//   x = auto_profile_shift(teeth, [pressure_angle], [helical], [profile_shift=]);\n//   x = auto_profile_shift(teeth, [pressure_angle], [helical], get_min=);\n//   x = auto_profile_shift(teeth, min_teeth=);\n// Description:\n//   Calculates the recommended profile shift to avoid gear tooth undercutting.  You can set `min_teeth` to a\n//   value to allow small undercutting, and only activate the profile shift for more extreme cases.  Is is common\n//   practice to make gears with 15-17 teeth with undercutting with the standard 20 deg pressure angle.\n//   .\n//   The `get_min` argument returns the minimum profile shift needed to avoid undercutting for the specified\n//   number of teeth.  This will be a negative value for gears with a large number of teeth; such gears can\n//   be given a negative profile shift without undercutting.  \n// Arguments:\n//   teeth = Total number of teeth in the gear.\n//   pressure_angle = The pressure angle of the gear.\n//   helical = helical angle\n//   ---\n//   min_teeth = If given, the minimum number of teeth on a gear that has acceptable undercut.\n//   get_min = If true then return the minimum profile shift to avoid undercutting, which may be a negative value for large gears.  \n//   profile_shift = If numerical then just return this value; if \"auto\" or not given then compute the automatic profile shift.\nfunction auto_profile_shift(teeth, pressure_angle=20, helical=0, min_teeth, profile_shift, get_min=false) =\n    assert(is_undef(profile_shift) || is_finite(profile_shift) || profile_shift==\"auto\", \"Profile shift must be \\\"auto\\\" or a number\")\n    is_num(profile_shift) ? profile_shift\n  : teeth==0 ? 0\n  : let(\n        pressure_angle=atan(tan(pressure_angle)/cos(helical)),\n        min_teeth = default(min_teeth, 2 / sin(pressure_angle)^2)\n    )\n    !get_min && teeth > floor(min_teeth)? 0\n  : (1 - (teeth / min_teeth))/cos(helical);\n\n\n// Function: gear_shorten()\n// Usage:\n//    shorten = gear_shorten(teeth1, teeth2, [helical], [profile_shift1], [profile_shift2], [pressure_angle=]);\n// Synopsis: Returns the tip shortening parameter for profile shifted parallel axis gears.\n// Description:\n//    Compute the gear tip shortening factor for gears that have profile shifts.  This factor depends on both\n//    gears in a pair and when applied, will results in teeth that meet the specified clearance distance.\n//    Generally if you don't apply it the teeth clearance will be decreased due to the profile shifting.\n//    Because it operates pairwise, if a gear mates with more than one other gear, you may have to decide\n//    which shortening factor to use.  The shortening factor is independent of the size of the teeth.\n// Arguments:\n//   teeth1 = number of teeth on first gear\n//   teeth2 = number of teeth on second gear\n//   helical = The helical angle (from vertical) of the teeth on the gear.  Default: 0\n//   profile_shift1 = Profile shift factor x for the first gear.  Default: \"auto\"\n//   profile_shift2 = Profile shift factor x for the second gear.  Default: \"auto\"\n//   ---\n//   pressure_angle = normal pressure angle of gear teeth.  Default: 20\n// Example(2D,Med,VPT=[53.9088,1.83058,26.0319],VPR=[0,0,0],VPD=140): Big profile shift eliminates the clearance between the teeth\n//   teeth1=25;\n//   teeth2=19;\n//   mod=4;\n//   ps1 = 0.75;\n//   ps2 = 0.75;\n//   d = gear_dist(mod=mod, teeth1,teeth2,0,ps1,ps2);\n//   color(\"lightblue\")\n//     spur_gear2d(mod=mod,teeth=teeth1,profile_shift=ps1,gear_spin=-90);\n//   right(d)\n//     spur_gear2d(mod=mod,teeth=teeth2,profile_shift=ps2,gear_spin=-90);\n// Example(2D,Med,VPT=[53.9088,1.83058,26.0319],VPR=[0,0,0],VPD=140,NoAxes): Applying the correct shortening factor restores the clearance to its normal value.  \n//   teeth1=25;\n//   teeth2=19;\n//   mod=4;\n//   ps1 = 0.75;\n//   ps2 = 0.75;\n//   d = gear_dist(mod=mod, teeth1,teeth2,0,ps1,ps2);\n//   shorten=gear_shorten(teeth1,teeth2,0,ps1,ps2);\n//   color(\"lightblue\")\n//     spur_gear2d(mod=mod,teeth=teeth1,profile_shift=ps1,shorten=shorten,gear_spin=-90);\n//   right(d)\n//     spur_gear2d(mod=mod,teeth=teeth2,profile_shift=ps2,shorten=shorten,gear_spin=-90);\nfunction gear_shorten(teeth1,teeth2,helical=0,profile_shift1=\"auto\",profile_shift2=\"auto\",pressure_angle=20) =\n    teeth1==0 || teeth2==0 ? 0\n  : let(\n         profile_shift1 = auto_profile_shift(teeth1,pressure_angle,helical,profile_shift=profile_shift1),\n         profile_shift2 = auto_profile_shift(teeth2,pressure_angle,helical,profile_shift=profile_shift2),\n         ax = gear_dist(mod=1,teeth1,teeth2,helical,profile_shift1,profile_shift2,pressure_angle=pressure_angle),\n         y = ax - (teeth1+teeth2)/2/cos(helical)\n    )\n    profile_shift1+profile_shift2-y;\n\n\n// Function: gear_shorten_skew()\n// Usage:\n//    shorten = gear_shorten_skew(teeth1, teeth2, helical1, helical2, [profile_shift1], [profile_shift2], [pressure_angle=]);\n// Synopsis: Returns the tip shortening parameter for profile shifted skew axis helical gears.\n// Description:\n//    Compute the gear tip shortening factor for skew axis helical gears that have profile shifts.  This factor depends on both\n//    gears in a pair and when applied, will results in teeth that meet the specified clearance distance.\n//    Generally if you don't apply it the teeth clearance will be decreased due to the profile shifting.\n//    Because it operates pairwise, if a gear mates with more than one other gear, you may have to decide\n//    which shortening factor to use.  The shortening factor is independent of the size of the teeth.\n// Arguments:\n//   teeth1 = Total number of teeth in the first gear.  If given 0, we assume this is a rack or worm.\n//   teeth2 = Total number of teeth in the second gear.  If given 0, we assume this is a rack or worm.\n//   helical1 = The helical angle (from vertical) of the teeth on the first gear. \n//   helical1 = The helical angle (from vertical) of the teeth on the second gear.\n//   profile_shift1 = Profile shift factor x for the first gear.  Default: \"auto\"\n//   profile_shift2 = Profile shift factor x for the second gear.  Default: \"auto\"\n//   ---\n//   pressure_angle = The pressure angle of the gear.\nfunction gear_shorten_skew(teeth1,teeth2,helical1,helical2,profile_shift1=\"auto\",profile_shift2=\"auto\",pressure_angle=20) =\n    let(\n         profile_shift1 = auto_profile_shift(teeth1,pressure_angle,helical1,profile_shift=profile_shift1),\n         profile_shift2 = auto_profile_shift(teeth2,pressure_angle,helical2,profile_shift=profile_shift2),\n         ax = gear_dist(mod=1,teeth1,teeth2,helical,profile_shift1,profile_shift2,pressure_angle=pressure_angle),\n         y = ax - (teeth1+teeth2)/2/cos(helical)\n    )\n    profile_shift1+profile_shift2-y;\n\n\nmodule _show_gear_tooth_profile(\n    circ_pitch,\n    teeth,\n    pressure_angle=20,\n    profile_shift,\n    helical=0,\n    internal=false,\n    clearance,\n    backlash=0,\n    show_verts=false,\n    diam_pitch,\n    mod\n) {\n    mod = module_value(circ_pitch=circ_pitch, diam_pitch=diam_pitch, mod=mod);\n    profile_shift = default(profile_shift, auto_profile_shift(teeth, pressure_angle, helical));\n    or = outer_radius(mod=mod, teeth=teeth, clearance=clearance, helical=helical, profile_shift=profile_shift, internal=internal);\n    pr = pitch_radius(mod=mod, teeth=teeth, helical=helical);\n    rr = _root_radius(mod=mod, teeth=teeth, helical=helical, profile_shift=profile_shift, clearance=clearance, internal=internal);\n    br = _base_radius(mod=mod, teeth=teeth, helical=helical, pressure_angle=pressure_angle);\n    tang = 360/teeth;\n    rang = tang * 1.075;\n    tsize = (or-rr) / 20;\n    clear = (1-profile_shift)*mod;\n    tooth = _gear_tooth_profile(\n        mod=mod, teeth=teeth,\n        pressure_angle=pressure_angle,\n        clearance=clearance,\n        backlash=backlash,\n        helical=helical,\n        internal=internal,\n        profile_shift=profile_shift\n    );\n    $fn=360;\n    union() {\n        color(\"cyan\") { // Pitch circle\n            stroke(arc(r=pr,start=90-rang/2,angle=rang), width=0.05);\n            zrot(-tang/2*1.10) back(pr) text(\"pitch\", size=tsize, halign=\"left\", valign=\"center\");\n        }\n        color(\"lightgreen\") { // Outer and Root circles\n            stroke(arc(r=or,start=90-rang/2,angle=rang), width=0.05);\n            stroke(arc(r=rr,start=90-rang/2,angle=rang), width=0.05);\n            zrot(-tang/2*1.10) back(or) text(\"tip\", size=tsize, halign=\"left\", valign=\"center\");\n            zrot(-tang/2*1.10) back(rr) text(\"root\", size=tsize, halign=\"left\", valign=\"center\");\n        }\n        color(\"#fcf\") { // Base circle\n            stroke(arc(r=br,start=90-rang/2,angle=rang), width=0.05);\n            zrot(tang/2*1.10) back(br) text(\"base\", size=tsize, halign=\"right\", valign=\"center\");\n        }\n        color(\"#ddd\") { // Clearance area\n            if (internal) {\n                dashed_stroke(arc(r=pr+clear, start=90-rang/2, angle=rang), width=0.05);\n                back((pr+clear+or)/2) text(\"clearance\", size=tsize, halign=\"center\", valign=\"center\");\n            } else {\n                dashed_stroke(arc(r=pr-clear, start=90-rang/2, angle=rang), width=0.05);\n                back((pr-clear+rr)/2) text(\"clearance\", size=tsize, halign=\"center\", valign=\"center\");\n            }\n        }\n        color(\"#ddd\") { // Tooth width markers\n            stroke([polar_to_xy(min(rr,br)-mod/10,90-180/teeth),polar_to_xy(or+mod/10,90-180/teeth)], width=0.05, closed=true);\n            stroke([polar_to_xy(min(rr,br)-mod/10,90+180/teeth),polar_to_xy(or+mod/10,90+180/teeth)], width=0.05, closed=true);\n        }\n        zrot_copies([0]) { // Tooth profile overlay\n            stroke(tooth, width=0.1, dots=(show_verts?\"dot\":false), endcap_color1=\"green\", endcap_color2=\"red\");\n        }\n    }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-16", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: geometry.scad\n//   Perform calculations on lines, polygons, planes and circles, including\n//   normals, intersections of objects, distance between objects, and tangent lines.\n//   Throughout this library, lines can be treated as either unbounded lines, as rays with\n//   a single endpoint or as segments, bounded by endpoints at both ends.  \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Math\n// FileSummary: Geometrical calculations including intersections of lines, circles and planes, circle from 3 points\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Lines, Rays, and Segments\n\n// Function: is_point_on_line()\n// Synopsis: Determine if a point is on a line, ray or segment. \n// Topics: Geometry, Points, Segments\n// See Also: is_collinear(), is_point_on_line(), point_line_distance(), line_from_points()\n// Usage:\n//   pt = is_point_on_line(point, line, [bounded], [eps]);\n// Description:\n//   Determine if the point is on the line segment, ray or segment defined by the two between two points.\n//   Returns true if yes, and false if not.  If bounded is set to true it specifies a segment, with\n//   both lines bounded at the ends.  Set bounded to `[true,false]` to get a ray.  You can use\n//   the shorthands RAY and SEGMENT to set bounded.  \n// Arguments:\n//   point = The point to test.\n//   line = Array of two points defining the line, ray, or segment to test against.\n//   bounded = boolean or list of two booleans defining endpoint conditions for the line. If false treat the line as an unbounded line.  If true treat it as a segment.  If [true,false] treat as a ray, based at the first endpoint.  Default: false\n//   eps = Tolerance in geometric comparisons.  Default: `EPSILON` (1e-9)\nfunction is_point_on_line(point, line, bounded=false, eps=EPSILON) =\n    assert(is_finite(eps) && (eps>=0), \"The tolerance should be a non-negative value.\" )\n    assert(is_vector(point), \"Point must be a vector\")\n    assert(_valid_line(line, len(point),eps),\"Given line is not valid\")\n    _is_point_on_line(point, line, bounded,eps);\n\nfunction _is_point_on_line(point, line, bounded=false, eps=EPSILON) =\n    let( \n        v1 = (line[1]-line[0]),\n        v0 = (point-line[0]),\n        t  = v0*v1/(v1*v1),\n        bounded = force_list(bounded,2)\n    ) \n    abs(cross(v0,v1))<=eps*norm(v1) \n    && (!bounded[0] || t>=-eps) \n    && (!bounded[1] || t<1+eps) ;\n\n\n///Internal - distance from point `d` to the line passing through the origin with unit direction n\n///_dist2line works for any dimension\nfunction _dist2line(d,n) = norm(d-(d * n) * n);\n\n\n///Internal\nfunction _valid_line(line,dim,eps=EPSILON) =\n    is_matrix(line,2,dim)\n    && norm(line[1]-line[0])>eps*max(norm(line[1]),norm(line[0]));\n\n//Internal\nfunction _valid_plane(p, eps=EPSILON) = is_vector(p,4) && ! approx(norm(p),0,eps);\n\n\n/// Internal Function: _is_at_left()\n/// Usage:\n///   pt = point_left_of_line2d(point, line);\n/// Topics: Geometry, Points, Lines\n/// Description:\n///   Return true iff a 2d point is on or at left of the line defined by `line`.\n/// Arguments:\n///   pt = The 2d point to check position of.\n///   line  = Array of two 2d points forming the line segment to test against.\n///   eps = Tolerance in the geometrical tests.\nfunction _is_at_left(pt,line,eps=EPSILON) = _tri_class([pt,line[0],line[1]],eps) <= 0;\n\n\n/// Internal Function: _degenerate_tri()\n/// Usage:\n///   degen = _degenerate_tri(triangle);\n/// Topics: Geometry, Triangles\n/// Description:\n///   Return true for a specific kind of degeneracy: any two triangle vertices are equal\n/// Arguments:\n///   tri = A list of three 2d points\n///   eps = Tolerance in the geometrical tests.\nfunction _degenerate_tri(tri,eps) =\n    max(norm(tri[0]-tri[1]), norm(tri[1]-tri[2]), norm(tri[2]-tri[0])) < eps ;\n    \n\n/// Internal Function: _tri_class()\n/// Usage:\n///   class = _tri_class(triangle);\n/// Topics: Geometry, Triangles\n/// Description:\n///   Return  1 if the triangle `tri` is CW.\n///   Return  0 if the triangle `tri` has colinear vertices.\n///   Return -1 if the triangle `tri` is CCW.\n/// Arguments:\n///   tri = A list of the three 2d vertices of a triangle.\n///   eps = Tolerance in the geometrical tests.\nfunction _tri_class(tri, eps=EPSILON) =\n    let( crx = cross(tri[1]-tri[2],tri[0]-tri[2]) )\n    abs( crx ) <= eps*norm(tri[1]-tri[2])*norm(tri[0]-tri[2]) ? 0 : sign( crx );\n    \n    \n/// Internal Function: _pt_in_tri()\n/// Usage:\n///   class = _pt_in_tri(point, tri);\n/// Topics: Geometry, Points, Triangles\n/// Description:\n//   For CW triangles `tri` :\n///    return  1 if point is inside the triangle interior.\n///    return =0 if point is on the triangle border.\n///    return -1 if point is outside the triangle.\n/// Arguments:\n///   point = The point to check position of.\n///   tri  =  A list of the three 2d vertices of a triangle.\n///   eps = Tolerance in the geometrical tests.\nfunction _pt_in_tri(point, tri, eps=EPSILON) = \n    min(  _tri_class([tri[0],tri[1],point],eps), \n          _tri_class([tri[1],tri[2],point],eps), \n          _tri_class([tri[2],tri[0],point],eps) );\n        \n\n/// Internal Function: _point_left_of_line2d()\n/// Usage:\n///   pt = point_left_of_line2d(point, line);\n/// Topics: Geometry, Points, Lines\n/// Description:\n///   Return >0 if point is left of the line defined by `line`.\n///   Return =0 if point is on the line.\n///   Return <0 if point is right of the line.\n/// Arguments:\n///   point = The point to check position of.\n///   line  = Array of two points forming the line segment to test against.\nfunction _point_left_of_line2d(point, line, eps=EPSILON) =\n    assert( is_vector(point,2) && is_vector(line*point, 2), \"Improper input.\" )\n//    cross(line[0]-point, line[1]-line[0]);\n    _tri_class([point,line[1],line[0]],eps);\n    \n\n// Function: is_collinear()\n// Synopsis: Determine if points are collinear.\n// Topics: Geometry, Points, Collinearity\n// See Also: is_collinear(), is_point_on_line(), point_line_distance(), line_from_points()\n// Usage:\n//   bool = is_collinear(a, [b, c], [eps]);\n// Description:\n//   Returns true if the points `a`, `b` and `c` are co-linear or if the list of points `a` is collinear.\n// Arguments:\n//   a = First point or list of points.\n//   b = Second point or undef; it should be undef if `c` is undef\n//   c = Third point or undef.\n//   eps = Tolerance in geometric comparisons.  Default: `EPSILON` (1e-9)\nfunction is_collinear(a, b, c, eps=EPSILON) =\n    assert( is_path([a,b,c],dim=undef)\n            || ( is_undef(b) && is_undef(c) && is_path(a,dim=undef) ),\n            \"Input should be 3 points or a list of points with same dimension.\")\n    assert( is_finite(eps) && (eps>=0), \"The tolerance should be a non-negative value.\" )\n    let( points = is_def(c) ? [a,b,c]: a )\n    len(points)<3 ? true :\n    _noncollinear_triple(points,error=false,eps=eps) == [];\n\n\n// Function: point_line_distance()\n// Synopsis: Find shortest distance from point to a line, segment or ray.\n// Topics: Geometry, Points, Lines, Distance\n// See Also: is_collinear(), is_point_on_line(), point_line_distance(), line_from_points()\n// Usage:\n//   dist = point_line_distance(pt, line, [bounded]);\n// Description:\n//   Finds the shortest distance from the point `pt` to the specified line, segment or ray.\n//   The bounded parameter specifies the whether the endpoints give a ray or segment.\n//   By default assumes an unbounded line.  \n// Arguments:\n//   pt = A point to find the distance of from the line.\n//   line = A list of two points defining a line.\n//   bounded = a boolean or list of two booleans specifiying whether each end is bounded.  Default: false\n// Example:\n//   dist1 = point_line_distance([3,8], [[-10,0], [10,0]]);  // Returns: 8\n//   dist2 = point_line_distance([3,8], [[-10,0], [10,0]],SEGMENT);  // Returns: 8\n//   dist3 = point_line_distance([14,3], [[-10,0], [10,0]],SEGMENT);  // Returns: 5\nfunction point_line_distance(pt, line, bounded=false) =\n    assert(is_bool(bounded) || is_bool_list(bounded,2), \"\\\"bounded\\\" is invalid\")\n    assert( _valid_line(line) && is_vector(pt,len(line[0])),\n            \"Invalid line, invalid point or incompatible dimensions.\" )\n    bounded == LINE ? _dist2line(pt-line[0],unit(line[1]-line[0]))\n                    : norm(pt-line_closest_point(line,pt,bounded));\n\n                           \n// Function: segment_distance()\n// Synopsis: Find smallest distance between two line semgnets.\n// Topics: Geometry, Segments, Distance\n// See Also: convex_collision(), convex_distance()\n// Usage:\n//   dist = segment_distance(seg1, seg2, [eps]);\n// Description:\n//   Returns the smallest distance of the points on two given line segments.\n// Arguments:\n//   seg1 = The list of two points representing the first line segment to check the distance of.\n//   seg2 = The list of two points representing the second line segment to check the distance of.\n//   eps = tolerance for point comparisons\n// Example:\n//   dist = segment_distance([[-14,3], [-15,9]], [[-10,0], [10,0]]);  // Returns: 5\n//   dist2 = segment_distance([[-5,5], [5,-5]], [[-10,3], [10,-3]]);  // Returns: 0\nfunction segment_distance(seg1, seg2,eps=EPSILON) =\n    assert( is_matrix(concat(seg1,seg2),4), \"Inputs should be two valid segments.\" )\n    convex_distance(seg1,seg2,eps);\n\n\n// Function: line_normal()\n// Synopsis: Return normal vector to given line. \n// Topics: Geometry, Lines\n// See Also: line_intersection(), line_from_points()\n// Usage:\n//   vec = line_normal([P1,P2])\n//   vec = line_normal(p1,p2)\n// Description:\n//   Returns the 2D normal vector to the given 2D line. This is otherwise known as the perpendicular vector counter-clockwise to the given ray.\n// Arguments:\n//   p1 = First point on 2D line.\n//   p2 = Second point on 2D line.\n// Example(2D):\n//   p1 = [10,10];\n//   p2 = [50,30];\n//   n = line_normal(p1,p2);\n//   stroke([p1,p2], endcap2=\"arrow2\");\n//   color(\"green\") stroke([p1,p1+10*n], endcap2=\"arrow2\");\n//   color(\"blue\") move_copies([p1,p2]) circle(d=2, $fn=12);\nfunction line_normal(p1,p2) =\n    is_undef(p2)\n      ? assert( len(p1)==2 && !is_undef(p1[1]) , \"Invalid input.\" )\n        line_normal(p1[0],p1[1])\n      : assert( _valid_line([p1,p2],dim=2), \"Invalid line.\" )\n        unit([p1.y-p2.y,p2.x-p1.x]);\n\n\n// 2D Line intersection from two segments.\n// This function returns [p,t,u] where p is the intersection point of\n// the lines defined by the two segments, t is the proportional distance\n// of the intersection point along s1, and u is the proportional distance\n// of the intersection point along s2.  The proportional values run over\n// the range of 0 to 1 for each segment, so if it is in this range, then\n// the intersection lies on the segment.  Otherwise it lies somewhere on\n// the extension of the segment.  If lines are parallel or coincident then\n// it returns undef.\n\nfunction _general_line_intersection(s1,s2,eps=EPSILON) =\n    let(\n        denominator = cross(s1[0]-s1[1],s2[0]-s2[1])\n    )\n    approx(denominator,0,eps=eps) ? undef :\n    let(\n        t = cross(s1[0]-s2[0],s2[0]-s2[1]) / denominator,\n        u = cross(s1[0]-s2[0],s1[0]-s1[1]) / denominator\n    )\n    [s1[0]+t*(s1[1]-s1[0]), t, u];\n                  \n\n// Function: line_intersection()\n// Synopsis: Compute intersection of two lines, segments or rays.\n// Topics: Geometry, Lines\n// See Also: line_normal(), line_from_points()\n// Usage:\n//    pt = line_intersection(line1, line2, [bounded1], [bounded2], [bounded=], [eps=]);\n// Description:\n//    Returns the intersection point of any two 2D lines, segments or rays.  Returns undef\n//    if they do not intersect.  You specify a line by giving two distinct points on the\n//    line.  You specify rays or segments by giving a pair of points and indicating\n//    bounded[0]=true to bound the line at the first point, creating rays based at l1[0] and l2[0],\n//    or bounded[1]=true to bound the line at the second point, creating the reverse rays bounded\n//    at l1[1] and l2[1].  If bounded=[true, true] then you have segments defined by their two\n//    endpoints.  By using bounded1 and bounded2 you can mix segments, rays, and lines as needed.\n//    You can set the bounds parameters to true as a shorthand for [true,true] to sepcify segments.\n// Arguments:\n//    line1 = List of two points in 2D defining the first line, segment or ray\n//    line2 = List of two points in 2D defining the second line, segment or ray\n//    bounded1 = boolean or list of two booleans defining which ends are bounded for line1.  Default: [false,false]\n//    bounded2 = boolean or list of two booleans defining which ends are bounded for line2.  Default: [false,false]\n//    ---\n//    bounded = boolean or list of two booleans defining which ends are bounded for both lines.  The bounded1 and bounded2 parameters override this if both are given.\n//    eps = tolerance for geometric comparisons.  Default: `EPSILON` (1e-9)\n// Example(2D):  The segments do not intersect but the lines do in this example. \n//    line1 = 10*[[9, 4], [5, 7]];\n//    line2 = 10*[[2, 3], [6, 5]];\n//    stroke(line1, endcaps=\"arrow2\");\n//    stroke(line2, endcaps=\"arrow2\");\n//    isect = line_intersection(line1, line2);\n//    color(\"red\") translate(isect) circle(r=1,$fn=12);\n// Example(2D): Specifying a ray and segment using the shorthand variables.\n//    line1 = 10*[[0, 2], [4, 7]];\n//    line2 = 10*[[10, 4], [3, 4]];\n//    stroke(line1);\n//    stroke(line2, endcap2=\"arrow2\");\n//    isect = line_intersection(line1, line2, SEGMENT, RAY);\n//    color(\"red\") translate(isect) circle(r=1,$fn=12);\n// Example(2D): Here we use the same example as above, but specify two segments using the bounded argument.\n//    line1 = 10*[[0, 2], [4, 7]];\n//    line2 = 10*[[10, 4], [3, 4]];\n//    stroke(line1);\n//    stroke(line2);\n//    isect = line_intersection(line1, line2, bounded=true);  // Returns undef\nfunction line_intersection(line1, line2, bounded1, bounded2, bounded, eps=EPSILON) =\n    assert( is_finite(eps) && (eps>=0), \"The tolerance should be a non-negative value.\" )\n    assert( _valid_line(line1,dim=2,eps=eps), \"First line invalid\")\n    assert( _valid_line(line2,dim=2,eps=eps), \"Second line invalid\")\n    assert( is_undef(bounded) || is_bool(bounded) || is_bool_list(bounded,2), \"Invalid value for \\\"bounded\\\"\")\n    assert( is_undef(bounded1) || is_bool(bounded1) || is_bool_list(bounded1,2), \"Invalid value for \\\"bounded1\\\"\")\n    assert( is_undef(bounded2) || is_bool(bounded2) || is_bool_list(bounded2,2), \"Invalid value for \\\"bounded2\\\"\")\n    let(isect = _general_line_intersection(line1,line2,eps=eps))\n    is_undef(isect) ? undef :\n    let(\n        bounded1 = force_list(first_defined([bounded1,bounded,false]),2),\n        bounded2 = force_list(first_defined([bounded2,bounded,false]),2),\n        good =  (!bounded1[0] || isect[1]>=0-eps)\n             && (!bounded1[1] || isect[1]<=1+eps)\n             && (!bounded2[0] || isect[2]>=0-eps)\n             && (!bounded2[1] || isect[2]<=1+eps)\n    )\n    good ? isect[0] : undef;\n    \n\n// Function: line_closest_point()\n// Synopsis: Find point on given line, segment or ray that is closest to a given point. \n// Topics: Geometry, Lines, Distance\n// See Also: line_normal(), point_line_distance()\n// Usage:\n//   pt = line_closest_point(line, pt, [bounded]);\n// Description:\n//   Returns the point on the given line, segment or ray that is closest to the given point `pt`.\n//   The inputs `line` and `pt` args should be of the same dimension.  The parameter bounded indicates\n//   whether the points of `line` should be treated as endpoints. \n// Arguments:\n//   line = A list of two points that are on the unbounded line.\n//   pt = The point to find the closest point on the line to.\n//   bounded = boolean or list of two booleans indicating that the line is bounded at that end.  Default: [false,false]\n// Example(2D):\n//   line = [[-30,0],[30,30]];\n//   pt = [-32,-10];\n//   p2 = line_closest_point(line,pt);\n//   stroke(line, endcaps=\"arrow2\");\n//   color(\"blue\") translate(pt) circle(r=1,$fn=12);\n//   color(\"red\") translate(p2) circle(r=1,$fn=12);\n// Example(2D):  If the line is bounded on the left you get the endpoint instead\n//   line = [[-30,0],[30,30]];\n//   pt = [-32,-10];\n//   p2 = line_closest_point(line,pt,bounded=[true,false]);\n//   stroke(line, endcap2=\"arrow2\");\n//   color(\"blue\") translate(pt) circle(r=1,$fn=12);\n//   color(\"red\") translate(p2) circle(r=1,$fn=12);\n// Example(2D):  In this case it doesn't matter how bounded is set.  Using SEGMENT is the most restrictive option. \n//   line = [[-30,0],[30,30]];\n//   pt = [-5,0];\n//   p2 = line_closest_point(line,pt,SEGMENT);\n//   stroke(line);\n//   color(\"blue\") translate(pt) circle(r=1,$fn=12);\n//   color(\"red\") translate(p2) circle(r=1,$fn=12);\n// Example(2D):  The result here is the same for a line or a ray. \n//   line = [[-30,0],[30,30]];\n//   pt = [40,25];\n//   p2 = line_closest_point(line,pt,RAY);\n//   stroke(line, endcap2=\"arrow2\");\n//   color(\"blue\") translate(pt) circle(r=1,$fn=12);\n//   color(\"red\") translate(p2) circle(r=1,$fn=12);\n// Example(2D):  But with a segment we get a different result\n//   line = [[-30,0],[30,30]];\n//   pt = [40,25];\n//   p2 = line_closest_point(line,pt,SEGMENT);\n//   stroke(line);\n//   color(\"blue\") translate(pt) circle(r=1,$fn=12);\n//   color(\"red\") translate(p2) circle(r=1,$fn=12);\n// Example(2D): The shorthand RAY uses the first point as the base of the ray.  But you can specify a reversed ray directly, and in this case the result is the same as the result above for the segment.\n//   line = [[-30,0],[30,30]];\n//   pt = [40,25];\n//   p2 = line_closest_point(line,pt,[false,true]);\n//   stroke(line,endcap1=\"arrow2\");\n//   color(\"blue\") translate(pt) circle(r=1,$fn=12);\n//   color(\"red\") translate(p2) circle(r=1,$fn=12);\n// Example(FlatSpin,VPD=200,VPT=[0,0,15]): A 3D example\n//   line = [[-30,-15,0],[30,15,30]];\n//   pt = [5,5,5];\n//   p2 = line_closest_point(line,pt);\n//   stroke(line, endcaps=\"arrow2\");\n//   color(\"blue\") translate(pt) sphere(r=1,$fn=12);\n//   color(\"red\") translate(p2) sphere(r=1,$fn=12);\nfunction line_closest_point(line, pt, bounded=false) =\n    assert(_valid_line(line), \"Invalid line\")\n    assert(is_vector(pt, len(line[0])), \"Invalid point or incompatible dimensions.\")\n    assert(is_bool(bounded) || is_bool_list(bounded,2), \"Invalid value for \\\"bounded\\\"\")\n    let(\n        bounded = force_list(bounded,2)\n    )\n    bounded==[false,false] ?\n          let( n = unit( line[0]- line[1]) )\n          line[1] + ((pt- line[1]) * n) * n\n    : bounded == [true,true] ?\n          pt + _closest_s1([line[0]-pt, line[1]-pt])[0]\n    : \n          let(\n               ray = bounded==[true,false] ? line : reverse(line),\n               seglen = norm(ray[1]-ray[0]),\n               segvec = (ray[1]-ray[0])/seglen,\n               projection = (pt-ray[0]) * segvec\n          )\n          projection<=0 ? ray[0] :\n                          ray[0] + projection*segvec;\n            \n\n// Function: line_from_points()\n// Synopsis: Given a list of collinear points, return the line they define. \n// Topics: Geometry, Lines, Points\n// Usage:\n//   line = line_from_points(points, [fast], [eps]);\n// Description:\n//   Given a list of 2 or more collinear points, returns two points defining a line containing them.\n//   If `fast` is false and the points are coincident or non-collinear, then `undef` is returned.\n//   if `fast` is true, then the collinearity test is skipped and a line passing through 2 distinct arbitrary points is returned.\n// Arguments:\n//   points = The list of points to find the line through.\n//   fast = If true, don't verify that all points are collinear.  Default: false\n//   eps = How much variance is allowed in testing each point against the line.  Default: `EPSILON` (1e-9)\nfunction line_from_points(points, fast=false, eps=EPSILON) =\n    assert( is_path(points), \"Invalid point list.\" )\n    assert( is_finite(eps) && (eps>=0), \"The tolerance should be a non-negative value.\" )\n    let( pb = furthest_point(points[0],points) )\n    norm(points[pb]-points[0])<eps*max(norm(points[pb]),norm(points[0])) ? undef :\n    fast || is_collinear(points)\n      ? [points[pb], points[0]]\n      : undef;\n\n\n\n// Section: Planes\n\n\n// Function: is_coplanar()\n// Synopsis: Check if 3d points are coplanar and not collinear.  \n// Topics: Geometry, Coplanarity\n// See Also: plane3pt(), plane3pt_indexed(), plane_from_normal(), plane_from_points(), plane_from_polygon()\n// Usage:\n//   bool = is_coplanar(points,[eps]);\n// Description:\n//   Returns true if the given 3D points are non-collinear and are on a plane.\n// Arguments:\n//   points = The points to test.\n//   eps = Tolerance in geometric comparisons.  Default: `EPSILON` (1e-9)\nfunction is_coplanar(points, eps=EPSILON) =\n    assert( is_path(points,dim=3) , \"Input should be a list of 3D points.\" )\n    assert( is_finite(eps) && eps>=0, \"The tolerance should be a non-negative value.\" )\n    len(points)<=2 ? false\n      : let( ip = _noncollinear_triple(points,error=false,eps=eps) )\n        ip == [] ? false :\n        let( plane  = plane3pt(points[ip[0]],points[ip[1]],points[ip[2]]) )\n        _pointlist_greatest_distance(points,plane) < eps;\n\n\n\n// Function: plane3pt()\n// Synopsis: Return a plane from 3 points. \n// Topics: Geometry, Planes\n// See Also: plane3pt(), plane3pt_indexed(), plane_from_normal(), plane_from_points(), plane_from_polygon()\n// Usage:\n//   plane = plane3pt(p1, p2, p3);\n//   plane = plane3pt([p1, p2, p3]);\n// Description:\n//   Generates the normalized cartesian equation of a plane from three 3d points.\n//   Returns [A,B,C,D] where Ax + By + Cz = D is the equation of a plane.\n//   Returns undef, if the points are collinear.\n// Arguments:\n//   p1 = The first point on the plane.\n//   p2 = The second point on the plane.\n//   p3 = The third point on the plane.\nfunction plane3pt(p1, p2, p3) =\n    is_undef(p2) && is_undef(p3) && is_path(p1,dim=3) ? plane3pt(p1[0],p1[1],p1[2])\n  : assert( is_path([p1,p2,p3],dim=3) && len(p1)==3,\n            \"Invalid points or incompatible dimensions.\" )\n    let(\n        crx = cross(p3-p1, p2-p1),\n        nrm = norm(crx)\n    ) approx(nrm,0) ? undef :\n    concat(crx, crx*p1)/nrm;\n\n\n// Function: plane3pt_indexed()\n// Synopsis: Given list of 3d points and 3 indices, return the plane they define.  \n// Topics: Geometry, Planes\n// See Also: plane3pt(), plane3pt_indexed(), plane_from_normal(), plane_from_points(), plane_from_polygon()\n// Usage:\n//   plane = plane3pt_indexed(points, i1, i2, i3);\n// Description:\n//   Given a list of 3d points, and the indices of three of those points,\n//   generates the normalized cartesian equation of a plane that those points all\n//   lie on. If the points are not collinear, returns [A,B,C,D] where Ax+By+Cz=D is the equation of a plane.\n//   If they are collinear, returns [].\n// Arguments:\n//   points = A list of points.\n//   i1 = The index into `points` of the first point on the plane.\n//   i2 = The index into `points` of the second point on the plane.\n//   i3 = The index into `points` of the third point on the plane.\nfunction plane3pt_indexed(points, i1, i2, i3) =\n    is_undef(i3) && is_undef(i2) && is_vector(i1) ? plane3pt_indexed(points, i1[0], i1[1], i1[2])\n  :\n    assert( is_vector([i1,i2,i3]) && min(i1,i2,i3)>=0 && is_list(points) && max(i1,i2,i3)<len(points),\n            \"Invalid or out of range indices.\" )\n    assert( is_path([points[i1], points[i2], points[i3]],dim=3),\n            \"Improper points or improper dimensions.\" )\n    let(\n        p1 = points[i1],\n        p2 = points[i2],\n        p3 = points[i3]\n    ) plane3pt(p1,p2,p3);\n\n\n// Function: plane_from_normal()\n// Synopsis: Return plane defined by normal vector and a point. \n// Topics: Geometry, Planes\n// See Also: plane3pt(), plane3pt_indexed(), plane_from_normal(), plane_from_points(), plane_from_polygon()\n// Usage:\n//   plane = plane_from_normal(normal, [pt])\n// Description:\n//   Returns a plane defined by a normal vector and a point.  If you omit `pt` you will get a plane\n//   passing through the origin.  \n// Arguments:\n//   normal = Normal vector to the plane to find.\n//   pt = Point 3D on the plane to find.\n// Example:\n//   plane_from_normal([0,0,1], [2,2,2]);  // Returns the xy plane passing through the point (2,2,2)\nfunction plane_from_normal(normal, pt=[0,0,0]) =\n    assert( is_matrix([normal,pt],2,3) && !approx(norm(normal),0),\n            \"Inputs `normal` and `pt` should be 3d vectors/points and `normal` cannot be zero.\" )\n    concat(normal, normal*pt) / norm(normal);\n\n\n// Eigenvalues for a 3x3 symmetrical matrix in decreasing order\n// Based on: https://en.wikipedia.org/wiki/Eigenvalue_algorithm\nfunction _eigenvals_symm_3(M) =\n  let( p1 = pow(M[0][1],2) + pow(M[0][2],2) + pow(M[1][2],2) )\n  (p1<EPSILON)\n  ? -sort(-[ M[0][0], M[1][1], M[2][2] ]) //  diagonal matrix: eigenvals in decreasing order\n  : let(  q  = (M[0][0]+M[1][1]+M[2][2])/3,\n          B  = (M - q*ident(3)),\n          dB = [B[0][0], B[1][1], B[2][2]],\n          p2 = dB*dB + 2*p1,\n          p  = sqrt(p2/6),\n          r  = det3(B/p)/2,\n          ph = acos(constrain(r,-1,1))/3,\n          e1 = q + 2*p*cos(ph),\n          e3 = q + 2*p*cos(ph+120),\n          e2 = 3*q - e1 - e3 )\n    [ e1, e2, e3 ];\n\n\n// the i-th normalized eigenvector of a 3x3 symmetrical matrix M from its eigenvalues\n// using Cayley\u2013Hamilton theorem according to:\n// https://en.wikipedia.org/wiki/Eigenvalue_algorithm\nfunction _eigenvec_symm_3(M,evals,i=0) =\n    let(\n        I = ident(3),\n        A = (M - evals[(i+1)%3]*I) * (M - evals[(i+2)%3]*I) ,\n        k = max_index( [for(i=[0:2]) norm(A[i]) ])\n    )\n    norm(A[k])<EPSILON ? I[k] : A[k]/norm(A[k]);\n\n\n// finds the eigenvector corresponding to the smallest eigenvalue of the covariance matrix of a pointlist\n// returns the mean of the points, the eigenvector and the greatest eigenvalue\nfunction _covariance_evec_eval(points) =\n    let(  pm    = sum(points)/len(points), // mean point\n          Y     = [ for(i=[0:len(points)-1]) points[i] - pm ],\n          M     = transpose(Y)*Y ,     // covariance matrix\n          evals = _eigenvals_symm_3(M), // eigenvalues in decreasing order\n          evec  = _eigenvec_symm_3(M,evals,i=2) )\n    [pm, evec, evals[0] ];\n    \n\n// Function: plane_from_points()\n// Synopsis: Return plane defined by a set of coplanar 3d points, with arbitrary normal direction.\n// Topics: Geometry, Planes, Points\n// See Also: plane3pt(), plane3pt_indexed(), plane_from_normal(), plane_from_points(), plane_from_polygon()\n// Usage:\n//   plane = plane_from_points(points, [fast], [eps]);\n// Description:\n//   Given a list of 3 or more coplanar 3D points, returns the coefficients of the normalized cartesian equation of a plane,\n//   that is [A,B,C,D] where Ax+By+Cz=D is the equation of the plane and norm([A,B,C])=1.\n//   If `fast` is false and the points in the list are collinear or not coplanar, then `undef` is returned.\n//   If `fast` is true, the polygon coplanarity check is skipped and a best fitting plane is returned.\n//   The direction of the plane's normal is arbitrary and is not determined by the point order, unlike {{plane_from_polygon()}}.\n//   This function is faster than {{plane_from_polygon()}}.  \n// Arguments:\n//   points = The list of points to find the plane of.\n//   fast = If true, don't verify the point coplanarity.  Default: false\n//   eps = Tolerance in geometric comparisons.  Default: `EPSILON` (1e-9)\n// Example(3D):\n//   points = rot(45, v=[-0.3,1,0], p=path3d(random_points(25,2,scale=55,seed=47), 70));\n//   plane = plane_from_points(points);\n//   #move_copies(points)sphere(d=3);\n//   cp = mean(points);\n//   move(cp) rot(from=UP,to=plane_normal(plane)) anchor_arrow(50);\nfunction plane_from_points(points, fast=false, eps=EPSILON) =\n    assert( is_path(points,dim=3), \"Improper 3d point list.\" )\n    assert( is_finite(eps) && (eps>=0), \"The tolerance should be a non-negative value.\" )\n    len(points) == 3\n      ? plane3pt(points[0],points[1],points[2]) \n      : let(\n            covmix = _covariance_evec_eval(points),\n            pm     = covmix[0],\n            evec   = covmix[1],\n            eval0  = covmix[2],\n            plane  = [ each evec, pm*evec]\n        )\n        !fast && _pointlist_greatest_distance(points,plane)>eps*eval0 ? undef :\n        plane ;\n\n\n// Function: plane_from_polygon()\n// Synopsis: Given a 3d planar polygon, returns directed plane.  \n// Topics: Geometry, Planes, Polygons\n// See Also: plane3pt(), plane3pt_indexed(), plane_from_normal(), plane_from_points(), plane_from_polygon()\n// Usage:\n//   plane = plane_from_polygon(points, [fast], [eps]);\n// Description:\n//   Given a 3D planar polygon, returns the normalized cartesian equation of its plane. \n//   Returns [A,B,C,D] where Ax+By+Cz=D is the equation of the plane where norm([A,B,C])=1.\n//   If not all the points in the polygon are coplanar, then [] is returned.\n//   If `fast` is false and the points in the list are collinear or not coplanar, then `undef` is returned.\n//   if `fast` is true, then the coplanarity test is skipped and a plane passing through 3 non-collinear arbitrary points is returned.\n//   The normal direction is determined by the order of the points and the right hand rule.  This is slower than {{plane_from_points()}},\n//   which returns an arbitrary normal.  \n// Arguments:\n//   poly = The planar 3D polygon to find the plane of.\n//   fast = If true, doesn't verify that all points in the polygon are coplanar.  Default: false\n//   eps = Tolerance in geometric comparisons.  Default: `EPSILON` (1e-9)\n// Example(3D):\n//   xyzpath = rot(45, v=[0,1,0], p=path3d(star(n=5,step=2,d=100), 70));\n//   plane = plane_from_polygon(xyzpath);\n//   #stroke(xyzpath,closed=true,width=3);\n//   cp = centroid(xyzpath);\n//   move(cp) rot(from=UP,to=plane_normal(plane)) anchor_arrow(45);\nfunction plane_from_polygon(poly, fast=false, eps=EPSILON) =\n    assert( is_path(poly,dim=3), \"Invalid polygon.\" )\n    assert( is_finite(eps) && (eps>=0), \"The tolerance should be a non-negative value.\" )\n    let(\n        poly_normal = polygon_normal(poly)\n    )\n    is_undef(poly_normal) ? undef :\n    let(\n        plane = plane_from_normal(poly_normal, poly[0])\n    )\n    fast? plane: are_points_on_plane(poly, plane, eps=eps)? plane: undef;\n\n\n// Function: plane_normal()\n// Synopsis: Returns the normal vector to a plane. \n// Topics: Geometry, Planes\n// See Also: plane3pt(), plane3pt_indexed(), plane_from_normal(), plane_from_points(), plane_from_polygon(), plane_normal(), plane_offset()\n// Usage:\n//   vec = plane_normal(plane);\n// Description:\n//   Returns the unit length normal vector for the given plane.\n// Arguments:\n//   plane = The `[A,B,C,D]` plane definition where `Ax+By+Cz=D` is the formula of the plane.\nfunction plane_normal(plane) =\n    assert( _valid_plane(plane), \"Invalid input plane.\" )\n    unit([plane.x, plane.y, plane.z]);\n\n\n// Function: plane_offset()\n// Synopsis: Returns the signed offset of the plane from the origin.  \n// Topics: Geometry, Planes\n// See Also: plane3pt(), plane3pt_indexed(), plane_from_normal(), plane_from_points(), plane_from_polygon(), plane_normal(), plane_offset()\n// Usage:\n//   d = plane_offset(plane);\n// Description:\n//   Returns coeficient D of the normalized plane equation `Ax+By+Cz=D`, or the scalar offset of the plane from the origin.\n//   This value may be negative.\n//   The absolute value of this coefficient is the distance of the plane from the origin.\n// Arguments:\n//   plane = The `[A,B,C,D]` plane definition where `Ax+By+Cz=D` is the formula of the plane.\nfunction plane_offset(plane) =\n    assert( _valid_plane(plane), \"Invalid input plane.\" )\n    plane[3]/norm([plane.x, plane.y, plane.z]);\n\n\n\n// Returns [POINT, U] if line intersects plane at one point, where U is zero at line[0] and 1 at line[1]\n// Returns [LINE, undef] if the line is on the plane.\n// Returns undef if line is parallel to, but not on the given plane.\nfunction _general_plane_line_intersection(plane, line, eps=EPSILON) =\n    let(\n        a = plane*[each line[0],-1],         //  evaluation of the plane expression at line[0]\n        b = plane*[each(line[1]-line[0]),0]  // difference between the plane expression evaluation at line[1] and at line[0]\n    )\n    approx(b,0,eps)                          // is  (line[1]-line[0]) \"parallel\" to the plane ?\n      ? approx(a,0,eps)                      // is line[0] on the plane ?\n        ? [line,undef]                       // line is on the plane\n        : undef                              // line is parallel but not on the plane\n      : [ line[0]-a/b*(line[1]-line[0]), -a/b ];\n\n\n/// Internal Function: normalize_plane()\n/// Usage:\n///   nplane = normalize_plane(plane);\n/// Topics: Geometry, Planes\n/// Description:\n///   Returns a new representation [A,B,C,D] of `plane` where norm([A,B,C]) is equal to one.\nfunction _normalize_plane(plane) =\n    assert( _valid_plane(plane), str(\"Invalid plane. \",plane ) )\n    plane/norm(point3d(plane));\n\n\n// Function: plane_line_intersection()\n// Synopsis: Returns the intersection of a plane and 3d line, segment or ray.  \n// Topics: Geometry, Planes, Lines, Intersection\n// See Also: plane3pt(), plane_from_normal(), plane_from_points(), plane_from_polygon(), line_intersection()\n// Usage:\n//   pt = plane_line_intersection(plane, line, [bounded], [eps]);\n// Description:\n//   Takes a line, and a plane [A,B,C,D] where the equation of that plane is `Ax+By+Cz=D`.\n//   If `line` intersects `plane` at one point, then that intersection point is returned.\n//   If `line` lies on `plane`, then the original given `line` is returned.\n//   If `line` is parallel to, but not on `plane`, then undef is returned.\n// Arguments:\n//   plane = The [A,B,C,D] values for the equation of the plane.\n//   line = A list of two distinct 3D points that are on the line.\n//   bounded = If false, the line is considered unbounded.  If true, it is treated as a bounded line segment.  If given as `[true, false]` or `[false, true]`, the boundedness of the points are specified individually, allowing the line to be treated as a half-bounded ray.  Default: false (unbounded)\n//   eps = Tolerance in geometric comparisons.  Default: `EPSILON` (1e-9)\nfunction plane_line_intersection(plane, line, bounded=false, eps=EPSILON) =\n    assert( is_finite(eps) && eps>=0, \"The tolerance should be a positive number.\" )\n    assert(_valid_plane(plane,eps=eps) && _valid_line(line,dim=3,eps=eps), \"Invalid plane and/or 3d line.\")\n    assert(is_bool(bounded) || is_bool_list(bounded,2), \"Invalid bound condition.\")\n    let(\n        bounded = is_list(bounded)? bounded : [bounded, bounded],\n        res = _general_plane_line_intersection(plane, line, eps=eps)\n    ) is_undef(res) ? undef :\n    is_undef(res[1]) ? res[0] :\n    bounded[0] && res[1]<0 ? undef :\n    bounded[1] && res[1]>1 ? undef :\n    res[0];\n\n\n\n// Function: plane_intersection()\n// Synopsis: Returns the intersection of two or three planes.  \n// Topics: Geometry, Planes, Intersection\n// See Also: plane3pt(), plane_from_normal(), plane_from_points(), plane_from_polygon(), line_intersection()\n// Usage:\n//   line = plane_intersection(plane1, plane2)\n//   pt = plane_intersection(plane1, plane2, plane3)\n// Description:\n//   Compute the point which is the intersection of the three planes, or the line intersection of two planes.\n//   If you give three planes the intersection is returned as a point.  If you give two planes the intersection\n//   is returned as a list of two points on the line of intersection.  If any two input planes are parallel\n//   or coincident then returns undef.\n// Arguments:\n//   plane1 = The [A,B,C,D] coefficients for the first plane equation `Ax+By+Cz=D`.\n//   plane2 = The [A,B,C,D] coefficients for the second plane equation `Ax+By+Cz=D`.\n//   plane3 = The [A,B,C,D] coefficients for the third plane equation `Ax+By+Cz=D`.\nfunction plane_intersection(plane1,plane2,plane3) =\n    assert( _valid_plane(plane1) && _valid_plane(plane2) && (is_undef(plane3) ||_valid_plane(plane3)),\n                \"The input must be 2 or 3 planes.\" )\n    is_def(plane3)\n      ? let(\n            matrix = [for(p=[plane1,plane2,plane3]) point3d(p)],\n            rhs = [for(p=[plane1,plane2,plane3]) p[3]]\n        )\n        linear_solve(matrix,rhs)\n      : let( normal = cross(plane_normal(plane1), plane_normal(plane2)) )\n        approx(norm(normal),0) ? undef :\n        let(\n            matrix = [for(p=[plane1,plane2]) point3d(p)],\n            rhs = [plane1[3], plane2[3]],\n            point = linear_solve(matrix,rhs)\n        )\n        point==[]? undef:\n        [point, point+normal];\n\n\n\n// Function: plane_line_angle()\n// Synopsis: Returns the angle between a plane and a 3d line. \n// Topics: Geometry, Planes, Lines, Angle\n// See Also: plane3pt(), plane_from_normal(), plane_from_points(), plane_from_polygon(), plane_intersection(), line_intersection(), vector_angle()\n// Usage:\n//   angle = plane_line_angle(plane,line);\n// Description:\n//   Compute the angle between a plane [A, B, C, D] and a 3d line, specified as a pair of 3d points [p1,p2].\n//   The resulting angle is signed, with the sign positive if the vector p2-p1 lies above the plane, on\n//   the same side of the plane as the plane's normal vector.\nfunction plane_line_angle(plane, line) =\n    assert( _valid_plane(plane), \"Invalid plane.\" )\n    assert( _valid_line(line,dim=3), \"Invalid 3d line.\" )\n    let(\n        linedir   = unit(line[1]-line[0]),\n        normal    = plane_normal(plane),\n        sin_angle = linedir*normal,\n        cos_angle = norm(cross(linedir,normal))\n    ) atan2(sin_angle,cos_angle);\n\n\n\n// Function: plane_closest_point()\n// Synopsis: Returns the orthogonal projection of points onto a plane. \n// Topics: Geometry, Planes, Projection\n// See Also: plane3pt(), line_closest_point(), point_plane_distance()\n// Usage:\n//   pts = plane_closest_point(plane, points);\n// Description:\n//   Given a plane definition `[A,B,C,D]`, where `Ax+By+Cz=D`, and a list of 2d or\n//   3d points, return the closest 3D orthogonal projection of the points on the plane.\n//   In other words, for every point given, returns the closest point to it on the plane.\n//   If points is a single point then returns a single point result.  \n// Arguments:\n//   plane = The `[A,B,C,D]` plane definition where `Ax+By+Cz=D` is the formula of the plane.\n//   points = List of points to project\n// Example(FlatSpin,VPD=500,VPT=[2,20,10]):\n//   points = move([10,20,30], p=yrot(25, p=path3d(circle(d=100, $fn=36))));\n//   plane = plane_from_normal([1,0,1]);\n//   proj = plane_closest_point(plane,points);\n//   color(\"red\") move_copies(points) sphere(d=4,$fn=12);\n//   color(\"blue\") move_copies(proj) sphere(d=4,$fn=12);\n//   move(centroid(proj)) {\n//       rot(from=UP,to=plane_normal(plane)) {\n//           anchor_arrow(50);\n//           %cube([120,150,0.1],center=true);\n//       }\n//   }\nfunction plane_closest_point(plane, points) =\n    is_vector(points,3) ? plane_closest_point(plane,[points])[0] :\n    assert( _valid_plane(plane), \"Invalid plane.\" )\n    assert( is_matrix(points,undef,3), \"Must supply 3D points.\")\n    let(\n        plane = _normalize_plane(plane),\n        n = point3d(plane)\n    )\n    [for(pi=points) pi - (pi*n - plane[3])*n];\n\n\n// Function: point_plane_distance()\n// Synopsis: Determine distance between a point and plane. \n// Topics: Geometry, Planes, Distance\n// See Also: plane3pt(), line_closest_point(), plane_closest_point()\n// Usage:\n//   dist = point_plane_distance(plane, point)\n// Description:\n//   Given a plane as [A,B,C,D] where the cartesian equation for that plane\n//   is Ax+By+Cz=D, determines how far from that plane the given point is.\n//   The returned distance will be positive if the point is above the\n//   plane, meaning on the side where the plane normal points.  \n//   If the point is below the plane, then the distance returned\n//   will be negative.  The normal of the plane is [A,B,C].\n// Arguments:\n//   plane = The `[A,B,C,D]` plane definition where `Ax+By+Cz=D` is the formula of the plane.\n//   point = The distance evaluation point.\nfunction point_plane_distance(plane, point) =\n    assert( _valid_plane(plane), \"Invalid input plane.\" )\n    assert( is_vector(point,3), \"The point should be a 3D point.\" )\n    let( plane = _normalize_plane(plane) )\n    point3d(plane)* point - plane[3];\n\n\n\n// the maximum distance from points to the plane\nfunction _pointlist_greatest_distance(points,plane) =\n    let(\n        normal = [plane[0],plane[1],plane[2]],\n        pt_nrm = points*normal\n    )\n    max( max(pt_nrm) - plane[3], -min(pt_nrm) + plane[3]) / norm(normal);\n\n\n// Function: are_points_on_plane()\n// Synopsis: Determine if all of the listed points are on a plane. \n// Topics: Geometry, Planes, Points\n// See Also: plane3pt(), line_closest_point(), plane_closest_point(), is_coplanar()\n// Usage:\n//   bool = are_points_on_plane(points, plane, [eps]);\n// Description:\n//   Returns true if the given 3D points are on the given plane.\n// Arguments:\n//   plane = The plane to test the points on.\n//   points = The list of 3D points to test.\n//   eps = Tolerance in geometric comparisons.  Default: `EPSILON` (1e-9)\nfunction are_points_on_plane(points, plane, eps=EPSILON) =\n    assert( _valid_plane(plane), \"Invalid plane.\" )\n    assert( is_matrix(points,undef,3) && len(points)>0, \"Invalid pointlist.\" ) // using is_matrix it accepts len(points)==1\n    assert( is_finite(eps) && eps>=0, \"The tolerance should be a positive number.\" )\n    _pointlist_greatest_distance(points,plane) < eps;\n\n\n/// Internal Function: is_point_above_plane()\n/// Usage:\n///   bool = _is_point_above_plane(plane, point);\n/// Topics: Geometry, Planes\n/// Description:\n///   Given a plane as [A,B,C,D] where the cartesian equation for that plane\n///   is Ax+By+Cz=D, determines if the given 3D point is on the side of that\n///   plane that the normal points towards.  The normal of the plane is the\n///   same as [A,B,C].\n/// Arguments:\n///   plane = The [A,B,C,D] coefficients for the first plane equation `Ax+By+Cz=D`.\n///   point = The 3D point to test.\nfunction _is_point_above_plane(plane, point) =\n    point_plane_distance(plane, point) > EPSILON;\n\n\n\n// Section: Circle Calculations\n\n// Function: circle_line_intersection()\n// Synopsis: Find the intersection points between a 2d circle and a line, ray or segment.\n// Topics: Geometry, Circles, Lines, Intersection\n// See Also: circle_line_intersection(), circle_circle_intersection(), circle_2tangents(), circle_3points(), circle_point_tangents(), circle_circle_tangents()\n// Usage:\n//   pts = circle_line_intersection(r|d=, cp, line, [bounded], [eps=]);\n// Description:\n//   Find intersection points between a 2D circle and a line, ray or segment specified by two points.\n//   By default the line is unbounded.  Returns the list of zero or more intersection points.\n// Arguments:\n//   r = Radius of circle\n//   cp = Center of circle\n//   line = Two points defining the line\n//   bounded = False for unbounded line, true for a segment, or a vector [false,true] or [true,false] to specify a ray with the first or second end unbounded.  Default: false\n//   ---\n//   d = Diameter of circle\n//   eps = Epsilon used for identifying the case with one solution.  Default: `1e-9`\n// Example(2D): Standard intersection returns two points.\n//   line = [[-15,2], [15,7]];\n//   cp = [1,2]; r = 10;\n//   translate(cp) circle(r=r);\n//   color(\"black\") stroke(line, endcaps=\"arrow2\", width=0.5);\n//   isects = circle_line_intersection(r=r, cp=cp, line=line);\n//   color(\"red\") move_copies(isects) circle(d=1);\n// Example(2D): Tangent intersection returns one point.\n//   line = [[-10,12], [10,12]];\n//   cp = [1,2]; r = 10;\n//   translate(cp) circle(r=r);\n//   color(\"black\") stroke(line, endcaps=\"arrow2\", width=0.5);\n//   isects = circle_line_intersection(r=r, cp=cp, line=line);\n//   color(\"#f44\") move_copies(isects) circle(d=1);\n// Example(2D): A bounded ray might only intersect in one direction.\n//   line = [[-5,2], [5,7]];\n//   extended = [line[0], line[0]+22*unit(line[1]-line[0])];\n//   cp = [1,2]; r = 10;\n//   translate(cp) circle(r=r);\n//   color(\"gray\") dashed_stroke(extended, width=0.2);\n//   color(\"black\") stroke(line, endcap2=\"arrow2\", width=0.5);\n//   isects = circle_line_intersection(r=r, cp=cp, line=line, bounded=[true,false]);\n//   color(\"#f44\") move_copies(isects) circle(d=1);\n// Example(2D): If they don't intersect at all, then an empty list is returned.\n//   line = [[-12,12], [12,8]];\n//   cp = [-5,-2]; r = 10;\n//   translate(cp) circle(r=r);\n//   color(\"black\") stroke(line, endcaps=\"arrow2\", width=0.5);\n//   isects = circle_line_intersection(r=r, cp=cp, line=line);\n//   color(\"#f44\") move_copies(isects) circle(d=1);\nfunction circle_line_intersection(r, cp, line, bounded=false, d, eps=EPSILON) =\n  assert(_valid_line(line,2), \"Invalid 2d line.\")\n  assert(is_vector(cp,2), \"Circle center must be a 2-vector\")\n  _circle_or_sphere_line_intersection(r, cp, line, bounded, d, eps);\n\n\n\nfunction _circle_or_sphere_line_intersection(r, cp, line, bounded=false, d, eps=EPSILON) =\n  let(r=get_radius(r=r,d=d,dflt=undef))\n  assert(is_num(r) && r>0, \"Radius must be positive\")\n  assert(is_bool(bounded) || is_bool_list(bounded,2), \"Invalid bound condition\")\n  let(\n      bounded = force_list(bounded,2),\n      closest = line_closest_point(line,cp),\n      d = norm(closest-cp)\n  )\n  d > r ? [] :\n  let(\n     isect = approx(d,r,eps) ? [closest] :\n             let( offset = sqrt(r*r-d*d),\n                  uvec=unit(line[1]-line[0])\n             ) [closest-offset*uvec, closest+offset*uvec]\n  )\n  [for(p=isect)\n     if ((!bounded[0] || (p-line[0])*(line[1]-line[0])>=0)\n        && (!bounded[1] || (p-line[1])*(line[0]-line[1])>=0)) p];\n\n\n// Function: circle_circle_intersection()\n// Synopsis: Find the intersection points of two 2d circles.\n// Topics: Geometry, Circles\n// See Also: circle_line_intersection(), circle_circle_intersection(), circle_2tangents(), circle_3points(), circle_point_tangents(), circle_circle_tangents()\n// Usage:\n//   pts = circle_circle_intersection(r1|d1=, cp1, r2|d2=, cp2, [eps]);\n// Description:\n//   Compute the intersection points of two circles.  Returns a list of the intersection points, which\n//   will contain two points in the general case, one point for tangent circles, or will be empty\n//   if the circles do not intersect.\n// Arguments:\n//   r1 = Radius of the first circle.\n//   cp1 = Centerpoint of the first circle.\n//   r2 = Radius of the second circle.\n//   cp2 = Centerpoint of the second circle.\n//   eps = Tolerance for detecting tangent circles.  Default: EPSILON\n//   ---\n//   d1 = Diameter of the first circle.\n//   d2 = Diameter of the second circle.\n// Example(2D,NoAxes): Circles intersect in two points. \n//   $fn=32;\n//   cp1 = [4,4];  r1 = 3;\n//   cp2 = [7,7];  r2 = 2;\n//   pts = circle_circle_intersection(r1, cp1, r2, cp2);\n//   move(cp1) stroke(circle(r=r1), width=0.2, closed=true);\n//   move(cp2) stroke(circle(r=r2), width=0.2, closed=true);\n//   color(\"red\") move_copies(pts) circle(r=.3);\n// Example(2D,NoAxes): Circles are tangent, so one intersection point:\n//   $fn=32;\n//   cp1 = [4,4];  r1 = 4;\n//   cp2 = [4,10]; r2 = 2;\n//   pts = circle_circle_intersection(r1, cp1, r2, cp2);\n//   move(cp1) stroke(circle(r=r1), width=0.2, closed=true);\n//   move(cp2) stroke(circle(r=r2), width=0.2, closed=true);\n//   color(\"red\") move_copies(pts) circle(r=.3);\n// Example(2D,NoAxes): Another tangent example:\n//   $fn=32;\n//   cp1 = [4,4];  r1 = 4;\n//   cp2 = [5,5];  r2 = 4-sqrt(2);\n//   pts = circle_circle_intersection(r1, cp1, r2, cp2);\n//   move(cp1) stroke(circle(r=r1), width=0.2, closed=true);\n//   move(cp2) stroke(circle(r=r2), width=0.2, closed=true);\n//   color(\"red\") move_copies(pts) circle(r=.3);\n// Example(2D,NoAxes): Circles do not intersect.  Returns empty list. \n//   $fn=32;\n//   cp1 = [3,4];  r1 = 2;\n//   cp2 = [7,10]; r2 = 3;\n//   pts = circle_circle_intersection(r1, cp1, r2, cp2);\n//   move(cp1) stroke(circle(r=r1), width=0.2, closed=true);\n//   move(cp2) stroke(circle(r=r2), width=0.2, closed=true);\n//   color(\"red\") move_copies(pts) circle(r=.3);\nfunction circle_circle_intersection(r1, cp1, r2, cp2, eps=EPSILON, d1, d2) =\n    assert( is_path([cp1,cp2],dim=2), \"Invalid center point(s).\" )\n    let(\n        r1 = get_radius(r1=r1,d1=d1),\n        r2 = get_radius(r1=r2,d1=d2),\n        d = norm(cp2-cp1),\n        a = (cp2-cp1)/d,\n        b = [-a.y,a.x],\n        L = (r1^2-r2^2+d^2)/2/d,\n        hsqr = r1^2-L^2\n    )\n    approx(hsqr,0,eps) ? [L*a+cp1]\n  : hsqr<0 ? []\n  : let(h=sqrt(hsqr))\n    [L*a+h*b+cp1, L*a-h*b+cp1];\n\n\n// Function: circle_2tangents()\n// Synopsis: Given two 2d or 3d rays, find a circle tangent to both.  \n// Topics: Geometry, Circles, Tangents\n// See Also: circle_line_intersection(), circle_circle_intersection(), circle_2tangents(), circle_3points(), circle_point_tangents(), circle_circle_tangents()\n// Usage:\n//   circ = circle_2tangents(r|d=, pt1, pt2, pt3, [tangents=]);\n//   circ = circle_2tangents(r|d=, [PT1, PT2, PT3], [tangents=]);\n// Description:\n//   Given a pair of 2d or 3d rays with a common origin, and a known circle radius/diameter, finds\n//   the centerpoint for the circle of that size that touches both rays tangentally.\n//   Both rays start at `pt2`, one passing through `pt1`, and the other through `pt3`.\n//   .\n//   When called with collinear rays, returns `undef`.\n//   Otherwise, when called with `tangents=false`, returns `[CP,NORMAL]`.\n//   Otherwise, when called with `tangents=true`, returns `[CP,NORMAL,TANPT1,TANPT2]`.\n//   - CP is the centerpoint of the circle.\n//   - NORMAL is the normal vector of the plane that the circle is on (UP or DOWN if the points are 2D).\n//   - TANPT1 is the point where the circle is tangent to the ray `[pt2,pt1]`.\n//   - TANPT2 is the point where the circle is tangent to the ray `[pt2,pt3]`.\n// Figure(3D,Med,NoAxes,VPD=130,VPT=[29,19,3],VPR=[55,0,25]):\n//   pts = [[45,10,-5], [10,5,10], [15,40,5]];\n//   rad = 15;\n//   circ = circle_2tangents(r=rad, pt1=pts[0], pt2=pts[1], pt3=pts[2], tangents=true);\n//   cp = circ[0]; n = circ[1]; tp1 = circ[2]; tp2 = circ[3];\n//   color(\"yellow\") stroke(pts, endcaps=\"arrow2\");\n//   color(\"purple\") move_copies([cp,tp1,tp2]) sphere(d=2, $fn=12);\n//   color(\"lightgray\") stroke([cp,tp2], width=0.5);\n//   stroke([cp,cp+n*20], endcap2=\"arrow2\");\n//   labels = [\n//       [\"pt1\",    \"blue\",  2.5, [ 4, 0, 1], pts[0]],\n//       [\"pt2\",    \"blue\",  2.5, [-4, 0,-3], pts[1]],\n//       [\"pt3\",    \"blue\",  2.5, [ 4, 0, 1], pts[2]],\n//       [\"r\",      \"blue\",  2.5, [ 0,-2, 2], (cp+tp2)/2],\n//       [\"CP\",     \"brown\", 2.5, [ 6,-4, 3], cp],\n//       [\"Normal\", \"brown\", 2.0, [ 5, 2, 1], cp+20*n],\n//       [\"TanPt1\", \"brown\", 2.0, [-5,-4, 0], tp1],\n//       [\"TanPt2\", \"brown\", 2.0, [-5, 0, 2], tp2],\n//   ];\n//   for(l=labels)\n//       color(l[1]) move(l[4]+l[3]) rot([55,0,25])\n//           linear_extrude(height=0.1)\n//               text(text=l[0], size=l[2], halign=\"center\", valign=\"center\");\n//   color(\"green\",0.5) move(cp) cyl(h=0.1, r=rad, orient=n, $fn=36);\n// Arguments:\n//   r = The radius of the circle to find.\n//   pt1 = A point that the first ray passes though.\n//   pt2 = The starting point of both rays.\n//   pt3 = A point that the second ray passes though.\n//   ---\n//   d = The diameter of the circle to find.\n//   tangents = If true, extended information about the tangent points is calculated and returned.  Default: false\n// Example(2D):\n//   pts = [[40,40], [10,10], [55,5]];  rad = 10;\n//   circ = circle_2tangents(r=rad, pt1=pts[0], pt2=pts[1], pt3=pts[2]);\n//   stroke(pts, endcaps=\"arrow2\");\n//   color(\"red\") move(circ[0]) circle(r=rad);\n// Example(2D):\n//   pts = [[20,40], [10,10], [55,20]];  rad = 10;\n//   circ = circle_2tangents(r=rad, pt1=pts[0], pt2=pts[1], pt3=pts[2], tangents=true);\n//   stroke(pts, endcaps=\"arrow2\");\n//   color(\"red\") move(circ[0]) circle(r=rad);\n//   color(\"blue\") move_copies(select(circ,2,3)) circle(d=2);\n// Example(3D): Fit into 3D path corner.\n//   pts = [[45,5,10], [10,10,15], [30,40,30]];  rad = 10;\n//   circ = circle_2tangents(rad, [pts[0], pts[1], pts[2]]);\n//   stroke(pts, endcaps=\"arrow2\");\n//   color(\"red\") move(circ[0]) cyl(h=10, r=rad, orient=circ[1]);\n// Example(3D):\n//   path = yrot(20, p=path3d(star(d=100, n=5, step=2)));\n//   stroke(path, closed=true);\n//   for (i = [0:1:5]) {\n//       crn = select(path, i*2-1, i*2+1);\n//       ci = circle_2tangents(5, crn[0], crn[1], crn[2]);\n//       move(ci[0]) cyl(h=10,r=5,orient=ci[1]);\n//   }\nfunction circle_2tangents(r, pt1, pt2, pt3, tangents=false, d) =\n    let(r = get_radius(r=r, d=d, dflt=undef))\n    assert(r!=undef, \"Must specify either r or d.\")\n    assert( ( is_path(pt1) && len(pt1)==3 && is_undef(pt2) && is_undef(pt3))\n            || (is_matrix([pt1,pt2,pt3]) && (len(pt1)==2 || len(pt1)==3) ),\n            str(\"Invalid input points. pt1=\",pt1,\", pt2=\",pt2,\", pt3=\",pt3))\n    is_undef(pt2)\n    ? circle_2tangents(r, pt1[0], pt1[1], pt1[2], tangents=tangents)\n    : is_collinear(pt1, pt2, pt3)? undef :\n        let(\n            v1 = unit(pt1 - pt2),\n            v2 = unit(pt3 - pt2),\n            vmid = unit(mean([v1, v2])),\n            n = vector_axis(v1, v2),\n            a = vector_angle(v1, v2),\n            hyp = r / sin(a/2),\n            cp = pt2 + hyp * vmid\n        )\n        !tangents ? [cp, n] :\n        let(\n            x = hyp * cos(a/2),\n            tp1 = pt2 + x * v1,\n            tp2 = pt2 + x * v2\n        )\n        [cp, n, tp1, tp2];\n\n\n// Function: circle_3points()\n// Synopsis: Find a circle passing through three 2d or 3d points. \n// Topics: Geometry, Circles\n// See Also: circle_line_intersection(), circle_circle_intersection(), circle_2tangents(), circle_3points(), circle_point_tangents(), circle_circle_tangents()\n// Usage:\n//   circ = circle_3points(pt1, pt2, pt3);\n//   circ = circle_3points([PT1, PT2, PT3]);\n// Description:\n//   Returns the [CENTERPOINT, RADIUS, NORMAL] of the circle that passes through three non-collinear\n//   points where NORMAL is the normal vector of the plane that the circle is on (UP or DOWN if the points are 2D).\n//   The centerpoint will be a 2D or 3D vector, depending on the points input.  If all three\n//   points are 2D, then the resulting centerpoint will be 2D, and the normal will be UP ([0,0,1]).\n//   If any of the points are 3D, then the resulting centerpoint will be 3D.  If the three points are\n//   collinear, then `[undef,undef,undef]` will be returned.  The normal will be a normalized 3D\n//   vector with a non-negative Z axis.  Instead of 3 arguments, it is acceptable to input the 3 points\n//   as a list given in `pt1`, leaving `pt2`and `pt3` as undef.\n// Arguments:\n//   pt1 = The first point.\n//   pt2 = The second point.\n//   pt3 = The third point.\n// Example(2D):\n//   pts = [[60,40], [10,10], [65,5]];\n//   circ = circle_3points(pts[0], pts[1], pts[2]);\n//   translate(circ[0]) color(\"green\") stroke(circle(r=circ[1]),closed=true,$fn=72);\n//   translate(circ[0]) color(\"red\") circle(d=3, $fn=12);\n//   move_copies(pts) color(\"blue\") circle(d=3, $fn=12);\nfunction circle_3points(pt1, pt2, pt3) =\n    (is_undef(pt2) && is_undef(pt3) && is_list(pt1))\n      ? circle_3points(pt1[0], pt1[1], pt1[2])\n      : assert( is_vector(pt1) && is_vector(pt2) && is_vector(pt3)\n                && max(len(pt1),len(pt2),len(pt3))<=3 && min(len(pt1),len(pt2),len(pt3))>=2,\n                \"Invalid point(s).\" )\n        is_collinear(pt1,pt2,pt3)? [undef,undef,undef] :\n        let(\n            v  = [ point3d(pt1), point3d(pt2), point3d(pt3) ], // triangle vertices\n            ed = [for(i=[0:2]) v[(i+1)%3]-v[i] ],    // triangle edge vectors\n            pm = [for(i=[0:2]) v[(i+1)%3]+v[i] ]/2,  // edge mean points\n            es = sortidx( [for(di=ed) norm(di) ] ),\n            e1 = ed[es[1]],                          // take the 2 longest edges\n            e2 = ed[es[2]],\n            n0 = vector_axis(e1,e2),                 // normal standardization\n            n  = n0.z<0? -n0 : n0,\n            sc = plane_intersection(\n                    [ each e1, e1*pm[es[1]] ],       // planes orthogonal to 2 edges\n                    [ each e2, e2*pm[es[2]] ],\n                    [ each n,  n*v[0] ]\n                ),  // triangle plane\n            cp = len(pt1)+len(pt2)+len(pt3)>6 ? sc : [sc.x, sc.y],\n            r  = norm(sc-v[0])\n        ) [ cp, r, n ];\n\n\n\n// Function: circle_point_tangents()\n// Synopsis: Given a circle and point, find tangents to circle passing through the point.\n// Topics: Geometry, Circles, Tangents\n// See Also: circle_line_intersection(), circle_circle_intersection(), circle_2tangents(), circle_3points(), circle_point_tangents(), circle_circle_tangents()\n// Usage:\n//   tangents = circle_point_tangents(r|d=, cp, pt);\n// Description:\n//   Given a 2d circle and a 2d point outside that circle, finds the 2d tangent point(s) on the circle for a\n//   line passing through the point.  Returns a list of zero or more 2D tangent points.\n// Arguments:\n//   r = Radius of the circle.\n//   cp = The coordinates of the 2d circle centerpoint.\n//   pt = The coordinates of the 2d external point.\n//   ---\n//   d = Diameter of the circle.\n// Example(2D):\n//   cp = [-10,-10];  r = 30;  pt = [30,10];\n//   tanpts = circle_point_tangents(r=r, cp=cp, pt=pt);\n//   color(\"yellow\") translate(cp) circle(r=r);\n//   color(\"cyan\") for(tp=tanpts) {stroke([tp,pt]); stroke([tp,cp]);}\n//   color(\"red\") move_copies(tanpts) circle(d=3,$fn=12);\n//   color(\"blue\") move_copies([cp,pt]) circle(d=3,$fn=12);\nfunction circle_point_tangents(r, cp, pt, d) =\n    assert(is_finite(r) || is_finite(d), \"Invalid radius or diameter.\" )\n    assert(is_path([cp, pt],dim=2), \"Invalid center point or external point.\")\n    let(\n        r = get_radius(r=r, d=d, dflt=1),\n        delta = pt - cp,\n        dist = norm(delta),\n        baseang = atan2(delta.y,delta.x)\n    ) dist < r? [] :\n    approx(dist,r)? [pt] :\n    let(\n        relang = acos(r/dist),\n        angs = [baseang + relang, baseang - relang]\n    ) [for (ang=angs) cp + r*[cos(ang),sin(ang)]];\n\n\n// Function: circle_circle_tangents()\n// Synopsis: Find tangents to a pair of circles in 2d.  \n// Topics: Geometry, Circles, Tangents\n// See Also: circle_line_intersection(), circle_circle_intersection(), circle_2tangents(), circle_3points(), circle_point_tangents(), circle_circle_tangents()\n// Usage:\n//   segs = circle_circle_tangents(r1|d1=, cp1, r2|d2=, cp2);\n// Description:\n//   Computes 2d lines tangents to a pair of circles in 2d.  Returns a list of line endpoints [p1,p2] where\n//   p1 is the tangent point on circle 1 and p2 is the tangent point on circle 2.\n//   If four tangents exist then the first one is the left hand exterior tangent as regarded looking from\n//   circle 1 toward circle 2.  The second value is the right hand exterior tangent.  The third entry\n//   gives the interior tangent that starts on the left of circle 1 and crosses to the right side of\n//   circle 2.  And the fourth entry is the last interior tangent that starts on the right side of\n//   circle 1.  If the circles intersect then the interior tangents don't exist and the function\n//   returns only two entries.  If one circle is inside the other one then no tangents exist\n//   so the function returns the empty set.  When the circles are tangent a degenerate tangent line\n//   passes through the point of tangency of the two circles:  this degenerate line is NOT returned.\n// Arguments:\n//   r1 = Radius of the first circle.\n//   cp1 = Centerpoint of the first circle.\n//   r2 = Radius of the second circle.\n//   cp2 = Centerpoint of the second circle.\n//   ---\n//   d1 = Diameter of the first circle.\n//   d2 = Diameter of the second circle.\n// Example(2D,NoAxes): Four tangents, first in green, second in black, third in blue, last in red.\n//   $fn=32;\n//   cp1 = [3,4];  r1 = 2;\n//   cp2 = [7,10]; r2 = 3;\n//   pts = circle_circle_tangents(r1, cp1, r2, cp2);\n//   move(cp1) stroke(circle(r=r1), width=0.2, closed=true);\n//   move(cp2) stroke(circle(r=r2), width=0.2, closed=true);\n//   colors = [\"green\",\"black\",\"blue\",\"red\"];\n//   for(i=[0:len(pts)-1]) color(colors[i]) stroke(pts[i],width=0.2);\n// Example(2D,NoAxes): Circles overlap so only exterior tangents exist.\n//   $fn=32;\n//   cp1 = [4,4];  r1 = 3;\n//   cp2 = [7,7];  r2 = 2;\n//   pts = circle_circle_tangents(r1, cp1, r2, cp2);\n//   move(cp1) stroke(circle(r=r1), width=0.2, closed=true);\n//   move(cp2) stroke(circle(r=r2), width=0.2, closed=true);\n//   colors = [\"green\",\"black\",\"blue\",\"red\"];\n//   for(i=[0:len(pts)-1]) color(colors[i]) stroke(pts[i],width=0.2);\n// Example(2D,NoAxes): Circles are tangent.  Only exterior tangents are returned.  The degenerate internal tangent is not returned.\n//   $fn=32;\n//   cp1 = [4,4];  r1 = 4;\n//   cp2 = [4,10]; r2 = 2;\n//   pts = circle_circle_tangents(r1, cp1, r2, cp2);\n//   move(cp1) stroke(circle(r=r1), width=0.2, closed=true);\n//   move(cp2) stroke(circle(r=r2), width=0.2, closed=true);\n//   colors = [\"green\",\"black\",\"blue\",\"red\"];\n//   for(i=[0:1:len(pts)-1]) color(colors[i]) stroke(pts[i],width=0.2);\n// Example(2D,NoAxes): One circle is inside the other: no tangents exist.  If the interior circle is tangent the single degenerate tangent will not be returned.\n//   $fn=32;\n//   cp1 = [4,4];  r1 = 4;\n//   cp2 = [5,5];  r2 = 2;\n//   pts = circle_circle_tangents(r1, cp1, r2, cp2);\n//   move(cp1) stroke(circle(r=r1), width=0.2, closed=true);\n//   move(cp2) stroke(circle(r=r2), width=0.2, closed=true);\n//   echo(pts);   // Returns []\nfunction circle_circle_tangents(r1, cp1, r2, cp2, d1, d2) =\n    assert( is_path([cp1,cp2],dim=2), \"Invalid center point(s).\" )\n    let(\n        r1 = get_radius(r1=r1,d1=d1),\n        r2 = get_radius(r1=r2,d1=d2),\n        Rvals = [r2-r1, r2-r1, -r2-r1, -r2-r1]/norm(cp1-cp2),\n        kvals = [-1,1,-1,1],\n        ext = [1,1,-1,-1],\n        N = 1-sqr(Rvals[2])>=0 ? 4 :\n            1-sqr(Rvals[0])>=0 ? 2 : 0,\n        coef= [\n            for(i=[0:1:N-1]) [\n                [Rvals[i], -kvals[i]*sqrt(1-sqr(Rvals[i]))],\n                [kvals[i]*sqrt(1-sqr(Rvals[i])), Rvals[i]]\n            ] * unit(cp2-cp1)\n        ]\n    ) [\n        for(i=[0:1:N-1]) let(\n            pt = [\n                cp1-r1*coef[i],\n                cp2-ext[i]*r2*coef[i]\n            ]\n        ) if (pt[0]!=pt[1]) pt\n    ];\n\n\n\n/// Internal Function: _noncollinear_triple()\n/// Usage:\n///   bool = _noncollinear_triple(points);\n/// Topics: Geometry, Noncollinearity\n/// Description:\n///   Finds the indices of three non-collinear points from the pointlist `points`.\n///   It selects two well separated points to define a line and chooses the third point\n///   to be the point farthest off the line.  The points do not necessarily having the\n///   same winding direction as the polygon so they cannot be used to determine the\n///   winding direction or the direction of the normal.  \n///   If all points are collinear returns [] when `error=true` or an error otherwise .\n/// Arguments:\n///   points = List of input points.\n///   error = Defines the behaviour for collinear input points. When `true`, produces an error, otherwise returns []. Default: `true`.\n///   eps = Tolerance for collinearity test. Default: EPSILON.\nfunction _noncollinear_triple(points,error=true,eps=EPSILON) =\n    assert( is_path(points), \"Invalid input points.\" )\n    assert( is_finite(eps) && (eps>=0), \"The tolerance should be a non-negative value.\" )\n    len(points)<3 ? [] :\n    let(\n        pa = points[0],\n        b  = furthest_point(pa, points),\n        pb = points[b],\n        nrm = norm(pa-pb)\n    )\n    nrm <= eps ?\n        assert(!error, \"Cannot find three noncollinear points in pointlist.\") [] :\n    let(\n        n = (pb-pa)/nrm,\n        distlist = [for(i=[0:len(points)-1]) _dist2line(points[i]-pa, n)]\n    )\n    max(distlist) < eps*nrm ?\n        assert(!error, \"Cannot find three noncollinear points in pointlist.\") [] :\n    [0, b, max_index(distlist)];\n\n\n\n// Section: Sphere Calculations\n\n\n// Function: sphere_line_intersection()\n// Synopsis: Find intersection between a sphere and line, ray or segment. \n// Topics: Geometry, Spheres, Lines, Intersection\n// See Also: circle_line_intersection(), circle_circle_intersection(), circle_2tangents(), circle_3points(), circle_point_tangents(), circle_circle_tangents()\n// Usage:\n//   isect = sphere_line_intersection(r|d=, cp, line, [bounded], [eps=]);\n// Description:\n//   Find intersection points between a sphere and a line, ray or segment specified by two points.\n//   By default the line is unbounded.\n// Arguments:\n//   r = Radius of sphere\n//   cp = Centerpoint of sphere\n//   line = Two points defining the line\n//   bounded = false for unbounded line, true for a segment, or a vector [false,true] or [true,false] to specify a ray with the first or second end unbounded.  Default: false\n//   ---\n//   d = diameter of sphere\n//   eps = epsilon used for identifying the case with one solution.  Default: 1e-9\n// Example(3D):\n//   cp = [10,20,5];  r = 40;\n//   line = [[-50,-10,25], [70,0,40]];\n//   isects = sphere_line_intersection(r=r, cp=cp, line=line);\n//   color(\"cyan\") stroke(line);\n//   move(cp) sphere(r=r, $fn=72);\n//   color(\"red\") move_copies(isects) sphere(d=3, $fn=12);\nfunction sphere_line_intersection(r, cp, line, bounded=false, d, eps=EPSILON) =\n  assert(_valid_line(line,3), \"Invalid 3d line.\")\n  assert(is_vector(cp,3), \"Sphere center must be a 3-vector\")\n  _circle_or_sphere_line_intersection(r, cp, line, bounded, d, eps);\n\n\n\n\n// Section: Polygons\n\n// Function: polygon_area()\n// Synopsis: Calculate area of a 2d or 3d polygon. \n// Topics: Geometry, Polygons, Area\n// See Also: polygon_area(), centroid(), polygon_normal(), point_in_polygon(), polygon_line_intersection()\n// Usage:\n//   area = polygon_area(poly, [signed]);\n// Description:\n//   Given a 2D or 3D simple planar polygon, returns the area of that polygon.\n//   If the polygon is non-planar the result is `undef.`  If the polygon is self-intersecting\n//   then the return will be a meaningless number.  \n//   When `signed` is true and the polygon is 2d, a signed area is returned: a positive area indicates a counter-clockwise polygon.\n//   The area of 3d polygons is always nonnegative.  \n// Arguments:\n//   poly = Polygon to compute the area of.\n//   signed = If true, a signed area is returned. Default: false.\nfunction polygon_area(poly, signed=false) =\n    assert(is_path(poly), \"Invalid polygon.\" )\n    len(poly)<3 ? 0 :\n    len(poly)==3 ?\n        let( total= len(poly[0])==2 ? 0.5*cross(poly[2]-poly[0],poly[2]-poly[1]) : 0.5*norm(cross(poly[2]-poly[0],poly[2]-poly[1])))\n        signed ? total : abs(total) :\n    len(poly[0])==2\n      ? let( total = sum([for(i=[1:1:len(poly)-2]) cross(poly[i]-poly[0],poly[i+1]-poly[0]) ])/2 )\n        signed ? total : abs(total)\n      : let( plane = plane_from_polygon(poly) )\n        is_undef(plane) ? undef :\n        let( \n            n = plane_normal(plane),  \n            total = \n                -sum([ for(i=[1:1:len(poly)-2])\n                        cross(poly[i]-poly[0], poly[i+1]-poly[0]) \n                    ]) * n/2\n        ) \n        signed ? total : abs(total);\n\n\n// Function: centroid()\n// Synopsis: Compute centroid of a 2d or 3d polygon or a VNF. \n// Topics: Geometry, Polygons, Centroid\n// See Also: polygon_area(), centroid(), polygon_normal(), point_in_polygon(), polygon_line_intersection()\n// Usage:\n//   c = centroid(object, [eps]);\n// Description:\n//   Given a simple 2D polygon, returns the 2D coordinates of the polygon's centroid.\n//   Given a simple 3D planar polygon, returns the 3D coordinates of the polygon's centroid.\n//   If you provide a non-planar or collinear polygon you will get an error.  For self-intersecting\n//   polygons you may get an error or you may get meaningless results.\n//   .\n//   Given a [region](regions.scad), returns the 2D coordinates of the region's centroid.\n//   .\n//   Given a manifold [VNF](vnf.scad) then returns the 3D centroid of the polyhedron.  The VNF must\n//   describe a valid polyhedron with consistent face direction and no holes in the mesh; otherwise\n//   the results are undefined.\n// Arguments:\n//   object = object to compute the centroid of\n//   eps = epsilon value for identifying degenerate cases\n// Example(2D):\n//   path = [\n//       [-10,10], [-5,15], [15,15], [20,0],\n//       [15,-5], [25,-20], [25,-27], [15,-20],\n//       [0,-30], [-15,-25], [-5,-5]\n//   ];\n//   linear_extrude(height=0.01) polygon(path);\n//   cp = centroid(path);\n//   color(\"red\") move(cp) sphere(d=2);\nfunction centroid(object,eps=EPSILON) =\n    assert(is_finite(eps) && (eps>=0), \"The tolerance should a non-negative value.\" )\n    is_vnf(object) ? _vnf_centroid(object,eps)\n  : is_path(object,[2,3]) ? _polygon_centroid(object,eps)\n  : is_region(object) ? (len(object)==1 ? _polygon_centroid(object[0],eps) : _region_centroid(object,eps))\n  : assert(false, \"Input must be a VNF, a region, or a 2D or 3D polygon\");\n\n\n/// Internal Function: _region_centroid()\n/// Compute centroid of region\nfunction _region_centroid(region,eps=EPSILON) =\n   let(\n       region=force_region(region),\n       parts = region_parts(region),\n       // Rely on region_parts returning all outside polygons clockwise\n       // and inside (hole) polygons counterclockwise, so areas have reversed sign\n       cent_area = [for(R=parts, p=R)\n                       let(A=polygon_area(p,signed=true))\n                       [A*_polygon_centroid(p),A]],\n       total = sum(cent_area)\n   )\n   total[0]/total[1];\n\n\n/// Internal Function: _polygon_centroid()\n/// Usage:\n///   cpt = _polygon_centroid(poly);\n/// Topics: Geometry, Polygons, Centroid\n/// Description:\n///   Given a simple 2D polygon, returns the 2D coordinates of the polygon's centroid.\n///   Given a simple 3D planar polygon, returns the 3D coordinates of the polygon's centroid.\n///   Collinear points produce an error.  The results are meaningless for self-intersecting\n///   polygons or an error is produced.\n/// Arguments:\n///   poly = Points of the polygon from which the centroid is calculated.\n///   eps = Tolerance in geometric comparisons.  Default: `EPSILON` (1e-9)\nfunction _polygon_centroid(poly, eps=EPSILON) =\n    assert( is_path(poly,dim=[2,3]), \"The input must be a 2D or 3D polygon.\" )\n    let(\n        n = len(poly[0])==2 ? 1 :\n            let( plane = plane_from_points(poly, fast=false))\n            assert(!is_undef(plane), \"The polygon must be planar.\" )\n            plane_normal(plane),\n        v0 = poly[0] ,\n        val = sum([\n            for(i=[1:len(poly)-2])\n            let(\n                v1 = poly[i],\n                v2 = poly[i+1],\n                area = cross(v2-v0,v1-v0)*n\n            ) [ area, (v0+v1+v2)*area ]\n        ])\n    )\n    assert(!approx(val[0],0, eps), \"The polygon is self-intersecting or its points are collinear.\")\n    val[1]/val[0]/3;\n\n\n\n// Function: polygon_normal()\n// Synopsis: Return normal to a polygon.  \n// Topics: Geometry, Polygons\n// See Also: polygon_area(), centroid(), polygon_normal(), point_in_polygon(), polygon_line_intersection()\n// Usage:\n//   vec = polygon_normal(poly);\n// Description:\n//   Given a 3D simple planar polygon, returns a unit normal vector for the polygon.  The vector\n//   is oriented so that if the normal points towards the viewer, the polygon winds in the clockwise\n//   direction.  If the polygon has zero area, returns `undef`.  If the polygon is self-intersecting\n//   the the result is undefined.  It doesn't check for coplanarity.\n// Arguments:\n//   poly = The list of 3D path points for the perimeter of the polygon.\n// Example(3D):\n//   path = rot([0,30,15], p=path3d(star(n=5, d=100, step=2)));\n//   stroke(path, closed=true);\n//   n = polygon_normal(path);\n//   rot(from=UP, to=n)\n//       color(\"red\")\n//           stroke([[0,0,0], [0,0,20]], endcap2=\"arrow2\");\nfunction polygon_normal(poly) =\n    assert(is_path(poly,dim=3), \"Invalid 3D polygon.\" )\n    let(\n        area_vec = sum([for(i=[1:len(poly)-2])\n                           cross(poly[i]-poly[0],\n                                 poly[i+1]-poly[i])])\n    )\n    unit(-area_vec, error=undef);\n\n\n// Function: point_in_polygon()\n// Synopsis: Checks if a 2d point is inside or on the boundary of a 2d polygon. \n// Topics: Geometry, Polygons\n// See Also: polygon_area(), centroid(), polygon_normal(), point_in_polygon(), polygon_line_intersection()\n// Usage:\n//   bool = point_in_polygon(point, poly, [nonzero], [eps])\n// Description:\n//   This function tests whether the given 2D point is inside, outside or on the boundary of\n//   the specified 2D polygon.  \n//   The polygon is given as a list of 2D points, not including the repeated end point.\n//   Returns -1 if the point is outside the polygon.\n//   Returns 0 if the point is on the boundary.\n//   Returns 1 if the point lies in the interior.\n//   The polygon does not need to be simple: it may have self-intersections.\n//   But the polygon cannot have holes (it must be simply connected).\n//   Rounding errors may give mixed results for points on or near the boundary.\n//   .\n//   When polygons intersect themselves different definitions exist for determining which points\n//   are inside the polygon.  The figure below shows the difference.\n//   OpenSCAD uses the Even-Odd rule when creating polygons, where membership in overlapping regions\n//   depends on how many times they overlap.  The Nonzero rule considers point inside the polygon if\n//   the polygon overlaps them any number of times.  For more information see\n//   https://en.wikipedia.org/wiki/Nonzero-rule and https://en.wikipedia.org/wiki/Even\u2013odd_rule.\n// Figure(2D,Med,NoAxes):\n//   a=20;\n//   b=30;\n//   ofs = 17;\n//   curve = [for(theta=[0:10:140])  [a * theta/360*2*PI - b*sin(theta), a-b*cos(theta)-20]];\n//   path = deduplicate(concat( reverse(offset(curve,r=ofs)),\n//                  xflip(offset(curve,r=ofs)),\n//                  xflip(reverse(curve)),\n//                  curve\n//                ));\n//   left(40){\n//     polygon(path);\n//     color(\"red\")stroke(path, width=1, closed=true);\n//     color(\"red\")back(28/(2/3))text(\"Even-Odd\", size=5/(2/3), halign=\"center\");\n//   }\n//   right(40){\n//      dp = polygon_parts(path,nonzero=true);\n//      region(dp);\n//      color(\"red\"){stroke(path,width=1,closed=true);\n//                   back(28/(2/3))text(\"Nonzero\", size=5/(2/3), halign=\"center\");\n//                   }\n//   }  \n// Arguments:\n//   point = The 2D point to check\n//   poly = The list of 2D points forming the perimeter of the polygon.\n//   nonzero = The rule to use: true for \"Nonzero\" rule and false for \"Even-Odd\". Default: false (Even-Odd)\n//   eps = Tolerance in geometric comparisons.  Default: `EPSILON` (1e-9)\n// Example(2D): With nonzero set to false (the default), we get this result. Green dots are inside the polygon and red are outside:\n//   a=20*2/3;\n//   b=30*2/3;\n//   ofs = 17*2/3;\n//   curve = [for(theta=[0:10:140])  [a * theta/360*2*PI - b*sin(theta), a-b*cos(theta)]];\n//   path = deduplicate(concat( reverse(offset(curve,r=ofs)),\n//                  xflip(offset(curve,r=ofs)),\n//                  xflip(reverse(curve)),\n//                  curve\n//                ));\n//   stroke(path,closed=true);\n//   pts = [[0,0],[10,0],[0,20]];\n//   for(p=pts){\n//     color(point_in_polygon(p,path)==1 ? \"green\" : \"red\")\n//     move(p)circle(r=1.5, $fn=12);\n//   }\n// Example(2D): With nonzero set to true, one dot changes color:\n//   a=20*2/3;\n//   b=30*2/3;\n//   ofs = 17*2/3;\n//   curve = [for(theta=[0:10:140])  [a * theta/360*2*PI - b*sin(theta), a-b*cos(theta)]];\n//   path = deduplicate(concat( reverse(offset(curve,r=ofs)),\n//                  xflip(offset(curve,r=ofs)),\n//                  xflip(reverse(curve)),\n//                  curve\n//                ));\n//   stroke(path,closed=true);\n//   pts = [[0,0],[10,0],[0,20]];\n//   for(p=pts){\n//     color(point_in_polygon(p,path,nonzero=true)==1 ? \"green\" : \"red\")\n//     move(p)circle(r=1.5, $fn=12);\n//   }\n\n// Internal function for point_in_polygon\n\nfunction _point_above_below_segment(point, edge) =\n    let( edge = edge - [point, point] )\n    edge[0].y <= 0\n      ? (edge[1].y >  0 && cross(edge[0], edge[1]-edge[0]) > 0) ?  1 : 0\n      : (edge[1].y <= 0 && cross(edge[0], edge[1]-edge[0]) < 0) ? -1 : 0;\n\n\nfunction point_in_polygon(point, poly, nonzero=false, eps=EPSILON) =\n    // Original algorithms from http://geomalgorithms.com/a03-_inclusion.html\n    assert( is_vector(point,2) && is_path(poly,dim=2) && len(poly)>2,\n            \"The point and polygon should be in 2D. The polygon should have more that 2 points.\" )\n    assert( is_finite(eps) && (eps>=0), \"The tolerance should be a non-negative value.\" )\n    // Check bounding box\n    let(\n        box = pointlist_bounds(poly)\n    )\n    point.x<box[0].x-eps || point.x>box[1].x+eps\n        || point.y<box[0].y-eps || point.y>box[1].y+eps  ? -1\n    :\n    // Does the point lie on any edges?  If so return 0.\n    let(\n        segs = pair(poly,true),\n        on_border = [for (seg=segs)\n                       if (norm(seg[0]-seg[1])>eps && _is_point_on_line(point, seg, SEGMENT, eps=eps)) 1]\n    )\n    on_border != [] ? 0 :\n    nonzero    // Compute winding number and return 1 for interior, -1 for exterior\n      ? let(\n            winding = [\n                       for(seg=segs)\n                         let(\n                             p0=seg[0]-point,\n                             p1=seg[1]-point\n                         )\n                         if (norm(p0-p1)>eps)\n                             p0.y <=0\n                                ? p1.y > 0 && cross(p0,p1-p0)>0 ? 1 : 0\n                                : p1.y <=0 && cross(p0,p1-p0)<0 ? -1: 0\n            ]\n        )\n        sum(winding) != 0 ? 1 : -1\n      : // or compute the crossings with the ray [point, point+[1,0]]\n        let(\n            cross = [\n                     for(seg=segs)\n                       let(\n                           p0 = seg[0]-point,\n                           p1 = seg[1]-point\n                       )\n                       if (\n                           ( (p1.y>eps && p0.y<=eps) || (p1.y<=eps && p0.y>eps) )\n                           &&  -eps < p0.x - p0.y *(p1.x - p0.x)/(p1.y - p0.y)\n                       )\n                       1\n            ]\n        )\n        2*(len(cross)%2)-1;\n\n\n\n// Function: polygon_line_intersection()\n// Synopsis: Find intersection between 2d or 3d polygon and a line, segment or ray.  \n// Topics: Geometry, Polygons, Lines, Intersection\n// See Also: polygon_area(), centroid(), polygon_normal(), point_in_polygon(), polygon_line_intersection()\n// Usage:\n//   pt = polygon_line_intersection(poly, line, [bounded], [nonzero], [eps]);\n// Description:\n//   Takes a possibly bounded line, and a 2D or 3D planar polygon, and finds their intersection.  Note the polygon is\n//   treated as its boundary and interior, so the intersection may include both points and line segments.  \n//   If the line does not intersect the polygon returns `undef`.  \n//   In 3D if the line is not on the plane of the polygon but intersects it then you get a single intersection point.\n//   Otherwise the polygon and line are in the same plane, or when your input is 2D, you will get a list of segments and \n//   single point lists.  Use `is_vector` to distinguish these two cases.\n//   .\n//   In the 2D case, a common result is a list containing a single segment, which lists the two intersection points\n//   with the boundary of the polygon.\n//   When single points are in the intersection (the line just touches a polygon corner) they appear on the segment\n//   list as lists of a single point\n//   (like single point segments) so a single point intersection in 2D has the form `[[[x,y,z]]]` as compared\n//   to a single point intersection in 3D which has the form `[x,y,z]`.  You can identify whether an entry in the\n//   segment list is a true segment by checking its length, which will be 2 for a segment and 1 for a point.  \n// Arguments:\n//   poly = The 3D planar polygon to find the intersection with.\n//   line = A list of two distinct 3D points on the line.\n//   bounded = If false, the line is considered unbounded.  If true, it is treated as a bounded line segment.  If given as `[true, false]` or `[false, true]`, the boundedness of the points are specified individually, allowing the line to be treated as a half-bounded ray.  Default: false (unbounded)\n//   nonzero = set to true to use the nonzero rule for determining it points are in a polygon.  See point_in_polygon.  Default: false.\n//   eps = Tolerance in geometric comparisons.  Default: `EPSILON` (1e-9)\n// Example(3D): The line intersects the 3d hexagon in a single point. \n//   hex = zrot(140,p=rot([-45,40,20],p=path3d(hexagon(r=15))));\n//   line = [[5,0,-13],[-3,-5,13]];\n//   isect = polygon_line_intersection(hex,line);\n//   stroke(hex,closed=true);\n//   stroke(line);\n//   color(\"red\")move(isect)sphere(r=1,$fn=12);\n// Example(2D): In 2D things are more complicated.  The output is a list of intersection parts, in the simplest case a single segment.\n//   hex = hexagon(r=15);\n//   line = [[-20,10],[25,-7]];\n//   isect = polygon_line_intersection(hex,line);\n//   stroke(hex,closed=true);\n//   stroke(line,endcaps=\"arrow2\");\n//   color(\"red\")\n//     for(part=isect)\n//        if(len(part)==1)\n//          move(part[0]) sphere(r=1);\n//        else\n//          stroke(part);\n// Example(2D): Here the line is treated as a ray. \n//   hex = hexagon(r=15);\n//   line = [[0,0],[25,-7]];\n//   isect = polygon_line_intersection(hex,line,RAY);\n//   stroke(hex,closed=true);\n//   stroke(line,endcap2=\"arrow2\");\n//   color(\"red\")\n//     for(part=isect)\n//        if(len(part)==1)\n//          move(part[0]) circle(r=1,$fn=12);\n//        else\n//          stroke(part);\n// Example(2D): Here the intersection is a single point, which is returned as a single point \"path\" on the path list.\n//   hex = hexagon(r=15);\n//   line = [[15,-10],[15,13]];\n//   isect = polygon_line_intersection(hex,line,RAY);\n//   stroke(hex,closed=true);\n//   stroke(line,endcap2=\"arrow2\");\n//   color(\"red\")\n//     for(part=isect)\n//        if(len(part)==1)\n//          move(part[0]) circle(r=1,$fn=12);\n//        else\n//          stroke(part);\n// Example(2D): Another way to get a single segment\n//   hex = hexagon(r=15);\n//   line = rot(30,p=[[15,-10],[15,25]],cp=[15,0]);\n//   isect = polygon_line_intersection(hex,line,RAY);\n//   stroke(hex,closed=true);\n//   stroke(line,endcap2=\"arrow2\");\n//   color(\"red\")\n//     for(part=isect)\n//        if(len(part)==1)\n//          move(part[0]) circle(r=1,$fn=12);\n//        else\n//          stroke(part);\n// Example(2D): Single segment again\n//   star = star(r=15,n=8,step=2);\n//   line = [[20,-5],[-5,20]];\n//   isect = polygon_line_intersection(star,line,RAY);\n//   stroke(star,closed=true);\n//   stroke(line,endcap2=\"arrow2\");\n//   color(\"red\")\n//     for(part=isect)\n//        if(len(part)==1)\n//          move(part[0]) circle(r=1,$fn=12);\n//        else\n//          stroke(part);\n// Example(2D): Solution is two points\n//   star = star(r=15,n=8,step=3);\n//   line = rot(22.5,p=[[15,-10],[15,20]],cp=[15,0]);\n//   isect = polygon_line_intersection(star,line,SEGMENT);\n//   stroke(star,closed=true);\n//   stroke(line);\n//   color(\"red\")\n//     for(part=isect)\n//        if(len(part)==1)\n//          move(part[0]) circle(r=1,$fn=12);\n//        else\n//          stroke(part);\n// Example(2D): Solution is list of three segments\n//   star = star(r=25,ir=9,n=8);\n//   line = [[-25,12],[25,12]];\n//   isect = polygon_line_intersection(star,line);\n//   stroke(star,closed=true);\n//   stroke(line,endcaps=\"arrow2\");\n//   color(\"red\")\n//     for(part=isect)\n//        if(len(part)==1)\n//          move(part[0]) circle(r=1,$fn=12);\n//        else\n//          stroke(part);\n// Example(2D): Solution is a mixture of segments and points\n//   star = star(r=25,ir=9,n=7);\n//   line = [left(10,p=star[8]), right(50,p=star[8])];\n//   isect = polygon_line_intersection(star,line);\n//   stroke(star,closed=true);\n//   stroke(line,endcaps=\"arrow2\");\n//   color(\"red\")\n//     for(part=isect)\n//        if(len(part)==1)\n//          move(part[0]) circle(r=1,$fn=12);\n//        else\n//          stroke(part);\nfunction polygon_line_intersection(poly, line, bounded=false, nonzero=false, eps=EPSILON) =\n    assert( is_finite(eps) && eps>=0, \"The tolerance should be a positive number.\" )\n    assert(is_path(poly,dim=[2,3]), \"Invalid polygon.\" )\n    assert(is_bool(bounded) || is_bool_list(bounded,2), \"Invalid bound condition.\")\n    assert(_valid_line(line,dim=len(poly[0]),eps=eps), \"Line invalid or does not match polygon dimension.\" )\n    let(\n        bounded = force_list(bounded,2),\n        poly = deduplicate(poly)\n    )\n    len(poly[0])==2 ?  // planar case\n       let( \n            linevec = unit(line[1] - line[0]),\n            bound = 100*max(v_abs(flatten(pointlist_bounds(poly)))),\n            boundedline = [line[0] + (bounded[0]? 0 : -bound) * linevec,\n                           line[1] + (bounded[1]? 0 :  bound) * linevec],\n            parts = split_region_at_region_crossings(boundedline, [poly], closed1=false)[0][0],\n            inside = [\n                      if(point_in_polygon(parts[0][0], poly, nonzero=nonzero, eps=eps) == 0)\n                         [parts[0][0]],   // Add starting point if it is on the polygon\n                      for(part = parts)\n                         if (point_in_polygon(mean(part), poly, nonzero=nonzero, eps=eps) >=0 )\n                             part\n                         else if(len(part)==2 && point_in_polygon(part[1], poly, nonzero=nonzero, eps=eps) == 0)\n                             [part[1]]   // Add segment end if it is on the polygon\n                     ]\n        )\n        (len(inside)==0 ? undef : _merge_segments(inside, [inside[0]], eps))\n    : // 3d case\n       let(indices = _noncollinear_triple(poly))\n       indices==[] ? undef :   // Polygon is collinear\n       let(\n           plane = plane3pt(poly[indices[0]], poly[indices[1]], poly[indices[2]]),\n           plane_isect = plane_line_intersection(plane, line, bounded, eps)\n       )\n       is_undef(plane_isect) ? undef :  \n       is_vector(plane_isect,3) ?  \n           let(\n               poly2d = project_plane(plane,poly),\n               pt2d = project_plane(plane, plane_isect)\n           )\n           (point_in_polygon(pt2d, poly2d, nonzero=nonzero, eps=eps) < 0 ? undef : plane_isect)\n       : // Case where line is on the polygon plane\n           let(\n               poly2d = project_plane(plane, poly),\n               line2d = project_plane(plane, line),\n               segments = polygon_line_intersection(poly2d, line2d, bounded=bounded, nonzero=nonzero, eps=eps)\n           )\n           segments==undef ? undef\n         : [for(seg=segments) len(seg)==2 ? lift_plane(plane,seg) : [lift_plane(plane,seg[0])]];\n\nfunction _merge_segments(insegs,outsegs, eps, i=1) = \n    i==len(insegs) ? outsegs : \n    approx(last(last(outsegs)), insegs[i][0], eps) \n        ? _merge_segments(insegs, [each list_head(outsegs),[last(outsegs)[0],last(insegs[i])]], eps, i+1)\n        : _merge_segments(insegs, [each outsegs, insegs[i]], eps, i+1);\n\n\n\n// Function: polygon_triangulate()\n// Synopsis: Divide a polygon into triangles. \n// Topics: Geometry, Triangulation\n// See Also: vnf_triangulate()\n// Usage:\n//   triangles = polygon_triangulate(poly, [ind], [error], [eps])\n// Description:\n//   Given a simple polygon in 2D or 3D, triangulates it and returns a list \n//   of triples indexing into the polygon vertices. When the optional argument `ind` is \n//   given, it is used as an index list into `poly` to define the polygon vertices. In that case, \n//   `poly` may have a length greater than `ind`. When `ind` is undefined, all points in `poly` \n//   are considered as vertices of the polygon.\n//   .\n//   For 2d polygons, the output triangles will have the same winding (CW or CCW) of\n//   the input polygon. For 3d polygons, the triangle windings will induce a normal\n//   vector with the same direction of the polygon normal.\n//   .\n//   The function produce correct triangulations for some non-twisted non-simple polygons. \n//   A polygon is non-twisted iff it is simple or it has a partition in\n//   simple polygons with the same winding such that the intersection of any two partitions is\n//   made of full edges and/or vertices of both partitions. These polygons may have \"touching\" vertices \n//   (two vertices having the same coordinates, but distinct adjacencies) and \"contact\" edges \n//   (edges whose vertex pairs have the same pairwise coordinates but are in reversed order) but has \n//   no self-crossing. See examples bellow. If all polygon edges are contact edges (polygons with \n//   zero area), it returns an empty list for 2d polygons and reports an error for 3d polygons. \n//   Triangulation errors are reported either by an assert error (when `error=true`) or by returning \n//   `undef` (when `error=false`). Invalid arguments always produce an assert error.\n//   .\n//   Twisted polygons have no consistent winding and when input to this function usually reports \n//   an error but when an error is not reported the outputs are not correct triangulations. The function\n//   can work for 3d non-planar polygons if they are close enough to planar but may otherwise \n//   report an error for this case. \n// Arguments:\n//   poly = Array of the polygon vertices.\n//   ind = If given, a list of indices indexing the vertices of the polygon in `poly`.  Default: use all the points of poly\n//   error = If false, returns `undef` when the polygon cannot be triangulated; otherwise, issues an assert error. Default: true.\n//   eps = A maximum tolerance in geometrical tests. Default: EPSILON\n// Example(2D,NoAxes): a simple polygon; see from above\n//   poly = star(id=10, od=15,n=11);\n//   tris =  polygon_triangulate(poly);\n//   color(\"lightblue\") for(tri=tris) polygon(select(poly,tri));\n//   color(\"blue\")    up(1) for(tri=tris) { stroke(select(poly,tri),.15,closed=true); }\n//   color(\"magenta\") up(2) stroke(poly,.25,closed=true); \n//   color(\"black\")   up(3) debug_vnf([path3d(poly),[]],faces=false,size=1);\n// Example(2D,NoAxes): a polygon with a hole and one \"contact\" edge; see from above\n//   poly = [ [-10,0], [10,0], [0,10], [-10,0], [-4,4], [4,4], [0,2], [-4,4] ];\n//   tris =  polygon_triangulate(poly);\n//   color(\"lightblue\") for(tri=tris) polygon(select(poly,tri));\n//   color(\"blue\")    up(1) for(tri=tris) { stroke(select(poly,tri),.15,closed=true); }\n//   color(\"magenta\") up(2) stroke(poly,.25,closed=true); \n//   color(\"black\")   up(3) debug_vnf([path3d(poly),[]],faces=false,size=1);\n// Example(2D,NoAxes): a polygon with \"touching\" vertices and no holes; see from above\n//   poly = [ [0,0], [5,5], [-5,5], [0,0], [-5,-5], [5,-5] ];\n//   tris =  polygon_triangulate(poly);\n//   color(\"lightblue\") for(tri=tris) polygon(select(poly,tri));\n//   color(\"blue\")    up(1) for(tri=tris) { stroke(select(poly,tri),.15,closed=true); }\n//   color(\"magenta\") up(2) stroke(poly,.25,closed=true); \n//   color(\"black\")   up(3) debug_vnf([path3d(poly),[]],faces=false,size=1);\n// Example(2D,NoAxes): a polygon with \"contact\" edges and no holes; see from above\n//   poly = [ [0,0], [10,0], [10,10], [0,10], [0,0], [3,3], [7,3], \n//            [7,7], [7,3], [3,3] ];\n//   tris =  polygon_triangulate(poly);\n//   color(\"lightblue\") for(tri=tris) polygon(select(poly,tri));\n//   color(\"blue\")    up(1) for(tri=tris) { stroke(select(poly,tri),.15,closed=true); }\n//   color(\"magenta\") up(2) stroke(poly,.25,closed=true); \n//   color(\"black\")   up(3) debug_vnf([path3d(poly),[]],faces=false,size=1);\n// Example(3D): \n//   include <BOSL2/polyhedra.scad>\n//   vnf = regular_polyhedron_info(name=\"dodecahedron\",side=5,info=\"vnf\");\n//   vnf_polyhedron(vnf);\n//   vnf_tri = [vnf[0], [for(face=vnf[1]) each polygon_triangulate(vnf[0], face) ] ];\n//   color(\"blue\")\n//   vnf_wireframe(vnf_tri, width=.15);\nfunction polygon_triangulate(poly, ind, error=true, eps=EPSILON) =\n    assert(is_path(poly) && len(poly)>=3, \"Polygon `poly` should be a list of at least three 2d or 3d points\")\n    assert(is_undef(ind) || (is_vector(ind) && min(ind)>=0 && max(ind)<len(poly) ),\n           \"Improper or out of bounds list of indices\")\n    let( ind = is_undef(ind) ? count(len(poly)) : ind )\n    len(ind) <=2 ? [] :\n    len(ind) == 3 \n      ? _degenerate_tri([poly[ind[0]], poly[ind[1]], poly[ind[2]]], eps) ? [] : \n        // non zero area\n        let( degen = norm(scalar_vec3(cross(poly[ind[1]]-poly[ind[0]], poly[ind[2]]-poly[ind[0]]))) < 2*eps )\n        assert( ! error || ! degen, \"The polygon vertices are collinear.\") \n        degen ? undef : [ind]\n      : len(poly[ind[0]]) == 3 \n          ? // find a representation of the polygon as a 2d polygon by projecting it on its own plane\n            let( \n                ind = deduplicate_indexed(poly, ind, eps) \n            )\n            len(ind)<3 ? [] :\n            let(\n                pts = select(poly,ind),\n                nrm = -polygon_normal(pts)\n            )\n            assert( ! error || (nrm != undef), \n                    \"The polygon has self-intersections or zero area or its vertices are collinear or non coplanar.\") \n            nrm == undef ? undef :\n            let(\n                imax  = max_index([for(p=pts) norm(p-pts[0]) ]),\n                v1    = unit( pts[imax] - pts[0] ),\n                v2    = cross(v1,nrm),\n                prpts = pts*transpose([v1,v2]) // the 2d projection of pts on the polygon plane\n            )\n            let( tris = _triangulate(prpts, count(len(ind)), error, eps) )\n            tris == undef ? undef :\n            [for(tri=tris) select(ind,tri) ]\n          : is_polygon_clockwise(select(poly, ind)) \n              ? _triangulate( poly, ind, error, eps )\n              : let( tris = _triangulate( poly, reverse(ind), error, eps ) )\n                tris == undef ? undef :\n                [for(tri=tris) reverse(tri) ];\n\n\n// poly is supposed to be a 2d cw polygon\n// implements a modified version of ear cut method for non-twisted polygons\n// the polygons accepted by this function are those decomposable in simple\n// CW polygons.\nfunction _triangulate(poly, ind,  error, eps=EPSILON, tris=[]) =\n    len(ind)==3 \n    ?   _degenerate_tri(select(poly,ind),eps) \n        ?   tris // if last 3 pts perform a degenerate triangle, ignore it\n        :   concat(tris,[ind]) // otherwise, include it\n    :   let( ear = _get_ear(poly,ind,eps) )\n        assert( ! error || (ear != undef), \n            \"The polygon has twists or all its vertices are collinear or non coplanar.\") \n        ear == undef ? undef :\n        is_list(ear) // is it a degenerate ear ?\n        ?   len(ind) <= 4 ? tris :\n            _triangulate(poly, select(ind,ear[0]+3, ear[0]), error, eps, tris) // discard it\n        :   let(\n                ear_tri = select(ind,ear,ear+2),\n                indr    = select(ind,ear+2, ear) //  indices of the remaining path\n            )\n            _triangulate(poly, indr, error, eps, concat(tris,[ear_tri]));\n\n\n// a returned ear will be:\n// 1. a CW non-reflex triangle, made of subsequent poly vertices, without any other \n//    poly points inside except possibly at its own vertices\n// 2. or a degenerate triangle where two vertices are coincident\n// the returned ear is specified by the index of `ind` of its first vertex\nfunction _get_ear(poly, ind,  eps, _i=0) =\n    let( lind = len(ind) )\n    lind==3 ? 0 :\n    let( // the _i-th ear candidate\n        p0 = poly[ind[_i]],\n        p1 = poly[ind[(_i+1)%lind]],\n        p2 = poly[ind[(_i+2)%lind]]\n    )\n    // if vertex p1 is a convex candidate to be an ear,\n    // check if the triangle [p0,p1,p2] contains any other point\n    // except possibly p0 and p2\n    // exclude the ear candidate central vertex p1 from the verts to check \n    _tri_class([p0,p1,p2],eps) > 0  \n    &&  _none_inside(select(ind,_i+2, _i),poly,p0,p1,p2,eps) ? _i : // found an ear\n    // otherwise check the next ear candidate \n    _i<lind-1 ?  _get_ear(poly, ind,  eps, _i=_i+1) :\n    // poly has no ears, look for wiskers\n    let( wiskers = [for(j=idx(ind)) if(norm(poly[ind[j]]-poly[ind[(j+2)%lind]])<eps) j ] )\n    wiskers==[] ? undef : [wiskers[0]];\n    \n    \n\n// returns false ASA it finds some reflex vertex of poly[idxs[.]] \n// inside the triangle different from p0 and p2\n// note: to simplify the expressions it is assumed that the input polygon has no twists \nfunction _none_inside(idxs,poly,p0,p1,p2,eps,i=0) =\n    i>=len(idxs) ? true :\n    let( \n        vert      = poly[idxs[i]], \n        prev_vert = poly[select(idxs,i-1)], \n        next_vert = poly[select(idxs,i+1)]\n    )\n    // check if vert prevent [p0,p1,p2] to be an ear\n    // this conditions might have a simpler expression\n    _tri_class([prev_vert, vert, next_vert],eps) <= 0  // reflex condition\n    &&  (  // vert is a cw reflex poly vertex inside the triangle [p0,p1,p2]\n          ( _tri_class([p0,p1,vert],eps)>0 && \n            _tri_class([p1,p2,vert],eps)>0 && \n            _tri_class([p2,p0,vert],eps)>=0  )\n          // or it is equal to p1 and some of its adjacent edges cross the open segment (p0,p2)\n          ||  ( norm(vert-p1) < eps \n                && _is_at_left(p0,[prev_vert,p1],eps) && _is_at_left(p2,[p1,prev_vert],eps) \n                && _is_at_left(p2,[p1,next_vert],eps) && _is_at_left(p0,[next_vert,p1],eps) \n              ) \n        )\n    ?   false\n    :   _none_inside(idxs,poly,p0,p1,p2,eps,i=i+1);\n\n\n// Function: is_polygon_clockwise()\n// Synopsis: Determine if a 2d polygon winds clockwise.  \n// Topics: Geometry, Polygons, Clockwise\n// See Also: clockwise_polygon(), ccw_polygon(), reverse_polygon()\n// Usage:\n//   bool = is_polygon_clockwise(poly);\n// Description:\n//   Return true if the given 2D simple polygon is in clockwise order, false otherwise.\n//   Results for complex (self-intersecting) polygon are indeterminate.\n// Arguments:\n//   poly = The list of 2D path points for the perimeter of the polygon.\n\n// For algorithm see 2.07 here: http://www.faqs.org/faqs/graphics/algorithms-faq/\nfunction is_polygon_clockwise(poly) =\n    assert(is_path(poly,dim=2), \"Input should be a 2d path\")\n    let(\n        minx = min(poly*[1,0]),\n        lowind = search(minx, poly, 0, 0),\n        lowpts = select(poly,lowind),\n        miny = min(lowpts*[0,1]),\n        extreme_sub = search(miny, lowpts, 1, 1)[0],\n        extreme = lowind[extreme_sub]\n    )\n    cross(select(poly,extreme+1)-poly[extreme],\n          select(poly,extreme-1)-poly[extreme])<0;\n\n\n// Function: clockwise_polygon()\n// Synopsis: Return clockwise version of a polygon. \n// Topics: Geometry, Polygons, Clockwise\n// See Also: is_polygon_clockwise(), ccw_polygon(), reverse_polygon()\n// Usage:\n//   newpoly = clockwise_polygon(poly);\n// Description:\n//   Given a 2D polygon path, returns the clockwise winding version of that path.\n// Arguments:\n//   poly = The list of 2D path points for the perimeter of the polygon.\nfunction clockwise_polygon(poly) =\n    assert(is_path(poly,dim=2), \"Input should be a 2d polygon\")\n    is_polygon_clockwise(poly) ? poly : reverse_polygon(poly);\n\n\n// Function: ccw_polygon()\n// Synopsis: Return counter-clockwise version of a polygon. \n// Topics: Geometry, Polygons, Clockwise\n// See Also: is_polygon_clockwise(), clockwise_polygon(), reverse_polygon()\n// Usage:\n//   newpoly = ccw_polygon(poly);\n// Description:\n//   Given a 2D polygon poly, returns the counter-clockwise winding version of that poly.\n// Arguments:\n//   poly = The list of 2D path points for the perimeter of the polygon.\nfunction ccw_polygon(poly) =\n    assert(is_path(poly,dim=2), \"Input should be a 2d polygon\")\n    is_polygon_clockwise(poly) ? reverse_polygon(poly) : poly;\n\n\n// Function: reverse_polygon()\n// Synopsis: Reverse winding direction of polygon. \n// Topics: Geometry, Polygons, Clockwise\n// See Also: is_polygon_clockwise(), ccw_polygon(), clockwise_polygon()\n// Usage:\n//   newpoly = reverse_polygon(poly)\n// Description:\n//   Reverses a polygon's winding direction, while still using the same start point.\n// Arguments:\n//   poly = The list of the path points for the perimeter of the polygon.\nfunction reverse_polygon(poly) =\n    let(poly=force_path(poly,\"poly\"))\n    assert(is_path(poly), \"Input should be a polygon\")\n    [ poly[0], for(i=[len(poly)-1:-1:1]) poly[i] ];\n\n\n// Function: reindex_polygon()\n// Synopsis: Adjust point indexing of polygon to minimize pointwise distance to a reference polygon. \n// Topics: Geometry, Polygons\n// See Also: reindex_polygon(), align_polygon(), are_polygons_equal()\n// Usage:\n//   newpoly = reindex_polygon(reference, poly);\n// Description:\n//   Rotates and possibly reverses the point order of a 2d or 3d polygon path to optimize its pairwise point\n//   association with a reference polygon.  The two polygons must have the same number of vertices and be the same dimension.\n//   The optimization is done by computing the distance, norm(reference[i]-poly[i]), between\n//   corresponding pairs of vertices of the two polygons and choosing the polygon point index rotation that\n//   makes the total sum over all pairs as small as possible.  Returns the reindexed polygon.  Note\n//   that the geometry of the polygon is not changed by this operation, just the labeling of its\n//   vertices.  If the input polygon is 2d and is oriented opposite the reference then its point order is\n//   reversed.\n// Arguments:\n//   reference = reference polygon path\n//   poly = input polygon to reindex\n// Example(2D):  The red dots show the 0th entry in the two input path lists.  Note that the red dots are not near each other.  The blue dot shows the 0th entry in the output polygon\n//   pent = subdivide_path([for(i=[0:4])[sin(72*i),cos(72*i)]],30);\n//   circ = circle($fn=30,r=2.2);\n//   reindexed = reindex_polygon(circ,pent);\n//   move_copies(concat(circ,pent)) circle(r=.1,$fn=32);\n//   color(\"red\") move_copies([pent[0],circ[0]]) circle(r=.1,$fn=32);\n//   color(\"blue\") translate(reindexed[0])circle(r=.1,$fn=32);\n// Example(2D): The indexing that minimizes the total distance will not necessarily associate the nearest point of `poly` with the reference, as in this example where again the blue dot indicates the 0th entry in the reindexed result.\n//   pent = move([3.5,-1],p=subdivide_path([for(i=[0:4])[sin(72*i),cos(72*i)]],30));\n//   circ = circle($fn=30,r=2.2);\n//   reindexed = reindex_polygon(circ,pent);\n//   move_copies(concat(circ,pent)) circle(r=.1,$fn=32);\n//   color(\"red\") move_copies([pent[0],circ[0]]) circle(r=.1,$fn=32);\n//   color(\"blue\") translate(reindexed[0])circle(r=.1,$fn=32);\nfunction reindex_polygon(reference, poly, return_error=false) =\n    let(reference=force_path(reference,\"reference\"),\n        poly=force_path(poly,\"poly\"))\n    assert(is_path(reference) && is_path(poly,dim=len(reference[0])),\n           \"Invalid polygon(s) or incompatible dimensions. \" )\n    assert(len(reference)==len(poly), \"The polygons must have the same length.\")\n    let(\n        dim = len(reference[0]),\n        N = len(reference),\n        fixpoly = dim != 2? poly :\n                  is_polygon_clockwise(reference)\n                  ? clockwise_polygon(poly)\n                  : ccw_polygon(poly),\n        I   = [for(i=reference) 1],\n        val = [ for(k=[0:N-1])\n                    [for(i=[0:N-1])\n                      norm(reference[i]-fixpoly[(i+k)%N]) ] ]*I,\n        min_ind = min_index(val),\n        optimal_poly = list_rotate(fixpoly, min_ind)\n    )\n    return_error? [optimal_poly, val[min_ind]] :\n    optimal_poly;\n\n\n// Function: align_polygon()\n// Synopsis: Find best alignment of a 2d polygon to a reference 2d polygon over a set of transformations.  \n// Topics: Geometry, Polygons\n// See Also: reindex_polygon(), align_polygon(), are_polygons_equal()\n// Usage:\n//   newpoly = align_polygon(reference, poly, [angles], [cp], [tran], [return_ind]);\n// Description:\n//   Find the best alignment of a specified 2D polygon with a reference 2D polygon over a set of\n//   transformations.  You can specify a list or range of angles and a centerpoint or you can\n//   give a list of arbitrary 2d transformation matrices.  For each transformation or angle, the polygon is\n//   reindexed, which is a costly operation so if run time is a problem, use a smaller sampling of angles or\n//   transformations.  By default returns the rotated and reindexed polygon.  You can also request that\n//   the best angle or the index into the transformation list be returned.  \n// Arguments:\n//   reference = reference polygon\n//   poly = polygon to rotate into alignment with the reference\n//   angles = list or range of angles to test\n//   cp = centerpoint for rotations\n//   ---\n//   tran = list of 2D transformation matrices to optimize over\n//   return_ind = if true, return the best angle (if you specified angles) or the index into tran otherwise of best alignment\n// Example(2D): Rotating the poorly aligned light gray triangle by 105 degrees produces the best alignment, shown in blue:\n//   ellipse = yscale(3,circle(r=10, $fn=32));\n//   tri = move([-50/3,-9],\n//              subdivide_path([[0,0], [50,0], [0,27]], 32));\n//   aligned = align_polygon(ellipse,tri, [0:5:180]);\n//   color(\"white\")stroke(tri,width=.5,closed=true);\n//   stroke(ellipse, width=.5, closed=true);\n//   color(\"blue\")stroke(aligned,width=.5,closed=true);\n// Example(2D,NoAxes): Translating a triangle (light gray) to the best alignment (blue)\n//   ellipse = yscale(2,circle(r=10, $fn=32));\n//   tri = subdivide_path([[0,0], [27,0], [-7,50]], 32);\n//   T = [for(x=[-10:0], y=[-30:-15]) move([x,y])];\n//   aligned = align_polygon(ellipse,tri, trans=T);\n//   color(\"white\")stroke(tri,width=.5,closed=true);\n//   stroke(ellipse, width=.5, closed=true);\n//   color(\"blue\")stroke(aligned,width=.5,closed=true);\nfunction align_polygon(reference, poly, angles, cp, trans, return_ind=false) =\n    let(reference=force_path(reference,\"reference\"),\n        poly=force_path(poly,\"poly\"))\n    assert(is_undef(trans) || (is_undef(angles) && is_undef(cp)), \"Cannot give both angles/cp and trans as input\")\n    let(\n        trans = is_def(trans) ? trans :\n            assert( (is_vector(angles) && len(angles)>0) || valid_range(angles),\n                \"The `angle` parameter must be a range or a non void list of numbers.\")\n            [for(angle=angles) zrot(angle,cp=cp)]\n    )\n    assert(is_path(reference,dim=2), \"reference must be a 2D polygon\")\n    assert(is_path(poly,dim=2), \"poly must be a 2D polygon\")\n    assert(len(reference)==len(poly), \"The polygons must have the same length.\")\n    let(     // alignments is a vector of entries of the form: [polygon, error]\n        alignments = [\n            for(T=trans)\n              reindex_polygon(\n                  reference,\n                  apply(T,poly),\n                  return_error=true\n              )\n        ],\n        scores = column(alignments,1),\n        minscore = min(scores),\n        minind = [for(i=idx(scores)) if (scores[i]<minscore+EPSILON) i],\n        dummy = is_def(angles) ? echo(best_angles = select(list(angles), minind)):0,\n        best = minind[0]\n    )\n    return_ind ? (is_def(angles) ? list(angles)[best] : best)\n    : alignments[best][0];\n    \n\n// Function: are_polygons_equal()\n// Synopsis: Check if two polygons (not necessarily in the same point order) are equal.  \n// Topics: Geometry, Polygons, Comparators\n// See Also: reindex_polygon(), align_polygon(), are_polygons_equal()\n// Usage:\n//    bool = are_polygons_equal(poly1, poly2, [eps])\n// Description:\n//    Returns true if poly1 and poly2 are the same polongs\n//    within given epsilon tolerance.\n// Arguments:\n//    poly1 = first polygon\n//    poly2 = second polygon\n//    eps = tolerance for comparison\n// Example(NORENDER):\n//    are_polygons_equal(pentagon(r=4),\n//                   rot(360/5, p=pentagon(r=4))); // returns true\n//    are_polygons_equal(pentagon(r=4),\n//                   rot(90, p=pentagon(r=4)));    // returns false\nfunction are_polygons_equal(poly1, poly2, eps=EPSILON) =\n    let(\n        poly1 = list_unwrap(poly1),\n        poly2 = list_unwrap(poly2),\n        l1 = len(poly1),\n        l2 = len(poly2)\n    ) l1 != l2 ? false :\n    let( maybes = find_approx(poly1[0], poly2, eps=eps, all=true) )\n    maybes == []? false :\n    [for (i=maybes) if (_are_polygons_equal(poly1, poly2, eps, i)) 1] != [];\n\nfunction _are_polygons_equal(poly1, poly2, eps, st) =\n    max([for(d=poly1-select(poly2,st,st-1)) d*d])<eps*eps;\n\n\n/// Function: _is_polygon_in_list()\n/// Topics: Polygons, Comparators\n/// See Also: are_polygons_equal(), are_regions_equal()\n/// Usage:\n///   bool = _is_polygon_in_list(poly, polys);\n/// Description:\n///   Returns true if one of the polygons in `polys` is equivalent to the polygon `poly`.\n/// Arguments:\n///   poly = The polygon to search for.\n///   polys = The list of polygons to look for the polygon in.\nfunction _is_polygon_in_list(poly, polys) =\n    ___is_polygon_in_list(poly, polys, 0);\n\nfunction ___is_polygon_in_list(poly, polys, i) =\n    i >= len(polys)? false :\n    are_polygons_equal(poly, polys[i])? true :\n    ___is_polygon_in_list(poly, polys, i+1);\n\n\n// Section: Convex Hull\n\n// This section originally based on Oskar Linde's Hull:\n//   - https://github.com/openscad/scad-utils\n\n\n// Function: hull()\n// Synopsis: Convex hull of a list of 2d or 3d points.\n// SynTags: Ext\n// Topics: Geometry, Hulling\n// See Also: hull_points(), hull2d_path(), hull3d_faces()\n// Usage:\n//   face_list_or_index_list = hull(points);\n// Description:\n//   Takes a list of 2D or 3D points (but not both in the same list) and returns either the list of\n//   indexes into `points` that forms the 2D convex hull perimeter path, or the list of faces that\n//   form the 3d convex hull surface.  Each face is a list of indexes into `points`.  If the input\n//   points are co-linear, the result will be the indexes of the two extrema points.  If the input\n//   points are co-planar, the results will be a simple list of vertex indices that will form a planar\n//   perimeter.  Otherwise a list of faces will be returned, where each face is a simple list of\n//   vertex indices for the perimeter of the face.\n// Arguments:\n//   points = The set of 2D or 3D points to find the hull of.\nfunction hull(points) =\n    assert(is_path(points),\"Invalid input to hull\")\n    len(points[0]) == 2\n      ? hull2d_path(points)\n      : hull3d_faces(points);\n\n\n// Module: hull_points()\n// Synopsis: Convex hull of a list of 2d or 3d points.  \n// Topics: Geometry, Hulling\n// See Also: hull(), hull_points(), hull2d_path(), hull3d_faces()\n// Usage:\n//   hull_points(points, [fast]);\n// Description:\n//   If given a list of 2D points, creates a 2D convex hull polygon that encloses all those points.\n//   If given a list of 3D points, creates a 3D polyhedron that encloses all the points.  This should\n//   handle about 4000 points in slow mode.  If `fast` is set to true, this should be able to handle\n//   far more.  When fast mode is off, 3d hulls that lie in a plane will produce a single face of a polyhedron, which can be viewed in preview but will not render.  \n// Arguments:\n//   points = The list of points to form a hull around.\n//   fast = If true for 3d case, uses a faster cheat that may handle more points, but also may emit warnings that can stop your script if you have \"Halt on first warning\" enabled.  Ignored for the 2d case.  Default: false\n// Example(2D):\n//   pts = [[-10,-10], [0,10], [10,10], [12,-10]];\n//   hull_points(pts);\n// Example(3D):\n//   pts = [for (phi = [30:60:150], theta = [0:60:359]) spherical_to_xyz(10, theta, phi)];\n//   hull_points(pts);\nmodule hull_points(points, fast=false) {\n    no_children($children);\n    check = assert(is_path(points))\n            assert(len(points)>=3, \"Point list must contain 3 points\");\n    attachable(){\n      if (len(points[0])==2)\n         hull() polygon(points=points);\n      else if (len(points)==3)\n         polyhedron(points=points, faces=[[0,1,2]]);\n      else {\n        if (fast) {\n           extra = len(points)%3;\n           faces = [\n                     [for(i=[0:1:extra+2])i], // If vertex count not divisible by 3, combine extras with first 3\n                     for(i=[extra+3:3:len(points)-3])[i,i+1,i+2]\n                   ];\n           hull() polyhedron(points=points, faces=faces);\n        } else {\n          faces = hull(points);\n          if (is_num(faces[0])){\n            if (len(faces)<=2) echo(\"Hull contains only two points\");\n            else polyhedron(points=points, faces=[faces]);\n          }\n          else polyhedron(points=points, faces=faces);\n        }\n      }\n      union();\n    }\n}\n\n\n\nfunction _backtracking(i,points,h,t,m,all) =\n    m<t || _is_cw(points[i], points[h[m-1]], points[h[m-2]],all) ? m :\n    _backtracking(i,points,h,t,m-1,all) ;\n\n// clockwise check (2d)\nfunction _is_cw(a,b,c,all) = \n    all ? cross(a-c,b-c)<=EPSILON*norm(a-c)*norm(b-c) :\n    cross(a-c,b-c)<-EPSILON*norm(a-c)*norm(b-c);\n\n\n// Function: hull2d_path()\n// Synopsis: Convex hull of a list of 2d points. \n// Topics: Geometry, Hulling\n// See Also: hull(), hull_points(), hull2d_path(), hull3d_faces()\n// Usage:\n//   index_list = hull2d_path(points,all)\n// Description:\n//   Takes a list of arbitrary 2D points, and finds the convex hull polygon to enclose them.\n//   Returns a path as a list of indices into `points`. \n//   When all==true, returns extra points that are on edges of the hull.\n// Arguments:\n//   points = list of 2d points to get the hull of.\n//   all = when true, includes all points on the edges of the convex hull. Default: false.\n// Example(2D):\n//   pts = [[-10,-10], [0,10], [10,10], [12,-10]];\n//   path = hull2d_path(pts);\n//   move_copies(pts) color(\"red\") circle(1,$fn=12);\n//   polygon(points=pts, paths=[path]);\n//\n// Code based on this method:\n// https://www.hackerearth.com/practice/math/geometry/line-sweep-technique/tutorial/\n//\nfunction hull2d_path(points, all=false) =\n    assert(is_path(points,2),\"Invalid input to hull2d_path\")\n    len(points) < 2 ? [] :\n    let( n  = len(points), \n         ip = sortidx(points) )\n    // lower hull points\n    let( lh = \n            [ for(   i = 2,\n                    k = 2, \n                    h = [ip[0],ip[1]]; // current list of hull point indices \n                  i <= n;\n                    k = i<n ? _backtracking(ip[i],points,h,2,k,all)+1 : k,\n                    h = i<n ? [for(j=[0:1:k-2]) h[j], ip[i]] : [], \n                    i = i+1\n                 ) if( i==n ) h ][0] )\n    // concat lower hull points with upper hull ones\n    [ for(   i = n-2,\n            k = len(lh), \n            t = k+1,\n            h = lh; // current list of hull point indices \n          i >= -1;\n            k = i>=0 ? _backtracking(ip[i],points,h,t,k,all)+1 : k,\n            h = [for(j=[0:1:k-2]) h[j], if(i>0) ip[i]],\n            i = i-1\n         ) if( i==-1 ) h ][0] ;\n       \n\nfunction _hull_collinear(points) =\n    let(\n        a = points[0],\n        i = max_index([for(pt=points) norm(pt-a)]),\n        n = points[i] - a\n    )\n    norm(n)==0 ? [0]\n    :\n    let(\n        points1d = [ for(p = points) (p-a)*n ],\n        min_i = min_index(points1d),\n        max_i = max_index(points1d)\n    ) [min_i, max_i];\n\n\n\n// Function: hull3d_faces()\n// Synopsis: Convex hull of a list of 3d points. \n// Topics: Geometry, Hulling\n// See Also: hull(), hull_points(), hull2d_path(), hull3d_faces()\n// Usage:\n//   faces = hull3d_faces(points)\n// Description:\n//   Takes a list of arbitrary 3D points, and finds the convex hull polyhedron to enclose\n//   them.  Returns a list of triangular faces, where each face is a list of indexes into the given `points`\n//   list.  The output will be valid for use with the polyhedron command, but may include vertices that are in the interior of a face of the hull, so it is not\n//   necessarily the minimal representation of the hull.  \n//   If all points passed to it are coplanar, then the return is the list of indices of points\n//   forming the convex hull polygon.\n// Example(3D):\n//   pts = [[-20,-20,0], [20,-20,0], [0,20,5], [0,0,20]];\n//   faces = hull3d_faces(pts);\n//   move_copies(pts) color(\"red\") sphere(1);\n//   %polyhedron(points=pts, faces=faces);\nfunction hull3d_faces(points) =\n    assert(is_path(points,3),\"Invalid input to hull3d_faces\")\n    len(points) < 3 ? count(len(points))\n  : let ( // start with a single non-collinear triangle\n          tri = _noncollinear_triple(points, error=false)\n        )\n    tri==[] ? _hull_collinear(points)\n  : let(\n        a = tri[0],\n        b = tri[1],\n        c = tri[2],\n        plane = plane3pt_indexed(points, a, b, c),\n        d = _find_first_noncoplanar(plane, points)\n    )\n    d == len(points)\n  ? /* all coplanar*/\n    let (\n        pts2d =  project_plane([points[a], points[b], points[c]],points),\n        hull2d = hull2d_path(pts2d)\n    ) hull2d\n  : let(\n        remaining = [for (i = [0:1:len(points)-1]) if (i!=a && i!=b && i!=c && i!=d) i],\n        // Build an initial tetrahedron.\n        // Swap b, c if d is in front of triangle t.\n        ifop = _is_point_above_plane(plane, points[d]),\n        bc = ifop? [c,b] : [b,c],\n        b = bc[0],\n        c = bc[1],\n        triangles = [\n            [a,b,c],\n            [d,b,a],\n            [c,d,a],\n            [b,d,c]\n        ],\n        // calculate the plane equations\n        planes = [ for (t = triangles) plane3pt_indexed(points, t[0], t[1], t[2]) ]\n    ) _hull3d_iterative(points, triangles, planes, remaining);\n\n\n// Adds the remaining points one by one to the convex hull\nfunction _hull3d_iterative(points, triangles, planes, remaining, _i=0) = //let( EPSILON=1e-12 )\n    _i >= len(remaining) ? triangles : \n    let (\n        // pick a point\n        i = remaining[_i],\n        // evaluate the triangle plane equations at point i\n        planeq_val = planes*[each points[i], -1],\n        // find the triangles that are in conflict with the point (point not inside)\n        conflicts = [for (i = [0:1:len(planeq_val)-1]) if (planeq_val[i]>EPSILON) i ],\n        // collect the halfedges of all triangles that are in conflict \n        halfedges = [ \n            for(c = conflicts, i = [0:2])\n                [triangles[c][i], triangles[c][(i+1)%3]]\n        ],\n        // find the outer perimeter of the set of conflicting triangles\n        horizon = _remove_internal_edges(halfedges),\n        // generate new triangles connecting point i to each horizon halfedge vertices\n        tri2add = [ for (h = horizon) concat(h,i) ],\n        // add tria2add and remove conflict triangles\n        new_triangles = \n            concat( tri2add,\n                    [ for (i = [0:1:len(planes)-1]) if (planeq_val[i]<=EPSILON) triangles[i] ] \n                  ),\n        // add the plane equations of new added triangles and remove the plane equations of the conflict ones\n        new_planes = \n            [ for (t = tri2add) plane3pt_indexed(points, t[0], t[1], t[2]) ,\n              for (i = [0:1:len(planes)-1]) if (planeq_val[i]<=EPSILON) planes[i] ] \n    ) _hull3d_iterative(\n        points,\n        new_triangles,\n        new_planes,\n        remaining,\n        _i+1\n    );\n\n\nfunction _remove_internal_edges(halfedges) = [\n    for (h = halfedges)  \n        if (!in_list(reverse(h), halfedges))\n            h\n];\n\nfunction _find_first_noncoplanar(plane, points, i=0) = \n    (i >= len(points) || !are_points_on_plane([points[i]],plane))? i :\n    _find_first_noncoplanar(plane, points, i+1);\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n\n\n\n\n// Section: Convex Sets\n\n\n// Function: is_polygon_convex()\n// Synopsis: Check if a polygon is convex. \n// Topics: Geometry, Convexity, Test\n// See Also: clockwise_polygon(), ccw_polygon()\n// Usage:\n//   bool = is_polygon_convex(poly, [eps]);\n// Description:\n//   Returns true if the given 2D or 3D polygon is convex.\n//   The result is meaningless if the polygon is not simple (self-crossing) or non coplanar.\n//   If the points are collinear or not coplanar an error may be generated.\n// Arguments:\n//   poly = Polygon to check.\n//   eps = Tolerance for the collinearity and coplanarity tests. Default: EPSILON.\n// Example:\n//   test1 = is_polygon_convex(circle(d=50));                                 // Returns: true\n//   test2 = is_polygon_convex(rot([50,120,30], p=path3d(circle(1,$fn=50)))); // Returns: true\n//   spiral = [for (i=[0:36]) let(a=-i*10) (10+i)*[cos(a),sin(a)]];\n//   test = is_polygon_convex(spiral);                                        // Returns: false\nfunction is_polygon_convex(poly,eps=EPSILON) =\n    assert(is_path(poly), \"The input should be a 2D or 3D polygon.\" )\n    let(\n        lp = len(poly),\n        p0 = poly[0]\n    )\n    assert( lp>=3 , \"A polygon must have at least 3 points\" )\n    let( crosses = [for(i=[0:1:lp-1]) cross(poly[(i+1)%lp]-poly[i], poly[(i+2)%lp]-poly[(i+1)%lp]) ] )\n    len(p0)==2\n      ? let( size = max([for(p=poly) norm(p-p0)]), tol=pow(size,2)*eps )\n        assert( size>eps, \"The polygon is self-crossing or its points are collinear\" )\n        min(crosses) >=-tol || max(crosses)<=tol\n      : let( ip = _noncollinear_triple(poly,error=false,eps=eps) )\n        assert( ip!=[], \"The points are collinear\")\n        let( \n            crx   = cross(poly[ip[1]]-poly[ip[0]],poly[ip[2]]-poly[ip[1]]),\n            nrm   = crx/norm(crx),\n            plane = concat(nrm, nrm*poly[0]), \n            prod  = crosses*nrm,\n            size  = norm(poly[ip[1]]-poly[ip[0]]),\n            tol   = pow(size,2)*eps\n        )\n        assert(_pointlist_greatest_distance(poly,plane) < size*eps, \"The polygon points are not coplanar\")\n        let(\n            minc = min(prod),\n            maxc = max(prod) ) \n        minc>=-tol || maxc<=tol;\n\n\n// Function: convex_distance()\n// Synopsis: Compute distance between convex hull of two point lists. \n// Topics: Geometry, Convexity, Distance\n// See also: convex_collision(), hull()\n// Usage:\n//   dist = convex_distance(points1, points2,eps);\n// Description:\n//   Returns the smallest distance between a point in convex hull of `points1`\n//   and a point in the convex hull of `points2`. All the points in the lists\n//   should have the same dimension, either 2D or 3D.\n//   A zero result means the hulls intercept whithin a tolerance `eps`.\n// Arguments:\n//   points1 = first list of 2d or 3d points.\n//   points2 = second list of 2d or 3d points.\n//   eps = tolerance in distance evaluations. Default: EPSILON.\n// Example(2D):\n//    pts1 = move([-3,0], p=square(3,center=true));\n//    pts2 = rot(a=45, p=square(2,center=true));\n//    pts3 = [ [2,0], [1,2],[3,2], [3,-2], [1,-2] ];\n//    polygon(pts1);\n//    polygon(pts2);\n//    polygon(pts3);\n//    echo(convex_distance(pts1,pts2)); // Returns: 0.0857864\n//    echo(convex_distance(pts2,pts3)); // Returns: 0\n// Example(3D):\n//    sphr1 = sphere(2,$fn=10);\n//    sphr2 = move([4,0,0], p=sphr1);\n//    sphr3 = move([4.5,0,0], p=sphr1);\n//    vnf_polyhedron(sphr1);\n//    vnf_polyhedron(sphr2);\n//    echo(convex_distance(sphr1[0], sphr2[0])); // Returns: 0\n//    echo(convex_distance(sphr1[0], sphr3[0])); // Returns: 0.5\nfunction convex_distance(points1, points2, eps=EPSILON) =\n    assert(is_matrix(points1) && is_matrix(points2,undef,len(points1[0])), \n           \"The input lists should be compatible consistent non empty lists of points.\")\n    assert(len(points1[0])==2 || len(points1[0])==3 ,\n           \"The input points should be 2d or 3d points.\")\n    let( d = points1[0]-points2[0] )\n    norm(d)<eps ? 0 :\n    let( v = _support_diff(points1,points2,-d) )\n    norm(_GJK_distance(points1, points2, eps, 0, v, [v]));\n\n\n// Finds the vector difference between the hulls of the two pointsets by the GJK algorithm\n// Based on:\n// http://www.dtecta.com/papers/jgt98convex.pdf\nfunction _GJK_distance(points1, points2, eps=EPSILON, lbd, d, simplex=[]) =\n    let( nrd = norm(d) ) // distance upper bound\n    nrd<eps ? d :\n    let(\n        v     = _support_diff(points1,points2,-d),\n        lbd   = max(lbd, d*v/nrd), // distance lower bound\n        close = (nrd-lbd <= eps*nrd)\n    )\n    close ? d :\n    let( newsplx = _closest_simplex(concat(simplex,[v]),eps) )\n    _GJK_distance(points1, points2, eps, lbd, newsplx[0], newsplx[1]);\n\n\n// Function: convex_collision()\n// Synopsis: Check whether the convex hulls of two point lists intersect. \n// Topics: Geometry, Convexity, Collision, Intersection\n// See also: \n//   convex_distance(), hull()\n// Usage:\n//   bool = convex_collision(points1, points2, [eps]);\n// Description:\n//   Returns `true` if the convex hull of `points1` intersects the convex hull of `points2`\n//   otherwise, `false`.\n//   All the points in the lists should have the same dimension, either 2D or 3D.\n//   This function is tipically faster than `convex_distance` to find a non-collision.\n// Arguments:\n//   points1 = first list of 2d or 3d points.\n//   points2 = second list of 2d or 3d points.\n//   eps - tolerance for the intersection tests. Default: EPSILON.\n// Example(2D):\n//    pts1 = move([-3,0], p=square(3,center=true));\n//    pts2 = rot(a=45, p=square(2,center=true));\n//    pts3 = [ [2,0], [1,2],[3,2], [3,-2], [1,-2] ];\n//    polygon(pts1);\n//    polygon(pts2);\n//    polygon(pts3);\n//    echo(convex_collision(pts1,pts2)); // Returns: false\n//    echo(convex_collision(pts2,pts3)); // Returns: true\n// Example(3D):\n//    sphr1 = sphere(2,$fn=10);\n//    sphr2 = move([4,0,0], p=sphr1);\n//    sphr3 = move([4.5,0,0], p=sphr1);\n//    vnf_polyhedron(sphr1);\n//    vnf_polyhedron(sphr2);\n//    echo(convex_collision(sphr1[0], sphr2[0])); // Returns: true\n//    echo(convex_collision(sphr1[0], sphr3[0])); // Returns: false\n//\nfunction convex_collision(points1, points2, eps=EPSILON) =\n    assert(is_matrix(points1) && is_matrix(points2,undef,len(points1[0])), \n           \"The input lists should be compatible consistent non empty lists of points.\")\n    assert(len(points1[0])==2 || len(points1[0])==3 ,\n           \"The input points should be 2d or 3d points.\")\n    let( d = points1[0]-points2[0] )\n    norm(d)<eps ? true :\n    let( v = _support_diff(points1,points2,-d) )\n    _GJK_collide(points1, points2, v, [v], eps);\n\n\n// Based on the GJK collision algorithms found in:\n// http://uu.diva-portal.org/smash/get/diva2/FFULLTEXT01.pdf\n// or\n// http://www.dtecta.com/papers/jgt98convex.pdf\nfunction _GJK_collide(points1, points2, d, simplex, eps=EPSILON) =\n    norm(d) < eps ? true :          // does collide\n    let( v = _support_diff(points1,points2,-d) ) \n    v*d > eps*eps ? false : // no collision\n    let( newsplx = _closest_simplex(concat(simplex,[v]),eps) )\n    norm(v-newsplx[0])<eps ? norm(v)<eps :\n    _GJK_collide(points1, points2, newsplx[0], newsplx[1], eps);\n\n\n// given a simplex s, returns a pair:\n//  - the point of the s closest to the origin\n//  - the smallest sub-simplex of s that contains that point\nfunction _closest_simplex(s,eps=EPSILON) =\n    len(s)==2 ? _closest_s1(s,eps) :\n    len(s)==3 ? _closest_s2(s,eps) :\n    len(s)==4 ? _closest_s3(s,eps) :\n    assert(false, \"Internal error.\");\n\n\n// find the point of a 1-simplex closest to the origin\nfunction _closest_s1(s,eps=EPSILON) =\n    norm(s[1]-s[0])<=eps*(norm(s[0])+norm(s[1]))/2 ? [ s[0], [s[0]] ] :\n    let(\n        c = s[1]-s[0],\n        t = -s[0]*c/(c*c)\n    )\n    t<0 ? [ s[0], [s[0]] ] :\n    t>1 ? [ s[1], [s[1]] ] :\n    [ s[0]+t*c, s ];\n\n\n// find the point of a 2-simplex closest to the origin\nfunction _closest_s2(s, eps=EPSILON) =\n    // considering that s[2] was the last inserted vertex in s by GJK, \n    // the plane orthogonal to the triangle [ origin, s[0], s[1] ] that \n    // contains [s[0],s[1]] have the origin and s[2] on the same side;\n    // that reduces the cases to test and the only possible simplex\n    // outcomes are s, [s[0],s[2]] and [s[1],s[2]] \n    let(\n        area  = cross(s[2]-s[0], s[1]-s[0]), \n        area2 = area*area                     // tri area squared\n    )\n    area2<=eps*max([for(si=s) pow(si*si,2)]) // degenerate tri\n    ?   norm(s[2]-s[0]) < norm(s[2]-s[1]) \n        ? _closest_s1([s[1],s[2]])\n        : _closest_s1([s[0],s[2]])\n    :   let(\n            crx1  = cross(s[0], s[2])*area,\n            crx2  = cross(s[1], s[0])*area,\n            crx0  = cross(s[2], s[1])*area\n        )\n        // all have the same signal -> origin projects inside the tri \n        max(crx1, crx0, crx2) < 0  || min(crx1, crx0, crx2) > 0\n        ?   // baricentric coords of projection   \n            [ [abs(crx0),abs(crx1),abs(crx2)]*s/area2, s ] \n       :   let( \n               cl12 = _closest_s1([s[1],s[2]]),\n               cl02 = _closest_s1([s[0],s[2]])\n            )\n            norm(cl12[0])<norm(cl02[0]) ? cl12 : cl02;\n        \n\n// find the point of a 3-simplex closest to the origin\nfunction _closest_s3(s,eps=EPSILON) =\n    let( nr = cross(s[1]-s[0],s[2]-s[0]),\n         sz = [ norm(s[0]-s[1]), norm(s[1]-s[2]), norm(s[2]-s[0]) ] )\n    norm(nr)<=eps*pow(max(sz),2)\n    ?   let( i = max_index(sz) )\n        _closest_s2([ s[i], s[(i+1)%3], s[3] ], eps) // degenerate case\n    :   // considering that s[3] was the last inserted vertex in s by GJK,\n        // the only possible outcomes will be:\n        //    s or some of the 3 faces of s containing s[3]\n        let(\n            tris = [ [s[0], s[1], s[3]],\n                     [s[1], s[2], s[3]],\n                     [s[2], s[0], s[3]] ],\n            cntr = sum(s)/4,\n            // indicator of the tris facing the origin\n            facing = [for(i=[0:2])\n                        let( nrm = _tri_normal(tris[i]) )\n                        if( ((nrm*(s[i]-cntr))>0)==(nrm*s[i]<0) ) i ]\n        )\n        len(facing)==0 ? [ [0,0,0], s ] : // origin is inside the simplex\n        len(facing)==1 ? _closest_s2(tris[facing[0]], eps) :\n        let( // look for the origin-facing tri closest to the origin\n            closest = [for(i=facing) _closest_s2(tris[i], eps) ],\n            dist    = [for(cl=closest) norm(cl[0]) ],\n            nearest = min_index(dist) \n        )\n        closest[nearest];\n\n\nfunction _tri_normal(tri) = cross(tri[1]-tri[0],tri[2]-tri[0]);\n\n\nfunction _support_diff(p1,p2,d) =\n    let( p1d = p1*d, p2d = p2*d )\n    p1[search(max(p1d),p1d,1)[0]] - p2[search(min(p2d),p2d,1)[0]];\n\n\n// Section: Rotation Decoding\n\n// Function: rot_decode()\n// Synopsis: Extract axis and rotation angle from a rotation matrix. \n// Topics: Affine, Matrices, Transforms\n// Usage:\n//   info = rot_decode(rotation,[long]); // Returns: [angle,axis,cp,translation]\n// Description:\n//   Given an input 3D rigid transformation operator (one composed of just rotations and translations) represented\n//   as a 4x4 matrix, compute the rotation and translation parameters of the operator.  Returns a list of the\n//   four parameters, the angle, in the interval [0,180], the rotation axis as a unit vector, a centerpoint for\n//   the rotation, and a translation.  If you set `parms = rot_decode(rotation)` then the transformation can be\n//   reconstructed from parms as `move(parms[3]) * rot(a=parms[0],v=parms[1],cp=parms[2])`.  This decomposition\n//   makes it possible to perform interpolation.  If you construct a transformation using `rot` the decoding\n//   may flip the axis (if you gave an angle outside of [0,180]).  The returned axis will be a unit vector, and\n//   the centerpoint lies on the plane through the origin that is perpendicular to the axis.  It may be different\n//   than the centerpoint you used to construct the transformation.\n//   .\n//   If you set `long` to true then return the reversed rotation, with the angle in [180,360].\n// Arguments:\n//   rotation = rigid transformation to decode\n//   long = if true return the \"long way\" around, with the angle in [180,360].  Default: false\n// Example:\n//   info = rot_decode(rot(45));\n//          // Returns: [45, [0,0,1], [0,0,0], [0,0,0]]\n//   info = rot_decode(rot(a=37, v=[1,2,3], cp=[4,3,-7])));\n//          // Returns: [37, [0.26, 0.53, 0.80], [4.8, 4.6, -4.6], [0,0,0]]\n//   info = rot_decode(left(12)*xrot(-33));\n//          // Returns: [33, [-1,0,0], [0,0,0], [-12,0,0]]\n//   info = rot_decode(translate([3,4,5]));\n//          // Returns: [0, [0,0,1], [0,0,0], [3,4,5]]\nfunction rot_decode(M,long=false) =\n    assert(is_matrix(M,4,4) && approx(M[3],[0,0,0,1]), \"Input matrix must be a 4x4 matrix representing a 3d transformation\")\n    let(R = submatrix(M,[0:2],[0:2]))\n    assert(approx(det3(R),1) && approx(norm_fro(R * transpose(R)-ident(3)),0),\"Input matrix is not a rotation\")\n    let(\n        translation = [for(row=[0:2]) M[row][3]],   // translation vector\n        largest  = max_index([R[0][0], R[1][1], R[2][2]]),\n        axis_matrix = R + transpose(R) - (matrix_trace(R)-1)*ident(3),   // Each row is on the rotational axis\n            // Construct quaternion q = c * [x sin(theta/2), y sin(theta/2), z sin(theta/2), cos(theta/2)]\n        q_im = axis_matrix[largest],\n        q_re = R[(largest+2)%3][(largest+1)%3] - R[(largest+1)%3][(largest+2)%3],\n        c_sin = norm(q_im),              // c * sin(theta/2) for some c\n        c_cos = abs(q_re)                // c * cos(theta/2)\n    )\n    approx(c_sin,0) ? [0,[0,0,1],[0,0,0],translation] :\n    let(\n        angle = 2*atan2(c_sin, c_cos),    // This is supposed to be more accurate than acos or asin\n        axis  = (q_re>=0 ? 1:-1)*q_im/c_sin,\n        tproj = translation - (translation*axis)*axis,    // Translation perpendicular to axis determines centerpoint\n        cp    = (tproj + cross(axis,tproj)*c_cos/c_sin)/2\n    )\n    [long ? 360-angle:angle,\n     long? -axis : axis,\n     cp,\n     (translation*axis)*axis];\n\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-17", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: hinges.scad\n//   Functions and modules for creating hinges and snap-locking hinged parts. \n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/hinges.scad>\n// FileGroup: Parts\n// FileSummary: Hinges and snap-locking hinged parts.  \n//////////////////////////////////////////////////////////////////////\n\ninclude <rounding.scad>\ninclude <screws.scad>\n\n// Section: Hinges\n\n// Module: knuckle_hinge()\n// Synopsis: Creates a knuckle-hinge shape.\n// SynTags: Geom\n// Topics: Hinges, Parts\n// See Also: living_hinge_mask(), snap_lock(), snap_socket()\n// Usage:\n//   knuckle_hinge(length, offset, segs, [inner], [arm_height=], [arm_angle=], [fill=], [clear_top=], [gap=], [round_top=], [round_bot=], [knuckle_diam=], [pin_diam=], [pin_fn=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n// Description:\n//   Construct standard knuckle hinge in two parts using a hinge pin that must be separately supplied.\n//   The default is configured to use a piece of 1.75 mm filament as the hinge pin, but you can select\n//   any dimensions you like to use a screw or other available pin material.  The BOTTOM of the hinge\n//   is its mount point, which is aligned with the hinge pin centersurface, and the hinge pin hole is\n//   the CENTER of the hinge.  The offset is the distance from a vertical mounting point to the center\n//   of the hinge pin.  The hinge barrel is held by an angled support and vertical support.  The\n//   length of the angled support is determined by its angle and the offset.  You specify the length\n//   of the vertical support with the arm_height parameter.\n//   .\n//   A hinge requires clearance so its parts don't interfere.  If the hinge pin is exactly centered on\n//   the top of your part, then the hinge may not close all the way due to interference at the edge.\n//   A small clearance, specified with `clearance=`, raises the hinge up and can ease this\n//   interference.  It should probably be equal to a layer thickness or two.  If the hinge knuckle is\n//   close to the hinged part then the mating part may interfere.  You can create clearance to address\n//   this problem by increasing the offset to move the hinge knuckles farther away.  Another method is\n//   to cut out a curved recess on the parts to allow space for the other hinges.  This is possible\n//   using the `knuckle_clearance=` parameter, which specifies the extra space to cut away to leave\n//   room for the hinge knuckles.  It must be positive for any space to be cut, and to use this option\n//   you must make the hinge a child of some object and specify {{diff()}} for the parent object of\n//   the hinge.\n// Figure(2D,Med,NoScales):  The basic hinge form appears on the left.  If fill is set to true the gap between the mount surface and hinge arm is filled as shown on the right. \n//   _knuckle_hinge_profile(4, 5, $fn=32, fill=false);\n//   right(13)_knuckle_hinge_profile(4, 5, $fn=32, fill=true);\n//   fwd(9)stroke([[0,0],[4,4],[4,9]], width=.3,color=\"black\");\n//   stroke([[5,-5],[5,0]], endcaps=\"arrow2\", color=\"blue\",width=.15);\n//   color(\"blue\"){move([6.2,-2.5])text(\"arm_height\",size=.75,valign=\"center\");\n//      stroke(arc(r=3, cp=[0,-9], angle=[47,90],$fn=64),width=.15,endcaps=\"arrow2\");\n//      move([-.5,-6])text(\"arm_angle\", size=0.75,halign=\"right\");\n//      move([14,-4])text(\"fill=true\", size=1);\n//   }\n// Continues:\n//   As shown in the above figure, the fill option fills the gap between the hinge arm and the mount surface to make a stronger connection.  When the\n//   arm height is set to zero, only a single segment connects the hinge barrel to the mount surface.  \n// Figure(2D,Med,NoScales): Zero arm height with 45 deg arm\n//   right(10)   _knuckle_hinge_profile(4, 0, $fn=32);\n//   _knuckle_hinge_profile(4, 0, $fn=32,fill=false);\n//   right(11)fwd(-3)color(\"blue\")text(\"fill=true\",size=1);\n//   right(.5)fwd(-3)color(\"blue\")text(\"fill=false\",size=1);\n// Continues:\n// Figure(2D,Med,NoScales): Zero arm height with 90 deg arm.  The clear_top parameter removes the hinge support material that is above the x axis\n//   _knuckle_hinge_profile(4, 0, 90, $fn=32);\n//   right(10)  _knuckle_hinge_profile(4, 0, 90, $fn=32,clear_top=true);\n//   right(9.5)fwd(-3)color(\"blue\")text(\"clear_top=true\",size=.76);\n//   right(.5)fwd(-3)color(\"blue\")text(\"clear_top=false\",size=.76);\n// Figure(2D,Med,NoScales):  An excessively large clearance value raises up the hinge center.  Note that the hinge mounting remains bounded by the X axis, so when `fill=true` or `clear_top=true` this is different than simply raising up the entire hinge.  \n//   right(10)  _knuckle_hinge_profile(4, 0, 90, $fn=32,clear_top=true,clearance=.5);\n//   _knuckle_hinge_profile(4, 0, $fn=32,fill=true,clearance=.5);\n// Continues:\n//   For 3D printability, you may prefer a teardrop shaped hole, which you can get with `teardrop=true`; \n//   if necessary you can specify the teardrop direction to be UP, DOWN, FORWARD, or BACK.\n//   (These directions assume that the base of the hinge is mounted on the back of something.)\n//   Another option for printability is to use an octagonal hole, though it does seem more\n//   difficult to size these for robust printability.  To get an octagonal hole set `pin_fn=8`.\n// Figure(2D,Med,NoScales): Alternate hole shapes for improved 3D printabililty\n//   right(10)   _knuckle_hinge_profile(4, 0, $fn=32,pin_fn=8);\n//   _knuckle_hinge_profile(4, 0, $fn=32,tearspin=0);\n//   right(11)fwd(-3)color(\"blue\")text(\"octagonal\",size=1);\n//   right(1.5)fwd(-3)color(\"blue\")text(\"teardrop\",size=1);\n// Continues:\n//   The default pin hole size admits a piece of 1.75 mm filament.  If you prefer to use a machine\n//   screw you can set the pin_diam to a screw specification like `\"M3\"` or \"#6\".  In this case,\n//   a clearance hole is created through most of the hinge with a self-tap hole for the last segment.\n//   If the last segment is very long you may shrink the self-tap portion using the tap_depth parameter.\n//   The pin hole diameter is enlarged by the `2*$slop` for numerically specified holes.\n//   Screw holes are made using {{screw_hole()}} which enlarges the hole by `4*$slop`.  \n//   .\n//   To blend hinges better with a model you can round off the joint with the mounting surface using\n//   the `round_top` and `round_bot` parameters, which specify the cut distance, the amount of material to add.\n//   They make a continuous curvature \"smooth\" roundover with `k=0.8`.  See [smooth roundovers](rounding.scad#section-types-of-roundovers) for more\n//   information.  If you specify too large of a roundover you will get an error that the rounding doesn't fit.  \n// Figure(2D,Med,NoScales): Top and bottom roundovers for smooth hinge attachment\n//   right(12)_knuckle_hinge_profile(6, 0, $fn=32,fill=false,round_top=1.5);\n//   _knuckle_hinge_profile(4, 0, $fn=32,fill=false,round_bot=1.5);\n//   right(12)fwd(11)color(\"blue\")text(\"round_top=1.8\",size=1);\n//   right(.5)fwd(-3)color(\"blue\")text(\"round_bot=1.5\",size=1);\n// Arguments:\n//   length = total length of the entire hinge\n//   offset = horizontal offset of the hinge pin center from the mount point\n//   segs = number of hinge segments\n//   inner = set to true for the \"inner\" hinge.  Default: false\n//   ---\n//   arm_height = vertical height of the arm that holds the hinge barrel.  Default: 0\n//   arm_angle = angle of the arm down from the vertical.  Default: 45\n//   fill = if true fill in space between arm and mount surface.  Default: true\n//   clear_top = if true remove any excess arm geometry that appears above the top of the mount surface.  Default: false\n//   gap = gap between hinge segments.  Default: 0.2\n//   round_top = rounding amount to add where top of hinge arm joins the mount surface.  Generally only useful when fill=false.  Default: 0\n//   round_bot = rounding amount to add where bottom of hinge arm joins the mount surface.  Default: 0\n//   knuckle_diam = diameter of hinge barrel.  Default: 4\n//   pin_diam = diameter of hinge pin hole as a number of screw specification.  Default: 1.75\n//   pin_fn = $fn value to use for the pin.\n//   teardrop = Set to true or UP/DOWN/FWD/BACK to specify teardrop shape for the pin hole.  Default: false\n//   screw_head = screw head to use for countersink\n//   screw_tolerance = screw hole tolerance.  Default: \"close\"\n//   tap_depth = Don't make the tapped part of the screw hole larger than this. \n//   $slop = increases pin hole diameter\n//   clearance = raises pin hole to create clearance at the edge of the mounted surface.  Default: 0.15\n//   clear_knuckle = clear space for hinge knuckle of mating part.  Must use with {{diff()}}.  Default: 0 \n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `BOTTOM`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example: Basic hinge, inner=false in front and inner=true in the back\n//   $fn=32;\n//   ydistribute(30){\n//     knuckle_hinge(length=35, segs=5, offset=3, arm_height=1);\n//     knuckle_hinge(length=35, segs=5, offset=3, arm_height=1,inner=true);\n//   }\n// Example(NoScales):  Basic hinge, mounted.  Odd segment count means the \"outside\" hinge is on the outside at both ends.  \n//   $fn=32;\n//   cuboid([2,40,15])\n//     position(TOP+RIGHT) orient(anchor=RIGHT)\n//       knuckle_hinge(length=35, segs=9, offset=3, arm_height=1);\n// Example(NoScales):  Corresponding inner hinge to go with previous example.  Note that the total number of hinge segments adds to the 9 specified.  \n//   $fn=32;\n//   cuboid([2,40,15])\n//     position(TOP+RIGHT) orient(anchor=RIGHT)\n//       knuckle_hinge(length=35, segs=9, offset=3, arm_height=1, inner=true);\n// Example(NoScales):  This example shows how to position and orient the hinge onto the front of an object instead of the right side. \n//   $fn=32;\n//   cuboid([40,2,15])\n//     position(TOP+FRONT) orient(anchor=FWD)\n//       knuckle_hinge(length=35, segs=9, offset=3, arm_height=1);\n// Example(NoScales):  Hinge with round_bot set to create a smooth transition, but octagonal hinge pin holes for printing\n//   $fn=32;\n//   cuboid([2,40,15])\n//     position(TOP+RIGHT) orient(anchor=RIGHT)\n//       knuckle_hinge(length=35, segs=9, offset=3, arm_height=1,\n//             round_bot=1, pin_fn=8);\n// Example(NoScales):  Hinge with no vertical arm, just angled arm\n//   $fn=32;\n//   cuboid([2,40,15])\n//     position(TOP+RIGHT) orient(anchor=RIGHT)\n//       knuckle_hinge(length=35, segs=9, offset=3, pin_fn=8);\n// Example(NoScales): Setting the arm_angle to a large value like 90 produces a hinge that doesn't look great\n//   $fn=32;\n//   cuboid([2,40,15])\n//     position(TOP+RIGHT) orient(anchor=RIGHT)\n//       knuckle_hinge(length=35, segs=9, offset=3, arm_angle=90,\n//             arm_height=0, pin_fn=8);\n// Example(NoScales): The above hinge is improved with clear_top, which allows nice attachment to a shape half the thickness of the hinge barrel\n//   $fn=32;\n//   cuboid([20,40,2])\n//     position(TOP+RIGHT) orient(anchor=RIGHT)\n//       knuckle_hinge(length=35, segs=9, offset=3, arm_height=0,\n//             arm_angle=90, pin_fn=8, clear_top=true);\n// Example(NoScales): Uneven hinge using seg_ratio.  Here the inner hinge segments are 1/3 the outer, a rather extreme difference.  Note also that it's a little simpler to mount the inner hinge on the LEFT side of the top section to interface with the hinge mounted on the RIGHT. \n//   $fn=32;\n//   cuboid([2,40,15]){\n//     position(TOP+RIGHT) orient(anchor=RIGHT)\n//       knuckle_hinge(length=35, segs=9, offset=3, arm_height=1,\n//             seg_ratio=1/3);\n//     attach(TOP,TOP) color(\"green\")\n//       cuboid([2,40,15],anchor=TOP)\n//         position(TOP+LEFT) orient(anchor=LEFT)\n//           knuckle_hinge(length=35, segs=9, offset=3, arm_height=1,\n//                 seg_ratio=1/3, inner=true);\n//    }\n// Example(NoScales): A single hinge with an even number of segments will probably look strange, but they work together neatly in a pair.  This example also shows that the arm_height can change between the inner and outer hinge parts and they will still interface properly.\n//   $fn=32;\n//   cuboid([2,40,15]){\n//     yflip_copy()\n//       position(TOP+RIGHT+FRONT) orient(anchor=RIGHT)\n//         knuckle_hinge(length=12, segs=2, offset=2, arm_height=2,\n//               anchor=BOT+LEFT);\n//     attach(TOP,TOP) color(\"green\")\n//       cuboid([2,40,15],anchor=TOP)\n//         yflip_copy()\n//           position(TOP+LEFT+FRONT) orient(anchor=LEFT)\n//             knuckle_hinge(length=12, segs=2, offset=2, arm_height=0,\n//                   inner=true, anchor=BOT+RIGHT);\n//    }\n// Example(NoScales): Hinge with self-tapping screw hole.  Note that last segment has smaller diameter for screw to bite, whereas other segments have clearance holes. \n//   $fn=32;\n//   bottom_half(z=.01)\n//     cuboid([2,40,15],anchor=TOP)\n//       position(TOP+RIGHT) orient(anchor=RIGHT)\n//         knuckle_hinge(length=35, segs=5, offset=5, knuckle_diam=9, pin_diam=\"#6\", fill=false,inner=false, screw_head=\"flat\");\n// Example(NoScales): If you give a non-flat screw head then a counterbore for that head is generated.  If you don't want the counterbore, don't give a head type.  In this example, tap_depth limits the narrower self-tap section of the hole.  \n//   $fn=32;\n//   bottom_half(z=.01)\n//      cuboid([2,40,15],anchor=TOP)\n//        position(TOP+RIGHT) orient(anchor=RIGHT)\n//           knuckle_hinge(length=35, segs=3, offset=5, knuckle_diam=9, pin_diam=\"#6\",\n//                 fill=false, inner=false, tap_depth=6, screw_head=\"socket\");\n// Example(NoScales): This hinge has a small offset, so the hinged parts may interfere.  To prevent this, use `knuckle_clearance`.  This example shows an excessive clearance value to make the effect obvious.  Note that you **must** use {{diff()}} when you set `knuckle_clearance`, and the hinge must be a child of the object it mounts to.  Otherwise the cylinders that are supposed to be subtracted will appear as extra objects.  This is an inner hinge, so it has clearance zones for the larger outer hinge that will mate with it.  \n//   $fn=32;\n//   diff()\n//     cuboid([4,40,15])\n//       position(TOP+RIGHT) orient(anchor=RIGHT)\n//         knuckle_hinge(length=35, segs=5, offset=2, inner=true, knuckle_clearance=1);\n// Example(NoScales): Oh no! Forgot to use {{diff()}} with knuckle_clearance!\n//   $fn=32;\n//     cuboid([4,40,15])\n//       position(TOP+RIGHT) orient(anchor=RIGHT)\n//         knuckle_hinge(length=35, segs=5, offset=2, inner=true, knuckle_clearance=1);\n\nfunction knuckle_hinge(length, segs, offset, inner=false, arm_height=0, arm_angle=45, gap=0.2,\n             seg_ratio=1, knuckle_diam=4, pin_diam=1.75, fill=true, clear_top=false,\n             round_bot=0, round_top=0, pin_fn, clearance,\n             tap_depth, screw_head, screw_tolerance=\"close\", \n             anchor=BOT,orient,spin) = no_function(\"hinge\");\n\nmodule knuckle_hinge(length, segs, offset, inner=false, arm_height=0, arm_angle=45, gap=0.2,\n             seg_ratio=1, knuckle_diam=4, pin_diam=1.75, fill=true, clear_top=false,\n             round_bot=0, round_top=0, pin_fn, clearance=0, teardrop,\n             tap_depth, screw_head, screw_tolerance=\"close\", knuckle_clearance, \n             anchor=BOT,orient,spin)\n{\n  dummy =\n    assert(is_str(pin_diam) || all_positive([pin_diam]), \"pin_diam must be a screw spec string or a positive number\")\n    assert(all_positive(length), \"length must be a postive number\")\n    assert(is_int(segs) && segs>=2, \"segs must be an integer 2 or greater\")\n    assert(is_finite(offset) && offset>=knuckle_diam/2, \"offset must be a valid number that is not smaller than radius of the hinge knuckle\")\n    assert(is_finite(arm_angle) && arm_angle>0 && arm_angle<=90, \"arm_angle must be greater than zero and less than or equal to 90\");\n  segs1 = ceil(segs/2);\n  segs2 = floor(segs/2);\n  seglen1 = gap + (length-(segs-1)*gap) / (segs1 + segs2*seg_ratio);\n  seglen2 = gap + (length-(segs-1)*gap) / (segs1 + segs2*seg_ratio) * seg_ratio;\n  z_adjust = segs%2==1 ? 0\n           : inner? seglen1/2\n           : seglen2/2;\n  tearspin = is_undef(teardrop) || teardrop==false ? undef\n           : teardrop==UP || teardrop==true ? 0\n           : teardrop==DOWN ? 180\n           : teardrop==BACK ? 270\n           : teardrop==FWD ? 90\n           : assert(false, \"Illegal value for teardrop\");\n  knuckle_segs = segs(knuckle_diam);\n  transform = down(offset)*yrot(-90)*zmove(z_adjust);\n\n  if(knuckle_clearance){\n    knuckle_clearance_diam = knuckle_diam / cos(180/knuckle_segs) + 2*knuckle_clearance;\n    tag(\"remove\")\n      attachable(anchor,spin,orient,\n                 size=[length,\n                       arm_height+offset/tan(arm_angle)+knuckle_diam/2+knuckle_diam/2/sin(arm_angle),\n                       offset+knuckle_diam/2],\n                 offset=[0,\n                         -arm_height/2-offset/tan(arm_angle)/2-knuckle_diam/sin(arm_angle)/4+knuckle_diam/4,\n                         -offset/2+knuckle_diam/4]\n      )\n      {\n        multmatrix(transform) down(segs%2==1? 0 : (seglen1+seglen2)/2){\n          move([offset,clearance])\n            intersection(){\n              n = inner && segs%2==1 ? segs1\n                \n                : inner ? segs1\n                : segs2;\n              zcopies(n=n, spacing=seglen1+seglen2)\n                 cyl(h=(inner?seglen1:seglen2)+gap-.01, d=knuckle_clearance_diam, circum=true, $fn=knuckle_segs, realign=true);\n              //cyl(h=length+2*gap, d=knuckle_clearance_diam, circum=true, $fn=knuckle_segs, realign=true);\n            }\n        }\n        union(){}\n    }\n  }\n  attachable(anchor,spin,orient,\n             size=[length,\n                   arm_height+offset/tan(arm_angle)+knuckle_diam/2+knuckle_diam/2/sin(arm_angle),\n                   offset+knuckle_diam/2],\n             offset=[0,\n                     -arm_height/2-offset/tan(arm_angle)/2-knuckle_diam/sin(arm_angle)/4+knuckle_diam/4,\n                     -offset/2+knuckle_diam/4]\n  )\n  {\n    multmatrix(transform)\n      force_tag() difference() {\n        zcopies(n=inner?segs2:segs1, spacing=seglen1+seglen2)\n          linear_extrude((inner?seglen2:seglen1)-gap,center=true)\n            _knuckle_hinge_profile(offset=offset, arm_height=arm_height, arm_angle=arm_angle, knuckle_diam=knuckle_diam, pin_diam=pin_diam,\n                                   fill=fill, clear_top=clear_top, round_bot=round_bot, round_top=round_top, pin_fn=pin_fn,clearance=clearance,tearspin=tearspin);\n        if (is_str(pin_diam)) back(clearance)right(offset) up(length/2-(inner?1:1)*z_adjust) zrot(default(tearspin,0)){\n          $fn = default(pin_fn,$fn);\n          tap_depth = min(segs%2==1?seglen1-gap/2:seglen2-gap/2, default(tap_depth, length));\n          screw_hole(pin_diam, length=length+.01, tolerance=\"self tap\", bevel=false, anchor=TOP, teardrop=is_def(tearspin));\n          multmatrix(inner ? zflip(z=-length/2) : IDENT)\n            if (is_undef(screw_head) || screw_head==\"none\" || starts_with(screw_head,\"flat\"))\n              screw_hole(pin_diam, length=length-tap_depth, tolerance=screw_tolerance, bevel=false, anchor=TOP, head=screw_head, teardrop=is_def(tearspin));\n            else {\n              screw_hole(pin_diam, length=length-tap_depth, tolerance=screw_tolerance, bevel=false, anchor=TOP, teardrop=is_def(tearspin));\n              screw_hole(pin_diam, length=.01, tolerance=screw_tolerance, bevel=false, anchor=TOP, head=screw_head, teardrop=is_def(tearspin));\n            }\n        }\n      }\n    children();\n  }    \n}  \n\n\nmodule _knuckle_hinge_profile(offset, arm_height, arm_angle=45, knuckle_diam=4, pin_diam=1.75, fill=true, clear_top=false, round_bot=0, round_top=0, pin_fn, clearance=0, tearspin)\n{\n  extra = .01;\n  skel = turtle([\"left\", 90-arm_angle, \"untilx\", offset+extra, \"left\", arm_angle,\n                 if (arm_height>0) each [\"move\", arm_height]]);\n  ofs = arm_height+offset/tan(arm_angle);\n  start=round_bot==0 && round_top==0 ? os_flat(abs_angle=90)\n                                     : os_round(abs_angle=90, cut=[-round_top,-round_bot],k=.8);\n  f=echo(clearance=clearance);\n  back(clearance)\n  difference(){\n    union(){\n      difference(){\n        fwd(ofs){\n          left(extra)offset_stroke(skel, width=knuckle_diam, start=start);\n          if (fill) polygon([each list_head(skel,-2), fwd(clearance,last(skel)), [-extra,ofs-clearance]]);\n        }\n        if (clear_top==true || clear_top==\"all\") left(.1)fwd(clearance) rect([offset+knuckle_diam,knuckle_diam+1+clearance],anchor=BOT+LEFT);\n        if (is_num(clear_top)) left(.1)fwd(clearance) rect([.1+clear_top, knuckle_diam+1+clearance], anchor=BOT+LEFT);\n      }\n      right(offset)ellipse(d=knuckle_diam,realign=true,circum=true);\n    }\n    if (is_num(pin_diam) && pin_diam>0){\n      $fn = default(pin_fn,$fn);\n      right(offset)\n        if (is_def(tearspin)){\n          teardrop2d(d=pin_diam+2*get_slop(), realign=true, circum=true, spin=tearspin);\n        }\n        else ellipse(d=pin_diam+2*get_slop(), realign=true, circum=true);\n    }\n  }\n} \n\n\n// Module: living_hinge_mask()\n// Synopsis: Creates a mask to make a folding \"living\" hinge.\n// SynTags: Geom\n// Topics: Hinges, Parts\n// See Also: knuckle_hinge(), living_hinge_mask(), snap_lock(), snap_socket(), apply_folding_hinges_and_snaps()\n// Usage:\n//   living_hinge_mask(l, thick, [layerheight=], [foldangle=], [hingegap=], [$slop=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n// Description:\n//   Creates a mask to be differenced away from a plate to create a \"live\" hinge, where a thin layer of plastic holds two parts together.  \n//   Center the mask at the bottom of the part you want to make a hinge in.\n//   The mask will leave  hinge material `2*layerheight` thick on the bottom of the hinge.\n// Arguments:\n//   l = Length of the hinge in mm.\n//   thick = Thickness in mm of the material to make the hinge in.\n//   ---\n//   layerheight = The expected printing layer height in mm.\n//   foldangle = The interior angle in degrees of the joint to be created with the hinge.  Default: 90\n//   hingegap = Size in mm of the gap at the bottom of the hinge, to make room for folding.\n//   $slop = Increase size of hinge gap by double this amount\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   living_hinge_mask(l=100, thick=3, foldangle=60);\nmodule living_hinge_mask(l, thick, layerheight=0.2, foldangle=90, hingegap=undef, anchor=CENTER, spin=0, orient=UP)\n{\n    hingegap = default(hingegap, layerheight)+2*get_slop();\n    size = [l, hingegap, 2*thick];\n    size2 = [l, hingegap+2*thick*tan(foldangle/2)];\n    attachable(anchor,spin,orient, size=size, size2=size2) {\n        up(layerheight*2) prismoid([l,hingegap], [l, hingegap+2*thick/tan(foldangle/2)], h=thick, anchor=BOT);\n        children();\n    }\n}\n\nmodule folding_hinge_mask(l, thick, layerheight=0.2, foldangle=90, hingegap=undef, anchor=CENTER, spin=0, orient=UP)\n{\n    deprecate(\"living_hinge_mask\");\n    living_hinge_mask(l, thick, layerheight, foldangle, hingegap, anchor, spin, orient);\n}\n\n\n\n// Section: Snap Locks\n\n\n// Module: apply_folding_hinges_and_snaps()\n// Synopsis: Adds snap shapes and removes living hinges from a child shape.\n// SynTags: Geom\n// Topics: Hinges, Parts\n// See Also: knuckle_hinge(), living_hinge_mask(), snap_lock(), snap_socket()\n// Usage:\n//   apply_folding_hinges_and_snaps(thick, [foldangle=], [hinges=], [snaps=], [sockets=], [snaplen=], [snapdiam=], [hingegap=], [layerheight=], [$slop=]) CHILDREN;\n// Description:\n//   Adds snaplocks and create hinges in children at the given positions.\n// Arguments:\n//   thick = Thickness in mm of the material to make the hinge in.\n//   foldangle = The interior angle in degrees of the joint to be created with the hinge.  Default: 90\n//   hinges = List of [LENGTH, POSITION, SPIN] for each hinge to difference from the children.\n//   snaps = List of [POSITION, SPIN] for each central snaplock to add to the children.\n//   sockets = List of [POSITION, SPIN] for each outer snaplock sockets to add to the children.\n//   snaplen = Length of locking snaps.\n//   snapdiam = Diameter/width of locking snaps.\n//   hingegap = Size in mm of the gap at the bottom of the hinge, to make room for folding.\n//   layerheight = The expected printing layer height in mm.\n//   ---\n//   $slop = increase hinge gap by twice this amount\n// Example(Med):\n//   size=100;\n//   apply_folding_hinges_and_snaps(\n//       thick=3, foldangle=acos(1/3),\n//       hinges=[\n//           for (a=[0,120,240], b=[-size/2,size/4]) each [\n//               [200, polar_to_xy(b,a), a+90]\n//           ]\n//       ],\n//       snaps=[\n//           for (a=[0,120,240]) each [\n//               [rot(a,p=[ size/4, 0        ]), a+90],\n//               [rot(a,p=[-size/2,-size/2.33]), a-90]\n//           ]\n//       ],\n//       sockets=[\n//           for (a=[0,120,240]) each [\n//               [rot(a,p=[ size/4, 0        ]), a+90],\n//               [rot(a,p=[-size/2, size/2.33]), a+90]\n//           ]\n//       ]\n//   ) {\n//       $fn=3;\n//       difference() {\n//           cylinder(r=size-1, h=3);\n//           down(0.01) cylinder(r=size/4.5, h=3.1, spin=180);\n//           down(0.01) for (a=[0:120:359.9]) zrot(a) right(size/2) cylinder(r=size/4.5, h=3.1);\n//       }\n//   }\nmodule apply_folding_hinges_and_snaps(thick, foldangle=90, hinges=[], snaps=[], sockets=[], snaplen=5, snapdiam=5, hingegap=undef, layerheight=0.2)\n{\n    hingegap = default(hingegap, layerheight)+2*get_slop();\n    difference() {\n        children();\n        for (hinge = hinges) {\n            translate(hinge[1]) {\n                living_hinge_mask(\n                    l=hinge[0], thick=thick, layerheight=layerheight,\n                    foldangle=foldangle, hingegap=hingegap, spin=hinge[2]\n                );\n            }\n        }\n    }\n    for (snap = snaps) {\n        translate(snap[0]) {\n            snap_lock(\n                thick=thick, snaplen=snaplen, snapdiam=snapdiam,\n                layerheight=layerheight, foldangle=foldangle,\n                hingegap=hingegap, spin=snap[1]\n            );\n        }\n    }\n    for (socket = sockets) {\n        translate(socket[0]) {\n            snap_socket(\n                thick=thick, snaplen=snaplen, snapdiam=snapdiam,\n                layerheight=layerheight, foldangle=foldangle,\n                hingegap=hingegap, spin=socket[1]\n            );\n        }\n    }\n}\n\n\n\n// Module: snap_lock()\n// Synopsis: Creates a snap-lock shape.\n// SynTags: Geom\n// Topics: Hinges, Parts\n// See Also: knuckle_hinge(), living_hinge_mask(), snap_lock(), snap_socket()\n// Usage:\n//   snap_lock(thick, [snaplen=], [snapdiam=], [layerheight=], [foldangle=], [hingegap=], [$slop=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n// Description:\n//   Creates the central snaplock part.\n// Arguments:\n//   thick = Thickness in mm of the material to make the hinge in.\n//   ---\n//   snaplen = Length of locking snaps.\n//   snapdiam = Diameter/width of locking snaps.\n//   layerheight = The expected printing layer height in mm.\n//   foldangle = The interior angle in degrees of the joint to be created with the hinge.  Default: 90\n//   hingegap = Size in mm of the gap at the bottom of the hinge, to make room for folding.\n//   $slop = increase size of hinge gap by double this amount\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   snap_lock(thick=3, foldangle=60);\nmodule snap_lock(thick, snaplen=5, snapdiam=5, layerheight=0.2, foldangle=90, hingegap=undef, anchor=CENTER, spin=0, orient=UP)\n{\n    hingegap = default(hingegap, layerheight)+2*get_slop();\n    snap_x = (snapdiam/2) / tan(foldangle/2) + (thick-2*layerheight)/tan(foldangle/2) + hingegap/2;\n    size = [snaplen, snapdiam, 2*thick];\n    attachable(anchor,spin,orient, size=size) {\n        back(snap_x) {\n            cube([snaplen, snapdiam, snapdiam/2+thick], anchor=BOT) {\n                attach(TOP) xcyl(l=snaplen, d=snapdiam, $fn = max(16,quant(segs(snapdiam/2),4)));\n                attach(TOP) xcopies(snaplen-snapdiam/4/3) xscale(0.333) sphere(d=snapdiam*0.8, $fn = max(12,quant(segs(snapdiam/2),4)));\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: snap_socket()\n// Synopsis: Creates a snap-lock socket shape.\n// SynTags: Geom\n// Topics: Hinges, Parts\n// See Also: knuckle_hinge(), living_hinge_mask(), snap_lock(), snap_socket()\n// Usage:\n//   snap_socket(thick, [snaplen=], [snapdiam=], [layerheight=], [foldangle=], [hingegap=], [$slop=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n// Description:\n//   Creates the outside snaplock socketed part.\n// Arguments:\n//   thick = Thickness in mm of the material to make the hinge in.\n//   ---\n//   snaplen = Length of locking snaps.\n//   snapdiam = Diameter/width of locking snaps.\n//   layerheight = The expected printing layer height in mm.\n//   foldangle = The interior angle in degrees of the joint to be created with the hinge.  Default: 90\n//   hingegap = Size in mm of the gap at the bottom of the hinge, to make room for folding.\n//   $slop = Increase size of hinge gap by double this amount\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   snap_socket(thick=3, foldangle=60);\nmodule snap_socket(thick, snaplen=5, snapdiam=5, layerheight=0.2, foldangle=90, hingegap=undef, anchor=CENTER, spin=0, orient=UP)\n{\n    hingegap = default(hingegap, layerheight)+2*get_slop();\n    snap_x = (snapdiam/2) / tan(foldangle/2) + (thick-2*layerheight)/tan(foldangle/2) + hingegap/2;\n    size = [snaplen, snapdiam, 2*thick];\n    attachable(anchor,spin,orient, size=size) {\n        fwd(snap_x) {\n            zrot_copies([0,180], r=snaplen+get_slop()) {\n                diff(\"divot\")\n                cube([snaplen, snapdiam, snapdiam/2+thick], anchor=BOT) {\n                    attach(TOP) xcyl(l=snaplen, d=snapdiam, $fn=max(16,quant(segs(snapdiam/2),4)));\n                    tag(\"divot\") attach(TOP) left((snaplen+snapdiam/4/3)/2) xscale(0.333) sphere(d=snapdiam*0.8, $fn = max(12,quant(segs(snapdiam/2),4)));\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-18", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: joiners.scad\n//   Modules for joining separately printed parts including screw together, snap-together and dovetails.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/joiners.scad>\n// FileGroup: Parts\n// FileSummary: Joiner shapes for connecting separately printed objects.\n//////////////////////////////////////////////////////////////////////\n\n\ninclude <rounding.scad>\n\n\n// Section: Half Joiners\n\n\n// Function&Module: half_joiner_clear()\n// Synopsis: Creates a mask to clear space for a {{half_joiner()}}.\n// SynTags: Geom, VNF\n// Topics: Joiners, Parts\n// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner(), snap_pin(), rabbit_clip(), dovetail()\n// Usage: As Module\n//   half_joiner_clear(l, w, [ang=], [clearance=], [overlap=]) [ATTACHMENTS];\n// Usage: As Function\n//   vnf = half_joiner_clear(l, w, [ang=], [clearance=], [overlap=]);\n// Description:\n//   Creates a mask to clear an area so that a half_joiner can be placed there.\n// Arguments:\n//   l = Length of the joiner to clear space for.\n//   w = Width of the joiner to clear space for.\n//   ang = Overhang angle of the joiner.\n//   ---\n//   clearance = Extra width to clear.\n//   overlap = Extra depth to clear.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   half_joiner_clear();\nfunction half_joiner_clear(l=20, w=10, ang=30, clearance=0, overlap=0.01, anchor=CENTER, spin=0, orient=UP) =\n    let(\n        guide = [w/3-get_slop()*2, ang_adj_to_opp(ang, l/3)*2, l/3],\n        path = [\n            [ l/2,-overlap], [ guide.z/2, -guide.y/2-overlap],\n            [-guide.z/2, -guide.y/2-overlap], [-l/2,-overlap],\n            [-l/2, overlap], [-guide.z/2,  guide.y/2+overlap],\n            [ guide.z/2,  guide.y/2+overlap], [ l/2, overlap],\n        ],\n        dpath = deduplicate(path, closed=true),\n        vnf = linear_sweep(dpath, height=w+clearance*2, center=true, spin=90, orient=RIGHT)\n    ) reorient(anchor,spin,orient, vnf=vnf, p=vnf);\n\nmodule half_joiner_clear(l=20, w=10, ang=30, clearance=0, overlap=0.01, anchor=CENTER, spin=0, orient=UP)\n{\n    vnf = half_joiner_clear(l=l, w=w, ang=ang, clearance=clearance, overlap=overlap);\n    attachable(anchor,spin,orient, vnf=vnf) {\n        vnf_polyhedron(vnf, convexity=2);\n        children();\n    }\n}\n\n\n// Function&Module: half_joiner()\n// Synopsis: Creates a half-joiner shape to mate with a {{half_joiner2()}} shape..\n// SynTags: Geom, VNF\n// Topics: Joiners, Parts\n// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner(), snap_pin(), rabbit_clip(), dovetail()\n// Usage: As Module\n//   half_joiner(l, w, [base=], [ang=], [screwsize=], [$slop=]) [ATTACHMENTS];\n// Usage: As Function\n//   vnf = half_joiner(l, w, [base=], [ang=], [screwsize=], [$slop=]);\n// Description:\n//   Creates a half_joiner object that can be attached to a matching half_joiner2 object.\n// Arguments:\n//   l = Length of the half_joiner.\n//   w = Width of the half_joiner.\n//   ---\n//   base = Length of the backing to the half_joiner.\n//   ang = Overhang angle of the half_joiner.\n//   screwsize = If given, diameter of screwhole.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = Printer specific slop value to make parts fit more closely.\n// Examples(FlatSpin,VPD=75):\n//   half_joiner(screwsize=3);\n//   half_joiner(l=20,w=10,base=10);\n// Example(3D):\n//   diff()\n//   cuboid(40)\n//       attach([FWD,TOP,RIGHT])\n//           xcopies(20) half_joiner();\nfunction half_joiner(l=20, w=10, base=10, ang=30, screwsize, anchor=CENTER, spin=0, orient=UP) =\n    let(\n        guide = [w/3-get_slop()*2, ang_adj_to_opp(ang, l/3)*2, l/3],\n        snap_h = 1,\n        snap = [guide.x+snap_h, 2*snap_h, l*0.6],\n        slope = guide.z/2/(w/8),\n        snap_top = slope * (snap.x-guide.x)/2,\n\n        verts = [\n            [-w/2,-base,-l/2], [-w/2,-base,l/2], [w/2,-base,l/2], [w/2,-base,-l/2],\n\n            [-w/2, 0,-l/2],\n            [-w/2,-guide.y/2,-guide.z/2],\n            [-w/2,-guide.y/2, guide.z/2],\n            [-w/2, 0,l/2],\n            [ w/2, 0,l/2],\n            [ w/2,-guide.y/2, guide.z/2],\n            [ w/2,-guide.y/2,-guide.z/2],\n            [ w/2, 0,-l/2],\n\n            [-guide.x/2, 0,-l/2],\n            [-guide.x/2,-guide.y/2,-guide.z/2],\n            [-guide.x/2-w/8,-guide.y/2, 0],\n            [-guide.x/2,-guide.y/2, guide.z/2],\n            [-guide.x/2, 0,l/2],\n            [ guide.x/2, 0,l/2],\n            [ guide.x/2,-guide.y/2, guide.z/2],\n            [ guide.x/2+w/8,-guide.y/2, 0],\n            [ guide.x/2,-guide.y/2,-guide.z/2],\n            [ guide.x/2, 0,-l/2],\n\n            [-w/6, -snap.y/2, -snap.z/2],\n            [-w/6, -snap.y/2, -guide.z/2],\n            [-snap.x/2, 0, min(snap_top-guide.z/2,-default(screwsize,0)*1.1/2)],\n            [-w/6,  snap.y/2, -guide.z/2],\n            [-w/6,  snap.y/2, -snap.z/2],\n            [-snap.x/2, 0, snap_top-snap.z/2],\n\n            [-w/6, -snap.y/2, snap.z/2],\n            [-w/6, -snap.y/2, guide.z/2],\n            [-snap.x/2, 0, max(guide.z/2-snap_top, default(screwsize,0)*1.1/2)],\n            [-w/6,  snap.y/2, guide.z/2],\n            [-w/6,  snap.y/2, snap.z/2],\n            [-snap.x/2, 0, snap.z/2-snap_top],\n\n            [ w/6, -snap.y/2, snap.z/2],\n            [ w/6, -snap.y/2, guide.z/2],\n            [ snap.x/2, 0, max(guide.z/2-snap_top, default(screwsize,0)*1.1/2)],\n            [ w/6,  snap.y/2, guide.z/2],\n            [ w/6,  snap.y/2, snap.z/2],\n            [ snap.x/2, 0, snap.z/2-snap_top],\n\n            [ w/6, -snap.y/2, -snap.z/2],\n            [ w/6, -snap.y/2, -guide.z/2],\n            [ snap.x/2, 0, min(snap_top-guide.z/2,-default(screwsize,0)*1.1/2)],\n            [ w/6,  snap.y/2, -guide.z/2],\n            [ w/6,  snap.y/2, -snap.z/2],\n            [ snap.x/2, 0, snap_top-snap.z/2],\n\n            [-w/6, guide.y/2, -guide.z/2],\n            [-guide.x/2-w/8, guide.y/2, 0],\n            [-w/6, guide.y/2,  guide.z/2],\n            [ w/6, guide.y/2,  guide.z/2],\n            [ guide.x/2+w/8, guide.y/2, 0],\n            [ w/6, guide.y/2, -guide.z/2],\n\n            if (screwsize != undef) each [\n                for (a = [0:45:359]) [guide.x/2+w/8, 0, 0] + screwsize * 1.1 / 2 * [-abs(sin(a))/slope, cos(a), sin(a)],\n                for (a = [0:45:359]) [-(guide.x/2+w/8), 0, 0] + screwsize * 1.1 / 2 * [abs(sin(a))/slope, cos(a), sin(a)],\n            ]\n        ],\n        faces = [\n            [0,1,2], [2,3,0],\n\n            [0,4,5], [0,5,6], [0,6,1], [1,6,7],\n            [3,10,11], [3,9,10], [2,9,3], [2,8,9],\n\n            [1,7,16], [1,16,17], [1,17,8], [1,8,2],\n            [0,3,11], [0,11,21], [0,21,12], [0,12,4],\n\n            [10,20,11], [20,21,11],\n            [12,13,5], [12,5,4],\n            [9,8,18], [17,18,8],\n            [6,16,7], [6,15,16],\n\n            [19,10,9], [19,9,18], [19,20,10],\n            [6,14,15], [6,5,14], [5,13,14],\n\n            [24,26,25], [26,24,27],\n            [22,27,24], [22,24,23],\n            [22,26,27],\n\n            [30,32,33], [30,31,32],\n            [30,33,28], [30,28,29],\n            [32,28,33],\n\n            [40,41,42], [40,42,45],\n            [45,42,43], [43,44,45],\n            [40,45,44],\n\n            [36,38,37], [36,39,38],\n            [36,35,34], [36,34,39],\n            [39,34,38],\n\n            [12,26,22], [12,22,13], [22,23,13], [12,46,26], [46,25,26],\n            [16,28,32], [16,15,28], [15,29,28], [48,16,32], [32,31,48],\n            [17,38,34], [17,34,18], [18,34,35], [49,38,17], [37,38,49],\n            [21,40,44], [51,21,44], [43,51,44], [20,40,21], [20,41,40],\n\n            [17,16,49], [49,16,48],\n            [21,51,46], [46,12,21],\n\n            [51,50,49], [48,47,46], [46,51,49], [46,49,48],\n\n            if (screwsize == undef) each [\n                [19,36,50], [19,35,36], [19,18,35], [36,37,50], [49,50,37],\n                [19,50,42], [19,42,41], [41,20,19], [50,43,42], [50,51,43],\n                [14,24,47], [14,23,24], [14,13,23], [47,24,25], [46,47,25],\n                [47,30,14], [14,30,29], [14,29,15], [47,31,30], [47,48,31],\n            ] else each [\n                [20,19,56], [20,56,57], [20,57,58], [41,58,42], [20,58,41],\n                [50,51,52], [51,59,52], [51,58,59], [43,42,58], [51,43,58],\n                [49,50,52], [49,52,53], [49,53,54], [37,54,36], [49,54,37],\n                [56,19,18], [18,55,56], [18,54,55], [35,36,54], [18,35,54],\n                [14,64,15], [15,64,63], [15,63,62], [29,62,30], [15,62,29],\n                [48,31,62], [31,30,62], [48,62,61], [48,61,60], [60,47,48],\n                [13,23,66], [23,24,66], [13,66,65], [13,65,64], [64,14,13],\n                [46,47,60], [46,60,67], [46,67,66], [46,66,25], [66,24,25],\n                for (i=[0:7]) let(b=52) [b+i, b+8+i, b+8+(i+1)%8],\n                for (i=[0:7]) let(b=52) [b+i, b+8+(i+1)%8, b+(i+1)%8],\n            ],\n        ],\n        pvnf = [verts, faces],\n        vnf = xrot(90, p=pvnf)\n    ) reorient(anchor,spin,orient, size=[w,l,base*2], p=vnf);\n\nmodule half_joiner(l=20, w=10, base=10, ang=30, screwsize, anchor=CENTER, spin=0, orient=UP)\n{\n    vnf = half_joiner(l=l, w=w, base=base, ang=ang, screwsize=screwsize);\n    if (is_list($tags_shown) && in_list(\"remove\",$tags_shown)) {\n        attachable(anchor,spin,orient, size=[w,l,base*2], $tag=\"remove\") {\n            half_joiner_clear(l=l, w=w, ang=ang, clearance=1);\n            union();\n        }\n    } else {\n        attachable(anchor,spin,orient, size=[w,base*2,l], $tag=\"keep\") {\n            vnf_polyhedron(vnf, convexity=12);\n            children();\n        }\n    }\n}\n\n\n// Function&Module: half_joiner2()\n// Synopsis: Creates a half_joiner2 shape to mate with a {{half_joiner()}} shape..\n// SynTags: Geom, VNF\n// Topics: Joiners, Parts\n// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner(), snap_pin(), rabbit_clip(), dovetail()\n// Usage: As Module\n//   half_joiner2(l, w, [base=], [ang=], [screwsize=])\n// Usage: As Function\n//   vnf = half_joiner2(l, w, [base=], [ang=], [screwsize=])\n// Description:\n//   Creates a half_joiner2 object that can be attached to half_joiner object.\n// Arguments:\n//   l = Length of the half_joiner.\n//   w = Width of the half_joiner.\n//   ---\n//   base = Length of the backing to the half_joiner.\n//   ang = Overhang angle of the half_joiner.\n//   screwsize = Diameter of screwhole.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples(FlatSpin,VPD=75):\n//   half_joiner2(screwsize=3);\n//   half_joiner2(w=10,base=10,l=20);\n// Example(3D):\n//   diff()\n//   cuboid(40)\n//       attach([FWD,TOP,RIGHT])\n//           xcopies(20) half_joiner2();\nfunction half_joiner2(l=20, w=10, base=10, ang=30, screwsize, anchor=CENTER, spin=0, orient=UP) =\n    let(\n        guide = [w/3, ang_adj_to_opp(ang, l/3)*2, l/3],\n        snap_h = 1,\n        snap = [guide.x+snap_h, 2*snap_h, l*0.6],\n        slope = guide.z/2/(w/8),\n        snap_top = slope * (snap.x-guide.x)/2,\n        s1 = min(snap_top-guide.z/2,-default(screwsize,0)*1.1/2),\n        s2 = max(guide.z/2-snap_top, default(screwsize,0)*1.1/2),\n\n        verts = [\n            [-w/2,-base,-l/2], [-w/2,-base,l/2], [w/2,-base,l/2], [w/2,-base,-l/2],\n\n            [-w/2, 0,-l/2],\n            [-w/2, guide.y/2,-guide.z/2],\n            [-w/2, guide.y/2, guide.z/2],\n            [-w/2, 0,l/2],\n            [ w/2, 0,l/2],\n            [ w/2, guide.y/2, guide.z/2],\n            [ w/2, guide.y/2,-guide.z/2],\n            [ w/2, 0,-l/2],\n\n            [-guide.x/2, 0,-l/2],\n            [-guide.x/2,-guide.y/2,-guide.z/2],\n            [-guide.x/2-w/8,-guide.y/2, 0],\n            [-guide.x/2,-guide.y/2, guide.z/2],\n            [-guide.x/2, 0,l/2],\n            [ guide.x/2, 0,l/2],\n            [ guide.x/2,-guide.y/2, guide.z/2],\n            [ guide.x/2+w/8,-guide.y/2, 0],\n            [ guide.x/2,-guide.y/2,-guide.z/2],\n            [ guide.x/2, 0,-l/2],\n\n            [-w/6, -snap.y/2, -snap.z/2],\n            [-w/6, -snap.y/2, -guide.z/2],\n            [-snap.x/2, 0, s1],\n            [-w/6,  snap.y/2, -guide.z/2],\n            [-w/6,  snap.y/2, -snap.z/2],\n            [-snap.x/2, 0, snap_top-snap.z/2],\n\n            [-w/6, -snap.y/2, snap.z/2],\n            [-w/6, -snap.y/2, guide.z/2],\n            [-snap.x/2, 0, s2],\n            [-w/6,  snap.y/2, guide.z/2],\n            [-w/6,  snap.y/2, snap.z/2],\n            [-snap.x/2, 0, snap.z/2-snap_top],\n\n            [ w/6, -snap.y/2, snap.z/2],\n            [ w/6, -snap.y/2, guide.z/2],\n            [ snap.x/2, 0, s2],\n            [ w/6,  snap.y/2, guide.z/2],\n            [ w/6,  snap.y/2, snap.z/2],\n            [ snap.x/2, 0, snap.z/2-snap_top],\n\n            [ w/6, -snap.y/2, -snap.z/2],\n            [ w/6, -snap.y/2, -guide.z/2],\n            [ snap.x/2, 0, s1],\n            [ w/6,  snap.y/2, -guide.z/2],\n            [ w/6,  snap.y/2, -snap.z/2],\n            [ snap.x/2, 0, snap_top-snap.z/2],\n\n            [-w/6, guide.y/2, -guide.z/2],\n            [-guide.x/2-w/8, guide.y/2, 0],\n            [-w/6, guide.y/2,  guide.z/2],\n            [ w/6, guide.y/2,  guide.z/2],\n            [ guide.x/2+w/8, guide.y/2, 0],\n            [ w/6, guide.y/2, -guide.z/2],\n\n            if (screwsize != undef) each [\n                for (a = [0:45:359]) [guide.x/2+w/8, 0, 0] + screwsize * 1.1 / 2 * [-abs(sin(a))/slope, cos(a), sin(a)],\n                for (a = [0:45:359]) [-(guide.x/2+w/8), 0, 0] + screwsize * 1.1 / 2 * [abs(sin(a))/slope, cos(a), sin(a)],\n                for (a = [0:45:359]) [w/2, 0, 0] + screwsize * 1.1 / 2 * [0, cos(a), sin(a)],\n                for (a = [0:45:359]) [-w/2, 0, 0] + screwsize * 1.1 / 2 * [0, cos(a), sin(a)],\n            ]\n        ],\n        faces = [\n            [0,1,2], [2,3,0],\n\n            [1,7,16], [1,16,17], [1,17,8], [1,8,2],\n            [0,3,11], [0,11,21], [0,21,12], [0,12,4],\n\n            [10,51,11], [51,21,11],\n            [12,46,5], [12,5,4],\n            [9,8,49], [17,49,8],\n            [6,16,7], [6,48,16],\n\n            [50,10,9], [50,9,49], [50,51,10],\n            [6,47,48], [6,5,47], [5,46,47],\n\n            [24,25,26], [26,27,24],\n            [22,24,27], [22,23,24],\n            [22,27,26],\n\n            [30,33,32], [30,32,31],\n            [30,28,33], [30,29,28],\n            [32,33,28],\n\n            [40,42,41], [40,45,42],\n            [45,43,42], [43,45,44],\n            [40,44,45],\n\n            [36,37,38], [36,38,39],\n            [36,34,35], [36,39,34],\n            [39,38,34],\n\n            [12,22,26], [12,13,22], [22,13,23], [12,26,46], [46,26,25],\n            [16,32,28], [16,28,15], [15,28,29], [48,32,16], [32,48,31],\n            [17,34,38], [17,18,34], [18,35,34], [49,17,38], [37,49,38],\n            [21,44,40], [51,44,21], [43,44,51], [20,21,40], [20,40,41],\n\n            [17,16,18], [18,16,15],\n            [21,20,13], [13,12,21],\n\n            [20,19,18], [15,14,13], [13,20,18], [13,18,15],\n\n            if (screwsize == undef) each [\n                [0,4,5], [0,5,6], [0,6,1], [1,6,7],\n                [3,10,11], [3,9,10], [2,9,3], [2,8,9],\n\n                [19,50,36], [19,36,35], [19,35,18], [36,50,37], [49,37,50],\n                [19,42,50], [19,41,42], [41,19,20], [50,42,43], [50,43,51],\n                [14,47,24], [14,24,23], [14,23,13], [47,25,24], [46,25,47],\n                [47,14,30], [14,29,30], [14,15,29], [47,30,31], [47,31,48],\n            ] else each [\n                [3,2,72], [2,71,72], [2,70,71], [2,8,70],\n                [8,9,70], [9,69,70], [9,68,69], [9,10,68],\n                [10,75,68], [10,74,75], [10,11,74],\n                [3,72,73], [3,73,74], [3,74,11],\n\n                [1,0,80], [0,81,80], [0,82,81], [0,4,82],\n                [4,5,82], [5,83,82], [5,76,83], [5,6,76],\n                [6,77,76], [6,78,77], [6,7,78],\n                [7,1,78], [1,79,78], [1,80,79],\n\n                [20,56,19], [20,57,56], [20,41,57], [41,58,57], [41,42,58],\n                [50,52,51], [51,52,59], [43,59,58], [43,58,42], [51,59,43],\n                [49,52,50], [49,53,52], [49,37,53], [37,36,54], [54,53,37],\n                [56,18,19], [18,56,55], [18,55,35], [35,55,54], [36,35,54],\n                [14,15,64], [15,63,64], [15,29,63], [29,62,63], [29,30,62],\n                [31,48,61], [31,61,62], [30,31,62], [48,60,61], [60,48,47],\n                [23,13,65], [65,66,23], [24,23,66], [13,64,65], [64,13,14],\n                [46,60,47], [46,67,60], [46,25,67], [66,67,25], [25,24,66],\n\n                for (i=[0:7]) let(b=52) each [\n                    [b+i, b+16+(i+1)%8, b+16+i],\n                    [b+i, b+(i+1)%8, b+16+(i+1)%8],\n                ],\n                for (i=[0:7]) let(b=60) each [\n                    [b+i, b+16+i, b+16+(i+1)%8],\n                    [b+i, b+16+(i+1)%8, b+(i+1)%8],\n                ],\n            ],\n        ],\n        verts2 = [\n            for (i = idx(verts))\n            !approx(s2, verts[54].z)? verts[i] :\n            i==54? [ snap.x/2-0.01, verts[i].y, verts[i].z] :\n            i==58? [ snap.x/2-0.01, verts[i].y, verts[i].z] :\n            i==62? [-snap.x/2+0.01, verts[i].y, verts[i].z] :\n            i==66? [-snap.x/2+0.01, verts[i].y, verts[i].z] :\n            verts[i]\n        ],\n        pvnf = [verts2, faces],\n        vnf = xrot(90, p=pvnf)\n    ) reorient(anchor,spin,orient, size=[w,l,base*2], p=vnf);\n\nmodule half_joiner2(l=20, w=10, base=10, ang=30, screwsize, anchor=CENTER, spin=0, orient=UP)\n{\n    vnf = half_joiner2(l=l, w=w, base=base, ang=ang, screwsize=screwsize);\n    if (is_list($tags_shown) && in_list(\"remove\",$tags_shown)) {\n        attachable(anchor,spin,orient, size=[w,l,base*2], $tag=\"remove\") {\n            half_joiner_clear(l=l, w=w, ang=ang, clearance=1);\n            union();\n        }\n    } else {\n        attachable(anchor,spin,orient, size=[w,base*2,l], $tag=\"keep\") {\n            vnf_polyhedron(vnf, convexity=12);\n            children();\n        }\n    }\n}\n\n\n\n// Section: Full Joiners\n\n\n// Module: joiner_clear()\n// Synopsis: Creates a mask to clear space for a {{joiner()}} shape.\n// SynTags: Geom\n// Topics: Joiners, Parts\n// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner(), snap_pin(), rabbit_clip(), dovetail()\n// Description:\n//   Creates a mask to clear an area so that a joiner can be placed there.\n// Usage:\n//   joiner_clear(l, w, [ang=], [clearance=], [overlap=]) [ATTACHMENTS];\n// Arguments:\n//   l = Length of the joiner to clear space for.\n//   w = Width of the joiner to clear space for.\n//   ang = Overhang angle of the joiner.\n//   ---\n//   clearance = Extra width to clear.\n//   overlap = Extra depth to clear.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   joiner_clear();\nfunction joiner_clear(l=40, w=10, ang=30, clearance=0, overlap=0.01, anchor=CENTER, spin=0, orient=UP) = no_function(\"joiner_clear\");\nmodule joiner_clear(l=40, w=10, ang=30, clearance=0, overlap=0.01, anchor=CENTER, spin=0, orient=UP)\n{\n    dmnd_height = l*0.5;\n    dmnd_width = dmnd_height*tan(ang);\n    guide_size = w/3;\n    guide_width = 2*(dmnd_height/2-guide_size)*tan(ang);\n\n    attachable(anchor,spin,orient, size=[w, guide_width, l]) {\n        union() {\n            back(l/4) half_joiner_clear(l=l/2+0.01, w=w, ang=ang, overlap=overlap, clearance=clearance);\n            fwd(l/4) half_joiner_clear(l=l/2+0.01, w=w, ang=ang, overlap=overlap, clearance=-0.01);\n        }\n        children();\n    }\n}\n\n\n\n// Module: joiner()\n// Synopsis: Creates a joiner shape that can mate with another rotated joiner shape.\n// SynTags: Geom\n// Topics: Joiners, Parts\n// See Also: half_joiner_clear(), half_joiner(), half_joiner2(), joiner_clear(), joiner(), snap_pin(), rabbit_clip(), dovetail()\n// Usage:\n//   joiner(l, w, base, [ang=], [screwsize=], [$slop=]) [ATTACHMENTS];\n// Description:\n//   Creates a joiner object that can be attached to another joiner object.\n// Arguments:\n//   l = Length of the joiner.\n//   w = Width of the joiner.\n//   base = Length of the backing to the joiner.\n//   ang = Overhang angle of the joiner.\n//   ---\n//   screwsize = If given, diameter of screwhole.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = Printer specific slop value to make parts fit more closely.\n// Examples(FlatSpin,VPD=125):\n//   joiner(screwsize=3);\n//   joiner(l=40, w=10, base=10);\n// Example(3D):\n//   diff()\n//   cuboid(50)\n//     attach([FWD,TOP,RIGHT])\n//       zrot_copies(n=2,r=15)\n//         joiner();\nfunction joiner(l=40, w=10, base=10, ang=30, screwsize, anchor=CENTER, spin=0, orient=UP) = no_function(\"joiner\");\nmodule joiner(l=40, w=10, base=10, ang=30, screwsize, anchor=CENTER, spin=0, orient=UP)\n{\n    if (is_list($tags_shown) && in_list(\"remove\",$tags_shown)) {\n        attachable(anchor,spin,orient, size=[w,l,base*2], $tag=\"remove\") {\n            joiner_clear(w=w, l=l, ang=ang, clearance=1);\n            union();\n        }\n    } else {\n        attachable(anchor,spin,orient, size=[w,l,base*2], $tag=\"keep\") {\n            union() {\n                back(l/4) half_joiner(l=l/2, w=w, base=base, ang=ang, screwsize=screwsize);\n                fwd(l/4) half_joiner2(l=l/2, w=w, base=base, ang=ang, screwsize=screwsize);\n            }\n            children();\n        }\n    }\n}\n\n\n\n// Section: Dovetails\n\n// Module: dovetail()\n// Synopsis: Creates a possibly tapered dovetail shape.\n// SynTags: Geom\n// Topics: Joiners, Parts\n// See Also: joiner(), snap_pin(), rabbit_clip()\n//\n// Usage:\n//   dovetail(gender, w=|width, h=|height, slide|thickness=, [slope=|angle=], [taper=|back_width=], [chamfer=], [r=|radius=], [round=], [extra=], [$slop=])\n//\n// Description:\n//   Produces a possibly tapered dovetail joint shape to attach to or subtract from two parts you wish to join together.\n//   The tapered dovetail is particularly advantageous for long joints because the joint assembles without binding until\n//   it is fully closed, and then wedges tightly.  You can chamfer or round the corners of the dovetail shape for better\n//   printing and assembly, or choose a fully rounded joint that looks more like a puzzle piece.  The dovetail appears\n//   parallel to the Y axis and projecting upwards, so in its default orientation it will slide together with a translation\n//   in the positive Y direction.  The gender determines whether the shape is meant to be added to your model or\n//   differenced, and it also changes the anchor and orientation.  The default anchor for dovetails is BOTTOM;\n//   the default orientation depends on the gender, with male dovetails oriented UP and female ones DOWN.  The dovetails by default\n//   have extra extension of 0.01 for unions and differences.  You should ensure that attachment is done with overlap=0 to ensure that\n//   the sizing and positioning is correct.  To adjust the fit, use the $slop variable, which increases the depth and width of\n//   the female part of the joint to allow a clearance gap of $slop on each of the three sides.\n//\n// Arguments:\n//   gender = A string, \"male\" or \"female\", to specify the gender of the dovetail.\n//   w / width = Width (at the wider, top end) of the dovetail before tapering\n//   h / height = Height of the dovetail (the amount it projects from its base)\n//   slide / thickness = Distance the dovetail slides when you assemble it (length of sliding dovetails, thickness of regular dovetails)\n//   ---\n//   slope = slope of the dovetail.  Standard woodworking slopes are 4, 6, or 8.  Default: 6.\n//   angle = angle (in degrees) of the dovetail.  Specify only one of slope and angle.\n//   taper = taper angle (in degrees). Dovetail gets narrower by this angle.  Default: no taper\n//   back_width = width of right hand end of the dovetail.  This alternate method of specifying the taper may be easier to manage.  Specify only one of `taper` and `back_width`.  Note that `back_width` should be smaller than `width` to taper in the customary direction, with the smaller end at the back.\n//   chamfer = amount to chamfer the corners of the joint (Default: no chamfer)\n//   r / radius = amount to round over the corners of the joint (Default: no rounding)\n//   round = true to round both corners of the dovetail and give it a puzzle piece look.  Default: false.\n//   $slop = Increase the width of socket by double this amount and depth by this amount to allow adjustment of the fit.\n//   extra = amount of extra length and base extension added to dovetails for unions and differences.  Default: 0.01\n// Example: Ordinary straight dovetail, male version (sticking up) and female version (below the xy plane)\n//   dovetail(\"male\", width=15, height=8, slide=30);\n//   right(20) dovetail(\"female\", width=15, height=8, slide=30);\n// Example: Adding a 6 degree taper (Such a big taper is usually not necessary, but easier to see for the example.)\n//   dovetail(\"male\", w=15, h=8, slide=30, taper=6);\n//   right(20) dovetail(\"female\", 15, 8, 30, taper=6);  // Same as above\n// Example: A block that can link to itself\n//   diff()\n//     cuboid([50,30,10]){\n//       attach(BACK) dovetail(\"male\", slide=10, width=15, height=8);\n//       tag(\"remove\")attach(FRONT) dovetail(\"female\", slide=10, width=15, height=8);\n//     }\n// Example: Setting the dovetail angle.  This is too extreme to be useful.\n//   diff()\n//     cuboid([50,30,10]){\n//       attach(BACK) dovetail(\"male\", slide=10, width=15, height=8, angle=30);\n//       tag(\"remove\")attach(FRONT) dovetail(\"female\", slide=10, width=15, height=8, angle=30);\n//     }\n// Example: Adding a chamfer helps printed parts fit together without problems at the corners\n//   diff(\"remove\")\n//     cuboid([50,30,10]){\n//       attach(BACK) dovetail(\"male\", slide=10, width=15, height=8, chamfer=1);\n//       tag(\"remove\")attach(FRONT) dovetail(\"female\", slide=10, width=15, height=8,chamfer=1);\n//     }\n// Example: Rounding the outside corners is another option\n//   diff(\"remove\")\n//   cuboid([50,30,10]) {\n//       attach(BACK)  dovetail(\"male\", slide=10, width=15, height=8, radius=1, $fn=32);\n//       tag(\"remove\") attach(FRONT) dovetail(\"female\", slide=10, width=15, height=8, radius=1, $fn=32);\n//   }\n// Example: Or you can make a fully rounded joint\n//   $fn=32;\n//   diff(\"remove\")\n//   cuboid([50,30,10]){\n//       attach(BACK) dovetail(\"male\", slide=10, width=15, height=8, radius=1.5, round=true);\n//       tag(\"remove\")attach(FRONT) dovetail(\"female\", slide=10, width=15, height=8, radius=1.5, round=true);\n//   }\n// Example: With a long joint like this, a taper makes the joint easy to assemble.  It will go together easily and wedge tightly if you get the tolerances right.  Specifying the taper with `back_width` may be easier than using a taper angle.\n//   cuboid([50,30,10])\n//     attach(TOP) dovetail(\"male\", slide=50, width=18, height=4, back_width=15, spin=90);\n//   fwd(35)\n//     diff(\"remove\")\n//       cuboid([50,30,10])\n//         tag(\"remove\") attach(TOP) dovetail(\"female\", slide=50, width=18, height=4, back_width=15, spin=90);\n// Example: A series of dovetails forming a tail board, with the inside of the joint up.  A standard wood joint would have a zero taper.\n//   cuboid([50,30,10])\n//     attach(BACK) xcopies(10,5) dovetail(\"male\", slide=10, width=7, taper=4, height=4);\n// Example: Mating pin board for a half-blind right angle joint, where the joint only shows on the side but not the front.  Note that the anchor method and use of `spin` ensures that the joint works even with a taper.\n//   diff(\"remove\")\n//     cuboid([50,30,10])\n//       tag(\"remove\")position(TOP+BACK) xcopies(10,5) dovetail(\"female\", slide=10, width=7, taper=4, height=4, anchor=BOTTOM+FRONT,spin=180);\nfunction dovetail(gender, width, height, slide, h, w, angle, slope, thickness, taper, back_width, chamfer, extra=0.01, r, radius, round=false, anchor=BOTTOM, spin=0, orient) = no_function(\"dovetail\");\nmodule dovetail(gender, width, height, slide, h, w, angle, slope, thickness, taper, back_width, chamfer, extra=0.01, r, radius, round=false, anchor=BOTTOM, spin=0, orient)\n{\n    radius = get_radius(r1=radius,r2=r);\n    slide = one_defined([slide,thickness],\"slide,thickness\");\n    h = one_defined([h,height],\"h,height\");\n    w = one_defined([w,width],\"w,width\");\n    orient = is_def(orient) ? orient\n           : gender == \"female\" ? DOWN\n           : UP;\n    count = num_defined([angle,slope]);\n    count2 = num_defined([taper,back_width]);\n    count3 = num_defined([chamfer, radius]);\n    dummy =\n        assert(count<=1, \"Do not specify both angle and slope\")\n        assert(count2<=1, \"Do not specify both taper and back_width\")\n        assert(count3<=1 || (radius==0 && chamfer==0), \"Do not specify both chamfer and radius\");\n    slope = is_def(slope) ? slope\n          : is_def(angle) ? 1/tan(angle)\n          :  6;\n    height_slop = gender == \"female\" ? get_slop() : 0;\n\n    // Need taper angle for computing width adjustment, but not used elsewhere\n    taper_ang = is_def(taper) ? taper\n              : is_def(back_width) ? atan((back_width-width)/2/slide)\n              : 0;\n    // This is the adjustment factor for width to grow in the direction normal to the dovetail face\n    wfactor = sqrt( 1/slope^2 + 1/cos(taper_ang)^2 );\n             // adjust width for increased height    adjust for normal to dovetail surface\n    width_slop = 2*height_slop/slope                + 2* height_slop * wfactor;\n    width = w + width_slop;\n    height = h + height_slop;\n    back_width = u_add(back_width, width_slop);\n\n    extra_offset = is_def(taper) ? -extra * tan(taper)\n                 : is_def(back_width) ? extra * (back_width-width)/slide/2\n                 : 0;\n\n    size = is_def(chamfer) && chamfer>0 ? chamfer\n         : is_def(radius) && radius>0 ? radius\n         : 0;\n    fullsize = round ? [size,size]\n             : gender == \"male\" ? [size,0]\n             : [0,size];\n\n    type = is_def(chamfer) && chamfer>0 ? \"chamfer\" : \"circle\";\n\n    smallend_half = round_corners(\n        move(\n            [0,-slide/2-extra,0],\n            p=[\n                [0,                                     0, height],\n                [width/2 - extra_offset,                0, height],\n                [width/2 - extra_offset - height/slope, 0, 0     ],\n                [width/2 - extra_offset + height,       0, 0     ]\n            ]\n        ),\n        method=type, cut = fullsize, closed=false\n    );\n\n    smallend_points = concat(select(smallend_half, 1, -2), [down(extra,p=select(smallend_half, -2))]);\n    offset = is_def(taper) ? -slide * tan(taper)\n           : is_def(back_width) ? (back_width-width) / 2\n           : 0;\n    bigend_points = move([offset+2*extra_offset,slide+2*extra,0], p=smallend_points);\n\n    bigenough = all_nonnegative(column(smallend_half,0)) && all_nonnegative(column(bigend_points,0));\n\n    assert(bigenough, \"Width of dovetail is not large enough for its geometry (angle and taper\");\n\n    //adjustment = $overlap * (gender == \"male\" ? -1 : 1);  // Adjustment for default overlap in attach()\n    adjustment = 0;    // Default overlap is assumed to be zero\n\n    // This code computes the true normal from which the exact width factor can be obtained\n    // as the x component.  Comparing to wfactor above shows that they agree.\n    //   pts = [smallend_points[0], smallend_points[1], bigend_points[1],bigend_points[0]];\n    //   n = -polygon_normal(pts);\n    //   echo(n=n);\n    //   echo(invwfactor = 1/wfactor, error = n.x-1/wfactor);\n\n    attachable(anchor,spin,orient, size=[width+2*offset, slide, height]) {\n        down(height/2+adjustment) {\n            //color(\"red\")stroke([pts],width=.1);\n\n            skin(\n                [\n                    reverse(concat(smallend_points, xflip(p=reverse(smallend_points)))),\n                    reverse(concat(bigend_points, xflip(p=reverse(bigend_points))))\n                ],\n                slices=0, convexity=4\n            );\n        }\n        children();\n    }\n}\n\n\n// Section: Tension Clips\n\n// h is total height above 0 of the nub\n// nub extends below xy plane by distance nub/2\nmodule _pin_nub(r, nub, h)\n{\n    L = h / 4;\n    rotate_extrude(){\n      polygon(\n       [[ 0,-nub/2],\n        [-r,-nub/2],\n        [-r-nub, nub/2],\n        [-r-nub, nub/2+L],\n        [-r, h],\n        [0, h]]);\n     }\n}\n\n\nmodule _pin_slot(l, r, t, d, nub, depth, stretch) {\n  yscale(4)\n    intersection() {\n      translate([t, 0, d + t / 4])\n          _pin_nub(r = r + t, nub = nub, h = l - (d + t / 4));\n      translate([-t, 0, d + t / 4])\n          _pin_nub(r = r + t, nub = nub, h = l - (d + t / 4));\n    }\n  cube([2 * r, depth, 2 * l], center = true);\n  up(l)\n    zscale(stretch)\n      ycyl(r = r, h = depth);\n}\n\n\nmodule _pin_shaft(r, lStraight, nub, nubscale, stretch, d, pointed)\n{\n   extra = 0.02;         // This sets the extra extension below the socket bottom\n                         // so that difference() works without issues\n   rPoint = r / sqrt(2);\n   down(extra) cylinder(r = r, h = lStraight + extra);\n   up(lStraight) {\n      zscale(stretch) {\n         hull() {\n            sphere(r = r);\n            if (pointed) up(rPoint) cylinder(r1 = rPoint, r2 = 0, h = rPoint/stretch);\n         }\n      }\n   }\n   up(d) yscale(nubscale) _pin_nub(r = r, nub = nub, h = lStraight - d);\n}\n\nfunction _pin_size(size) =\n  is_undef(size) ? [] :\n  let(sizeok = in_list(size,[\"tiny\", \"small\",\"medium\", \"large\", \"standard\"]))\n  assert(sizeok,\"Pin size must be one of \\\"tiny\\\", \\\"small\\\", \\\"medium\\\" or \\\"standard\\\"\")\n  size==\"standard\" || size==\"large\" ?\n     struct_set([], [\"length\", 10.8,\n                     \"diameter\", 7,\n                     \"snap\", 0.5,\n                     \"nub_depth\", 1.8,\n                     \"thickness\", 1.8,\n                     \"preload\", 0.2]):\n  size==\"medium\" ?\n     struct_set([], [\"length\", 8,\n                     \"diameter\", 4.6,\n                     \"snap\", 0.45,\n                     \"nub_depth\", 1.5,\n                     \"thickness\", 1.4,\n                     \"preload\", 0.2]) :\n  size==\"small\" ?\n     struct_set([], [\"length\", 6,\n                     \"diameter\", 3.2,\n                     \"snap\", 0.4,\n                     \"nub_depth\", 1.2,\n                     \"thickness\", 1.0,\n                     \"preload\", 0.16]) :\n  size==\"tiny\" ?\n     struct_set([], [\"length\", 4,\n                     \"diameter\", 2.5,\n                     \"snap\", 0.25,\n                     \"nub_depth\", 0.9,\n                     \"thickness\", 0.8,\n                     \"preload\", 0.1]):\n  undef;\n\n\n// Module: snap_pin()\n// Synopsis: Creates a snap-pin that can slot into a {{snap_pin_socket()}} to join two parts.\n// SynTags: Geom\n// Topics: Joiners, Parts\n// See Also: snap_pin_socket(), joiner(), dovetail(), snap_pin(), rabbit_clip()\n// Usage:\n//    snap_pin(size, [pointed=], [anchor=], [spin=], [orient]=) [ATTACHMENTS];\n//    snap_pin(r=|radius=|d=|diameter=, l=|length=, nub_depth=, snap=, thickness=, [clearance=], [preload=], [pointed=]) [ATTACHMENTS];\n// Description:\n//    Creates a snap pin that can be inserted into an appropriate socket to connect two objects together.  You can choose from some standard\n//    pin dimensions by giving a size, or you can specify all the pin geometry parameters yourself.  If you use a standard size you can\n//    override the standard parameters by specifying other ones.  The pins have flat sides so they can\n//    be printed.  When oriented UP the shaft of the pin runs in the Z direction and the flat sides are the front and back.  The default\n//    orientation (FRONT) and anchor (FRONT) places the pin in a printable configuration, flat side down on the xy plane.\n//    The tightness of fit is determined by `preload` and `clearance`.  To make pins tighter increase `preload` and/or decrease `clearance`.\n//    .\n//    The \"large\" or \"standard\" size pin has a length of 10.8 and diameter of 7.  The \"medium\" pin has a length of 8 and diameter of 4.6.  The \"small\" pin\n//    has a length of 6 and diameter of 3.2.  The \"tiny\" pin has a length of 4 and a diameter of 2.5.\n//    .\n//    This pin is based on https://www.thingiverse.com/thing:213310 by Emmett Lalishe\n//    and a modified version at https://www.thingiverse.com/thing:3218332 by acwest\n//    and distributed under the Creative Commons - Attribution - Share Alike License\n// Arguments:\n//    size = text string to select from a list of predefined sizes, one of \"standard\", \"medium\", \"small\", or \"tiny\".\n//    ---\n//    pointed = set to true to get a pointed pin, false to get one with a rounded end.  Default: true\n//    r/radius = radius of the pin\n//    d/diameter = diameter of the pin\n//    l/length = length of the pin\n//    nub_depth = the distance of the nub from the base of the pin\n//    snap = how much snap the pin provides (the nub projection)\n//    thickness = thickness of the pin walls\n//    pointed = if true the pin is pointed, otherwise it has a rounded tip.  Default: true\n//    clearance = how far to shrink the pin away from the socket walls.  Default: 0.2\n//    preload = amount to move the nub towards the pin base, which can create tension from the misalignment with the socket.  Default: 0.2\n// Example: Pin in native orientation\n//    snap_pin(\"standard\", anchor=CENTER, orient=UP, thickness = 1, $fn=40);\n// Example: Pins oriented for printing\n//    xcopies(spacing=10, n=4) snap_pin(\"standard\", $fn=40);\nfunction snap_pin(size,r,radius,d,diameter, l,length, nub_depth, snap, thickness, clearance=0.2, preload, pointed=true, anchor=FRONT, spin=0, orient=FRONT, center) =no_function(\"snap_pin\");\nmodule snap_pin(size,r,radius,d,diameter, l,length, nub_depth, snap, thickness, clearance=0.2, preload, pointed=true, anchor=FRONT, spin=0, orient=FRONT, center) {\n  preload_default = 0.2;\n  sizedat = _pin_size(size);\n  radius = get_radius(r1=r,r2=radius,d1=d,d2=diameter,dflt=struct_val(sizedat,\"diameter\")/2);\n  length = first_defined([l,length,struct_val(sizedat,\"length\")]);\n  snap = first_defined([snap, struct_val(sizedat,\"snap\")]);\n  thickness = first_defined([thickness, struct_val(sizedat,\"thickness\")]);\n  nub_depth = first_defined([nub_depth, struct_val(sizedat,\"nub_depth\")]);\n  preload = first_defined([first_defined([preload, struct_val(sizedat, \"preload\")]),preload_default]);\n\n  nubscale = 0.9;      // Mysterious arbitrary parameter\n\n  // The basic pin assumes a rounded cap of length sqrt(2)*r, which defines lStraight.\n  // If the point is enabled the cap length is instead 2*r\n  // preload shrinks the length, bringing the nubs closer together\n\n  rInner = radius - clearance;\n  stretch = sqrt(2)*radius/rInner;  // extra stretch factor to make cap have proper length even though r is reduced.\n  lStraight = length - sqrt(2) * radius - clearance;\n  lPin = lStraight + (pointed ? 2*radius : sqrt(2)*radius);\n  attachable(anchor=anchor,spin=spin, orient=orient,\n             size=[nubscale*(2*rInner+2*snap + clearance),radius*sqrt(2)-2*clearance,2*lPin]){\n  zflip_copy()\n      difference() {\n        intersection() {\n            cube([3 * (radius + snap), radius * sqrt(2) - 2 * clearance, 2 * length + 3 * radius], center = true);\n            _pin_shaft(rInner, lStraight, snap+clearance/2, nubscale, stretch, nub_depth-preload, pointed);\n        }\n        _pin_slot(l = lStraight, r = rInner - thickness, t = thickness, d = nub_depth - preload, nub = snap, depth = 2 * radius + 0.02, stretch = stretch);\n      }\n  children();\n  }\n}\n\n// Module: snap_pin_socket()\n// Synopsis: Creates a snap-pin socket for a {{snap_pin()}} to slot into.\n// SynTags: Geom\n// Topics: Joiners, Parts\n// See Also: snap_pin(), joiner(), dovetail(), snap_pin(), rabbit_clip()\n// Usage:\n//   snap_pin_socket(size, [fixed=], [fins=], [pointed=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n//   snap_pin_socket(r=|radius=|d=|diameter=, l=|length=, nub_depth=, snap=, [fixed=], [pointed=], [fins=]) [ATTACHMENTS];\n// Description:\n//   Constructs a socket suitable for a snap_pin with the same parameters.   If `fixed` is true then the socket has flat walls and the\n//   pin will not rotate in the socket.  If `fixed` is false then the socket is round and the pin will rotate, particularly well\n//   if you add a lubricant.  If `pointed` is true the socket is pointed to receive a pointed pin, otherwise it has a rounded and and\n//   will be shorter.  If `fins` is set to true then two fins are included inside the socket to act as supports (which may help when printing tip up,\n//   especially when `pointed=false`).  The default orientation is DOWN with anchor BOTTOM so that you can difference() the socket away from an object.\n//   The socket extends 0.02 extra below its bottom anchor point so that differences will work correctly.  (You must have $overlap smaller than 0.02 in\n//   attach or the socket will be beneath the surface of the parent object.)\n//   .\n//   The \"large\" or \"standard\" size pin has a length of 10.8 and diameter of 7.  The \"medium\" pin has a length of 8 and diameter of 4.6.  The \"small\" pin\n//   has a length of 6 and diameter of 3.2.  The \"tiny\" pin has a length of 4 and a diameter of 2.5.\n// Arguments:\n//   size = text string to select from a list of predefined sizes, one of \"standard\", \"medium\", \"small\", or \"tiny\".\n//   ---\n//   pointed = set to true to get a pointed pin, false to get one with a rounded end.  Default: true\n//   r/radius = radius of the pin\n//   d/diameter = diameter of the pin\n//   l/length = length of the pin\n//   nub_depth = the distance of the nub from the base of the pin\n//   snap = how much snap the pin provides (the nub projection)\n//   fixed = if true the pin cannot rotate, if false it can.  Default: true\n//   pointed = if true the socket has a pointed tip.  Default: true\n//   fins = if true supporting fins are included.  Default: false\n// Example:  The socket shape itself in native orientation.\n//   snap_pin_socket(\"standard\", anchor=CENTER, orient=UP, fins=true, $fn=40);\n// Example:  A spinning socket with fins:\n//   snap_pin_socket(\"standard\", anchor=CENTER, orient=UP, fins=true, fixed=false, $fn=40);\n// Example:  A cube with a socket in the middle and one half-way off the front edge so you can see inside:\n//   $fn=40;\n//   diff(\"socket\") cuboid([20,20,20])\n//     tag(\"socket\"){\n//       attach(TOP) snap_pin_socket(\"standard\");\n//       position(TOP+FRONT)snap_pin_socket(\"standard\");\n//     }\nfunction snap_pin_socket(size, r, radius, l,length, d,diameter,nub_depth, snap, fixed=true, pointed=true, fins=false, anchor=BOTTOM, spin=0, orient=DOWN) = no_function(\"snap_pin_socket\");\nmodule snap_pin_socket(size, r, radius, l,length, d,diameter,nub_depth, snap, fixed=true, pointed=true, fins=false, anchor=BOTTOM, spin=0, orient=DOWN) {\n  sizedat = _pin_size(size);\n  radius = get_radius(r1=r,r2=radius,d1=d,d2=diameter,dflt=struct_val(sizedat,\"diameter\")/2);\n  length = first_defined([l,length,struct_val(sizedat,\"length\")]);\n  snap = first_defined([snap, struct_val(sizedat,\"snap\")]);\n  nub_depth = first_defined([nub_depth, struct_val(sizedat,\"nub_depth\")]);\n\n  tip = pointed ? sqrt(2) * radius : radius;\n  lPin = length + (pointed?(2-sqrt(2))*radius:0);\n  lStraight = lPin - (pointed?sqrt(2)*radius:radius);\n  attachable(anchor=anchor,spin=spin,orient=orient,\n             size=[2*(radius+snap),radius*sqrt(2),lPin])\n  {\n  down(lPin/2)\n    intersection() {\n      cube([3 * (radius + snap), fixed ? radius * sqrt(2) : 3*(radius+snap), 3 * lPin + 3 * radius], center = true);\n      union() {\n        _pin_shaft(radius,lStraight,snap,1,1,nub_depth,pointed);\n        if (fins)\n          up(lStraight){\n            cube([2 * radius, 0.01, 2 * tip], center = true);\n            cube([0.01, 2 * radius, 2 * tip], center = true);\n          }\n      }\n    }\n  children();\n  }\n}\n\n\n\n// Module: rabbit_clip()\n// Synopsis: Creates a rabbit-eared clip that can snap into a slot.\n// SynTags: Geom\n// Topics: Joiners, Parts\n// See Also: snap_pin(), joiner(), dovetail(), snap_pin(), rabbit_clip()\n// Usage:\n//   rabbit_clip(type, length, width, snap, thickness, depth, [compression=], [clearance=], [lock=], [lock_clearance=], [splineteps=], [anchor=], [orient=], [spin=]) [ATTACHMENTS];\n// Description:\n//   Creates a clip with two flexible ears to lock into a mating socket, or create a mask to produce the appropriate\n//   mating socket.  The clip can be made to insert and release easily, or to hold much better, or it can be\n//   created with locking flanges that will make it very hard or impossible to remove.  Unlike the snap pin, this clip\n//   is rectangular and can be made at any height, so a suitable clip could be very thin.  It's also possible to get a\n//   solid connection with a short pin.\n//   .\n//   The type parameters specifies whether to make a clip, a socket mask, or a double clip.  The length is the\n//   total nominal length of the clip.  (The actual length will be very close, but not equal to this.)  The width\n//   gives the nominal width of the clip, which is the actual width of the clip at its base.  The snap parameter\n//   gives the depth of the clip sides, which controls how easy the clip is to insert and remove.  The clip \"ears\" are\n//   made over-wide by the compression value.  A nonzero compression helps make the clip secure in its socket.\n//   The socket's width and length are increased by the clearance value which creates some space and can compensate\n//   for printing inaccuracy.  The socket will be slightly longer than the nominal width.  The thickness is the thickness\n//   curved line that forms the clip.  The clip depth is the amount the basic clip shape is extruded.  Be sure that you\n//   make the socket with a larger depth than the clip (try 0.4 mm) to allow ease of insertion of the clip.  The clearance\n//   value does not apply to the depth.  The splinesteps parameter increases the sampling of the clip curves.\n//   .\n//   By default clips appear with orient=UP and sockets with orient=DOWN.  The clips and sockets extend 0.02 units below\n//   their base so that unions and differences will work without trouble, but be sure that the attach overlap is smaller\n//   than 0.02.\n//   .\n//   The first figure shows the dimensions of the rabbit clip.  The second figure shows the clip in red overlayed on\n//   its socket in yellow.  The left clip has a nonzero clearance, so its socket is bigger than the clip all around.\n//   The right hand locking clip has no clearance, but it has a lock clearance, which provides some space behind\n//   the lock to allow the clip to fit.  (Note that depending on your printer, this can be set to zero.)\n// Figure(2DMed,NoAxes):\n//   snap=1.5;\n//   comp=0.75;\n//   mid = 8.053;  // computed in rabbit_clip\n//   tip = [-4.58,18.03];\n//   translate([9,3]){\n//   back_half()\n//      rabbit_clip(\"pin\",width=12, length=18, depth=1, thickness = 1, compression=comp, snap=snap, orient=BACK);\n//   color(\"blue\"){\n//      stroke([[6,0],[6,18]],width=0.1);\n//      stroke([[6+comp, 12], [6+comp, 18]], width=.1);\n//   }\n//   color(\"red\"){\n//      stroke([[6-snap,mid], [6,mid]], endcaps=\"arrow2\",width=0.15);\n//      translate([6+.4,mid-.15])text(\"snap\",size=1,valign=\"center\");\n//      translate([6+comp/2,19.5])text(\"compression\", size=1, halign=\"center\");\n//      stroke([[6+comp/2,19.3], [6+comp/2,17.7]], endcap2=\"arrow2\", width=.15);\n//      fwd(1.1)text(\"width\",size=1,halign=\"center\");\n//      xflip_copy()stroke([[2,-.7], [6,-.7]], endcap2=\"arrow2\", width=.15);\n//      move([-6.7,mid])rot(90)text(\"length\", size=1, halign=\"center\");\n//      stroke([[-7,10.3], [-7,18]], width=.15, endcap2=\"arrow2\");\n//      stroke([[-7,0], [-7,5.8]], width=.15,endcap1=\"arrow2\");\n//      stroke([tip, tip-[0,1]], width=.15);\n//      move([tip.x+2,19.5])text(\"thickness\", halign=\"center\",size=1);\n//      stroke([[tip.x+2, 19.3], tip+[.1,.1]], width=.15, endcap2=\"arrow2\");\n//   }\n//   }\n//\n// Figure(2DMed,NoAxes):\n//   snap=1.5;\n//   comp=0;\n//   translate([29,3]){\n//   back_half()\n//      rabbit_clip(\"socket\", width=12, length=18, depth=1, thickness = 1, compression=comp, snap=snap, orient=BACK,lock=true);\n//   color(\"red\")back_half()\n//      rabbit_clip(\"pin\",width=12, length=18, depth=1, thickness = 1, compression=comp, snap=snap,\n//               orient=BACK,lock=true,lock_clearance=1);\n//   }\n//   translate([9,3]){\n//   back_half()\n//      rabbit_clip(\"socket\", clearance=.5,width=12, length=18, depth=1, thickness = 1,\n//                  compression=comp, snap=snap, orient=BACK,lock=false);\n//   color(\"red\")back_half()\n//      rabbit_clip(\"pin\",width=12, length=18, depth=1, thickness = 1, compression=comp, snap=snap,\n//               orient=BACK,lock=false,lock_clearance=1);\n//   }\n// Arguments:\n//   type = One of \"pin\",  \"socket\", \"male\", \"female\" or \"double\" to specify what to make.\n//   length = nominal clip length\n//   width = nominal clip width\n//   snap = depth of hollow on the side of the clip\n//   thickness = thickness of the clip \"line\"\n//   depth = amount to extrude clip (give extra room for the socket, about 0.4mm)\n//   ---\n//   compression = excess width at the \"ears\" to lock more tightly.  Default: 0.1\n//   clearance = extra space in the socket for easier insertion.  Default: 0.1\n//   lock = set to true to make a locking clip that may be irreversible.  Default: false\n//   lock_clearance = give clearance for the lock.  Default: 0\n//   splinesteps = number of samples in the curves of the clip.  Default: 8\n//   anchor = anchor point for clip\n//   orient = clip orientation.  Default: UP for pins, DOWN for sockets\n//   spin = spin the clip.  Default: 0\n//\n// Example:  Here are several sizes that work printed in PLA on a Prusa MK3, with default clearance of 0.1 and a depth of 5\n//   module test_pair(length, width, snap, thickness, compression, lock=false)\n//   {\n//     depth = 5;\n//     extra_depth = 10;// Change this to 0.4 for closed sockets\n//     cuboid([max(width+5,12),12, depth], chamfer=.5, edges=[FRONT,\"Y\"], anchor=BOTTOM)\n//         attach(BACK)\n//           rabbit_clip(type=\"pin\",length=length, width=width,snap=snap,thickness=thickness,depth=depth,\n//                       compression=compression,lock=lock);\n//     right(width+13)\n//     diff(\"remove\")\n//         cuboid([width+8,max(12,length+2),depth+3], chamfer=.5, edges=[FRONT,\"Y\"], anchor=BOTTOM)\n//           tag(\"remove\")\n//             attach(BACK)\n//               rabbit_clip(type=\"socket\",length=length, width=width,snap=snap,thickness=thickness,\n//                           depth=depth+extra_depth, lock=lock,compression=0);\n//   }\n//   left(37)ydistribute(spacing=28){\n//     test_pair(length=6, width=7, snap=0.25, thickness=0.8, compression=0.1);\n//     test_pair(length=3.5, width=7, snap=0.1, thickness=0.8, compression=0.1);  // snap = 0.2 gives a firmer connection\n//     test_pair(length=3.5, width=5, snap=0.1, thickness=0.8, compression=0.1);  // hard to take apart\n//   }\n//   right(17)ydistribute(spacing=28){\n//     test_pair(length=12, width=10, snap=1, thickness=1.2, compression=0.2);\n//     test_pair(length=8, width=7, snap=0.75, thickness=0.8, compression=0.2, lock=true); // With lock, very firm and irreversible\n//     test_pair(length=8, width=7, snap=0.75, thickness=0.8, compression=0.2, lock=true); // With lock, very firm and irreversible\n//   }\n// Example: Double clip to connect two sockets\n//   rabbit_clip(\"double\",length=8, width=7, snap=0.75, thickness=0.8, compression=0.2,depth=5);\n// Example:  A modified version of the clip that acts like a backpack strap clip, where it locks tightly but you can squeeze to release.\n//   cuboid([25,15,5],anchor=BOTTOM)\n//       attach(BACK)rabbit_clip(\"pin\", length=25, width=25, thickness=1.5, snap=2, compression=0, lock=true, depth=5, lock_clearance=3);\n//   left(32)\n//   diff(\"remove\")\n//   cuboid([30,30,11],orient=BACK,anchor=BACK){\n//       tag(\"remove\")attach(BACK)rabbit_clip(\"socket\", length=25, width=25, thickness=1.5, snap=2, compression=0, lock=true, depth=5.5, lock_clearance=3);\n//       xflip_copy()\n//         position(FRONT+LEFT)\n//         xscale(0.8)\n//         tag(\"remove\")zcyl(l=20,r=13.5, $fn=64);\n//   }\n\nfunction rabbit_clip(type, length, width,  snap, thickness, depth, compression=0.1,  clearance=.1, lock=false, lock_clearance=0,\n                   splinesteps=8, anchor, orient, spin=0) = no_function(\"rabbit_clip\");\n\nmodule rabbit_clip(type, length, width,  snap, thickness, depth, compression=0.1,  clearance=.1, lock=false, lock_clearance=0,\n                   splinesteps=8, anchor, orient, spin=0)\n{\n  legal_types = [\"pin\",\"socket\",\"male\",\"female\",\"double\"];\n  check =\n    assert(is_num(width) && width>0,\"Width must be a positive value\")\n    assert(is_num(length) && length>0, \"Length must be a positive value\")\n    assert(is_num(thickness) && thickness>0, \"Thickness must be a positive value\")\n    assert(is_num(snap) && snap>=0, \"Snap must be a non-negative value\")\n    assert(is_num(depth) && depth>0, \"Depth must be a positive value\")\n    assert(is_num(compression) && compression >= 0, \"Compression must be a nonnegative value\")\n    assert(is_bool(lock))\n    assert(is_num(lock_clearance))\n    assert(in_list(type,legal_types),str(\"type must be one of \",legal_types));\n  if (type==\"double\") {\n    attachable(size=[width+2*compression, depth, 2*length], anchor=default(anchor,BACK), spin=spin, orient=default(orient,BACK)){\n      union(){\n        rabbit_clip(\"pin\", length=length, width=width, snap=snap, thickness=thickness, depth=depth, compression=compression,\n                    lock=lock, anchor=BOTTOM, orient=UP);\n        rabbit_clip(\"pin\", length=length, width=width, snap=snap, thickness=thickness, depth=depth, compression=compression,\n                    lock=lock, anchor=BOTTOM, orient=DOWN);\n        cuboid([width-thickness, depth, thickness]);\n      }\n      children();\n    }\n  } else {\n    anchor = default(anchor,BOTTOM);\n    is_pin = in_list(type,[\"pin\",\"male\"]);\n    //default_overlap = 0.01 * (is_pin?1:-1);    // Shift by this much to undo default overlap\n    default_overlap = 0;\n    extra = 0.02;  // Amount of extension below nominal based position for the socket, must exceed default overlap of 0.01\n    clearance = is_pin ? 0 : clearance;\n    compression = is_pin ? compression : 0;\n    orient =  is_def(orient) ? orient\n            : is_pin ? UP\n            : DOWN;\n    earwidth = 2*thickness+snap;\n    point_length = earwidth/2.15;\n    // The adjustment is using cos(theta)*earwidth/2 and sin(theta)*point_length, but the computation\n    // is obscured because theta is atan(length/2/snap)\n    scaled_len = length - 0.5 * (earwidth * snap + point_length * length) / sqrt(sqr(snap)+sqr(length/2));\n    bottom_pt = [0,max(scaled_len*0.15+thickness, 2*thickness)];\n    ctr = [width/2,scaled_len] + line_normal([width/2-snap, scaled_len/2], [width/2, scaled_len]) * earwidth/2;\n    inside_pt = circle_circle_tangents(0, bottom_pt, earwidth/2, ctr)[0][1];\n    sidepath =[\n               [width/2,0],\n               [width/2-snap,scaled_len/2],\n               [width/2+(is_pin?compression:0), scaled_len],\n               ctr - point_length * line_normal([width/2,scaled_len], inside_pt),\n               inside_pt\n              ];\n    fullpath = concat(\n                      sidepath,\n                      [bottom_pt],\n                      reverse(apply(xflip(),sidepath))\n                      );\n    dummy2 = assert(fullpath[4].y < fullpath[3].y, \"Pin is too wide for its length\");\n\n    snapmargin = -snap + last(sidepath).x;// - compression;\n    if (is_pin){\n      if (snapmargin<0) echo(\"WARNING: The snap is too large for the clip to squeeze to fit its socket\")\n      echo(snapmargin=snapmargin);\n    }\n    // Force tangent to be vertical at the outer edge of the clip to avoid overshoot\n    fulltangent = list_set(path_tangents(fullpath, uniform=false),[2,8], [[0,1],[0,-1]]);\n\n    subset = is_pin ? [0:10] : [0,1,2,3, 7,8,9,10];  // Remove internal points from the socket\n    tangent = select(fulltangent, subset);\n    path = select(fullpath, subset);\n\n    socket_smooth = .04;\n    pin_smooth = [.075, .075, .15, .12, .06];\n    smoothing = is_pin\n                  ? concat(pin_smooth, reverse(pin_smooth))\n                  : let(side_smooth=select(pin_smooth, 0, 2))\n                    concat(side_smooth, [socket_smooth], reverse(side_smooth));\n    bez = path_to_bezpath(path,relsize=smoothing,tangents=tangent);\n    rounded = bezpath_curve(bez,splinesteps=splinesteps);\n    bounds = pointlist_bounds(rounded);\n    extrapt = is_pin ? [] : [rounded[0] - [0,extra]];\n    finalpath = is_pin ? rounded\n                       : let(withclearance=offset(rounded, r=-clearance))\n                         concat( [[withclearance[0].x,-extra]],\n                                 withclearance,\n                                 [[-withclearance[0].x,-extra]]);\n    attachable(size=[bounds[1].x-bounds[0].x, depth, bounds[1].y-bounds[0].y], anchor=anchor, spin=spin, orient=orient){\n      xrot(90)\n        translate([0,-(bounds[1].y-bounds[0].y)/2+default_overlap,-depth/2])\n        linear_extrude(height=depth, convexity=10) {\n            if (lock)\n              xflip_copy()\n              right(clearance)\n              polygon([sidepath[1]+[-thickness/10,lock_clearance],\n                       sidepath[2]-[thickness*.75,0],\n                       sidepath[2],\n                       [sidepath[2].x,sidepath[1].y+lock_clearance]]);\n            if (is_pin)\n              offset_stroke(finalpath, width=[thickness,0]);\n            else\n              polygon(finalpath);\n        }\n      children();\n    }\n  }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-19", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: linalg.scad\n//   This file provides linear algebra, with support for matrix construction,\n//   solutions to linear systems of equations, QR and Cholesky factorizations, and\n//   matrix inverse.  \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Math\n// FileSummary: Linear Algebra: solve linear systems, construct and modify matrices.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n// Section: Matrices\n//   The matrix, a rectangular array of numbers which represents a linear transformation,\n//   is the fundamental object in linear algebra.  In OpenSCAD a matrix is a list of lists of numbers\n//   with a rectangular structure.  Because OpenSCAD treats all data the same, most of the functions that\n//   index matrices or construct them will work on matrices (lists of lists) whose elements are not numbers but may be\n//   arbitrary data: strings, booleans, or even other lists.  It may even be acceptable in some cases if the structure is non-rectangular.\n//   Of course, linear algebra computations and solutions require true matrices with rectangular structure, where all the entries are\n//   finite numbers.\n//   .\n//   Matrices in OpenSCAD are lists of row vectors.  However, a potential source of confusion is that OpenSCAD\n//   treats vectors as either column vectors or row vectors as demanded by\n//   context.  Thus both `v*M` and `M*v` are valid if `M` is square and `v` has the right length.  If you want to multiply\n//   `M` on the left by `v` and `w` you can do this with `[v,w]*M` but if you want to multiply on the right side with `v` and `w` as\n//   column vectors, you now need to use {{transpose()}} because OpenSCAD doesn't adjust matrices\n//   contextually:  `A=M*transpose([v,w])`.  The solutions are now columns of A and you must extract\n//   them with {{column()}} or take the transpose of `A`.  \n\n\n// Section: Matrix testing and display\n\n// Function: is_matrix()\n// Synopsis: Check if input is a numeric matrix, optionally of specified size\n// Topics: Matrices\n// See Also: is_matrix_symmetric(), is_rotation()\n// Usage:\n//   test = is_matrix(A, [m], [n], [square])\n// Description:\n//   Returns true if A is a numeric matrix of height m and width n with finite entries.  If m or n\n//   are omitted or set to undef then true is returned for any positive dimension.\n// Arguments:\n//   A = The matrix to test.\n//   m = If given, requires the matrix to have this height.\n//   n = Is given, requires the matrix to have this width.\n//   square = If true, matrix must have height equal to width. Default: false\nfunction is_matrix(A,m,n,square=false) =\n   is_list(A)\n   && (( is_undef(m) && len(A) ) || len(A)==m)\n   && (!square || len(A) == len(A[0]))\n   && is_vector(A[0],n)\n   && is_consistent(A);\n\n\n// Function: is_matrix_symmetric()\n// Synopsis: Checks if matrix is symmetric\n// Topics: Matrices\n// See Also: is_matrix(), is_rotation()\n// Usage:\n//   b = is_matrix_symmetric(A, [eps])\n// Description:\n//   Returns true if the input matrix is symmetric, meaning it approximately equals its transpose.  \n//   The matrix can have arbitrary entries.  \n// Arguments:\n//   A = matrix to test\n//   eps = epsilon for comparing equality.  Default: 1e-12\nfunction is_matrix_symmetric(A,eps=1e-12) =\n    approx(A,transpose(A), eps);\n\n\n// Function: is_rotation()\n// Synopsis: Check if a transformation matrix represents a rotation.\n// Topics: Affine, Matrices, Transforms\n// See Also: is_matrix(), is_matrix_symmetric(), is_rotation()\n// Usage:\n//   b = is_rotation(A, [dim], [centered])\n// Description:\n//   Returns true if the input matrix is a square affine matrix that is a rotation around any point,\n//   or around the origin if `centered` is true. \n//   The matrix must be 3x3 (representing a 2d transformation) or 4x4 (representing a 3d transformation).\n//   You can set `dim` to 2 to require a 2d transform (3x3 matrix) or to 3 to require a 3d transform (4x4 matrix).\n// Arguments:\n//   A = matrix to test\n//   dim = if set, specify dimension in which the transform operates (2 or 3)\n//   centered = if true then require rotation to be around the origin.  Default: false\nfunction is_rotation(A,dim,centered=false) =\n    let(n=len(A))\n    is_matrix(A,square=true)\n    && ( n==3 || n==4 && (is_undef(dim) || dim==n-1))\n    &&\n    (\n      let(\n          rotpart =  [for(i=[0:n-2]) [for(j=[0:n-2]) A[j][i]]]\n      )\n      approx(determinant(rotpart),1)\n    )\n    && \n    (!centered || [for(row=[0:n-2]) if (!approx(A[row][n-1],0)) row]==[]);\n  \n\n// Function&Module: echo_matrix()\n// Synopsis: Print a matrix neatly to the console.\n// Topics: Matrices\n// See Also: is_matrix(), is_matrix_symmetric(), is_rotation()\n// Usage:\n//    echo_matrix(M, [description], [sig], [sep], [eps]);\n//    dummy = echo_matrix(M, [description], [sig], [sep], [eps]),\n// Description:\n//    Display a numerical matrix in a readable columnar format with `sig` significant\n//    digits.  Values smaller than eps display as zero.  If you give a description\n//    it is displayed at the top.  You can change the space between columns by\n//    setting `sep` to a number of spaces, which will use wide figure spaces the same\n//    width as digits, or you can set it to any string to separate the columns.\n//    Values that are NaN or INF will display as \"nan\" and \"inf\".  Values which are\n//    otherwise non-numerica display as two dashes.  Note that this includes lists, so\n//    a 3D array will display as a list of dashes.  \n// Arguments:\n//    M = matrix to display, which should be numerical\n//    description = optional text to print before the matrix\n//    sig = number of digits to display.  Default: 4\n//    sep = number of spaces between columns or a text string to separate columns.  Default: 1\n//    eps = numbers smaller than this display as zero.  Default: 1e-9\nfunction echo_matrix(M,description,sig=4,sep=1,eps=1e-9) =\n  let(\n      horiz_line = chr(8213),\n      matstr = _format_matrix(M,sig=sig,sep=sep,eps=eps),\n      separator = str_join(repeat(horiz_line,10)),\n      dummy=echo(str(separator,is_def(description) ? str(\"  \",description) : \"\"))\n            [for(row=matstr) echo(row)]\n  )\n  echo(separator);\n\nmodule echo_matrix(M,description,sig=4,sep=1,eps=1e-9)\n{\n  dummy = echo_matrix(M,description,sig,sep,eps);\n}\n\n\n// Section: Matrix indexing\n\n// Function: column()\n// Synopsis: Extract a column from a matrix.\n// Topics: Matrices, List Handling, Arrays\n// See Also: select(), slice()\n// Usage:\n//   list = column(M, i);\n// Description:\n//   Extracts entry `i` from each list in M, or equivalently column i from the matrix M, and returns it as a vector.  \n//   This function will return `undef` at all entry positions indexed by i not found in M.\n// Arguments:\n//   M = The given list of lists.\n//   i = The index to fetch\n// Example:\n//   M = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]];\n//   a = column(M,2);      // Returns [3, 7, 11, 15]\n//   b = column(M,0);      // Returns [1, 5, 9, 13]\n//   N = [ [1,2], [3], [4,5], [6,7,8] ];\n//   c = column(N,1);      // Returns [1,undef,5,7]\n//   data = [[1,[3,4]], [3, [9,3]], [4, [3,1]]];   // Matrix with non-numeric entries\n//   d = column(data,0);   // Returns [1,3,4]\n//   e = column(data,1);   // Returns [[3,4],[9,3],[3,1]]\nfunction column(M, i) =\n    assert( is_list(M), \"The input is not a list.\" )\n    assert( is_int(i) && i>=0, \"Invalid index\")\n    [for(row=M) row[i]];\n\n\n// Function: submatrix()\n// Synopsis: Extract a submatrix from a matrix\n// Topics: Matrices, Arrays\n// See Also: column(), block_matrix(), submatrix_set()\n// Usage:\n//   mat = submatrix(M, idx1, idx2);\n// Description:\n//   The input must be a list of lists (a matrix or 2d array).  Returns a submatrix by selecting the rows listed in idx1 and columns listed in idx2.\n// Arguments:\n//   M = Given list of lists\n//   idx1 = rows index list or range\n//   idx2 = column index list or range\n// Example:\n//   M = [[ 1, 2, 3, 4, 5],\n//        [ 6, 7, 8, 9,10],\n//        [11,12,13,14,15],\n//        [16,17,18,19,20],\n//        [21,22,23,24,25]];\n//   submatrix(M,[1:2],[3:4]);  // Returns [[9, 10], [14, 15]]\n//   submatrix(M,[1], [3,4]));  // Returns [[9,10]]\n//   submatrix(M,1, [3,4]));  // Returns [[9,10]]\n//   submatrix(M,1,3));  // Returns [[9]]\n//   submatrix(M, [3,4],1); // Returns  [[17],[22]]);\n//   submatrix(M, [1,3],[2,4]); // Returns [[8,10],[18,20]]);\n//   A = [[true,    17, \"test\"],\n//        [[4,2],   91, false],\n//        [6,    [3,4], undef]];\n//   submatrix(A,[0,2],[1,2]);   // Returns [[17, \"test\"], [[3, 4], undef]]\nfunction submatrix(M,idx1,idx2) =\n    [for(i=idx1) [for(j=idx2) M[i][j] ] ];\n\n\n// Section: Matrix construction and modification\n\n// Function: ident()\n// Synopsis: Return identity matrix.\n// Topics: Affine, Matrices, Transforms\n// See Also: IDENT, submatrix(), column()\n// Usage:\n//   mat = ident(n);\n// Description:\n//   Create an `n` by `n` square identity matrix.\n// Arguments:\n//   n = The size of the identity matrix square, `n` by `n`.\n// Example:\n//   mat = ident(3);\n//   // Returns:\n//   //   [\n//   //     [1, 0, 0],\n//   //     [0, 1, 0],\n//   //     [0, 0, 1]\n//   //   ]\n// Example:\n//   mat = ident(4);\n//   // Returns:\n//   //   [\n//   //     [1, 0, 0, 0],\n//   //     [0, 1, 0, 0],\n//   //     [0, 0, 1, 0],\n//   //     [0, 0, 0, 1]\n//   //   ]\nfunction ident(n) = [\n    for (i = [0:1:n-1]) [\n        for (j = [0:1:n-1]) (i==j)? 1 : 0\n    ]\n];\n\n\n// Function: diagonal_matrix()\n// Synopsis: Make a diagonal matrix.\n// Topics: Affine, Matrices\n// See Also: column(), submatrix()\n// Usage:\n//   mat = diagonal_matrix(diag, [offdiag]);\n// Description:\n//   Creates a square matrix with the items in the list `diag` on\n//   its diagonal.  The off diagonal entries are set to offdiag,\n//   which is zero by default.\n// Arguments:\n//   diag = A list of items to put in the diagnal cells of the matrix.\n//   offdiag = Value to put in non-diagonal matrix cells.\nfunction diagonal_matrix(diag, offdiag=0) =\n  assert(is_list(diag) && len(diag)>0)\n  [for(i=[0:1:len(diag)-1]) [for(j=[0:len(diag)-1]) i==j?diag[i] : offdiag]];\n\n\n// Function: transpose()\n// Synopsis: Transpose a matrix\n// Topics: Linear Algebra, Matrices\n// See Also: submatrix(), block_matrix(), hstack(), flatten()\n// Usage:\n//    M = transpose(M, [reverse]);\n// Description:\n//    Returns the transpose of the given input matrix.  The input can be a matrix with arbitrary entries or\n//    a numerical vector.  If you give a vector then transpose returns it unchanged.  \n//    When reverse=true, the transpose is done across to the secondary diagonal.  (See example below.)\n//    By default, reverse=false.\n// Example:\n//   M = [\n//       [1, 2, 3],\n//       [4, 5, 6],\n//       [7, 8, 9]\n//   ];\n//   t = transpose(M);\n//   // Returns:\n//   // [\n//   //     [1, 4, 7], \n//   //     [2, 5, 8], \n//   //     [3, 6, 9]\n//   // ]\n// Example:\n//   M = [\n//       [1, 2, 3], \n//       [4, 5, 6]\n//   ];\n//   t = transpose(M);\n//   // Returns:\n//   // [\n//   //     [1, 4],\n//   //     [2, 5],\n//   //     [3, 6],\n//   // ]\n// Example:\n//   M = [\n//       [1, 2, 3], \n//       [4, 5, 6], \n//       [7, 8, 9]\n//   ];\n//   t = transpose(M, reverse=true);\n//   // Returns:\n//   // [\n//   //  [9, 6, 3],\n//   //  [8, 5, 2],\n//   //  [7, 4, 1]\n//   // ]\n// Example: Transpose on a list of numbers returns the list unchanged\n//   transpose([3,4,5]);  // Returns: [3,4,5]\n// Example: Transpose on non-numeric input\n//   arr = [\n//       [  \"a\",  \"b\", \"c\"],\n//       [  \"d\",  \"e\", \"f\"],\n//       [[1,2],[3,4],[5,6]]\n//   ];\n//   t = transpose(arr);\n//   // Returns:\n//   // [\n//   //     [\"a\", \"d\", [1,2]],\n//   //     [\"b\", \"e\", [3,4]],\n//   //     [\"c\", \"f\", [5,6]],\n//   // ]\n\nfunction transpose(M, reverse=false) =\n    assert( is_list(M) && len(M)>0, \"Input to transpose must be a nonempty list.\")\n    is_list(M[0])\n    ?   let( len0 = len(M[0]) )\n        assert([for(a=M) if(!is_list(a) || len(a)!=len0) 1 ]==[], \"Input to transpose has inconsistent row lengths.\" )\n        reverse\n        ? [for (i=[0:1:len0-1]) \n              [ for (j=[0:1:len(M)-1]) M[len(M)-1-j][len0-1-i] ] ] \n        : [for (i=[0:1:len0-1]) \n              [ for (j=[0:1:len(M)-1]) M[j][i] ] ] \n    :  assert( is_vector(M), \"Input to transpose must be a vector or list of lists.\")\n           M;\n\n\n// Function: outer_product()\n// Synopsis: Compute the outer product of two vectors. \n// Topics: Linear Algebra, Matrices\n// See Also: submatrix(), determinant()\n// Usage:\n//   x = outer_product(u,v);\n// Description:\n//   Compute the outer product of two vectors, which is a matrix.\n// Usage:\n//   M = outer_product(u,v);\nfunction outer_product(u,v) =\n  assert(is_vector(u) && is_vector(v), \"The inputs must be vectors.\")\n  [for(ui=u) ui*v];\n\n// Function: submatrix_set()\n// Synopsis: Takes a matrix as input and change values in a submatrix.\n// Topics: Matrices, Arrays\n// See Also: column(), submatrix()\n// Usage:\n//   mat = submatrix_set(M, A, [m], [n]);\n// Description:\n//   Sets a submatrix of M equal to the matrix A.  By default the top left corner of M is set to A, but\n//   you can specify offset coordinates m and n.  If A (as adjusted by m and n) extends beyond the bounds\n//   of M then the extra entries are ignored.  You can pass in `A=[[]]`, a null matrix, and M will be\n//   returned unchanged.  This function works on arbitrary lists of lists and the input M need not be rectangular in shape.  \n// Arguments:\n//   M = Original matrix.\n//   A = Submatrix of new values to write into M\n//   m = Row number of upper-left corner to place A at.  Default: 0\n//   n = Column number of upper-left corner to place A at.  Default: 0 \nfunction submatrix_set(M,A,m=0,n=0) =\n    assert(is_list(M))\n    assert(is_list(A))\n    assert(is_int(m))\n    assert(is_int(n))\n    let( badrows = [for(i=idx(A)) if (!is_list(A[i])) i])\n    assert(badrows==[], str(\"Input submatrix malformed rows: \",badrows))\n    [for(i=[0:1:len(M)-1])\n        assert(is_list(M[i]), str(\"Row \",i,\" of input matrix is not a list\"))\n        [for(j=[0:1:len(M[i])-1]) \n            i>=m && i <len(A)+m && j>=n && j<len(A[0])+n ? A[i-m][j-n] : M[i][j]]];\n\n\n// Function: hstack()\n// Synopsis: Make a new matrix by stacking matrices horizontally.\n// Topics: Matrices, Arrays\n// See Also: column(), submatrix(), block_matrix()\n// Usage: \n//   A = hstack(M1, M2)\n//   A = hstack(M1, M2, M3)\n//   A = hstack([M1, M2, M3, ...])\n// Description:\n//   Constructs a matrix by horizontally \"stacking\" together compatible matrices or vectors.  Vectors are treated as columsn in the stack.\n//   This command is the inverse of `column`.  Note: strings given in vectors are broken apart into lists of characters.  Strings given\n//   in matrices are preserved as strings.  If you need to combine vectors of strings use {{list_to_matrix()}} as shown below to convert the\n//   vector into a column matrix.  Also note that vertical stacking can be done directly with concat.  \n// Arguments:\n//   M1 = If given with other arguments, the first matrix (or vector) to stack.  If given alone, a list of matrices/vectors to stack. \n//   M2 = Second matrix/vector to stack\n//   M3 = Third matrix/vector to stack.\n// Example:\n//   M = ident(3);\n//   v1 = [2,3,4];\n//   v2 = [5,6,7];\n//   v3 = [8,9,10];\n//   a = hstack(v1,v2);     // Returns [[2, 5], [3, 6], [4, 7]]\n//   b = hstack(v1,v2,v3);  // Returns [[2, 5,  8],\n//                          //          [3, 6,  9],\n//                          //          [4, 7, 10]]\n//   c = hstack([M,v1,M]);  // Returns [[1, 0, 0, 2, 1, 0, 0],\n//                          //          [0, 1, 0, 3, 0, 1, 0],\n//                          //          [0, 0, 1, 4, 0, 0, 1]]\n//   d = hstack(column(M,0), submatrix(M,idx(M),[1 2]));  // Returns M\n//   strvec = [\"one\",\"two\"];\n//   strmat = [[\"three\",\"four\"], [\"five\",\"six\"]];\n//   e = hstack(strvec,strvec); // Returns [[\"o\", \"n\", \"e\", \"o\", \"n\", \"e\"],\n//                              //          [\"t\", \"w\", \"o\", \"t\", \"w\", \"o\"]]\n//   f = hstack(list_to_matrix(strvec,1), list_to_matrix(strvec,1));\n//                              // Returns [[\"one\", \"one\"],\n//                              //          [\"two\", \"two\"]]\n//   g = hstack(strmat,strmat); //  Returns: [[\"three\", \"four\", \"three\", \"four\"],\n//                              //            [ \"five\",  \"six\",  \"five\",  \"six\"]]\nfunction hstack(M1, M2, M3) =\n    (M3!=undef)? hstack([M1,M2,M3]) : \n    (M2!=undef)? hstack([M1,M2]) :\n    assert(all([for(v=M1) is_list(v)]), \"One of the inputs to hstack is not a list\")\n    let(\n        minlen = min_length(M1),\n        maxlen = max_length(M1)\n    )\n    assert(minlen==maxlen, \"Input vectors to hstack must have the same length\")\n    [for(row=[0:1:minlen-1])\n        [for(matrix=M1)\n           each matrix[row]\n        ]\n    ];\n\n\n// Function: block_matrix()\n// Synopsis: Make a new matrix from a block of matrices. \n// Topics: Matrices, Arrays\n// See Also: column(), submatrix()\n// Usage:\n//    bmat = block_matrix([[M11, M12,...],[M21, M22,...], ... ]);\n// Description:\n//    Create a block matrix by supplying a matrix of matrices, which will\n//    be combined into one unified matrix.  Every matrix in one row\n//    must have the same height, and the combined width of the matrices\n//    in each row must be equal. Strings will stay strings. \n// Example:\n//  A = [[1,2],\n//       [3,4]];\n//  B = ident(2);\n//  C = block_matrix([[A,B],[B,A],[A,B]]);\n//      // Returns:\n//      //        [[1, 2, 1, 0],\n//      //         [3, 4, 0, 1],\n//      //         [1, 0, 1, 2],\n//      //         [0, 1, 3, 4],\n//      //         [1, 2, 1, 0],\n//      //         [3, 4, 0, 1]]);\n//  D = block_matrix([[A,B], ident(4)]);\n//      // Returns:\n//      //        [[1, 2, 1, 0],\n//      //         [3, 4, 0, 1],\n//      //         [1, 0, 0, 0],\n//      //         [0, 1, 0, 0],\n//      //         [0, 0, 1, 0],\n//      //         [0, 0, 0, 1]]);\n//  E = [[\"one\", \"two\"], [3,4]];\n//  F = block_matrix([[E,E]]);\n//      // Returns:\n//      //        [[\"one\", \"two\", \"one\", \"two\"],\n//      //         [    3,     4,     3,     4]]\nfunction block_matrix(M) =\n    let(\n        bigM = [for(bigrow = M) each hstack(bigrow)],\n        len0 = len(bigM[0]),\n        badrows = [for(row=bigM) if (len(row)!=len0) 1]\n    )\n    assert(badrows==[], \"Inconsistent or invalid input\")\n    bigM;\n\n\n// Section: Solving Linear Equations and Matrix Factorizations\n\n// Function: linear_solve()\n// Synopsis: Solve Ax=b or, for overdetermined case, solve the least square problem. \n// Topics: Matrices, Linear Algebra\n// See Also: linear_solve3(), matrix_inverse(), rot_inverse(), back_substitute(), cholesky()\n// Usage:\n//   solv = linear_solve(A,b,[pivot])\n// Description:\n//   Solves the linear system Ax=b.  If `A` is square and non-singular the unique solution is returned.  If `A` is overdetermined\n//   the least squares solution is returned. If `A` is underdetermined, the minimal norm solution is returned.\n//   If `A` is rank deficient or singular then linear_solve returns `[]`.  If `b` is a matrix that is compatible with `A`\n//   then the problem is solved for the matrix valued right hand side and a matrix is returned.  Note that if you \n//   want to solve Ax=b1 and Ax=b2 that you need to form the matrix `transpose([b1,b2])` for the right hand side and then\n//   transpose the returned value.  The solution is computed using QR factorization.  If `pivot` is set to true (the default) then\n//   pivoting is used in the QR factorization, which is slower but expected to be more accurate.\n// Arguments:\n//   A = Matrix describing the linear system, which need not be square\n//   b = right hand side for linear system, which can be a matrix to solve several cases simultaneously.  Must be consistent with A.\n//   pivot = if true use pivoting when computing the QR factorization.  Default: true\nfunction linear_solve(A,b,pivot=true) =\n    assert(is_matrix(A), \"Input should be a matrix.\")\n    let(\n        m = len(A),\n        n = len(A[0])\n    )\n    assert(is_vector(b,m) || is_matrix(b,m),\"Invalid right hand side or incompatible with the matrix\")\n    let (\n        qr = m<n? qr_factor(transpose(A),pivot) : qr_factor(A,pivot),\n        maxdim = max(n,m),\n        mindim = min(n,m),\n        Q = submatrix(qr[0],[0:maxdim-1], [0:mindim-1]),\n        R = submatrix(qr[1],[0:mindim-1], [0:mindim-1]),\n        P = qr[2],\n        zeros = [for(i=[0:mindim-1]) if (approx(R[i][i],0)) i]\n    )\n    zeros != [] ? [] :\n    m<n ? Q*back_substitute(R,transpose(P)*b,transpose=true) // Too messy to avoid input checks here\n        : P*_back_substitute(R, transpose(Q)*b);             // Calling internal version skips input checks\n\n\n// Function: linear_solve3()\n// Synopsis: Fast solution to Ax=b where A is 3x3.\n// Topics: Matrices, Linear Algebra\n// See Also: linear_solve(), matrix_inverse(), rot_inverse(), back_substitute(), cholesky()\n// Usage:\n//   x = linear_solve3(A,b)\n// Description:\n//   Fast solution to a 3x3 linear system using Cramer's rule (which appears to be the fastest\n//   method in OpenSCAD).  The input `A` must be a 3x3 matrix.  Returns undef if `A` is singular.\n//   The input `b` must be a 3-vector.  Note that Cramer's rule is not a stable algorithm, so for\n//   the highest accuracy on ill-conditioned problems you may want to use the general solver, which is about ten times slower.\n// Arguments:\n//   A = 3x3 matrix for linear system\n//   b = length 3 vector, right hand side of linear system\nfunction linear_solve3(A,b) =\n  // Arg sanity checking adds 7% overhead\n  assert(b*0==[0,0,0], \"Input b must be a 3-vector\")\n  assert(A*0==[[0,0,0],[0,0,0],[0,0,0]],\"Input A must be a 3x3 matrix\")\n  let(\n      Az = [for(i=[0:2])[A[i][0], A[i][1], b[i]]],\n      Ay = [for(i=[0:2])[A[i][0], b[i], A[i][2]]],\n      Ax = [for(i=[0:2])[b[i], A[i][1], A[i][2]]],\n      detA = det3(A)\n  )\n  detA==0 ? undef : [det3(Ax), det3(Ay), det3(Az)] / detA;\n\n\n// Function: matrix_inverse()\n// Synopsis: General matrix inverse. \n// Topics: Matrices, Linear Algebra\n// See Also: linear_solve(), linear_solve3(), matrix_inverse(), rot_inverse(), back_substitute(), cholesky()\n// Usage:\n//    mat = matrix_inverse(A)\n// Description:\n//    Compute the matrix inverse of the square matrix `A`.  If `A` is singular, returns `undef`.\n//    Note that if you just want to solve a linear system of equations you should NOT use this function.\n//    Instead use {{linear_solve()}}, or use {{qr_factor()}}.  The computation\n//    will be faster and more accurate.  \nfunction matrix_inverse(A) =\n    assert(is_matrix(A) && len(A)==len(A[0]),\"Input to matrix_inverse() must be a square matrix\")\n    linear_solve(A,ident(len(A)));\n\n\n// Function: rot_inverse()\n// Synopsis: Invert 2d or 3d rotation transformations. \n// Topics: Matrices, Linear Algebra, Affine\n// See Also: linear_solve(), linear_solve3(), matrix_inverse(), rot_inverse(), back_substitute(), cholesky()\n// Usage:\n//   B = rot_inverse(A)\n// Description:\n//   Inverts a 2d (3x3) or 3d (4x4) rotation matrix.  The matrix can be a rotation around any center,\n//   so it may include a translation.  This is faster and likely to be more accurate than using `matrix_inverse()`.  \nfunction rot_inverse(T) =\n    assert(is_matrix(T,square=true),\"Matrix must be square\")\n    let( n = len(T))\n    assert(n==3 || n==4, \"Matrix must be 3x3 or 4x4\")\n    let(\n        rotpart =  [for(i=[0:n-2]) [for(j=[0:n-2]) T[j][i]]],\n        transpart = [for(row=[0:n-2]) T[row][n-1]]\n    )\n    assert(approx(determinant(T),1),\"Matrix is not a rotation\")\n    concat(hstack(rotpart, -rotpart*transpart),[[for(i=[2:n]) 0, 1]]);\n\n\n\n\n// Function: null_space()\n// Synopsis: Return basis for the null space of A. \n// Topics: Matrices, Linear Algebra\n// See Also: linear_solve(), linear_solve3(), matrix_inverse(), rot_inverse(), back_substitute(), cholesky()\n// Usage:\n//   x = null_space(A)\n// Description:\n//   Returns an orthonormal basis for the null space of `A`, namely the vectors {x} such that Ax=0.\n//   If the null space is just the origin then returns an empty list. \nfunction null_space(A,eps=1e-12) =\n    assert(is_matrix(A))\n    let(\n        Q_R = qr_factor(transpose(A),pivot=true),\n        R = Q_R[1],\n        zrows = [for(i=idx(R)) if (all_zero(R[i],eps)) i]\n    )\n    len(zrows)==0 ? [] :\n    select(transpose(Q_R[0]), zrows);\n\n// Function: qr_factor()\n// Synopsis: Compute QR factorization of a matrix.\n// Topics: Matrices, Linear Algebra\n// See Also: linear_solve(), linear_solve3(), matrix_inverse(), rot_inverse(), back_substitute(), cholesky()\n// Usage:\n//   qr = qr_factor(A,[pivot]);\n// Description:\n//   Calculates the QR factorization of the input matrix A and returns it as the list [Q,R,P].  This factorization can be\n//   used to solve linear systems of equations.  The factorization is `A = Q*R*transpose(P)`.  If pivot is false (the default)\n//   then P is the identity matrix and A = Q*R.  If pivot is true then column pivoting results in an R matrix where the diagonal\n//   is non-decreasing.  The use of pivoting is supposed to increase accuracy for poorly conditioned problems, and is necessary\n//   for rank estimation or computation of the null space, but it may be slower.  \nfunction qr_factor(A, pivot=false) =\n    assert(is_matrix(A), \"Input must be a matrix.\" )\n    let(\n        m = len(A),\n        n = len(A[0])\n    )\n    let(\n        qr = _qr_factor(A, Q=ident(m),P=ident(n), pivot=pivot, col=0, m = m, n = n),\n        Rzero = let( R = qr[1]) [\n            for(i=[0:m-1]) [\n                let( ri = R[i] )\n                for(j=[0:n-1]) i>j ? 0 : ri[j]\n            ]\n        ]\n    ) [qr[0], Rzero, qr[2]];\n\nfunction _qr_factor(A,Q,P, pivot, col, m, n) =\n    col >= min(m-1,n) ? [Q,A,P] :\n    let(\n        swap = !pivot ? 1\n             : _swap_matrix(n,col,col+max_index([for(i=[col:n-1]) sqr([for(j=[col:m-1]) A[j][i]])])),\n        A = pivot ? A*swap : A,\n        x = [for(i=[col:1:m-1]) A[i][col]],\n        alpha = (x[0]<=0 ? 1 : -1) * norm(x),\n        u = x - concat([alpha],repeat(0,m-1)),\n        v = alpha==0 ? u : u / norm(u),\n        Qc = ident(len(x)) - 2*outer_product(v,v),\n        Qf = [for(i=[0:m-1]) [for(j=[0:m-1]) i<col || j<col ? (i==j ? 1 : 0) : Qc[i-col][j-col]]]\n    )\n    _qr_factor(Qf*A, Q*Qf, P*swap, pivot, col+1, m, n);\n\n// Produces an n x n matrix that swaps column i and j (when multiplied on the right)\nfunction _swap_matrix(n,i,j) =\n  assert(i<n && j<n && i>=0 && j>=0, \"Swap indices out of bounds\")\n  [for(y=[0:n-1]) [for (x=[0:n-1])\n     x==i ? (y==j ? 1 : 0)\n   : x==j ? (y==i ? 1 : 0)\n   : x==y ? 1 : 0]];\n\n\n\n// Function: back_substitute()\n// Synopsis: Solve an upper triangular system, Rx=b.  \n// Topics: Matrices, Linear Algebra\n// See Also: linear_solve(), linear_solve3(), matrix_inverse(), rot_inverse(), back_substitute(), cholesky()\n// Usage:\n//   x = back_substitute(R, b, [transpose]);\n// Description:\n//   Solves the problem Rx=b where R is an upper triangular square matrix.  The lower triangular entries of R are\n//   ignored.  If transpose==true then instead solve transpose(R)*x=b.\n//   You can supply a compatible matrix b and it will produce the solution for every column of b.  Note that if you want to\n//   solve Rx=b1 and Rx=b2 you must set b to transpose([b1,b2]) and then take the transpose of the result.  If the matrix\n//   is singular (e.g. has a zero on the diagonal) then it returns [].  \nfunction back_substitute(R, b, transpose = false) =\n    assert(is_matrix(R, square=true))\n    let(n=len(R))\n    assert(is_vector(b,n) || is_matrix(b,n),str(\"R and b are not compatible in back_substitute \",n, len(b)))\n    transpose\n      ? reverse(_back_substitute(transpose(R, reverse=true), reverse(b)))  \n      : _back_substitute(R,b);\n\nfunction _back_substitute(R, b, x=[]) =\n    let(n=len(R))\n    len(x) == n ? x\n    : let(ind = n - len(x) - 1)\n      R[ind][ind] == 0 ? []\n    : let(\n          newvalue = len(x)==0\n            ? b[ind]/R[ind][ind]\n            : (b[ind]-list_tail(R[ind],ind+1) * x)/R[ind][ind]\n      )\n      _back_substitute(R, b, concat([newvalue],x));\n\n\n\n// Function: cholesky()\n// Synopsis: Compute the Cholesky factorization of a matrix. \n// Topics: Matrices, Linear Algebra\n// See Also: linear_solve(), linear_solve3(), matrix_inverse(), rot_inverse(), back_substitute(), cholesky()\n// Usage:\n//   L = cholesky(A);\n// Description:\n//   Compute the cholesky factor, L, of the symmetric positive definite matrix A.\n//   The matrix L is lower triangular and `L * transpose(L) = A`.  If the A is\n//   not symmetric then an error is displayed.  If the matrix is symmetric but\n//   not positive definite then undef is returned.  \nfunction cholesky(A) =\n  assert(is_matrix(A,square=true),\"A must be a square matrix\")\n  assert(is_matrix_symmetric(A),\"Cholesky factorization requires a symmetric matrix\")\n  _cholesky(A,ident(len(A)), len(A));\n\nfunction _cholesky(A,L,n) = \n    A[0][0]<0 ? undef :     // Matrix not positive definite\n    len(A) == 1 ? submatrix_set(L,[[sqrt(A[0][0])]], n-1,n-1):\n    let(\n        i = n+1-len(A)\n    )\n    let(\n        sqrtAii = sqrt(A[0][0]),\n        Lnext = [for(j=[0:n-1])\n                  [for(k=[0:n-1])\n                      j<i-1 || k<i-1 ?  (j==k ? 1 : 0)\n                     : j==i-1 && k==i-1 ? sqrtAii\n                     : j==i-1 ? 0\n                     : k==i-1 ? A[j-(i-1)][0]/sqrtAii\n                     : j==k ? 1 : 0]],\n        Anext = submatrix(A,[1:n-1], [1:n-1]) - outer_product(list_tail(A[0]), list_tail(A[0]))/A[0][0]\n    )\n    _cholesky(Anext,L*Lnext,n);\n\n\n// Section: Matrix Properties: Determinants, Norm, Trace\n\n// Function: det2()\n// Synopsis: Compute determinant of 2x2 matrix.\n// Topics: Matrices, Linear Algebra\n// See Also: det2(), det3(), det4(), determinant(), norm_fro(), matrix_trace()\n// Usage:\n//   d = det2(M);\n// Description:\n//   Rturns the determinant for the given 2x2 matrix.\n// Arguments:\n//   M = The 2x2 matrix to get the determinant of.\n// Example:\n//   M = [ [6,-2], [1,8] ];\n//   det = det2(M);  // Returns: 50\nfunction det2(M) = \n    assert(is_def(M) && M*0==[[0,0],[0,0]], \"Expected square matrix (2x2)\")\n    cross(M[0],M[1]);\n\n\n// Function: det3()\n// Synopsis: Compute determinant of 3x3 matrix.\n// Topics: Matrices, Linear Algebra\n// See Also: det2(), det3(), det4(), determinant(), norm_fro(), matrix_trace()\n// Usage:\n//   d = det3(M);\n// Description:\n//   Returns the determinant for the given 3x3 matrix.\n// Arguments:\n//   M = The 3x3 square matrix to get the determinant of.\n// Example:\n//   M = [ [6,4,-2], [1,-2,8], [1,5,7] ];\n//   det = det3(M);  // Returns: -334\nfunction det3(M) =\n    assert(is_def(M) && M*0==[[0,0,0],[0,0,0],[0,0,0]], \"Expected square matrix (3x3).\")\n    M[0][0] * (M[1][1]*M[2][2]-M[2][1]*M[1][2]) -\n    M[1][0] * (M[0][1]*M[2][2]-M[2][1]*M[0][2]) +\n    M[2][0] * (M[0][1]*M[1][2]-M[1][1]*M[0][2]);\n\n// Function: det4()\n// Synopsis: Compute determinant of 4x4 matrix. \n// Topics: Matrices, Linear Algebra\n// See Also: det2(), det3(), det4(), determinant(), norm_fro(), matrix_trace()\n// Usage:\n//   d = det4(M);\n// Description:\n//   Returns the determinant for the given 4x4 matrix.\n// Arguments:\n//   M = The 4x4 square matrix to get the determinant of.\n// Example:\n//   M = [ [6,4,-2,1], [1,-2,8,-3], [1,5,7,4], [2,3,4,7] ];\n//   det = det4(M);  // Returns: -1773\nfunction det4(M) =\n    assert(is_def(M) && M*0==[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]], \"Expected square matrix (4x4).\")\n    M[0][0]*M[1][1]*M[2][2]*M[3][3] + M[0][0]*M[1][2]*M[2][3]*M[3][1] + M[0][0]*M[1][3]*M[2][1]*M[3][2]\n    + M[0][1]*M[1][0]*M[2][3]*M[3][2] + M[0][1]*M[1][2]*M[2][0]*M[3][3] + M[0][1]*M[1][3]*M[2][2]*M[3][0]\n    + M[0][2]*M[1][0]*M[2][1]*M[3][3] + M[0][2]*M[1][1]*M[2][3]*M[3][0] + M[0][2]*M[1][3]*M[2][0]*M[3][1]\n    + M[0][3]*M[1][0]*M[2][2]*M[3][1] + M[0][3]*M[1][1]*M[2][0]*M[3][2] + M[0][3]*M[1][2]*M[2][1]*M[3][0]\n    - M[0][0]*M[1][1]*M[2][3]*M[3][2] - M[0][0]*M[1][2]*M[2][1]*M[3][3] - M[0][0]*M[1][3]*M[2][2]*M[3][1]\n    - M[0][1]*M[1][0]*M[2][2]*M[3][3] - M[0][1]*M[1][2]*M[2][3]*M[3][0] - M[0][1]*M[1][3]*M[2][0]*M[3][2]\n    - M[0][2]*M[1][0]*M[2][3]*M[3][1] - M[0][2]*M[1][1]*M[2][0]*M[3][3] - M[0][2]*M[1][3]*M[2][1]*M[3][0]\n    - M[0][3]*M[1][0]*M[2][1]*M[3][2] - M[0][3]*M[1][1]*M[2][2]*M[3][0] - M[0][3]*M[1][2]*M[2][0]*M[3][1];\n\n// Function: determinant()\n// Synopsis: compute determinant of an arbitrary square matrix. \n// Topics: Matrices, Linear Algebra\n// See Also: det2(), det3(), det4(), determinant(), norm_fro(), matrix_trace()\n// Usage:\n//   d = determinant(M);\n// Description:\n//   Returns the determinant for the given square matrix.\n// Arguments:\n//   M = The NxN square matrix to get the determinant of.\n// Example:\n//   M = [ [6,4,-2,9], [1,-2,8,3], [1,5,7,6], [4,2,5,1] ];\n//   det = determinant(M);  // Returns: 2267\nfunction determinant(M) =\n    assert(is_list(M), \"Input must be a square matrix.\" )  \n    len(M)==1? M[0][0] :\n    len(M)==2? det2(M) :\n    len(M)==3? det3(M) :\n    len(M)==4? det4(M) :\n    assert(is_matrix(M, square=true), \"Input must be a square matrix.\" )    \n    sum(\n        [for (col=[0:1:len(M)-1])\n            ((col%2==0)? 1 : -1) *\n                M[col][0] *\n                determinant(\n                    [for (r=[1:1:len(M)-1])\n                        [for (c=[0:1:len(M)-1])\n                            if (c!=col) M[c][r]\n                        ]\n                    ]\n                )\n        ]\n    );\n\n\n// Function: norm_fro()\n// Synopsis: Compute Frobenius norm of a matrix\n// Topics: Matrices, Linear Algebra\n// See Also: det2(), det3(), det4(), determinant(), norm_fro(), matrix_trace()\n// Usage:\n//    norm_fro(A)\n// Description:\n//    Computes frobenius norm of input matrix.  The frobenius norm is the square root of the sum of the\n//    squares of all of the entries of the matrix.  On vectors it is the same as the usual 2-norm.\n//    This is an easily computed norm that is convenient for comparing two matrices.  \nfunction norm_fro(A) =\n    assert(is_matrix(A) || is_vector(A))\n    norm(flatten(A));\n\n\n// Function: matrix_trace()\n// Synopsis: Compute the trace of a square matrix. \n// Topics: Matrices, Linear Algebra\n// See Also: det2(), det3(), det4(), determinant(), norm_fro(), matrix_trace()\n// Usage:\n//   matrix_trace(M)\n// Description:\n//   Computes the trace of a square matrix, the sum of the entries on the diagonal.  \nfunction matrix_trace(M) =\n   assert(is_matrix(M,square=true), \"Input to trace must be a square matrix\")\n   [for(i=[0:1:len(M)-1])1] * [for(i=[0:1:len(M)-1]) M[i][i]];\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-20", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: linear_bearings.scad\n//   Mounts and models for LMxUU style linear bearings.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/linear_bearings.scad>\n// FileGroup: Parts\n// FileSummary: Mounts for LMxUU style linear bearings.\n//////////////////////////////////////////////////////////////////////\n\ninclude <screws.scad>\n\n\n// Section: Generic Linear Bearings\n\n// Module: linear_bearing_housing()\n// Synopsis: Creates a generic linear bearing mount clamp.\n// SynTags: Geom\n// Topics: Parts, Bearings\n// See Also: linear_bearing(), lmXuu_info(), ball_bearing()\n// Usage:\n//   linear_bearing_housing(d, l, tab, gap, wall, tabwall, screwsize) [ATTACHMENTS];\n// Description:\n//   Creates a model of a clamp to hold a generic linear bearing cartridge.\n// Arguments:\n//   d = Diameter of linear bearing. (Default: 15)\n//   l = Length of linear bearing. (Default: 24)\n//   tab = Clamp tab height. (Default: 8)\n//   tabwall = Clamp Tab thickness. (Default: 5)\n//   wall = Wall thickness of clamp housing. (Default: 3)\n//   gap = Gap in clamp. (Default: 5)\n//   screwsize = Size of screw to use to tighten clamp. (Default: 3)\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   linear_bearing_housing(d=19, l=29, wall=2, tab=8, screwsize=2.5);\nmodule linear_bearing_housing(d=15, l=24, tab=8, gap=5, wall=3, tabwall=5, screwsize=3, anchor=BOTTOM, spin=0, orient=UP)\n{\n    od = d+2*wall;\n    ogap = gap+2*tabwall;\n    tabh = tab/2+od/2*sqrt(2)-ogap/2-1;\n    h = od+tab/2;\n    anchors = [\n        named_anchor(\"axis\", [0,0,-tab/2/2]),\n        named_anchor(\"screw\", [0,2-ogap/2,tabh-tab/2/2],FWD),\n        named_anchor(\"nut\", [0,ogap/2-2,tabh-tab/2/2],FWD)\n    ];\n    attachable(anchor,spin,orient, size=[l, od, h], anchors=anchors) {\n        down(tab/2/2)\n        difference() {\n            union() {\n                // Housing\n                zrot(90) teardrop(r=od/2,h=l);\n\n                // Base\n                cube([l,od,od/2], anchor=TOP);\n\n                // Tabs\n                cube([l,ogap,od/2+tab/2], anchor=BOTTOM);\n            }\n\n            // Clear bearing space\n            zrot(90) teardrop(r=d/2,h=l+0.05);\n\n            // Clear gap\n            cube([l+0.05,gap,od], anchor=BOTTOM);\n\n            up(tabh) {\n                screwsize = is_string(screwsize)? screwsize : str(\"M\",screwsize);\n\n                // Screwhole\n                fwd(ogap/2-2+0.01)\n                    screw_hole(str(screwsize,\",\",ogap), head=\"socket\", counterbore=3, anchor=\"head_bot\", orient=FWD, $fn=12);\n\n                // Nut holder\n                back(ogap/2-2+0.01)\n                    nut_trap_inline(tabwall, screwsize, orient=BACK);\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: linear_bearing()\n// Synopsis: Creates a generic linear bearing cartridge.\n// SynTags: Geom\n// Topics: Parts, Bearings\n// See Also: linear_bearing_housing(), lmXuu_info(), ball_bearing()\n// Usage:\n//   linear_bearing(l, od, id, length) [ATTACHMENTS];\n// Description:\n//   Creates a rough model of a generic linear ball bearing cartridge.\n// Arguments:\n//   l/length = The length of the linear bearing cartridge.\n//   od = The outer diameter of the linear bearing cartridge.\n//   id = The inner diameter of the linear bearing cartridge.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   linear_bearing(l=24, od=15, id=8);\nmodule linear_bearing(l, od=15, id=8, length, anchor=CTR, spin=0, orient=UP) {\n    l = first_defined([l, length, 24]);\n    attachable(anchor,spin,orient, d=od, l=l) {\n        color(\"silver\") {\n            tube(id=id, od=od, l=l-1);\n            tube(id=od-1, od=od, l=l);\n            tube(id=id, od=id+1, l=l);\n            tube(id=id+2, od=od-2, l=l);\n        }\n        children();\n    }\n}\n\n\n// Section: lmXuu Linear Bearings\n\n// Module: lmXuu_housing()\n// Synopsis: Creates a standardized LM*UU linear bearing mount clamp.\n// SynTags: Geom\n// Topics: Parts, Bearings\n// See Also: linear_bearing(), linear_bearing_housing(), lmXuu_info(), lmXuu_bearing(), lmXuu_housing(), ball_bearing()\n// Usage:\n//   lmXuu_housing(size, tab, gap, wall, tabwall, screwsize) [ATTACHMENTS];\n// Description:\n//   Creates a model of a clamp to hold a standard sized lmXuu linear bearing cartridge.\n// Arguments:\n//   size = Standard lmXuu inner size.\n//   tab = Clamp tab height.  Default: 7\n//   tabwall = Clamp Tab thickness.  Default: 5\n//   wall = Wall thickness of clamp housing.  Default: 3\n//   gap = Gap in clamp.  Default: 5\n//   screwsize = Size of screw to use to tighten clamp.  Default: 3\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   lmXuu_housing(size=10, wall=2, tab=6, screwsize=2.5);\nmodule lmXuu_housing(size=8, tab=7, gap=5, wall=3, tabwall=5, screwsize=3, anchor=BOTTOM, spin=0, orient=UP)\n{\n    info = lmXuu_info(size);\n    d = info[0];\n    l = info[1];\n    linear_bearing_housing(d=d, l=l, tab=tab, gap=gap, wall=wall, tabwall=tabwall, screwsize=screwsize, orient=orient, spin=spin, anchor=anchor) children();\n}\n\n\n// Module: lmXuu_bearing()\n// Synopsis: Creates a standardized LM*UU linear bearing cartridge.\n// SynTags: Geom\n// Topics: Parts, Bearings\n// See Also: linear_bearing(), linear_bearing_housing(), lmXuu_info(), lmXuu_bearing(), lmXuu_housing(), ball_bearing()\n// Usage:\n//   lmXuu_bearing(size) [ATTACHMENTS];\n// Description:\n//   Creates a model of an lmXuu linear ball bearing cartridge.\n// Arguments:\n//   size = Standard lmXuu inner size.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   lmXuu_bearing(size=10);\nmodule lmXuu_bearing(size=8, anchor=CTR, spin=0, orient=UP) {\n    info = lmXuu_info(size);\n    linear_bearing(l=info[1], id=size, od=info[0], anchor=anchor, spin=spin, orient=orient) children();\n}\n\n\n// Section: lmXuu Linear Bearing Info\n\n\n// Function: lmXuu_info()\n// Synopsis: Returns the sizes of a standard LM*UU linear bearing cartridge.\n// Topics: Parts, Bearings\n// See Also: linear_bearing(), linear_bearing_housing(), lmXuu_info(), lmXuu_bearing(), lmXuu_housing(), ball_bearing()\n// Usage:\n//   diam_len = lmXuu_info(size);\n// Description:\n//   Get dimensional info for a standard metric lmXuu linear bearing cartridge.\n//   Returns `[DIAM, LENGTH]` for the cylindrical cartridge.\n// Arguments:\n//   size = Inner diameter of lmXuu bearing, in mm.\nfunction lmXuu_info(size) =\n    let(\n        data = [\n            // size, diam, length\n            [  4,   8,  12],\n            [  5,  10,  15],\n            [  6,  12,  19],\n            [  8,  15,  24],\n            [ 10,  19,  29],\n            [ 12,  21,  30],\n            [ 13,  23,  32],\n            [ 16,  28,  37],\n            [ 20,  32,  42],\n            [ 25,  40,  59],\n            [ 30,  45,  64],\n            [ 35,  52,  70],\n            [ 40,  60,  80],\n            [ 50,  80, 100],\n            [ 60,  90, 110],\n            [ 80, 120, 140],\n            [100, 150, 175],\n        ],\n        found = search([size], data, 1)[0]\n    )\n    assert(found!=[], str(\"Unsupported lmXuu linear bearing size: \", size))\n    select(data[found], 1, -1);\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-21", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: lists.scad\n//   Functions for operating on generic lists.  Provides functiosn for indexing lists, changing list\n//   structure, and constructing lists by rearranging or modifying another list. \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Data Management\n// FileSummary: List indexing, change list structure, rearrange/modify lists\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n// Terminology:\n//   **List** = An ordered collection of zero or more arbitrary items.  ie: `[\"a\", \"b\", \"c\"]`, or `[3, \"a\", [4,5]]`\n//   **Vector** = A list of numbers. ie: `[4, 5, 6]`\n//   **Set** = A list of unique items.\n\n// Section: List Query Operations\n\n// Function: is_homogeneous()\n// Alias: is_homogenous()\n// Synopsis: Returns true if all members of a list are of the same type.\n// Topics: List Handling, Type Checking\n// See Also: is_vector(), is_matrix()\n// Usage:\n//   bool = is_homogeneous(list, [depth]);\n// Description:\n//   Returns true when the list has elements of same type up to the depth `depth`.\n//   Booleans and numbers are not distinguinshed as of distinct types. \n// Arguments:\n//   l = the list to check\n//   depth = the lowest level the check is done.  Default: 10\n// Example:\n//   a = is_homogeneous([[1,[\"a\"]], [2,[\"b\"]]]);     // Returns true\n//   b = is_homogeneous([[1,[\"a\"]], [2,[true]]]);    // Returns false\n//   c = is_homogeneous([[1,[\"a\"]], [2,[true]]], 1); // Returns true\n//   d = is_homogeneous([[1,[\"a\"]], [2,[true]]], 2); // Returns false\n//   e = is_homogeneous([[1,[\"a\"]], [true,[\"b\"]]]);  // Returns true\nfunction is_homogeneous(l, depth=10) =\n    !is_list(l) || l==[] ? false :\n    let( l0=l[0] )\n    [] == [for(i=[1:1:len(l)-1]) if( ! _same_type(l[i],l0, depth+1) )  0 ];\n\nfunction is_homogenous(l, depth=10) = is_homogeneous(l, depth);\n                 \n\nfunction _same_type(a,b, depth) = \n    (depth==0) ||\n    (is_undef(a) && is_undef(b)) ||\n    (is_bool(a) && is_bool(b)) ||\n    (is_num(a) && is_num(b)) ||\n    (is_string(a) && is_string(b)) ||\n    (is_list(a) && is_list(b) && len(a)==len(b) \n          && []==[for(i=idx(a)) if( ! _same_type(a[i],b[i],depth-1) ) 0] ); \n  \n\n// Function: min_length()\n// Synopsis: Given a list of sublists, returns the length of the shortest sublist.\n// Topics: List Handling\n// See Also: max_length()\n// Usage:\n//   llen = min_length(list);\n// Description:\n//   Returns the length of the shortest sublist in a list of lists.\n// Arguments:\n//   list = A list of lists.\n// Example:\n//   slen = min_length([[3,4,5],[6,7,8,9]]);  // Returns: 3\nfunction min_length(list) =\n    assert(is_list(list), \"Invalid input.\" )\n    min([for (v = list) len(v)]);\n\n\n// Function: max_length()\n// Synopsis: Given a list of sublists, returns the length of the longest sublist.\n// Topics: List Handling\n// See Also: min_length()\n// Usage:\n//   llen = max_length(list);\n// Description:\n//   Returns the length of the longest sublist in a list of lists.\n// Arguments:\n//   list = A list of lists.\n// Example:\n//   llen = max_length([[3,4,5],[6,7,8,9]]);  // Returns: 4\nfunction max_length(list) =\n    assert(is_list(list), \"Invalid input.\" )\n    max([for (v = list) len(v)]);\n\n\n\n\n// Internal.  Not exposed.\nfunction _list_shape_recurse(v) =\n    !is_list(v[0])\n    ?   len( [for(entry=v) if(!is_list(entry)) 0] ) == 0 ? [] : [undef]\n    :   let(\n          firstlen = is_list(v[0]) ? len(v[0]): undef,\n          first = len( [for(entry = v) if(! is_list(entry) || (len(entry) != firstlen)) 0  ]   ) == 0 ? firstlen : undef,\n          leveldown = flatten(v)\n        ) \n        is_list(leveldown[0])\n        ?  concat([first],_list_shape_recurse(leveldown))\n        : [first];\n\nfunction _list_shape_recurse(v) =\n    let( alen = [for(vi=v) is_list(vi) ? len(vi): -1] )\n    v==[] || max(alen)==-1 ? [] :\n    let( add = max(alen)!=min(alen) ? undef : alen[0] ) \n    concat( add, _list_shape_recurse(flatten(v)));\n\n\n// Function: list_shape()\n// Synopsis: Returns the dimensions of an array.\n// Topics: Matrices, List Handling\n// See Also: is_homogenous()\n// Usage:\n//   dims = list_shape(v, [depth]);\n// Description:\n//   Returns the size of a multi-dimensional array, a list of the lengths at each depth.\n//   If the returned value has `dims[i] = j` then it means the ith index ranges of j items.\n//   The return `dims[0]` is equal to the length of v.  Then `dims[1]` is equal to the\n//   length of the lists in v, and in general, `dims[i]` is equal to the length of the items\n//   nested to depth i in the list v.  If the length of items at that depth is inconsistent, then\n//   `undef` is returned.  If no items exist at that depth then `0` is returned.  Note that\n//   for simple vectors or matrices it is faster to compute `len(v)` and `len(v[0])`.  \n// Arguments:\n//   v = list to get shape of\n//   depth = depth to compute the size of.  If not given, returns a list of sizes at all depths. \n// Example:\n//   a = list_shape([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]]);     // Returns [2,2,3]\n//   b = list_shape([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]], 0);  // Returns 2\n//   c = list_shape([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]], 2);  // Returns 3\n//   d = list_shape([[[1,2,3],[4,5,6]],[[7,8,9]]]);                // Returns [2,undef,3]\nfunction list_shape(v, depth=undef) =\n    assert( is_undef(depth) || ( is_finite(depth) && depth>=0 ), \"Invalid depth.\")\n    ! is_list(v) ? 0 :\n    (depth == undef)\n    ?   concat([len(v)], _list_shape_recurse(v))\n    :   (depth == 0)\n        ?  len(v)\n        :  let( dimlist = _list_shape_recurse(v))\n           (depth > len(dimlist))? 0 : dimlist[depth-1] ;\n\n\n\n// Function: in_list()\n// Synopsis: Returns true if a value is in a list.\n// Topics: List Handling\n// See Also: select(), slice()\n// Usage:\n//   bool = in_list(val, list, [idx]);\n// Description:\n//   Returns true if value `val` is in list `list`. When `val==NAN` the answer will be false for any list.\n// Arguments:\n//   val = The simple value to search for.\n//   list = The list to search.\n//   idx = If given, searches the given columns for matches for `val`.\n// Example:\n//   a = in_list(\"bar\", [\"foo\", \"bar\", \"baz\"]);  // Returns true.\n//   b = in_list(\"bee\", [\"foo\", \"bar\", \"baz\"]);  // Returns false.\n//   c = in_list(\"bar\", [[2,\"foo\"], [4,\"bar\"], [3,\"baz\"]], idx=1);  // Returns true.\n\n// Note that a huge complication occurs because OpenSCAD's search() finds\n// index i as a hits if the val equals list[i] but also if val equals list[i][0].\n// This means every hit needs to be checked to see if it's actually a hit,\n// and if the first hit is a mismatch we have to keep searching.\n// We assume that the normal case doesn't have mixed data, and try first\n// with just one hit, but if this finds a mismatch then we try again\n// with all hits, which could be slow for long lists.  \nfunction in_list(val,list,idx) = \n    assert(is_list(list),\"Input is not a list\")\n    assert(is_undef(idx) || is_finite(idx), \"Invalid idx value.\")\n    let( firsthit = search([val], list, num_returns_per_match=1, index_col_num=idx)[0] )\n    firsthit==[] ? false\n    : is_undef(idx) && val==list[firsthit] ? true\n    : is_def(idx) && val==list[firsthit][idx] ? true\n    // first hit was found but didn't match, so try again with all hits\n    : let ( allhits = search([val], list, 0, idx)[0])\n      is_undef(idx) ? [for(hit=allhits) if (list[hit]==val) 1] != []\n    : [for(hit=allhits) if (list[hit][idx]==val) 1] != [];\n\n\n\n// Section: List Indexing\n\n// Function: select()\n// Synopsis: Returns one or more items from a list, with wrapping.\n// Topics: List Handling\n// See Also: slice(), column(), last()\n// Description:\n//   Returns a portion of a list, wrapping around past the beginning, if end<start. \n//   The first item is index 0. Negative indexes are counted back from the end.\n//   The last item is -1.  If only the `start` index is given, returns just the value\n//   at that position when `start` is a number or the selected list of entries when `start` is\n//   a list of indices or a range.\n// Usage:\n//   item = select(list, start);\n//   item = select(list, [s:d:e]);\n//   item = select(list, [i0,i1...,ik]);\n//   list = select(list, start, end);\n// Arguments:\n//   list = The list to get the portion of.\n//   start = Either the index of the first item or an index range or a list of indices.\n//   end = The index of the last item when `start` is a number. When `start` is a list or a range, `end` should not be given.\n// Example:\n//   l = [3,4,5,6,7,8,9];\n//   a = select(l, 5, 6);   // Returns [8,9]\n//   b = select(l, 5, 8);   // Returns [8,9,3,4]\n//   c = select(l, 5, 2);   // Returns [8,9,3,4,5]\n//   d = select(l, -3, -1); // Returns [7,8,9]\n//   e = select(l, 3, 3);   // Returns [6]\n//   f = select(l, 4);      // Returns 7\n//   g = select(l, -2);     // Returns 8\n//   h = select(l, [1:3]);  // Returns [4,5,6]\n//   i = select(l, [3,1]);  // Returns [6,4]\nfunction select(list, start, end) =\n    assert( is_list(list) || is_string(list), \"Invalid list.\")\n    let(l=len(list))\n    l==0\n      ? []\n      : end==undef\n          ? is_num(start)\n              ? list[ (start%l+l)%l ]\n              : assert( start==[] || is_vector(start) || is_range(start), \"Invalid start parameter\")\n                [for (i=start) list[ (i%l+l)%l ] ]\n          : assert(is_finite(start), \"When `end` is given, `start` parameter should be a number.\")\n            assert(is_finite(end), \"Invalid end parameter.\")\n            let( s = (start%l+l)%l, e = (end%l+l)%l )\n            (s <= e)\n              ? [ for (i = [s:1:e])   list[i] ]\n              : [ for (i = [s:1:l-1]) list[i], \n                  for (i = [0:1:e])   list[i] ] ;\n\n\n// Function: slice()\n// Synopsis: Returns part of a list without wrapping.\n// Topics: List Handling\n// See Also: select(), column(), last()\n// Usage:\n//   list = slice(list, s, e);\n// Description:\n//   Returns a slice of a list, from the first position `s` up to and including the last position `e`.\n//   The first item in the list is at index 0.  Negative indexes are counted back from the end, with\n//   -1 referring to the last list item.  If `s` is after `e` then the empty list is returned.\n//   If an index is off the start/end of the list it will refer to the list start/end.  \n// Arguments:\n//   list = The list to get the slice of.\n//   start = The index of the first item to return.  Default: 0\n//   end = The index of the last item to return.  Default: -1 (last item)\n// Example:\n//   a = slice([3,4,5,6,7,8,9], 3, 5);   // Returns [6,7,8]\n//   b = slice([3,4,5,6,7,8,9], 2, -1);  // Returns [5,6,7,8,9]\n//   c = slice([3,4,5,6,7,8,9], 1, 1);   // Returns [4]\n//   d = slice([3,4,5,6,7,8,9], 5);      // Returns [8,9]\n//   e = slice([3,4,5,6,7,8,9], 2, -2);  // Returns [5,6,7,8]\n//   f = slice([3,4,5,6,7,8,9], 4, 3;    // Returns []\n//   g = slice([3,4,5], 1, 5;            // Returns [4,5]\n//   h = slice([3,4,5], 5, 7);           // Returns []\nfunction slice(list,start=0,end=-1) =\n    assert(is_list(list))\n    assert(is_int(start))\n    assert(is_int(end))\n    !list? [] :\n    let(\n        l = len(list),\n        start = start+(start<0 ? l : 0),\n        end = end + (end<0? l : 0)\n    )\n    [if (start<=end && end>=0 && start<=l) for (i=[max(start,0):1:min(end,l-1)]) list[i]];\n\n\n// Function: last()\n// Synopsis: Returns the last item of a list.\n// Topics: List Handling\n// See Also: select(), slice(), column()\n// Usage:\n//   item = last(list);\n// Description:\n//   Returns the last element of a list, or undef if empty.\n// Arguments:\n//   list = The list to get the last element of.\n// Example:\n//   l = [3,4,5,6,7,8,9];\n//   x = last(l);  // Returns 9.\nfunction last(list) =\n    list[len(list)-1];\n\n\n// Function: list_head()\n// Synopsis: Returns the elements at the beginning of a list.\n// Topics: List Handling\n// See Also: select(), slice(), list_tail(), last()\n// Usage:\n//   list = list_head(list, [to]);\n// Description:\n//   Returns the head of the given list, from the first item up until the `to` index, inclusive.\n//   By default returns all but the last element of the list.  \n//   If the `to` index is negative, then the length of the list is added to it, such that\n//   `-1` is the last list item.  `-2` is the second from last.  `-3` is third from last, etc.\n//   If the list is shorter than the given index, then the full list is returned.\n// Arguments:\n//   list = The list to get the head of.\n//   to = The last index to include.  If negative, adds the list length to it.  ie: -1 is the last list item.  Default: -2\n// Example:\n//   hlist1 = list_head([\"foo\", \"bar\", \"baz\"]);  // Returns: [\"foo\", \"bar\"]\n//   hlist2 = list_head([\"foo\", \"bar\", \"baz\"], -3); // Returns: [\"foo\"]\n//   hlist3 = list_head([\"foo\", \"bar\", \"baz\"], 2);  // Returns: [\"foo\",\"bar\"]\n//   hlist4 = list_head([\"foo\", \"bar\", \"baz\"], -5); // Returns: []\n//   hlist5 = list_head([\"foo\", \"bar\", \"baz\"], 5);  // Returns: [\"foo\",\"bar\",\"baz\"]\nfunction list_head(list, to=-2) =\n   assert(is_list(list))\n   assert(is_finite(to))\n   to<0? [for (i=[0:1:len(list)+to]) list[i]] :\n   to<len(list)? [for (i=[0:1:to]) list[i]] :\n   list;\n\n\n// Function: list_tail()\n// Synopsis: Returns the elements at the end of a list.\n// Topics: List Handling\n// See Also: select(), slice(), list_tail(), last()\n// Usage:\n//   list = list_tail(list, [from]);\n// Description:\n//   Returns the tail of the given list, from the `from` index up until the end of the list, inclusive.\n//   By default returns all but the first item.  \n//   If the `from` index is negative, then the length of the list is added to it, such that\n//   `-1` is the last list item.  `-2` is the second from last.  `-3` is third from last, etc.\n//   If you want it to return the last three items of the list, use `from=-3`.\n// Arguments:\n//   list = The list to get the tail of.\n//   from = The first index to include.  If negative, adds the list length to it.  ie: -1 is the last list item.  Default: 1.\n// Example:\n//   tlist1 = list_tail([\"foo\", \"bar\", \"baz\"]);  // Returns: [\"bar\", \"baz\"]\n//   tlist2 = list_tail([\"foo\", \"bar\", \"baz\"], -1); // Returns: [\"baz\"]\n//   tlist3 = list_tail([\"foo\", \"bar\", \"baz\"], 2);  // Returns: [\"baz\"]\n//   tlist4 = list_tail([\"foo\", \"bar\", \"baz\"], -5); // Returns: [\"foo\",\"bar\",\"baz\"]\n//   tlist5 = list_tail([\"foo\", \"bar\", \"baz\"], 5);  // Returns: []\nfunction list_tail(list, from=1) =\n   assert(is_list(list))\n   assert(is_finite(from))\n   from>=0? [for (i=[from:1:len(list)-1]) list[i]] :\n   let(from = from + len(list))\n   from>=0? [for (i=[from:1:len(list)-1]) list[i]] :\n   list;\n\n\n\n// Function: bselect()\n// Synopsis: Select list items using boolean index list.\n// Topics: List Handling\n// See Also: list_bset()\n// Usage:\n//   sublist = bselect(list, index);\n// Description:\n//   Returns the items in `list` whose matching element in `index` evaluates as true.  \n// Arguments:\n//   list = Initial list (or string) to extract items from.\n//   index = List of values that will be evaluated as boolean, same length as `list`.  \n// Example:\n//   a = bselect([3,4,5,6,7], [false,true,true,false,true]);  // Returns: [4,5,7]\nfunction bselect(list,index) =\n    assert(is_list(list)||is_string(list), \"First argument must be a list or string.\" )\n    assert(is_list(index) && len(index)==len(list) , \"Second argument must have same length as the first.\" )\n    is_string(list)? str_join(bselect( [for (x=list) x], index)) :\n    [for(i=idx(list)) if (index[i]) list[i]];\n\n\n// Section: List Construction\n\n\n// Function: repeat()\n// Synopsis: Returns a list of repeated copies of a value.\n// Topics: List Handling\n// See Also: count(), lerpn()\n// Usage:\n//   list = repeat(val, n);\n// Description:\n//   Generates a list of `n` copies of the given value `val`.\n//   If the count `n` is given as a list of counts, then this creates a\n//   multi-dimensional array, filled with `val`.  If `n` is negative, returns the empty list. \n// Arguments:\n//   val = The value to repeat to make the list or array.\n//   n = The number of copies to make of `val`.  Can be a list to make an array of copies.\n// Example:\n//   a = repeat(1, 4);        // Returns [1,1,1,1]\n//   b = repeat(8, [2,3]);    // Returns [[8,8,8], [8,8,8]]\n//   c = repeat(0, [2,2,3]);  // Returns [[[0,0,0],[0,0,0]], [[0,0,0],[0,0,0]]]\n//   d = repeat([1,2,3],3);   // Returns [[1,2,3], [1,2,3], [1,2,3]]\n//   e = repeat(4, -1);       // Returns []\nfunction repeat(val, n, i=0) =\n    is_num(n)? [for(j=[1:1:n]) val] :\n    assert( is_list(n), \"Invalid count number.\")\n    (i>=len(n))? val :\n    [for (j=[1:1:n[i]]) repeat(val, n, i+1)];\n\n\n\n// Function: list_bset()\n// Synopsis: Returns a list where values are spread to locations indicated by a boolean index list.\n// Topics: List Handling\n// See Also: bselect()\n// Usage:\n//   arr = list_bset(indexset, valuelist, [dflt]);\n// Description:\n//   Opposite of `bselect()`.  Returns a list the same length as `indexlist`, where each item will\n//   either be 0 if the corresponding item in `indexset` is false, or the next sequential value\n//   from `valuelist` if the item is true.  The number of `true` values in `indexset` must be equal \n//   to the length of `valuelist`.\n// Arguments:\n//   indexset = A list of boolean values.\n//   valuelist = The list of values to set into the returned list.\n//   dflt = Default value to store when the indexset item is false.  Default: 0\n// Example:\n//   a = list_bset([false,true,false,true,false], [3,4]);  // Returns: [0,3,0,4,0]\n//   b = list_bset([false,true,false,true,false], [3,4], dflt=1);  // Returns: [1,3,1,4,1]\nfunction list_bset(indexset, valuelist, dflt=0) =\n    assert(is_list(indexset), \"The index set is not a list.\" )\n    assert(is_list(valuelist), \"The `valuelist` is not a list.\" )\n    let( trueind = search([true], indexset,0)[0] )\n    assert( !(len(trueind)>len(valuelist)), str(\"List `valuelist` too short; its length should be \",len(trueind)) )\n    assert( !(len(trueind)<len(valuelist)), str(\"List `valuelist` too long; its length should be \",len(trueind)) )\n    concat(\n        list_set([],trueind, valuelist, dflt=dflt),    // Fill in all of the values\n        repeat(dflt,len(indexset)-max(trueind)-1)  // Add trailing values so length matches indexset\n    );\n\n\n\n// Function: list()\n// Synopsis: Expands a range into a full list.\n// Topics: List Handling, Type Conversion\n// See Also: scalar_vec3(), force_list()\n// Usage:\n//   list = list(l)\n// Description:\n//   Expands a range into a full list.  If given a list, returns it verbatim.\n//   If given a string, explodes it into a list of single letters.\n// Arguments:\n//   l = The value to expand.\n// Example:\n//   l1 = list([3:2:9]);  // Returns: [3,5,7,9]\n//   l2 = list([3,4,5]);  // Returns: [3,4,5]\n//   l3 = list(\"Foo\");    // Returns: [\"F\",\"o\",\"o\"]\n//   l4 = list(23);       // Returns: [23]\nfunction list(l) = is_list(l)? l : [for (x=l) x];\n\n\n// Function: force_list()\n// Synopsis: Coerces non-list values into a list.\n// Topics: List Handling\n// See Also: scalar_vec3()\n// Usage:\n//   list = force_list(value, [n], [fill]);\n// Description:\n//   Coerces non-list values into a list.  Makes it easy to treat a scalar input\n//   consistently as a singleton list, as well as list inputs.\n//   - If `value` is a list, then that list is returned verbatim.\n//   - If `value` is not a list, and `fill` is not given, then a list of `n` copies of `value` will be returned.\n//   - If `value` is not a list, and `fill` is given, then a list `n` items long will be returned where `value` will be the first item, and the rest will contain the value of `fill`.\n// Arguments:\n//   value = The value or list to coerce into a list.\n//   n = The number of items in the coerced list.  Default: 1\n//   fill = The value to pad the coerced list with, after the firt value.  Default: undef (pad with copies of `value`)\n// Example:\n//   x = force_list([3,4,5]);  // Returns: [3,4,5]\n//   y = force_list(5);  // Returns: [5]\n//   z = force_list(7, n=3);  // Returns: [7,7,7]\n//   w = force_list(4, n=3, fill=1);  // Returns: [4,1,1]\nfunction force_list(value, n=1, fill) =\n    is_list(value) ? value :\n    is_undef(fill)? [for (i=[1:1:n]) value] : [value, for (i=[2:1:n]) fill];\n\n\n// Section: List Modification\n\n// Function: reverse()\n// Synopsis: Reverses the elements of a list.\n// Topics: List Handling\n// See Also: select(), list_rotate()\n// Usage:\n//   rlist = reverse(list);\n// Description:\n//   Reverses a list or string.\n// Arguments:\n//   list = The list or string to reverse.\n// Example:\n//   reverse([3,4,5,6]);  // Returns [6,5,4,3]\nfunction reverse(list) =\n    assert(is_list(list)||is_string(list), str(\"Input to reverse must be a list or string. Got: \",list))\n    let (elems = [ for (i = [len(list)-1 : -1 : 0]) list[i] ])\n    is_string(list)? str_join(elems) : elems;\n\n\n// Function: list_rotate()\n// Synopsis: Rotates the ordering of a list.\n// Topics: List Handling\n// See Also: select(), reverse()\n// Usage:\n//   rlist = list_rotate(list, [n]);\n// Description:\n//   Rotates the contents of a list by `n` positions left, so that list[n] becomes the first entry of the list.\n//   If `n` is negative, then the rotation is `abs(n)` positions to the right.\n//   If `list` is a string, then a string is returned with the characters rotates within the string.\n// Arguments:\n//   list = The list to rotate.\n//   n = The number of positions to rotate by.  If negative, rotated to the right.  Positive rotates to the left.  Default: 1\n// Example:\n//   l1 = list_rotate([1,2,3,4,5],-2); // Returns: [4,5,1,2,3]\n//   l2 = list_rotate([1,2,3,4,5],-1); // Returns: [5,1,2,3,4]\n//   l3 = list_rotate([1,2,3,4,5],0);  // Returns: [1,2,3,4,5]\n//   l4 = list_rotate([1,2,3,4,5],1);  // Returns: [2,3,4,5,1]\n//   l5 = list_rotate([1,2,3,4,5],2);  // Returns: [3,4,5,1,2]\n//   l6 = list_rotate([1,2,3,4,5],3);  // Returns: [4,5,1,2,3]\n//   l7 = list_rotate([1,2,3,4,5],4);  // Returns: [5,1,2,3,4]\n//   l8 = list_rotate([1,2,3,4,5],5);  // Returns: [1,2,3,4,5]\n//   l9 = list_rotate([1,2,3,4,5],6);  // Returns: [2,3,4,5,1]\nfunction list_rotate(list,n=1) =\n    assert(is_list(list)||is_string(list), \"Invalid list or string.\")\n    assert(is_int(n), \"The rotation number should be integer\")\n    let (\n        ll = len(list),\n        n = ((n % ll) + ll) % ll,\n        elems = [\n            for (i=[n:1:ll-1]) list[i],\n            for (i=[0:1:n-1]) list[i]\n        ]\n    )\n    is_string(list)? str_join(elems) : elems;\n\n    \n\n// Function: shuffle()\n// Synopsis: Randomizes the order of a list.\n// Topics: List Handling\n// See Also: sort(), sortidx(), unique(), unique_count()\n// Usage:\n//   shuffled = shuffle(list, [seed]);\n// Description:\n//   Shuffles the input list into random order.\n//   If given a string, shuffles the characters within the string.\n//   If you give a numeric seed value then the permutation\n//   will be repeatable.\n// Arguments:\n//   list = The list to shuffle.\n//   seed = Optional random number seed for the shuffling.\n// Example:\n//   //        Spades   Hearts    Diamonds  Clubs\n//   suits = [\"\\u2660\", \"\\u2661\", \"\\u2662\", \"\\u2663\"];\n//   ranks = [2,3,4,5,6,7,8,9,10,\"J\",\"Q\",\"K\",\"A\"];\n//   cards = [for (suit=suits, rank=ranks) str(rank,suit)];\n//   deck = shuffle(cards);\nfunction shuffle(list,seed) =\n    assert(is_list(list)||is_string(list), \"Invalid input.\" )\n    is_string(list)? str_join(shuffle([for (x = list) x],seed=seed)) :\n    len(list)<=1 ? list :\n    let(\n        rval = is_num(seed) ? rands(0,1,len(list),seed_value=seed)\n                            : rands(0,1,len(list)),\n        left  = [for (i=[0:len(list)-1]) if (rval[i]< 0.5) list[i]],\n        right = [for (i=[0:len(list)-1]) if (rval[i]>=0.5) list[i]]\n    ) \n    concat(shuffle(left), shuffle(right));\n\n\n\n// Function: repeat_entries()\n// Synopsis: Repeats list entries (as uniformly as possible) to make list of specified length.\n// Topics: List Handling\n// See Also: repeat()\n// Usage:\n//   newlist = repeat_entries(list, N, [exact]);\n// Description:\n//   Takes a list as input and duplicates some of its entries to produce a list\n//   with length `N`.  If the requested `N` is not a multiple of the list length then\n//   the entries will be duplicated as uniformly as possible.  You can also set `N` to a vector,\n//   in which case len(N) must equal len(list) and the output repeats the ith entry N[i] times.\n//   In either case, the result will be a list of length `N`.  The `exact` option requires\n//   that the final length is exactly as requested.  If you set it to `false` then the\n//   algorithm will favor uniformity and the output list may have a different number of\n//   entries due to rounding.\n//   .\n//   When applied to a path the output path is the same geometrical shape but has some vertices\n//   repeated.  This can be useful when you need to align paths with a different number of points.\n//   (See also subdivide_path for a different way to do that.) \n// Arguments:\n//   list = list whose entries will be repeated\n//   N = scalar total number of points desired or vector requesting N[i] copies of vertex i.  \n//   exact = if true return exactly the requested number of points, possibly sacrificing uniformity.  If false, return uniform points that may not match the number of points requested.  Default: True\n// Example:\n//   list = [0,1,2,3];\n//   a = repeat_entries(list, 6);  // Returns: [0,0,1,2,2,3]\n//   b = repeat_entries(list, 6, exact=false);  // Returns: [0,0,1,1,2,2,3,3]\n//   c = repeat_entries(list, [1,1,2,1], exact=false);  // Returns: [0,1,2,2,3]\nfunction repeat_entries(list, N, exact=true) =\n    assert(is_list(list) && len(list)>0, \"The list cannot be void.\")\n    assert((is_finite(N) && N>0) || is_vector(N,len(list)),\n            \"Parameter N must be a number greater than zero or vector with the same length of `list`\")\n    let(\n        length = len(list),\n        reps_guess = is_list(N)? N : repeat(N/length,length),\n        reps = exact ?\n                 _sum_preserving_round(reps_guess) \n               : [for (val=reps_guess) round(val)]\n    )\n    [for(i=[0:length-1]) each repeat(list[i],reps[i])];\n\n\n// Function: list_pad()\n// Synopsis: Extend list to specified length.\n// Topics: List Handling\n// See Also: force_list(), scalar_vec3()\n// Usage:\n//   newlist = list_pad(list, minlen, [fill]);\n// Description:\n//   If the list `list` is shorter than `minlen` length, pad it to length with the value given in `fill`.\n// Arguments:\n//   list = A list.\n//   minlen = The minimum length to pad the list to.\n//   fill = The value to pad the list with.  Default: `undef`\n// Example:\n//   list = [3,4,5];\n//   nlist = list_pad(list,5,23);  // Returns: [3,4,5,23,23]\nfunction list_pad(list, minlen, fill) =\n    assert(is_list(list), \"Invalid input.\" )\n    concat(list,repeat(fill,minlen-len(list)));\n\n\n// Function: list_set()\n// Synopsis: Sets the value of specific list items.\n// Topics: List Handling\n// See Also: list_insert(), list_remove(), list_remove_values()\n// Usage:\n//   list = list_set(list, indices, values, [dflt], [minlen]);\n// Description:\n//   Takes the input list and returns a new list such that `list[indices[i]] = values[i]` for all of\n//   the (index,value) pairs supplied and unchanged for other indices.  If you supply `indices` that are \n//   larger that the length of the list then the list is extended and filled in with the `dflt` value.\n//   If you specify indices smaller than zero then they index from the end, with -1 being the last element.\n//   Negative indexing does not wrap around: an error occurs if you give a value smaller than `-len(list)`.\n//   If you set `minlen` then the list is lengthed, if necessary, by padding with `dflt` to that length.  \n//   Repetitions in `indices` are not allowed. The lists `indices` and `values` must have the same length.  \n//   If `indices` is given as a scalar, then that index of the given `list` will be set to the scalar value of `values`.\n// Arguments:\n//   list = List to set items in.  Default: []\n//   indices = List of indices into `list` to set.\n//   values = List of values to set.\n//   dflt = Default value to store in sparse skipped indices.\n//   minlen = Minimum length to expand list to.\n// Example:\n//   a = list_set([2,3,4,5], 2, 21);  // Returns: [2,3,21,5]\n//   b = list_set([2,3,4,5], [1,3], [81,47]);  // Returns: [2,81,4,47]\nfunction list_set(list=[],indices,values,dflt=0,minlen=0) =\n    assert(is_list(list))\n    !is_list(indices)?\n        assert(is_finite(indices))\n        let(\n            index = indices<0 ? indices+len(list) : indices\n        )\n        assert(index>=0, str(\"Index \",indices,\" is smaller than negative list length\"))\n        (\n            index<len(list) ?\n                [\n                  for(i=[0:1:index-1]) list[i],\n                  values,\n                  for(i=[index+1:1:len(list)-1]) list[i],\n                  for(i=[len(list):1:minlen-1]) dflt\n                ]\n            : concat(list, repeat(dflt, index-len(list)), [values], repeat(dflt, minlen-index-1))\n        )\n  : indices==[] && values==[]\n      ? concat(list, repeat(dflt, minlen-len(list)))\n  : assert(is_vector(indices) && is_list(values) && len(values)==len(indices),\n           \"Index list and value list must have the same length\")\n    let(  indices = [for(ind=indices) ind<0 ? ind+len(list) : ind],\n          midx = max(len(list)-1, max(indices))\n    )\n    assert(min(indices)>=0, \"Index list contains value smaller than negative list length\")\n    [\n       for (i=[0:1:midx])\n           let(\n               j = search(i,indices,0),\n               k = j[0]\n           )\n           assert( len(j)<2, \"Repeated indices are not allowed.\" )\n           k!=undef ? values[k]\n         : i<len(list) ? list[i]\n         : dflt,\n       each repeat(dflt, minlen-max(len(list),max(indices)+1))\n    ];\n\n\n\n// Function: list_insert()\n// Synopsis: Inserts values into the middle of a list.\n// Topics: List Handling\n// See Also: list_set(), list_remove(), list_remove_values()\n// Usage:\n//   list = list_insert(list, indices, values);\n// Description:\n//   Insert `values` into `list` before position `indices`.  The indices for insertion \n//   are based on the original list, before any insertions have occurred.\n//   You can use negative indices to count from the end of the list.  Note that -1 refers\n//   to the last element, so the insertion will be *before* the last element.  \n// Arguments:\n//   list = list to insert items into\n//   indices = index or list of indices where values are inserted\n//   values = value or list of values to insert\n// Example:\n//   a = list_insert([3,6,9,12],1,5);  // Returns [3,5,6,9,12]\n//   b = list_insert([3,6,9,12],[1,3],[5,11]);  // Returns [3,5,6,9,11,12]\nfunction list_insert(list, indices, values) = \n    assert(is_list(list))\n    !is_list(indices) ?\n        assert(is_finite(indices), \"Invalid indices.\" )\n        let(indices = indices<0 ? indices+len(list) : indices)\n        assert(indices>=0, \"Index is too small, must be >= len(list)\")\n        assert( indices<=len(list), \"Indices must be <= len(list) .\" )\n        [\n          for (i=idx(list)) each ( i==indices?  [ values, list[i] ] : [ list[i] ] ),\n          if (indices==len(list)) values\n        ] :\n    indices==[] && values==[] ? list :\n    assert( is_vector(indices) && is_list(values) && len(values)==len(indices),\n           \"Index list and value list must have the same length\")\n    assert( max(indices)<=len(list), \"Indices must be <= len(list).\" )\n    let(\n        indices = [for(ind=indices) ind<0 ? ind+len(list) : ind],\n        maxidx = max(indices),\n        minidx = min(indices)\n    )\n    assert(minidx>=0, \"Index list contains values that are too small\")\n    assert(maxidx<=len(list), \"Index list contains values that are too large\")\n    [\n        for (i=[0:1:minidx-1] ) list[i],\n        for (i=[minidx : min(maxidx, len(list)-1)] )\n            let(\n                j = search(i,indices,0),\n                k = j[0],\n                x = assert( len(j)<2, \"Repeated indices are not allowed.\" )\n            ) each ( k != undef  ? [ values[k], list[i] ] : [ list[i] ] ),\n        for ( i = [min(maxidx, len(list)-1)+1 : 1 : len(list)-1] ) list[i],\n        if (maxidx == len(list)) values[max_index(indices)]\n    ];\n\n\n// Function: list_remove()\n// Synopsis: Removes items by index from a list.\n// Topics: List Handling\n// See Also: list_set(), list_insert(), list_remove_values()\n// Usage:\n//   list = list_remove(list, ind);\n// Description:\n//   If `ind` is a number remove `list[ind]` from the list.  If `ind` is a list of indices\n//   remove from the list the item all items whose indices appear in `ind`.  If you give\n//   indices that are not in the list they are ignored.  \n// Arguments:\n//   list = The list to remove items from.\n//   ind = index or list of indices of items to remove. \n// Example:\n//   a = list_remove([3,6,9,12],1);      // Returns: [3,9,12]\n//   b = list_remove([3,6,9,12],[1,3]);  // Returns: [3,9]\n//   c = list_remove([3,6],3);           // Returns: [3,6]\nfunction list_remove(list, ind) =\n    assert(is_list(list), \"Invalid list in list_remove\")\n    is_finite(ind) ?\n        (\n         (ind<0 || ind>=len(list)) ? list\n         :                                        \n            [\n              for (i=[0:1:ind-1]) list[i],\n              for (i=[ind+1:1:len(list)-1]) list[i]\n            ]\n        )\n    :   ind==[] ? list\n    :   assert( is_vector(ind), \"Invalid index list in list_remove\")\n        let(sres = search(count(list),ind,1))\n        [\n            for(i=idx(list))\n                if (sres[i] == []) \n                    list[i]\n        ];\n\n// This method is faster for long lists with few values to remove\n//     let(   rem = list_set([], indices, repeat(1,len(indices)), minlen=len(list)))\n//     [for(i=idx(list)) if (rem[i]==0) list[i]];\n\n\n\n// Function: list_remove_values()\n// Synopsis: Removes items by value from a list.\n// Topics: List Handling\n// See Also: list_set(), list_insert(), list_remove()\n// Usage:\n//   list = list_remove_values(list, values, [all]);\n// Description:\n//   Removes the first, or all instances of the given value or list of values from the list.\n//   If you specify `all=false` and list a value twice then the first two instances will be removed.  \n//   Note that if you want to remove a list value such as `[3,4]` then you must give it as\n//   a singleton list, or it will be interpreted as a list of two scalars to remove.  \n// Arguments:\n//   list = The list to modify.\n//   values = The value or list of values to remove from the list.\n//   all = If true, remove all instances of the value `value` from the list `list`.  If false, remove only the first.  Default: false\n// Example:\n//   test = [3,4,[5,6],7,5,[5,6],4,[6,5],7,[4,4]];\n//   a=list_remove_values(test,4); // Returns: [3, [5, 6], 7, 5, [5, 6], 4, [6, 5], 7, [4, 4]]\n//   b=list_remove_values(test,[4,4]); // Returns: [3, [5, 6], 7, 5, [5, 6], [6, 5], 7, [4, 4]]\n//   c=list_remove_values(test,[4,7]); // Returns: [3, [5, 6], 5, [5, 6], 4, [6, 5], 7, [4, 4]]\n//   d=list_remove_values(test,[5,6]); // Returns: [3, 4, [5, 6], 7, [5, 6], 4, [6, 5], 7, [4, 4]]\n//   e=list_remove_values(test,[[5,6]]); // Returns: [3,4,7,5,[5,6],4,[6,5],7,[4,4]]\n//   f=list_remove_values(test,[[5,6]],all=true); // Returns: [3,4,7,5,4,[6,5],7,[4,4]]\n//   animals = [\"bat\", \"cat\", \"rat\", \"dog\", \"bat\", \"rat\"];\n//   animals2 = list_remove_values(animals, \"rat\");   // Returns: [\"bat\",\"cat\",\"dog\",\"bat\",\"rat\"]\n//   nonflying = list_remove_values(animals, \"bat\", all=true);  // Returns: [\"cat\",\"rat\",\"dog\",\"rat\"]\n//   animals3 = list_remove_values(animals, [\"bat\",\"rat\"]);  // Returns: [\"cat\",\"dog\",\"bat\",\"rat\"]\n//   domestic = list_remove_values(animals, [\"bat\",\"rat\"], all=true);  // Returns: [\"cat\",\"dog\"]\n//   animals4 = list_remove_values(animals, [\"tucan\",\"rat\"], all=true);  // Returns: [\"bat\",\"cat\",\"dog\",\"bat\"]\nfunction list_remove_values(list,values=[],all=false) =\n    !is_list(values)? list_remove_values(list, values=[values], all=all) :\n    assert(is_list(list), \"Invalid list\")\n    len(values)==0 ? list :\n    len(values)==1 ?\n      (\n        !all ?\n           (\n               let(firsthit = search(values,list,1)[0])\n               firsthit==[] ? list\n             : list[firsthit]==values[0] ? list_remove(list,firsthit)\n             : let(allhits = search(values,list,0)[0],\n                   allind = [for(i=allhits) if (list[i]==values[0]) i]\n               )\n               allind==[] ? list : list_remove(list,min(allind))\n           )\n        :\n           (\n             let(allhits = search(values,list,0)[0],\n                 allind = [for(i=allhits) if (list[i]==values[0]) i]\n             )\n             allind==[] ? list : list_remove(list,allind)\n           )\n     )\n    :!all ? list_remove_values(list_remove_values(list, values[0],all=all), list_tail(values),all=all)\n    :    \n    [\n      for(i=idx(list))\n        let(hit=search([list[i]],values,0)[0])\n          if (hit==[]) list[i]\n          else\n            let(check = [for(j=hit) if (values[j]==list[i]) 1])\n            if (check==[]) list[i]\n    ];\n\n\n\n// Section: List Iteration Index Helper\n\n// Function: idx()\n// Synopsis: Returns a range useful for iterating over a list.\n// Topics: List Handling, Iteration\n// See Also: count()\n// Usage:\n//   range = idx(list, [s=], [e=], [step=]);\n//   for(i=idx(list, [s=], [e=], [step=])) ...\n// Description:\n//   Returns the range that gives the indices for a given list.  This makes is a little bit\n//   easier to loop over a list by index, when you need the index numbers and looping of list values isn't enough.\n//   Note that the return is a **range** not a list.  \n// Arguments:\n//   list = The list to returns the index range of.\n//   ---\n//   s = The starting index.  Default: 0\n//   e = The delta from the end of the list.  Default: -1 (end of list)\n//   step = The step size to stride through the list.  Default: 1\n// Example(2D):\n//   colors = [\"red\", \"green\", \"blue\"];\n//   for (i=idx(colors)) right(20*i) color(colors[i]) circle(d=10);\nfunction idx(list, s=0, e=-1, step=1) =\n    assert(is_list(list)||is_string(list), \"Invalid input.\" )\n    let( ll = len(list) )\n    ll == 0 ? [0:1:ll-1] :\n    let(\n        _s = posmod(s,ll),\n        _e = posmod(e,ll)\n    ) [_s : step : _e];\n\n\n// Section: Lists of Subsets\n\n\n// Function: pair()\n// Synopsis: Returns a list of overlapping consecutive pairs in a list.\n// Topics: List Handling, Iteration\n// See Also: idx(), triplet(), combinations(), permutations()\n// Usage:\n//   p = pair(list, [wrap]);\n//   for (p = pair(list, [wrap])) ...  // On each iteration, p contains a list of two adjacent items.\n// Description:\n//   Returns a list of all of the pairs of adjacent items from a list, optionally wrapping back to the front.  The pairs overlap, and\n//   are returned in order starting with the first two entries in the list.  If the list has less than two elements, the empty list is returned. \n// Arguments:\n//   list = The list to use for making pairs\n//   wrap = If true, wrap back to the start from the end.  ie: return the last and first items as the last pair.  Default: false\n// Example(2D): Does NOT wrap from end to start,\n//   for (p = pair(circle(d=40, $fn=12)))\n//       stroke(p, endcap2=\"arrow2\");\n// Example(2D): Wraps around from end to start.\n//   for (p = pair(circle(d=40, $fn=12), wrap=true))\n//       stroke(p, endcap2=\"arrow2\");\n// Example:\n//   l = [\"A\",\"B\",\"C\",\"D\"];\n//   echo([for (p=pair(l)) str(p.y,p.x)]);  // Outputs: [\"BA\", \"CB\", \"DC\"]\nfunction pair(list, wrap=false) =\n    assert(is_list(list)||is_string(list), \"Invalid input.\" )\n    assert(is_bool(wrap))\n    let( L = len(list)-1)\n    L<1 ? [] :\n    [\n      for (i=[0:1:L-1]) [list[i], list[i+1]],\n      if(wrap) [list[L], list[0]]\n    ];\n\n\n\n// Function: triplet()\n// Synopsis: Returns a list of overlapping consecutive triplets in a list.\n// Topics: List Handling, Iteration\n// See Also: idx(), pair(), combinations(), permutations()\n// Usage:\n//   list = triplet(list, [wrap]);\n//   for (t = triplet(list, [wrap])) ...\n// Description:\n//   Returns a list of all adjacent triplets from a list, optionally wrapping back to the front.\n//   If you set `wrap` to true then the first triplet is the one centered on the first list element, so it includes\n//   the last element and the first two elements.  If the list has fewer than three elements then the empty list is returned.\n// Arguments:\n//   list = list to produce triplets from\n//   wrap = if true, wrap triplets around the list.  Default: false\n// Example:\n//   list = [0,1,2,3,4];\n//   a = triplet(list);               // Returns [[0,1,2],[1,2,3],[2,3,4]]\n//   b = triplet(list,wrap=true);     // Returns [[4,0,1],[0,1,2],[1,2,3],[2,3,4],[3,4,0]]\n//   letters = [\"A\",\"B\",\"C\",\"D\",\"E\"];\n//   [for (p=triplet(letters)) str(p.z,p.y,p.x)];     // Returns: [\"CBA\", \"DCB\", \"EDC\"]\n// Example(2D):\n//   path = [for (i=[0:24]) polar_to_xy(i*2, i*360/12)];\n//   for (t = triplet(path)) {\n//       a = t[0]; b = t[1]; c = t[2];\n//       v = unit(unit(a-b) + unit(c-b));\n//       translate(b) rot(from=FWD,to=v) anchor_arrow2d();\n//   }\n//   stroke(path);\nfunction triplet(list, wrap=false) =\n    assert(is_list(list)||is_string(list), \"Invalid input.\" )\n    assert(is_bool(wrap))\n    let(L=len(list))\n    L<3 ? [] :\n    [\n      if(wrap) [list[L-1], list[0], list[1]],\n      for (i=[0:1:L-3]) [list[i],list[i+1],list[i+2]],\n      if(wrap) [list[L-2], list[L-1], list[0]]\n    ];\n\n\n// Function: combinations()\n// Synopsis: Returns a list of all combinations of the list entries.\n// Topics: List Handling, Iteration\n// See Also: idx(), pair(), triplet(), permutations()\n// Usage:\n//   list = combinations(l, [n]);\n// Description:\n//   Returns a list of all of the (unordered) combinations of `n` items out of the given list `l`.\n//   For the list `[1,2,3,4]`, with `n=2`, this will return `[[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]`.\n//   For the list `[1,2,3,4]`, with `n=3`, this will return `[[1,2,3], [1,2,4], [1,3,4], [2,3,4]]`.\n// Arguments:\n//   l = The list to provide permutations for.\n//   n = The number of items in each combination. Default: 2\n// Example:\n//   pairs = combinations([3,4,5,6]);  // Returns: [[3,4],[3,5],[3,6],[4,5],[4,6],[5,6]]\n//   triplets = combinations([3,4,5,6],n=3);  // Returns: [[3,4,5],[3,4,6],[3,5,6],[4,5,6]]\n// Example(2D):\n//   for (p=combinations(regular_ngon(n=7,d=100))) stroke(p);\nfunction combinations(l,n=2,_s=0) =\n    assert(is_list(l), \"Invalid list.\" )\n    assert( is_finite(n) && n>=1 && n<=len(l), \"Invalid number `n`.\" )\n    n==1\n      ? [for (i=[_s:1:len(l)-1]) [l[i]]] \n      : [for (i=[_s:1:len(l)-n], p=combinations(l,n=n-1,_s=i+1)) concat([l[i]], p)];\n\n\n\n// Function: permutations()\n// Synopsis: Returns a list of all permutations of the list entries.\n// Topics: List Handling, Iteration\n// See Also: idx(), pair(), triplet(), combinations()\n// Usage:\n//   list = permutations(l, [n]);\n// Description:\n//   Returns a list of all of the (ordered) permutation `n` items out of the given list `l`.  \n//   For the list `[1,2,3]`, with `n=2`, this will return `[[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]`\n//   For the list `[1,2,3]`, with `n=3`, this will return `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`\n// Arguments:\n//   l = The list to provide permutations for.\n//   n = The number of items in each permutation. Default: 2\n// Example:\n//   pairs = permutations([3,4,5,6]);  // // Returns: [[3,4],[3,5],[3,6],[4,3],[4,5],[4,6],[5,3],[5,4],[5,6],[6,3],[6,4],[6,5]]\nfunction permutations(l,n=2) =\n    assert(is_list(l), \"Invalid list.\" )\n    assert( is_finite(n) && n>=1 && n<=len(l), \"Invalid number `n`.\" )\n    n==1\n      ? [for (i=[0:1:len(l)-1]) [l[i]]] \n      : [for (i=idx(l), p=permutations([for (j=idx(l)) if (i!=j) l[j]], n=n-1)) concat([l[i]], p)];\n\n\n\n// Section: Changing List Structure\n\n\n// Function: list_to_matrix()\n// Synopsis: Groups items in a list into sublists.\n// Topics: Matrices, List Handling\n// See Also: column(), submatrix(), hstack(), flatten(), full_flatten()\n// Usage:\n//   groups = list_to_matrix(v, cnt, [dflt]);\n// Description:\n//   Takes a flat list of values, and groups items in sets of `cnt` length.\n//   The opposite of this is `flatten()`.\n// Arguments:\n//   v = The list of items to group.\n//   cnt = The number of items to put in each grouping. \n//   dflt = The default value to fill in with if the list is not a multiple of `cnt` items long.  Default: undef\n// Example:\n//   v = [1,2,3,4,5,6];\n//   a = list_to_matrix(v,2)  // returns [[1,2], [3,4], [5,6]]\n//   b = list_to_matrix(v,3)  // returns [[1,2,3], [4,5,6]]\n//   c = list_to_matrix(v,4,0)  // returns [[1,2,3,4], [5,6,0,0]]\nfunction list_to_matrix(v, cnt, dflt=undef) =\n    [for (i = [0:cnt:len(v)-1]) [for (j = [0:1:cnt-1]) default(v[i+j], dflt)]];\n\n\n\n// Function: flatten()\n// Synopsis: Flattens a list of sublists into a single list.\n// Topics: Matrices, List Handling\n// See Also: column(), submatrix(), hstack(), full_flatten()\n// Usage:\n//   list = flatten(l);\n// Description:\n//   Takes a list of lists and flattens it by one level.\n// Arguments:\n//   l = List to flatten.\n// Example:\n//   l = flatten([[1,2,3], [4,5,[6,7,8]]]);  // returns [1,2,3,4,5,[6,7,8]]\nfunction flatten(l) =\n    !is_list(l)? l :\n    [for (a=l) if (is_list(a)) (each a) else a];\n\n\n// Function: full_flatten()\n// Synopsis: Recursively flattens nested sublists into a single list of non-list values.\n// Topics: Matrices, List Handling\n// See Also: column(), submatrix(), hstack(), flatten()\n// Usage:\n//   list = full_flatten(l);\n// Description: \n//   Collects in a list all elements recursively found in any level of the given list.\n//   The output list is ordered in depth first order.\n// Arguments:\n//   l = List to flatten.\n// Example:\n//   l = full_flatten([[1,2,3], [4,5,[6,7,8]]]);  // returns [1,2,3,4,5,6,7,8]\nfunction full_flatten(l) =\n    !is_list(l)? l :\n    [for (a=l) if (is_list(a)) (each full_flatten(a)) else a];\n\n\n\n// Section: Set Manipulation\n\n// Function: set_union()\n// Synopsis: Merges two lists, returning a list of unique items.\n// Topics: Set Handling, List Handling\n// See Also: set_difference(), set_intersection()\n// Usage:\n//   s = set_union(a, b, [get_indices]);\n// Description:\n//   Given two sets (lists with unique items), returns the set of unique items that are in either `a` or `b`.\n//   If `get_indices` is true, a list of indices into the new union set are returned for each item in `b`,\n//   in addition to returning the new union set.  In this case, a 2-item list is returned, `[INDICES, NEWSET]`,\n//   where INDICES is the list of indices for items in `b`, and NEWSET is the new union set.\n// Arguments:\n//   a = One of the two sets to merge.\n//   b = The other of the two sets to merge.\n//   get_indices = If true, indices into the new union set are also returned for each item in `b`.  Returns `[INDICES, NEWSET]`.  Default: false\n// Example:\n//   set_a = [2,3,5,7,11];\n//   set_b = [1,2,3,5,8];\n//   set_u = set_union(set_a, set_b);\n//   // set_u now equals [2,3,5,7,11,1,8]\n//   set_v = set_union(set_a, set_b, get_indices=true);\n//   // set_v now equals [[5,0,1,2,6], [2,3,5,7,11,1,8]]\nfunction set_union(a, b, get_indices=false) =\n    assert( is_list(a) && is_list(b), \"Invalid sets.\" )\n    let(\n        found1 = search(b, a),\n        found2 = search(b, b),\n        c = [ for (i=idx(b))\n                if (found1[i] == [] && found2[i] == i)\n                    b[i] \n            ],\n        nset = concat(a, c)\n    ) \n    ! get_indices ? nset :\n    let(\n        la = len(a),\n        found3 = search(b, c),\n        idxs =  [ for (i=idx(b))\n                    (found1[i] != [])? found1[i] : la + found3[i]\n                ]\n    ) [idxs, nset];\n\n\n// Function: set_difference()\n// Synopsis: Returns a list of unique items that are in list A, but not in list B.\n// Topics: Set Handling, List Handling\n// See Also: set_union(), set_intersection()\n// Usage:\n//   s = set_difference(a, b);\n// Description:\n//   Given two sets (lists with unique items), returns the set of items that are in `a`, but not `b`.\n// Arguments:\n//   a = The starting set.\n//   b = The set of items to remove from set `a`.\n// Example:\n//   set_a = [2,3,5,7,11];\n//   set_b = [1,2,3,5,8];\n//   set_d = set_difference(set_a, set_b);\n//   // set_d now equals [7,11]\nfunction set_difference(a, b) =\n    assert( is_list(a) && is_list(b), \"Invalid sets.\" )\n    let( found = search(a, b, num_returns_per_match=1) )\n    [ for (i=idx(a)) if(found[i]==[]) a[i] ];\n\n\n// Function: set_intersection()\n// Synopsis: Returns a list of unique items that are in both given lists.\n// Topics: Set Handling, List Handling\n// See Also: set_union(), set_difference()\n// Usage:\n//   s = set_intersection(a, b);\n// Description:\n//   Given two sets (lists with unique items), returns the set of items that are in both sets.\n// Arguments:\n//   a = The starting set.\n//   b = The set of items to intersect with set `a`.\n// Example:\n//   set_a = [2,3,5,7,11];\n//   set_b = [1,2,3,5,8];\n//   set_i = set_intersection(set_a, set_b);\n//   // set_i now equals [2,3,5]\nfunction set_intersection(a, b) =\n    assert( is_list(a) && is_list(b), \"Invalid sets.\" )\n    let( found = search(a, b, num_returns_per_match=1) )\n    [ for (i=idx(a)) if(found[i]!=[]) a[i] ];\n\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-22", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: masks2d.scad\n//   This file provides 2D masking shapes that you can use with {{edge_profile()}} to mask edges.\n//   The shapes include the simple roundover and chamfer as well as more elaborate shapes\n//   like the cove and ogee found in furniture and architecture.  You can make the masks\n//   as geometry or as 2D paths.\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: 2D masking shapes for edge profiling: including roundover, cove, teardrop, ogee.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: 2D Masking Shapes\n\n// Function&Module: mask2d_roundover()\n// Synopsis: Creates a 2D beading mask shape useful for rounding edges.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)\n// See Also: corner_profile(), edge_profile(), face_profile(), fillet()\n// Usage: As module\n//   mask2d_roundover(r|d=|h=|cut=|joint=, [inset], [mask_angle], [excess], [flat_top=]) [ATTACHMENTS];\n// Usage: As function\n//   path = mask2d_roundover(r|d=|h=|cut=|joint=, [inset], [mask_angle], [excess], [flat_top=]);\n// Description:\n//   Creates a 2D roundover/bead mask shape that is useful for extruding into a 3D mask for an edge.\n//   Conversely, you can use that same extruded shape to make an interior fillet between two walls.\n//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.\n//   If called as a function, this just returns a 2D path of the outline of the mask shape.\n//   The roundover can be specified by radius, diameter, height, cut, or joint length.\n//   ![Types of Roundovers](images/rounding/section-types-of-roundovers_fig1.png)\n// Arguments:\n//   r = Radius of the roundover.\n//   inset = Optional bead inset size.  Default: 0\n//   mask_angle = Number of degrees in the corner angle to mask.  Default: 90\n//   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape.  Default: 0.01\n//   ---\n//   d = Diameter of the roundover.\n//   h = Mask height.  Given instead of r or d when you want a consistent mask height, no matter what the mask angle.\n//   cut = Cut distance.  IE: How much of the corner to cut off.  See [Types of Roundovers](rounding.scad#section-types-of-roundovers).\n//   joint = Joint distance.  IE: How far from the edge the roundover should start.  See [Types of Roundovers](rounding.scad#section-types-of-roundovers).\n//   flat_top = If true, the top inset of the mask will be horizontal instead of angled by the mask_angle.  Default: true.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Side Effects:\n//  Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n//\n// Example(2D): 2D Roundover Mask by Radius\n//   mask2d_roundover(r=10);\n// Example(2D): 2D Bead Mask\n//   mask2d_roundover(r=10,inset=2);\n// Example(2D): 2D Bead Mask by Height\n//   mask2d_roundover(h=10,inset=2);\n// Example(2D): 2D Bead Mask for a Non-Right Edge.\n//   mask2d_roundover(r=10, inset=2, mask_angle=75);\n// Example(2D): Disabling flat_top=\n//   mask2d_roundover(r=10, inset=2, flat_top=false, mask_angle=75);\n// Example(2D): 2D Angled Bead Mask by Joint Length\n//   mask2d_roundover(joint=10, inset=2, mask_angle=75);\n// Example(2D): Increasing the Excess\n//   mask2d_roundover(r=10, inset=2, mask_angle=75, excess=2);\n// Example: Masking by Edge Attachment\n//   diff()\n//   cube([50,60,70],center=true)\n//       edge_profile([TOP,\"Z\"],except=[BACK,TOP+LEFT])\n//           mask2d_roundover(h=12, inset=2);\n// Example: Making an interior fillet\n//   %render() difference() {\n//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);\n//       cube(310, anchor=BOT+LEFT);\n//   }\n//   xrot(90)\n//       linear_extrude(height=30, center=true)\n//           mask2d_roundover(r=10);\nmodule mask2d_roundover(r, inset=0, mask_angle=90, excess=0.01, flat_top=true, d, h, cut, joint, anchor=CENTER,spin=0) {\n    path = mask2d_roundover(r=r, d=d, h=h, cut=cut, joint=joint, inset=inset, flat_top=flat_top, mask_angle=mask_angle, excess=excess);\n    default_tag(\"remove\") {\n        attachable(anchor,spin, two_d=true, path=path) {\n            polygon(path);\n            children();\n        }\n    }\n}\n\nfunction mask2d_roundover(r, inset=0, mask_angle=90, excess=0.01, flat_top=true, d, h, cut, joint, anchor=CENTER, spin=0) =\n    assert(one_defined([r,d,h,cut,joint],\"r,d,h,cut,joint\"))\n    assert(is_undef(r) || is_finite(r))\n    assert(is_undef(d) || is_finite(d))\n    assert(is_undef(h) || is_finite(h))\n    assert(is_undef(cut) || is_finite(cut))\n    assert(is_undef(joint) || is_finite(joint))\n    assert(is_finite(excess))\n    assert(is_finite(mask_angle) && mask_angle>0 && mask_angle<180)\n    assert(is_finite(inset)||(is_vector(inset)&&len(inset)==2))\n    assert(is_bool(flat_top))\n    let(\n        inset = is_list(inset)? inset : [inset,inset],\n        r = is_finite(joint)? adj_ang_to_opp(joint, mask_angle/2) :\n            is_finite(h)? (\n                mask_angle==90? h-inset.y :\n                mask_angle < 90 ? adj_ang_to_opp(opp_ang_to_hyp(h-inset.y,mask_angle), mask_angle/2) :\n                adj_ang_to_opp(adj_ang_to_hyp(h-inset.y,mask_angle-90), mask_angle/2)\n            ) :\n            is_finite(cut)\n              ? let(\n                    o = adj_ang_to_opp(cut, mask_angle/2),\n                    h = adj_ang_to_hyp(cut, mask_angle/2)\n                ) adj_ang_to_opp(o+h, mask_angle/2)\n              : get_radius(r=r,d=d,dflt=undef),\n        pts = _inset_isect(inset,mask_angle,flat_top,excess,-r),\n        arcpts = arc(r=r, corner=[pts[4],pts[5],pts[0]]),\n        path = [\n            each select(pts, 1, 3),\n            each arcpts,\n        ]\n    ) reorient(anchor,spin, two_d=true, path=path, extent=false, p=path);\n\n\nfunction _inset_isect(inset,mask_angle,flat_top,excess,r,size) =\n    assert(one_defined([size,r],\"size,r\"))\n    let(\n        lft_n = polar_to_xy(1, mask_angle-90),\n        rgt_n = [1,0],\n        top_n = flat_top? [1,0] : lft_n,\n        bot_n = [0,1],\n\n        line_lft = [[0,0], polar_to_xy(100, mask_angle)],\n        line_bot = [[0,0], [100,0]],\n        ex_line_lft = move(-excess*lft_n, p=line_lft),\n        ex_line_bot = move(-excess*bot_n, p=line_bot),\n        in_line_lft = move(inset.x*top_n, p=line_lft),\n        in_line_bot = move(inset.y*bot_n, p=line_bot),\n\n        ex_pt = line_intersection(ex_line_lft, ex_line_bot),\n        in_pt = line_intersection(in_line_lft, in_line_bot),\n\n        pos_r = r==undef || r >= 0,\n        r = r==undef? undef : abs(r),\n        x = is_undef(size)? r : size.x,\n        y = is_undef(size)? r : size.y,\n        base_pt = !flat_top && is_num(r)? in_pt :\n            in_pt + [y*cos(mask_angle)/sin(mask_angle), 0],\n        line_top = !flat_top && is_num(r)\n          ? let( pt = in_pt + polar_to_xy(r/(pos_r?1:tan(mask_angle/2)), mask_angle) )\n            [pt, pt - top_n]\n          : [base_pt + [0,y], base_pt + [0,y] - top_n],\n        line_rgt = !flat_top && is_num(r)\n          ? pos_r\n            ? [in_pt + [r,0], in_pt + [r,1]]\n            : [in_pt + [r/tan(mask_angle/2),0], in_pt + [r/tan(mask_angle/2),1]]\n          : [base_pt + [x,0], base_pt + [x,1]],\n        top_pt = line_intersection(ex_line_lft, line_top),\n\n        path = is_vector(size)? [\n            // All size based\n            base_pt + [size.x,0],\n            [base_pt.x + size.x, -excess],\n            ex_pt,\n            top_pt,\n            base_pt + [0,size.y],\n            base_pt,\n            base_pt + size,\n        ] : flat_top? [\n            // flat_top radius\n            base_pt + [r,0],\n            [base_pt.x + r, -excess],\n            ex_pt,\n            top_pt,\n            base_pt + [0,r],\n            base_pt,\n            base_pt + [r,r],\n        ] : let(\n            cp_pt = line_intersection(line_rgt, line_top)\n        ) pos_r? [\n            // non-flat_top radius from inside\n            in_pt + [r,0],\n            [in_pt.x + r, -excess],\n            ex_pt,\n            top_pt,\n            in_pt + polar_to_xy(r,mask_angle),\n            in_pt,\n            cp_pt,\n        ] : [\n            // non-flat_top radius from outside\n            line_rgt[0],\n            [cp_pt.x, -excess],\n            ex_pt,\n            top_pt,\n            in_pt + polar_to_xy(r/tan(mask_angle/2),mask_angle),\n            in_pt,\n            cp_pt,\n        ]\n    ) path;\n\n\n\n// Function&Module: mask2d_cove()\n// Synopsis: Creates a 2D cove (quarter-round) mask shape.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)\n// See Also: corner_profile(), edge_profile(), face_profile()\n// Usage: As module\n//   mask2d_cove(r|d=|h=, [inset], [mask_angle], [excess], [flat_top=]) [ATTACHMENTS];\n// Usage: As function\n//   path = mask2d_cove(r|d=|h=, [inset], [mask_angle], [excess], [flat_top=]);\n// Description:\n//   Creates a 2D cove mask shape that is useful for extruding into a 3D mask for an edge.\n//   Conversely, you can use that same extruded shape to make an interior rounded shelf decoration between two walls.\n//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.\n//   If called as a function, this just returns a 2D path of the outline of the mask shape.\n// Arguments:\n//   r = Radius of the cove.\n//   inset = Optional amount to inset code from corner.  Default: 0\n//   mask_angle = Number of degrees in the corner angle to mask.  Default: 90\n//   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape.  Default: 0.01\n//   ---\n//   d = Diameter of the cove.\n//   h = Mask height.  Given instead of r or d when you want a consistent mask height, no matter what the mask angle.\n//   flat_top = If true, the top inset of the mask will be horizontal instead of angled by the mask_angle.  Default: true.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Side Effects:\n//  Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example(2D): 2D Cove Mask by Radius\n//   mask2d_cove(r=10);\n// Example(2D): 2D Inset Cove Mask\n//   mask2d_cove(r=10,inset=3);\n// Example(2D): 2D Inset Cove Mask by Height\n//   mask2d_cove(h=10,inset=2);\n// Example(2D): 2D Inset Cove Mask for a Non-Right Edge\n//   mask2d_cove(r=10,inset=3,mask_angle=75);\n// Example(2D): Disabling flat_top=\n//   mask2d_cove(r=10, inset=3, flat_top=false, mask_angle=75);\n// Example(2D): Increasing the Excess\n//   mask2d_cove(r=10,inset=3,mask_angle=75, excess=2);\n// Example: Masking by Edge Attachment\n//   diff()\n//   cube([50,60,70],center=true)\n//       edge_profile([TOP,\"Z\"],except=[BACK,TOP+LEFT])\n//           mask2d_cove(h=10, inset=3);\n// Example: Making an interior rounded shelf\n//   %render() difference() {\n//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);\n//       cube(310, anchor=BOT+LEFT);\n//   }\n//   xrot(90)\n//       linear_extrude(height=30, center=true)\n//           mask2d_cove(r=5, inset=5);\nmodule mask2d_cove(r, inset=0, mask_angle=90, excess=0.01, flat_top=true, d, h, anchor=CENTER, spin=0) {\n    path = mask2d_cove(r=r, d=d, h=h, flat_top=flat_top, inset=inset, mask_angle=mask_angle, excess=excess);\n    default_tag(\"remove\") {\n        attachable(anchor,spin, two_d=true, path=path) {\n            polygon(path);\n            children();\n        }\n    }\n}\n\nfunction mask2d_cove(r, inset=0, mask_angle=90, excess=0.01, flat_top=true, d, h, anchor=CENTER, spin=0) =\n    assert(one_defined([r,d,h],\"r,d,h\"))\n    assert(is_undef(r) || is_finite(r))\n    assert(is_undef(d) || is_finite(d))\n    assert(is_undef(h) || is_finite(h))\n    assert(is_finite(mask_angle) && mask_angle>0 && mask_angle<180)\n    assert(is_finite(excess))\n    assert(is_finite(inset)||(is_vector(inset)&&len(inset)==2))\n    assert(is_bool(flat_top))\n    let(\n        inset = is_list(inset)? inset : [inset,inset],\n        r = is_finite(h)? (\n                mask_angle==90? h-inset.y :\n                mask_angle < 90 ? adj_ang_to_opp(opp_ang_to_hyp(h-inset.y,mask_angle), mask_angle/2) :\n                adj_ang_to_opp(adj_ang_to_hyp(h-inset.y,mask_angle-90), mask_angle/2)\n            ) : get_radius(r=r,d=d,dflt=undef),\n        pts = _inset_isect(inset,mask_angle,flat_top,excess,r),\n        arcpts = arc(r=r, corner=[pts[4],pts[6],pts[0]]),\n        ipath = [\n            each select(pts, 1, 3),\n            each arcpts,\n        ],\n        path = deduplicate(ipath)\n    ) reorient(anchor,spin, two_d=true, path=path, p=path);\n\n\n// Function&Module: mask2d_chamfer()\n// Synopsis: Produces a 2D chamfer mask shape.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)\n// See Also: corner_profile(), edge_profile(), face_profile()\n// Usage: As Module\n//   mask2d_chamfer(edge, [angle], [inset], [excess]) [ATTACHMENTS];\n//   mask2d_chamfer(y=, [angle=], [inset=], [excess=]) [ATTACHMENTS];\n//   mask2d_chamfer(x=, [angle=], [inset=], [excess=]) [ATTACHMENTS];\n// Usage: As Function\n//   path = mask2d_chamfer(edge, [angle], [inset], [excess]);\n//   path = mask2d_chamfer(y=, [angle=], [inset=], [excess=]);\n//   path = mask2d_chamfer(x=, [angle=], [inset=], [excess=]);\n// Description:\n//   Creates a 2D chamfer mask shape that is useful for extruding into a 3D mask for a 90\u00b0 edge.\n//   Conversely, you can use that same extruded shape to make an interior chamfer between two walls at a 90\u00ba angle.\n//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.\n//   If called as a function, this just returns a 2D path of the outline of the mask shape.\n//   The edge parameter specifies the length of the chamfer's slanted edge.  Alternatively you can give x or y to\n//   specify the width or height.  Only one of x, y, or width is permitted.  \n// Arguments:\n//   edge = The length of the edge of the chamfer.\n//   angle = The angle of the chamfer edge, away from vertical.  Default: 45.\n//   inset = Optional amount to inset code from corner.  Default: 0\n//   mask_angle = Number of degrees in the corner angle to mask.  Default: 90\n//   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape.  Default: 0.01\n//   ---\n//   x = The width of the chamfer.\n//   y = The height of the chamfer.\n//   flat_top = If true, the top inset of the mask will be horizontal instead of angled by the mask_angle.  Default: true.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Side Effects:\n//  Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example(2D): 2D Chamfer Mask\n//   mask2d_chamfer(x=10);\n// Example(2D): 2D Chamfer Mask by Width.\n//   mask2d_chamfer(x=10, angle=30);\n// Example(2D): 2D Chamfer Mask by Height.\n//   mask2d_chamfer(y=10, angle=30);\n// Example(2D): 2D Inset Chamfer Mask\n//   mask2d_chamfer(x=10, inset=2);\n// Example: Masking by Edge Attachment\n//   diff()\n//   cube([50,60,70],center=true)\n//       edge_profile([TOP,\"Z\"],except=[BACK,TOP+LEFT])\n//           mask2d_chamfer(x=10, inset=2);\n// Example: Making an interior chamfer\n//   %render() difference() {\n//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);\n//       cube(310, anchor=BOT+LEFT);\n//   }\n//   xrot(90)\n//       linear_extrude(height=30, center=true)\n//           mask2d_chamfer(edge=10);\nmodule mask2d_chamfer(edge, angle=45, inset=0, excess=0.01, mask_angle=90, flat_top=true, x, y, anchor=CENTER,spin=0) {\n    path = mask2d_chamfer(x=x, y=y, edge=edge, angle=angle, excess=excess, inset=inset, mask_angle=mask_angle, flat_top=flat_top);\n    default_tag(\"remove\") {\n        attachable(anchor,spin, two_d=true, path=path, extent=true) {\n            polygon(path);\n            children();\n        }\n    }\n}\n\nfunction mask2d_chamfer(edge, angle=45, inset=0, excess=0.01, mask_angle=90, flat_top=true, x, y, anchor=CENTER,spin=0) =\n    let(dummy=one_defined([x,y,edge],[\"x\",\"y\",\"edge\"]))\n    assert(is_finite(angle))\n    assert(is_finite(excess))\n    assert(is_finite(mask_angle) && mask_angle>0 && mask_angle<180)\n    assert(is_finite(inset)||(is_vector(inset)&&len(inset)==2))\n    let(\n        inset = is_list(inset)? inset : [inset,inset],\n        x = is_def(x)? x :\n            is_def(y)? adj_ang_to_opp(adj=y,ang=angle) :\n            hyp_ang_to_opp(hyp=edge,ang=angle),\n        y = opp_ang_to_adj(opp=x,ang=angle),\n        pts = _inset_isect(inset,mask_angle,flat_top,excess,size=[x,y]),\n        path = [\n            each select(pts, 1, 4),\n            pts[0],\n        ]\n    ) reorient(anchor,spin, two_d=true, path=path, extent=true, p=path);\n\n\n// Function&Module: mask2d_rabbet()\n// Synopsis: Creates a rabbet mask shape.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)\n// See Also: corner_profile(), edge_profile(), face_profile()\n// Usage: As Module\n//   mask2d_rabbet(size, [mask_angle], [excess], [flat_top=]) [ATTACHMENTS];\n// Usage: As Function\n//   path = mask2d_rabbet(size, [mask_angle], [excess], [flat_top=]);\n// Description:\n//   Creates a 2D rabbet mask shape that is useful for extruding into a 3D mask for an edge.\n//   Conversely, you can use that same extruded shape to make an interior shelf decoration between two walls.\n//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.\n//   If called as a function, this just returns a 2D path of the outline of the mask shape.\n// Arguments:\n//   size = The size of the rabbet, either as a scalar or an [X,Y] list.\n//   inset = Optional bead inset size.  Default: 0\n//   mask_angle = Number of degrees in the corner angle to mask.  Default: 90\n//   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape. Default: 0.01\n//   ---\n//   flat_top = If true, the top inset of the mask will be horizontal instead of angled by the mask_angle.  Default: true.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Side Effects:\n//  Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example(2D): 2D Rabbet Mask\n//   mask2d_rabbet(size=10);\n// Example(2D): 2D Asymmetrical Rabbet Mask\n//   mask2d_rabbet(size=[5,10]);\n// Example(2D): 2D Mask for a Non-Right Edge\n//   mask2d_rabbet(size=10, mask_angle=75);\n// Example(2D): Disabling flat_top=\n//   mask2d_rabbet(size=10, flat_top=false, mask_angle=75);\n// Example: Masking by Edge Attachment\n//   diff()\n//   cube([50,60,70],center=true)\n//       edge_profile([TOP,\"Z\"],except=[BACK,TOP+LEFT])\n//           mask2d_rabbet(size=10);\n// Example: Making an interior shelf\n//   %render() difference() {\n//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);\n//       cube(310, anchor=BOT+LEFT);\n//   }\n//   xrot(90)\n//       linear_extrude(height=30, center=true)\n//           mask2d_rabbet(size=[5,10]);\nmodule mask2d_rabbet(size, inset=[0,0], mask_angle=90, excess=0.01, flat_top=true, anchor=CTR, spin=0) {\n    path = mask2d_rabbet(size=size, inset=inset, mask_angle=mask_angle, excess=excess, flat_top=flat_top);\n    default_tag(\"remove\") {\n        attachable(anchor,spin, two_d=true, path=path, extent=false) {\n            polygon(path);\n            children();\n        }\n    }\n}\n\nfunction mask2d_rabbet(size, inset=[0,0], mask_angle=90, excess=0.01, flat_top=true, anchor=CTR, spin=0) =\n    assert(is_finite(size)||(is_vector(size)&&len(size)==2))\n    assert(is_finite(mask_angle) && mask_angle>0 && mask_angle<180)\n    assert(is_finite(excess))\n    assert(is_bool(flat_top))\n    let(\n        size = is_list(size)? size : [size,size],\n        pts = _inset_isect(inset,mask_angle,flat_top,excess,size=size),\n        path = [\n            each select(pts, 1, 4),\n            pts[6],\n            pts[0],\n        ]\n    ) reorient(anchor,spin, two_d=true, path=path, extent=false, p=path);\n\n\n// Function&Module: mask2d_dovetail()\n// Synopsis: Creates a 2D dovetail mask shape.\n// SynTags: Geom, Path\n// Topics: Masks (2D), Shapes (2D), Paths (2D), Path Generators, Attachable \n// See Also: corner_profile(), edge_profile(), face_profile()\n// Usage: As Module\n//   mask2d_dovetail(edge, [angle], [inset], [shelf], [excess], ...) [ATTACHMENTS];\n//   mask2d_dovetail(x=, [angle=], [inset=], [shelf=], [excess=], ...) [ATTACHMENTS];\n//   mask2d_dovetail(y=, [angle=], [inset=], [shelf=], [excess=], ...) [ATTACHMENTS];\n// Usage: As Function\n//   path = mask2d_dovetail(edge, [angle], [inset], [shelf], [excess]);\n// Description:\n//   Creates a 2D dovetail mask shape that is useful for extruding into a 3D mask for a 90\u00b0 edge.\n//   Conversely, you can use that same extruded shape to make an interior dovetail between two walls at a 90\u00ba angle.\n//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.\n//   If called as a function, this just returns a 2D path of the outline of the mask shape.\n// Arguments:\n//   edge = The length of the edge of the dovetail.\n//   angle = The angle of the chamfer edge, away from vertical.  Default: 30.\n//   shelf = The extra height to add to the inside corner of the dovetail.  Default: 0\n//   inset = Optional amount to inset code from corner.  Default: 0\n//   mask_angle = Number of degrees in the corner angle to mask.  Default: 90\n//   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape.  Default: 0.01\n//   ---\n//   x = The width of the dovetail.\n//   y = The height of the dovetail.\n//   flat_top = If true, the top inset of the mask will be horizontal instead of angled by the mask_angle.  Default: true.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Side Effects:\n//  Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example(2D): 2D Dovetail Mask\n//   mask2d_dovetail(x=10);\n// Example(2D): 2D Dovetail Mask by Width.\n//   mask2d_dovetail(x=10, angle=30);\n// Example(2D): 2D Dovetail Mask by Height.\n//   mask2d_dovetail(y=10, angle=30);\n// Example(2D): 2D Inset Dovetail Mask\n//   mask2d_dovetail(x=10, inset=2);\n// Example: Masking by Edge Attachment\n//   diff()\n//   cube([50,60,70],center=true)\n//       edge_profile([TOP,\"Z\"],except=[BACK,TOP+LEFT])\n//           mask2d_dovetail(x=10, inset=2);\n// Example: Making an interior dovetail\n//   %render() difference() {\n//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);\n//       cube(310, anchor=BOT+LEFT);\n//   }\n//   xrot(90)\n//       linear_extrude(height=30, center=true)\n//           mask2d_dovetail(x=10);\nmodule mask2d_dovetail(edge, angle=30, shelf=0, inset=0, mask_angle=90, excess=0.01, flat_top=true, x, y, anchor=CENTER, spin=0) {\n    path = mask2d_dovetail(x=x, y=y, edge=edge, angle=angle, inset=inset, shelf=shelf, excess=excess, flat_top=flat_top, mask_angle=mask_angle);\n    default_tag(\"remove\") {\n        attachable(anchor,spin, two_d=true, path=path) {\n            polygon(path);\n            children();\n        }\n    }\n}\n\nfunction mask2d_dovetail(edge, angle=30, shelf=0, inset=0, mask_angle=90, excess=0.01, flat_top=true, x, y, anchor=CENTER, spin=0) =\n    assert(num_defined([x,y,edge])==1)\n    assert(is_finite(first_defined([x,y,edge])))\n    assert(is_finite(angle))\n    assert(is_finite(excess))\n    assert(is_finite(inset)||(is_vector(inset)&&len(inset)==2))\n    let(\n        inset = is_list(inset)? inset : [inset,inset],\n        x = !is_undef(x)? x :\n            !is_undef(y)? adj_ang_to_opp(adj=y,ang=angle) :\n            hyp_ang_to_opp(hyp=edge,ang=angle),\n        y = opp_ang_to_adj(opp=x,ang=angle),\n        pts = _inset_isect(inset,mask_angle,flat_top,excess,size=[x,y+shelf]),\n        path = [\n            [max(0,pts[5].x),-excess],\n            each select(pts, 2, 4),\n            pts[6],\n            pts[6]-[0,shelf],\n            pts[5],\n        ]\n    ) reorient(anchor,spin, two_d=true, path=path, p=path);\n\n\n// Function&Module: mask2d_teardrop()\n// Synopsis: Creates a 2D teardrop mask shape with a controllable maximum angle from vertical.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D), FDM Optimized\n// See Also: corner_profile(), edge_profile(), face_profile()\n// Usage: As Module\n//   mask2d_teardrop(r|d=, [angle], [mask_angle], [excess]) [ATTACHMENTS];\n// Usage: As Function\n//   path = mask2d_teardrop(r|d=, [angle], [mask_angle], [excess]);\n// Description:\n//   Creates a 2D teardrop mask shape that is useful for extruding into a 3D mask for an edge.\n//   Conversely, you can use that same extruded shape to make an interior teardrop fillet between two walls.\n//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.\n//   If called as a function, this just returns a 2D path of the outline of the mask shape.\n//   This is particularly useful to make partially rounded bottoms, that don't need support to print.\n//   The roundover can be specified by radius, diameter, height, cut, or joint length.\n//   ![Types of Roundovers](images/rounding/section-types-of-roundovers_fig1.png)\n// Arguments:\n//   r = Radius of the rounding.\n//   angle = The maximum angle from vertical.\n//   inset = Optional bead inset size.  Default: 0\n//   mask_angle = Number of degrees in the corner angle to mask.  Default: 90\n//   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape. Default: 0.01\n//   ---\n//   d = Diameter of the rounding.\n//   h = Mask height.  Given instead of r or d when you want a consistent mask height, no matter what the mask angle.\n//   cut = Cut distance.  IE: How much of the corner to cut off.  See [Types of Roundovers](rounding.scad#section-types-of-roundovers).\n//   joint = Joint distance.  IE: How far from the edge the roundover should start.  See [Types of Roundovers](rounding.scad#section-types-of-roundovers).\n//   flat_top = If true, the top inset of the mask will be horizontal instead of angled by the mask_angle.  Default: true.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Side Effects:\n//  Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example(2D): 2D Teardrop Mask\n//   mask2d_teardrop(r=10);\n// Example(2D): 2D Teardrop Mask for a Non-Right Edge\n//   mask2d_teardrop(r=10, mask_angle=75);\n// Example(2D): Increasing Excess\n//   mask2d_teardrop(r=10, mask_angle=75, excess=2);\n// Example(2D): Using a Custom Angle\n//   mask2d_teardrop(r=10,angle=30);\n// Example: Masking by Edge Attachment\n//   diff()\n//   cube([50,60,70],center=true)\n//       edge_profile(BOT)\n//           mask2d_teardrop(r=10, angle=40);\n// Example: Making an interior teardrop fillet\n//   %render() difference() {\n//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);\n//       cube(310, anchor=BOT+LEFT);\n//   }\n//   xrot(90)\n//       linear_extrude(height=30, center=true)\n//           mask2d_teardrop(r=10);\nfunction mask2d_teardrop(r, angle=45, inset=[0,0], mask_angle=90, excess=0.01, flat_top=true, d, h, cut, joint, anchor=CENTER, spin=0) =  \n    assert(one_defined([r,d,h,cut,joint],\"r,d,h,cut,joint\"))\n    assert(is_undef(r) || is_finite(r))\n    assert(is_undef(d) || is_finite(d))\n    assert(is_undef(h) || is_finite(h))\n    assert(is_undef(cut) || is_finite(cut))\n    assert(is_undef(joint) || is_finite(joint))\n    assert(is_finite(angle))\n    assert(angle>0 && angle<90)\n    assert(is_finite(mask_angle) && mask_angle>0 && mask_angle<180)\n    assert(is_finite(excess))\n    let(\n        r = is_finite(joint)? adj_ang_to_opp(joint, mask_angle/2) :\n            is_finite(h)? (\n                mask_angle==90? h :\n                mask_angle < 90 ? adj_ang_to_opp(opp_ang_to_hyp(h,mask_angle), mask_angle/2) :\n                adj_ang_to_opp(adj_ang_to_hyp(h,mask_angle-90), mask_angle/2)\n            ) :\n            is_finite(cut)\n              ? let(\n                    o = adj_ang_to_opp(cut, mask_angle/2),\n                    h = adj_ang_to_hyp(cut, mask_angle/2)\n                ) adj_ang_to_opp(o+h, mask_angle/2)\n              : get_radius(r=r,d=d,dflt=undef),\n        pts = _inset_isect(inset,mask_angle,flat_top,excess,-r),\n        arcpts = arc(r=r, corner=[pts[4],pts[5],pts[0]]),\n        arcpts2 = [\n            for (i = idx(arcpts))\n            if(i==0 || v_theta(arcpts[i]-arcpts[i-1]) <= angle-90)\n            arcpts[i]\n        ],\n        line1 = [last(arcpts2), last(arcpts2) + polar_to_xy(1, angle-90)],\n        line2 = [[0,inset.y], [100,inset.y]],\n        ipt = line_intersection(line1,line2),\n        path = [\n            [ipt.x, -excess],\n            each select(pts, 2, 3),\n            each arcpts2,\n            ipt,\n        ]\n    ) reorient(anchor,spin, two_d=true, path=path, p=path);\n\nmodule mask2d_teardrop(r, angle=45, mask_angle=90, excess=0.01, flat_top=true, d, h, cut, joint, anchor=CENTER, spin=0) {\n    path = mask2d_teardrop(r=r, d=d, h=h, cut=cut, joint=joint, angle=angle, mask_angle=mask_angle, excess=excess);\n    default_tag(\"remove\") {\n        attachable(anchor,spin, two_d=true, path=path) {\n            polygon(path);\n            children();\n        }\n    }\n}\n\n\n// Function&Module: mask2d_ogee()\n// Synopsis: Creates a 2D ogee mask shape.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable, Masks (2D)\n// See Also: corner_profile(), edge_profile(), face_profile()\n// Usage: As Module\n//   mask2d_ogee(pattern, [excess], ...) [ATTAHCMENTS];\n// Usage: As Function\n//   path = mask2d_ogee(pattern, [excess], ...);\n//\n// Description:\n//   Creates a 2D Ogee mask shape that is useful for extruding into a 3D mask for a 90\u00b0 edge.\n//   Conversely, you can use that same extruded shape to make an interior ogee decoration between two walls at a 90\u00ba angle.\n//   As a 2D mask, this is designed to be differenced away from the edge of a shape that is in the first (X+Y+) quadrant.\n//   Since there are a number of shapes that fall under the name ogee, the shape of this mask is given as a pattern.\n//   Patterns are given as TYPE, VALUE pairs.  ie: `[\"fillet\",10, \"xstep\",2, \"step\",[5,5], ...]`.  See Patterns below.\n//   If called as a function, this just returns a 2D path of the outline of the mask shape.\n//   .\n//   ### Patterns\n//   .\n//   Type     | Argument  | Description\n//   -------- | --------- | ----------------\n//   \"step\"   | [x,y]     | Makes a line to a point `x` right and `y` down.\n//   \"xstep\"  | dist      | Makes a `dist` length line towards X+.\n//   \"ystep\"  | dist      | Makes a `dist` length line towards Y-.\n//   \"round\"  | radius    | Makes an arc that will mask a roundover.\n//   \"fillet\" | radius    | Makes an arc that will mask a fillet.\n//\n// Arguments:\n//   pattern = A list of pattern pieces to describe the Ogee.\n//   excess = Extra amount of mask shape to creates on the X- and Y- sides of the shape. Default: 0.01\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//\n// Side Effects:\n//  Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n//\n// Example(2D): 2D Ogee Mask\n//   mask2d_ogee([\n//       \"xstep\",1,  \"ystep\",1,  // Starting shoulder.\n//       \"fillet\",5, \"round\",5,  // S-curve.\n//       \"ystep\",1,  \"xstep\",1   // Ending shoulder.\n//   ]);\n// Example: Masking by Edge Attachment\n//   diff()\n//   cube([50,60,70],center=true)\n//       edge_profile(TOP)\n//           mask2d_ogee([\n//               \"xstep\",1,  \"ystep\",1,  // Starting shoulder.\n//               \"fillet\",5, \"round\",5,  // S-curve.\n//               \"ystep\",1,  \"xstep\",1   // Ending shoulder.\n//           ]);\n// Example: Making an interior ogee\n//   %render() difference() {\n//       move(-[5,0,5]) cube(30, anchor=BOT+LEFT);\n//       cube(310, anchor=BOT+LEFT);\n//   }\n//   xrot(90)\n//       linear_extrude(height=30, center=true)\n//           mask2d_ogee([\n//               \"xstep\", 1, \"round\",5,\n//               \"ystep\",1, \"fillet\",5,\n//               \"xstep\", 1, \"ystep\", 1,\n//           ]);\nmodule mask2d_ogee(pattern, excess=0.01, anchor=CENTER,spin=0) {\n    path = mask2d_ogee(pattern, excess=excess);\n    default_tag(\"remove\") {\n        attachable(anchor,spin, two_d=true, path=path) {\n            polygon(path);\n            children();\n        }\n    }\n}\n\nfunction mask2d_ogee(pattern, excess=0.01, anchor=CENTER, spin=0) =\n    assert(is_list(pattern))\n    assert(len(pattern)>0)\n    assert(len(pattern)%2==0,\"pattern must be a list of TYPE, VAL pairs.\")\n    assert(all([for (i = idx(pattern,step=2)) in_list(pattern[i],[\"step\",\"xstep\",\"ystep\",\"round\",\"fillet\"])]))\n    let(\n        x = concat([0], cumsum([\n            for (i=idx(pattern,step=2)) let(\n                type = pattern[i],\n                val = pattern[i+1]\n            ) (\n                type==\"step\"?   val.x :\n                type==\"xstep\"?  val :\n                type==\"round\"?  val :\n                type==\"fillet\"? val :\n                0\n            )\n        ])),\n        y = concat([0], cumsum([\n            for (i=idx(pattern,step=2)) let(\n                type = pattern[i],\n                val = pattern[i+1]\n            ) (\n                type==\"step\"?   val.y :\n                type==\"ystep\"?  val :\n                type==\"round\"?  val :\n                type==\"fillet\"? val :\n                0\n            )\n        ])),\n        tot_x = last(x),\n        tot_y = last(y),\n        data = [\n            for (i=idx(pattern,step=2)) let(\n                type = pattern[i],\n                val = pattern[i+1],\n                pt = [x[i/2], tot_y-y[i/2]] + (\n                    type==\"step\"?   [val.x,-val.y] :\n                    type==\"xstep\"?  [val,0] :\n                    type==\"ystep\"?  [0,-val] :\n                    type==\"round\"?  [val,0] :\n                    type==\"fillet\"? [0,-val] :\n                    [0,0]\n                )\n            ) [type, val, pt]\n        ],\n        path = [\n            [tot_x,-excess],\n            [-excess,-excess],\n            [-excess,tot_y],\n            for (pat = data) each\n                pat[0]==\"step\"?  [pat[2]] :\n                pat[0]==\"xstep\"? [pat[2]] :\n                pat[0]==\"ystep\"? [pat[2]] :\n                let(\n                    r = pat[1],\n                    steps = segs(abs(r)),\n                    step = 90/steps\n                ) [\n                    for (i=[0:1:steps]) let(\n                        a = pat[0]==\"round\"? (180+i*step) : (90-i*step)\n                    ) pat[2] + abs(r)*[cos(a),sin(a)]\n                ]\n        ],\n        path2 = deduplicate(path)\n    ) reorient(anchor,spin, two_d=true, path=path2, p=path2);\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-23", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: masks3d.scad\n//   This file defines 3D masks for applying chamfers, roundovers, and teardrop roundovers to straight edges and circular\n//   edges in three dimensions.  \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: 3D masks for rounding or chamfering edges and corners.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Chamfer Masks\n\n\n// Module: chamfer_edge_mask()\n// Synopsis: Creates a shape to chamfer a 90\u00b0 edge.\n// SynTags: Geom\n// Topics: Masking, Chamfers, Shapes (3D)\n// See Also: chamfer_corner_mask(), chamfer_cylinder_mask(), chamfer_edge_mask(), default_tag(), diff()\n// Usage:\n//   chamfer_edge_mask(l|h=|length=|height=, chamfer, [excess]) [ATTACHMENTS];\n// Description:\n//   Creates a shape that can be used to chamfer a 90\u00b0 edge.\n//   Difference it from the object to be chamfered.  The center of\n//   the mask object should align exactly with the edge to be chamfered.\n// Arguments:\n//   l/h/length/height = Length of mask.\n//   chamfer = Size of chamfer.\n//   excess = The extra amount to add to the length of the mask so that it differences away from other shapes cleanly.  Default: `0.1`\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example:\n//   chamfer_edge_mask(l=50, chamfer=10);\n// Example:\n//   difference() {\n//       cube(50, anchor=BOTTOM+FRONT);\n//       #chamfer_edge_mask(l=50, chamfer=10, orient=RIGHT);\n//   }\n// Example: Masking by Attachment\n//   diff()\n//   cube(50, center=true) {\n//       edge_mask(TOP+RIGHT)\n//           #chamfer_edge_mask(l=50, chamfer=10);\n//   }\nfunction chamfer_edge_mask(l, chamfer=1, excess=0.1, h, length, height, anchor=CENTER, spin=0, orient=UP) = no_function(\"chamfer_edge_mask\");\nmodule chamfer_edge_mask(l, chamfer=1, excess=0.1, h, length, height, anchor=CENTER, spin=0, orient=UP) {\n    l = one_defined([l, h, height, length], \"l,h,height,length\");\n    default_tag(\"remove\") {\n        attachable(anchor,spin,orient, size=[chamfer*2, chamfer*2, l]) {\n            cylinder(r=chamfer, h=l+excess, center=true, $fn=4);\n            children();\n        }\n    }\n}\n\n\n// Module: chamfer_corner_mask()\n// Synopsis: Creates a shape to chamfer a 90\u00b0 corner.\n// SynTags: Geom\n// Topics: Masking, Chamfers, Shapes (3D)\n// See Also: chamfer_corner_mask(), chamfer_cylinder_mask(), chamfer_edge_mask(), default_tag(), diff()\n// Usage:\n//   chamfer_corner_mask(chamfer) [ATTACHMENTS];\n// Description:\n//   Creates a shape that can be used to chamfer a 90\u00b0 corner.\n//   Difference it from the object to be chamfered.  The center of\n//   the mask object should align exactly with the corner to be chamfered.\n// Arguments:\n//   chamfer = Size of chamfer.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example:\n//   chamfer_corner_mask(chamfer=10);\n// Example:\n//   difference() {\n//       cuboid(50, chamfer=10, trimcorners=false);\n//       move(25*[1,-1,1]) #chamfer_corner_mask(chamfer=10);\n//   }\n// Example: Masking by Attachment\n//   diff()\n//   cuboid(100, chamfer=20, trimcorners=false) {\n//       corner_mask(TOP+FWD+RIGHT)\n//           chamfer_corner_mask(chamfer=20);\n//   }\n// Example: Anchors\n//   chamfer_corner_mask(chamfer=20)\n//       show_anchors();\nfunction chamfer_corner_mask(chamfer=1, anchor=CENTER, spin=0, orient=UP) = no_function(\"chamfer_corner_mask\");\nmodule chamfer_corner_mask(chamfer=1, anchor=CENTER, spin=0, orient=UP) {\n    default_tag(\"remove\") {\n        octahedron(chamfer*4, anchor=anchor, spin=spin, orient=orient) children();\n    }\n}\n\n\n// Module: chamfer_cylinder_mask()\n// Synopsis: Creates a shape to chamfer the end of a cylinder.\n// SynTags: Geom\n// Topics: Masking, Chamfers, Cylinders\n// See Also: chamfer_corner_mask(), chamfer_cylinder_mask(), chamfer_edge_mask(), default_tag(), diff()\n// Usage:\n//   chamfer_cylinder_mask(r|d=, chamfer, [ang], [from_end]) [ATTACHMENTS];\n// Description:\n//   Create a mask that can be used to bevel/chamfer the end of a cylindrical region.\n//   Difference it from the end of the region to be chamfered.  The center of the mask\n//   object should align exactly with the center of the end of the cylindrical region\n//   to be chamfered.\n// Arguments:\n//   r = Radius of cylinder to chamfer.\n//   chamfer = Size of the edge chamfered, inset from edge.\n//   ---\n//   d = Diameter of cylinder to chamfer. Use instead of r.\n//   ang = Angle of chamfer in degrees from the horizontal.  (Default: 45)\n//   from_end = If true, chamfer size is measured from end of cylinder.  If false, chamfer is measured outset from the radius of the cylinder.  (Default: false)\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example:\n//   difference() {\n//       cylinder(r=50, h=100, center=true);\n//       up(50) #chamfer_cylinder_mask(r=50, chamfer=10);\n//   }\n// Example:\n//   difference() {\n//       cylinder(r=50, h=100, center=true);\n//       up(50) chamfer_cylinder_mask(r=50, chamfer=10);\n//   }\n// Example: Changing the chamfer angle\n//   difference() {\n//       cylinder(r=50, h=100, center=true);\n//       up(50) #chamfer_cylinder_mask(r=50, chamfer=10, ang=70);\n//   }\n// Example:\n//   difference() {\n//       cylinder(r=50, h=100, center=true);\n//       up(50) chamfer_cylinder_mask(r=50, chamfer=10, ang=70);\n//   }\n// Example: Masking by Attachment\n//   diff()\n//   cyl(d=100,h=40)\n//      attach([TOP,BOT])\n//         tag(\"remove\")chamfer_cylinder_mask(d=100, chamfer=10);\nfunction chamfer_cylinder_mask(r, chamfer, d, ang=45, from_end=false, anchor=CENTER, spin=0, orient=UP) = no_function(\"chamfer_cylinder_mask\");\nmodule chamfer_cylinder_mask(r, chamfer, d, ang=45, from_end=false, anchor=CENTER, spin=0, orient=UP)\n{\n    r = get_radius(r=r, d=d, dflt=1);\n    dummy = assert(all_nonnegative([chamfer]), \"Chamfer must be a nonnegative number\");\n    ch = from_end? chamfer : opp_ang_to_adj(chamfer,90-ang);\n    default_tag(\"remove\"){\n        attachable(anchor,spin,orient, r=r, l=ch*2) {\n            difference() {\n                cyl(r=r+chamfer, l=ch*2, anchor=CENTER);\n                cyl(r=r, l=ch*3, chamfer=chamfer, chamfang=ang, from_end=from_end, anchor=TOP);\n            }\n            children();\n        }\n    }\n}\n\n\n\n// Section: Rounding Masks\n\n// Module: rounding_edge_mask()\n// Synopsis: Creates a shape to round a 90\u00b0 edge.\n// SynTags: Geom\n// Topics: Masks, Rounding, Shapes (3D)\n// See Also: rounding_angled_edge_mask(), rounding_corner_mask(), rounding_angled_corner_mask(), default_tag(), diff() \n// Usage:\n//   rounding_edge_mask(l|h=|length=|height=, r|d=, [excess=]) [ATTACHMENTS];\n//   rounding_edge_mask(l|h=|length=|height=, r1=|d1=, r2=|d2=, [excess=]) [ATTACHMENTS];\n// Description:\n//   Creates a shape that can be used to round a vertical 90\u00b0 edge.\n//   Difference it from the object to be rounded.  The center of the mask\n//   object should align exactly with the edge to be rounded.\n// Arguments:\n//   l/h/length/height = Length of mask.\n//   r = Radius of the rounding.\n//   ---\n//   r1 = Bottom radius of rounding.\n//   r2 = Top radius of rounding.\n//   d = Diameter of the rounding.\n//   d1 = Bottom diameter of rounding.\n//   d2 = Top diameter of rounding.\n//   excess = Extra size for the mask.  Defaults: 0.1\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example(VPD=200,VPR=[55,0,120]):\n//   rounding_edge_mask(l=50, r1=10, r2=25);\n// Example:\n//   difference() {\n//       cube(size=100, center=false);\n//       #rounding_edge_mask(l=100, r=25, orient=UP, anchor=BOTTOM);\n//   }\n// Example: Varying Rounding Radius\n//   difference() {\n//       cube(size=50, center=false);\n//       #rounding_edge_mask(l=50, r1=25, r2=10, orient=UP, anchor=BOTTOM);\n//   }\n// Example: Masking by Attachment\n//   diff()\n//   cube(100, center=true)\n//       edge_mask(FRONT+RIGHT)\n//           #rounding_edge_mask(l=$parent_size.z+0.01, r=25);\n// Example: Multiple Masking by Attachment\n//   diff()\n//   cube([80,90,100], center=true) {\n//       let(p = $parent_size*1.01) {\n//           edge_mask(TOP)\n//               rounding_edge_mask(l=p.z, r=25);\n//       }\n//   }\nfunction rounding_edge_mask(l, r, r1, r2, d, d1, d2, excess=0.1, anchor=CENTER, spin=0, orient=UP, h,height,length) = no_function(\"rounding_edge_mask\");\nmodule rounding_edge_mask(l, r, r1, r2, d, d1, d2, excess=0.1, anchor=CENTER, spin=0, orient=UP, h,height,length)\n{\n    l = one_defined([l, h, height, length], \"l,h,height,length\");\n    r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1);\n    r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1);\n    sides = quantup(segs(max(r1,r2)),4);\n    default_tag(\"remove\") {\n        attachable(anchor,spin,orient, size=[2*r1,2*r1,l], size2=[2*r2,2*r2]) {\n            if (r1<r2) {\n                zflip() {\n                    linear_extrude(height=l, convexity=4, center=true, scale=r1/r2) {\n                        difference() {\n                            translate(-excess*[1,1]) square(r2+excess);\n                            translate([r2,r2]) circle(r=r2, $fn=sides);\n                        }\n                    }\n                }\n            } else {\n                linear_extrude(height=l, convexity=4, center=true, scale=r2/r1) {\n                    difference() {\n                        translate(-excess*[1,1]) square(r1+excess);\n                        translate([r1,r1]) circle(r=r1, $fn=sides);\n                    }\n                }\n            }\n            children();\n        }\n    }\n}\n\n\n// Module: rounding_corner_mask()\n// Synopsis: Creates a shape to round 90\u00b0 corners.\n// SynTags: Geom\n// Topics: Masking, Rounding, Shapes (3D)\n// See Also: rounding_angled_corner_mask(), rounding_edge_mask(), rounding_angled_edge_mask(), default_tag(), diff()\n// Usage:\n//   rounding_corner_mask(r|d, [excess=], [style=]) [ATTACHMENTS];\n// Description:\n//   Creates a shape that you can use to round 90\u00b0 corners.\n//   Difference it from the object to be rounded.  The center of the mask\n//   object should align exactly with the corner to be rounded.\n// Arguments:\n//   r = Radius of corner rounding.\n//   ---\n//   d = Diameter of corner rounding.\n//   excess = Extra size for the mask.  Defaults: 0.1\n//   style = The style of the sphere cutout's construction. One of \"orig\", \"aligned\", \"stagger\", \"octa\", or \"icosa\".  Default: \"octa\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example:\n//   rounding_corner_mask(r=20.0);\n// Example:\n//   difference() {\n//       cube(size=[50, 60, 70], center=true);\n//       translate([-25, -30, 35])\n//           #rounding_corner_mask(r=20, spin=90, orient=DOWN);\n//       translate([25, -30, 35])\n//           #rounding_corner_mask(r=20, orient=DOWN);\n//       translate([25, -30, -35])\n//           #rounding_corner_mask(r=20, spin=90);\n//   }\n// Example: Masking by Attachment\n//   diff()\n//   cube(size=[50, 60, 70]) {\n//       corner_mask(TOP)\n//           #rounding_corner_mask(r=20);\n//   }\nfunction rounding_corner_mask(r, d, style=\"octa\", excess=0.1, anchor=CENTER, spin=0, orient=UP) = no_function(\"rounding_corner_mask\");\nmodule rounding_corner_mask(r, d, style=\"octa\", excess=0.1, anchor=CENTER, spin=0, orient=UP)\n{\n    r = get_radius(r=r, d=d, dflt=1);\n    default_tag(\"remove\") {\n        attachable(anchor,spin,orient, size=[2,2,2]*r) {\n            difference() {\n                translate(-excess*[1,1,1])\n                    cube(size=r+excess, center=false);\n                translate([r,r,r])\n                    spheroid(r=r, style=style);\n            }\n            children();\n        }\n    }\n}\n\n\n// Module: rounding_angled_edge_mask()\n// Synopsis: Creates a shape to round edges of any angle.\n// SynTags: Geom\n// Topics: Masks, Rounding\n// See Also: rounding_angled_corner_mask(), rounding_edge_mask(), rounding_corner_mask(), default_tag(), diff()\n// Usage:\n//   rounding_angled_edge_mask(h|l=|length=|height=, r|d=, [ang=]) [ATTACHMENTS];\n//   rounding_angled_edge_mask(h|l=|length=|height=, r1=|d1=, r2=|d2=, [ang=]) [ATTACHMENTS];\n// Description:\n//   Creates a vertical mask that can be used to round the edge where two face meet, at any arbitrary\n//   angle.  Difference it from the object to be rounded.  The center of the mask should align exactly\n//   with the edge to be rounded.\n// Arguments:\n//   h/l/height/length = Height of vertical mask.\n//   r = Radius of the rounding.\n//   ---\n//   r1 = Bottom radius of rounding.\n//   r2 = Top radius of rounding.\n//   d = Diameter of the rounding.\n//   d1 = Bottom diameter of rounding.\n//   d2 = Top diameter of rounding.\n//   ang = Angle that the planes meet at. Default: 90\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example:\n//   difference() {\n//       pie_slice(ang=70, h=50, d=100, center=true);\n//       #rounding_angled_edge_mask(h=51, r=20.0, ang=70, $fn=32);\n//   }\n// Example: Varying Rounding Radius\n//   difference() {\n//       pie_slice(ang=70, h=50, d=100, center=true);\n//       #rounding_angled_edge_mask(h=51, r1=10, r2=25, ang=70, $fn=32);\n//   }\nfunction rounding_angled_edge_mask(h, r, r1, r2, d, d1, d2, ang=90, anchor=CENTER, spin=0, orient=UP,l,height,length) = no_function(\"rounding_angled_edge_mask\");\nmodule rounding_angled_edge_mask(h, r, r1, r2, d, d1, d2, ang=90, anchor=CENTER, spin=0, orient=UP,l,height,length)\n{\n    function _mask_shape(r) = [\n        for (i = [0:1:n]) let (a=90+ang+i*sweep/n) [r*cos(a)+x, r*sin(a)+r],\n        for (i = [0:1:n]) let (a=90+i*sweep/n) [r*cos(a)+x, r*sin(a)-r],\n        [min(-1, r*cos(270-ang)+x-1), r*sin(270-ang)-r],\n        [min(-1, r*cos(90+ang)+x-1), r*sin(90+ang)+r],\n    ];\n    h = one_defined([l, h, height, length], \"l,h,height,length\");\n    sweep = 180-ang;\n    r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1);\n    r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1);\n    n = ceil(segs(max(r1,r2))*sweep/360);\n    x = sin(90-(ang/2))/sin(ang/2) * (r1<r2? r2 : r1);\n    if(r1<r2) {\n        default_tag(\"remove\") {\n            attachable(anchor,spin,orient, size=[2*x*r1/r2,2*r1,h], size2=[2*x,2*r2]) {\n                zflip() {\n                    linear_extrude(height=h, convexity=4, center=true, scale=r1/r2) {\n                        polygon(_mask_shape(r2));\n                    }\n                }\n                children();\n            }\n        }\n    } else {\n        default_tag(\"remove\") {\n            attachable(anchor,spin,orient, size=[2*x,2*r1,h], size2=[2*x*r2/r1,2*r2]) {\n                linear_extrude(height=h, convexity=4, center=true, scale=r2/r1) {\n                    polygon(_mask_shape(r1));\n                }\n                children();\n            }\n        }\n    }\n}\n\n\n// Module: rounding_angled_corner_mask()\n// Synopsis: Creates a shape to round the corner of an arbitrary angle.\n// SynTags: Geom\n// Topics: Masks, Rounding, Shapes (3D)\n// See Also: rounding_angled_edge_mask(), rounding_corner_mask(), rounding_edge_mask(), default_tag(), diff()\n// Usage:\n//   rounding_angled_corner_mask(r|d=, [ang]) [ATTACHMENTS];\n// Description:\n//   Creates a shape that can be used to round the corner of an angle.\n//   Difference it from the object to be rounded.  The center of the mask\n//   object should align exactly with the point of the corner to be rounded.\n// Arguments:\n//   r = Radius of the rounding.\n//   ---\n//   d = Diameter of the rounding.\n//   ang = Angle between planes that you need to round the corner of.  Default: 90\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example(Med):\n//   ang=60;\n//   difference() {\n//       pie_slice(ang=ang, h=50, r=200, center=true);\n//       up(50/2) #rounding_angled_corner_mask(r=20, ang=ang);\n//   }\nfunction rounding_angled_corner_mask(r, ang=90, d, anchor=CENTER, spin=0, orient=UP) = no_function(\"rounding_angled_corner_mask\");\nmodule rounding_angled_corner_mask(r, ang=90, d, anchor=CENTER, spin=0, orient=UP)\n{\n    r = get_radius(r=r, d=d, dflt=1);\n    dx = r / tan(ang/2);\n    dx2 = dx / cos(ang/2) + 1;\n    fn = quantup(segs(r), 4);\n    default_tag(\"remove\") {\n        attachable(anchor,spin,orient, d=dx2, l=2*r) {\n            difference() {\n                down(r) cylinder(r=dx2, h=r+1, center=false);\n                yflip_copy() {\n                    translate([dx, r, -r]) {\n                        hull() {\n                            sphere(r=r, $fn=fn);\n                            down(r*3) sphere(r=r, $fn=fn);\n                            zrot_copies([0,ang]) {\n                                right(r*3) sphere(r=r, $fn=fn);\n                            }\n                        }\n                    }\n                }\n            }\n            children();\n        }\n    }\n}\n\n\n// Module: rounding_cylinder_mask()\n// Synopsis: Creates a shape to round the end of a cylinder.\n// SynTags: Geom\n// Topics: Masking, Rounding, Cylinders\n// See Also: rounding_hole_mask(), rounding_angled_edge_mask(), rounding_corner_mask(), rounding_angled_corner_mask(), default_tag(), diff()\n// Usage:\n//   rounding_cylinder_mask(r|d=, rounding);\n// Description:\n//   Create a mask that can be used to round the end of a cylinder.\n//   Difference it from the cylinder to be rounded.  The center of the\n//   mask object should align exactly with the center of the end of the\n//   cylinder to be rounded.\n// Arguments:\n//   r = Radius of cylinder.\n//   rounding = Radius of the edge rounding.\n//   ---\n//   d = Diameter of cylinder.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example:\n//   difference() {\n//     cylinder(r=50, h=50, center=false);\n//     up(50) #rounding_cylinder_mask(r=50, rounding=10);\n//   }\n// Example:\n//   difference() {\n//     cylinder(r=50, h=50, center=false);\n//     up(50) rounding_cylinder_mask(r=50, rounding=10);\n//   }\n// Example: Masking by Attachment\n//   diff()\n//   cyl(h=30, d=30) {\n//       attach(TOP)\n//         #tag(\"remove\")\n//           rounding_cylinder_mask(d=30, rounding=5);\n//   }\nfunction rounding_cylinder_mask(r, rounding, d, anchor, spin, orient) = no_function(\"rounding_cylinder_mask\");\nmodule rounding_cylinder_mask(r, rounding, d, anchor=CENTER, spin=0, orient=UP)\n{\n    r = get_radius(r=r, d=d, dflt=1);\n    default_tag(\"remove\") {\n        attachable(anchor,spin,orient, r=r+rounding, l=rounding*2) {\n            difference() {\n                cyl(r=r+rounding, l=rounding*2, anchor=CENTER);\n                cyl(r=r, l=rounding*3, rounding=rounding, anchor=TOP);\n            }\n            children();\n        }\n    }\n}\n\n\n\n// Module: rounding_hole_mask()\n// Synopsis: Creates a shape to round the edge of a round hole.\n// SynTags: Geom\n// Topics: Masking, Rounding\n// See Also: rounding_cylinder_mask(), rounding_hole_mask(), rounding_angled_edge_mask(), rounding_corner_mask(), rounding_angled_corner_mask(), default_tag(), diff()\n// Usage:\n//   rounding_hole_mask(r|d, rounding, [excess]) [ATTACHMENTS];\n// Description:\n//   Create a mask that can be used to round the edge of a circular hole.\n//   Difference it from the hole to be rounded.  The center of the\n//   mask object should align exactly with the center of the end of the\n//   hole to be rounded.\n// Arguments:\n//   r = Radius of hole.\n//   rounding = Radius of the rounding.\n//   excess = The extra thickness of the mask.  Default: `0.1`.\n//   ---\n//   d = Diameter of hole to rounding.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example:\n//   rounding_hole_mask(r=40, rounding=20, $fa=2, $fs=2);\n// Example(Med):\n//   difference() {\n//     cube([150,150,100], center=true);\n//     cylinder(r=50, h=100.1, center=true);\n//     up(50) #rounding_hole_mask(r=50, rounding=10);\n//   }\n// Example(Med):\n//   difference() {\n//     cube([150,150,100], center=true);\n//     cylinder(r=50, h=100.1, center=true);\n//     up(50) rounding_hole_mask(r=50, rounding=10);\n//   }\nfunction rounding_hole_mask(r, rounding, excess=0.1, d, anchor=CENTER, spin=0, orient=UP) = no_function(\"rounding_hole_mask\");\nmodule rounding_hole_mask(r, rounding, excess=0.1, d, anchor=CENTER, spin=0, orient=UP)\n{\n    r = get_radius(r=r, d=d, dflt=1);\n    default_tag(\"remove\") {\n        attachable(anchor,spin,orient, r=r+rounding, l=2*rounding) {\n            rotate_extrude(convexity=4) {\n                difference() {\n                    right(r-excess) fwd(rounding) square(rounding+excess, center=false);\n                    right(r+rounding) fwd(rounding) circle(r=rounding);\n                }\n            }\n            children();\n        }\n    }\n}\n\n\n// Section: Teardrop Masking\n\n// Module: teardrop_edge_mask()\n// Synopsis: Creates a shape to round a 90\u00b0 edge but limit the angle of overhang.\n// SynTags: Geom\n// Topics: Masking, Rounding, Shapes (3D), FDM Optimized\n// See Also: teardrop_corner_mask(), teardrop_edge_mask(), default_tag(), diff()\n// Usage:\n//   teardrop_edge_mask(l|h=|length=|height=, r|d=, [angle], [excess], [anchor], [spin], [orient]) [ATTACHMENTS];\n// Description:\n//   Makes an apropriate 3D edge rounding mask that keeps within `angle` degrees of vertical.\n// Arguments:\n//   l/h/length/height = length of mask\n//   r = Radius of the mask rounding.\n//   angle = Maximum angle from vertical. Default: 45\n//   excess = Excess mask size.  Default: 0.1\n//   ---\n//   d = Diameter of the mask rounding.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example(VPD=50,VPR=[55,0,120]):\n//   teardrop_edge_mask(l=20, r=10, angle=40);\n// Example(VPD=300,VPR=[75,0,25]):\n//   diff()\n//   cuboid([50,60,70],rounding=10,edges=\"Z\",anchor=CENTER) {\n//       edge_mask(BOT)\n//           teardrop_edge_mask(l=max($parent_size)+1, r=10, angle=40);\n//       corner_mask(BOT)\n//           teardrop_corner_mask(r=10, angle=40);\n//   }\nfunction teardrop_edge_mask(l, r, angle=45, excess=0.1, d, anchor, spin, orient,h,height,length) = no_function(\"teardrop_edge_mask\");\nmodule teardrop_edge_mask(l, r, angle=45, excess=0.1, d, anchor=CTR, spin=0, orient=UP,h,height,length)\n{\n    l = one_defined([l, h, height, length], \"l,h,height,length\");\n    check = \n      assert(is_num(l) && l>0, \"Length of mask must be positive\")\n      assert(is_num(angle) && angle>0 && angle<90, \"Angle must be a number between 0 and 90\")\n      assert(is_num(excess));\n    r = get_radius(r=r, d=d, dflt=1);\n    path = mask2d_teardrop(r=r, angle=angle, excess=excess);\n    default_tag(\"remove\") {\n        linear_sweep(path, height=l, center=true, atype=\"bbox\", anchor=anchor, spin=spin, orient=orient) children();\n    }\n}\n\n\n// Module: teardrop_corner_mask()\n// Synopsis: Creates a shape to round a 90\u00b0 corner but limit the angle of overhang.\n// SynTags: Geom\n// Topics: Masking, Rounding, Shapes (3D), FDM Optimized\n// See Also: teardrop_corner_mask(), teardrop_edge_mask(), default_tag(), diff()\n// Usage:\n//   teardrop_corner_mask(r|d=, [angle], [excess], [anchor], [spin], [orient]) [ATTACHMENTS];\n// Description:\n//   Makes an apropriate 3D corner rounding mask that keeps within `angle` degrees of vertical.\n// Arguments:\n//   r = Radius of the mask rounding.\n//   angle = Maximum angle from vertical. Default: 45\n//   excess = Excess mask size.  Default: 0.1\n//   ---\n//   d = Diameter of the mask rounding.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Tags the children with \"remove\" (and hence sets `$tag`) if no tag is already set.\n// Example:\n//   teardrop_corner_mask(r=20, angle=40);\n// Example:\n//   diff()\n//   cuboid([50,60,70],rounding=10,edges=\"Z\",anchor=CENTER) {\n//       edge_profile(BOT)\n//           mask2d_teardrop(r=10, angle=40);\n//       corner_mask(BOT)\n//           teardrop_corner_mask(r=10, angle=40);\n//   }\nfunction teardrop_corner_mask(r, angle=45, excess=0.1, d, anchor, spin, orient) = no_function(\"teardrop_corner_mask\");\nmodule teardrop_corner_mask(r, angle=45, excess=0.1, d, anchor=CTR, spin=0, orient=UP)\n{  \n    assert(is_num(angle));\n    assert(is_num(excess));\n    assert(angle>0 && angle<90);\n    r = get_radius(r=r, d=d, dflt=1);\n    size = (r+excess) * [1,1,1];\n    midpt = (r-excess)/2 * [1,1,1];\n    default_tag(\"remove\") {\n        attachable(anchor,spin,orient, size=size, offset=midpt) {\n            difference() {\n                translate(-[1,1,1]*excess) cube(r+excess, center=false);\n                translate([1,1,1]*r) onion(r=r, ang=angle, orient=DOWN);\n            }\n            children();\n        }\n    }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-24", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: math.scad\n//   Assorted math functions, including linear interpolation, list operations (sums, mean, products),\n//   convolution, quantization, log2, hyperbolic trig functions, random numbers, derivatives,\n//   polynomials, and root finding. \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Math\n// FileSummary: Math on lists, special functions, quantization, random numbers, calculus, root finding\n//  \n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n// Section: Math Constants\n\n// Constant: PHI\n// Synopsis: The golden ratio \u03c6 (phi).  Approximately 1.6180339887\n// Topics: Constants, Math\n// See Also: EPSILON, INF, NAN\n// Description: The golden ratio \u03c6 (phi).  Approximately 1.6180339887\nPHI = (1+sqrt(5))/2;\n\n// Constant: EPSILON\n// Synopsis: A tiny value to compare floating point values.  `1e-9`\n// Topics: Constants, Math\n// See Also: PHI, EPSILON, INF, NAN\n// Description: A really small value useful in comparing floating point numbers.  ie: abs(a-b)<EPSILON  `1e-9`\nEPSILON = 1e-9;\n\n// Constant: INF\n// Synopsis: The floating point value for Infinite.\n// Topics: Constants, Math\n// See Also: PHI, EPSILON, INF, NAN\n// Description: The value `inf`, useful for comparisons.\nINF = 1/0;\n\n// Constant: NAN\n// Synopsis: The floating point value for Not a Number.\n// Topics: Constants, Math\n// See Also: PHI, EPSILON, INF, NAN\n// Description: The value `nan`, useful for comparisons.\nNAN = acos(2);\n\n\n\n// Section: Interpolation and Counting\n\n\n// Function: count()\n// Synopsis: Creates a list of incrementing numbers.\n// Topics: Math, Indexing\n// See Also: idx()\n// Usage:\n//   list = count(n, [s], [step], [reverse]);\n// Description:\n//   Creates a list of `n` numbers, starting at `s`, incrementing by `step` each time.\n//   You can also pass a list for n and then the length of the input list is used.  \n// Arguments:\n//   n = The length of the list of numbers to create, or a list to match the length of\n//   s = The starting value of the list of numbers.\n//   step = The amount to increment successive numbers in the list.\n//   reverse = Reverse the list.  Default: false.\n// Example:\n//   nl1 = count(5);  // Returns: [0,1,2,3,4]\n//   nl2 = count(5,3);  // Returns: [3,4,5,6,7]\n//   nl3 = count(4,3,2);  // Returns: [3,5,7,9]\n//   nl4 = count(5,reverse=true);    // Returns: [4,3,2,1,0]\n//   nl5 = count(5,3,reverse=true);  // Returns: [7,6,5,4,3]\nfunction count(n,s=0,step=1,reverse=false) = let(n=is_list(n) ? len(n) : n)\n                                             reverse? [for (i=[n-1:-1:0]) s+i*step]\n                                                    : [for (i=[0:1:n-1]) s+i*step];\n\n\n// Function: lerp()\n// Synopsis: Linearly interpolates between two values.\n// Topics: Interpolation, Math\n// See Also: v_lookup(), lerpn()\n// Usage:\n//   x = lerp(a, b, u);\n//   l = lerp(a, b, LIST);\n// Description:\n//   Interpolate between two values or vectors.\n//   If `u` is given as a number, returns the single interpolated value.\n//   If `u` is 0.0, then the value of `a` is returned.\n//   If `u` is 1.0, then the value of `b` is returned.\n//   If `u` is a range, or list of numbers, returns a list of interpolated values.\n//   It is valid to use a `u` value outside the range 0 to 1.  The result will be an extrapolation\n//   along the slope formed by `a` and `b`.\n// Arguments:\n//   a = First value or vector.\n//   b = Second value or vector.\n//   u = The proportion from `a` to `b` to calculate.  Standard range is 0.0 to 1.0, inclusive.  If given as a list or range of values, returns a list of results.\n// Example:\n//   x = lerp(0,20,0.3);  // Returns: 6\n//   x = lerp(0,20,0.8);  // Returns: 16\n//   x = lerp(0,20,-0.1); // Returns: -2\n//   x = lerp(0,20,1.1);  // Returns: 22\n//   p = lerp([0,0],[20,10],0.25);  // Returns [5,2.5]\n//   l = lerp(0,20,[0.4,0.6]);  // Returns: [8,12]\n//   l = lerp(0,20,[0.25:0.25:0.75]);  // Returns: [5,10,15]\n// Example(2D):\n//   p1 = [-50,-20];  p2 = [50,30];\n//   stroke([p1,p2]);\n//   pts = lerp(p1, p2, [0:1/8:1]);\n//   // Points colored in ROYGBIV order.\n//   rainbow(pts) translate($item) circle(d=3,$fn=8);\nfunction lerp(a,b,u) =\n    assert(same_shape(a,b), \"Bad or inconsistent inputs to lerp\")\n    is_finite(u)? (1-u)*a + u*b :\n    assert(is_finite(u) || is_vector(u) || valid_range(u), \"Input u to lerp must be a number, vector, or valid range.\")\n    [for (v = u) (1-v)*a + v*b ];\n\n\n// Function: lerpn()\n// Synopsis: Returns exactly `n` values, linearly interpolated between `a` and `b`.\n// Topics: Interpolation, Math\n// See Also: v_lookup(), lerp()\n// Usage:\n//   x = lerpn(a, b, n);\n//   x = lerpn(a, b, n, [endpoint]);\n// Description:\n//   Returns exactly `n` values, linearly interpolated between `a` and `b`.\n//   If `endpoint` is true, then the last value will exactly equal `b`.\n//   If `endpoint` is false, then the last value will be `a+(b-a)*(1-1/n)`.\n// Arguments:\n//   a = First value or vector.\n//   b = Second value or vector.\n//   n = The number of values to return.\n//   endpoint = If true, the last value will be exactly `b`.  If false, the last value will be one step less.\n// Example:\n//   l = lerpn(-4,4,9);        // Returns: [-4,-3,-2,-1,0,1,2,3,4]\n//   l = lerpn(-4,4,8,false);  // Returns: [-4,-3,-2,-1,0,1,2,3]\n//   l = lerpn(0,1,6);         // Returns: [0, 0.2, 0.4, 0.6, 0.8, 1]\n//   l = lerpn(0,1,5,false);   // Returns: [0, 0.2, 0.4, 0.6, 0.8]\nfunction lerpn(a,b,n,endpoint=true) =\n    assert(same_shape(a,b), \"Bad or inconsistent inputs to lerpn\")\n    assert(is_int(n))\n    assert(is_bool(endpoint))\n    let( d = n - (endpoint? 1 : 0) )\n    [for (i=[0:1:n-1]) let(u=i/d) (1-u)*a + u*b];\n\n\n\n// Section: Miscellaneous Functions \n\n// Function: sqr()\n// Synopsis: Returns the square of the given value.\n// Topics: Math\n// See Also: hypot(), log2()\n// Usage:\n//   x2 = sqr(x);\n// Description:\n//   If given a number, returns the square of that number,\n//   If given a vector, returns the sum-of-squares/dot product of the vector elements.\n//   If given a matrix, returns the matrix multiplication of the matrix with itself.\n// Example:\n//   sqr(3);     // Returns: 9\n//   sqr(-4);    // Returns: 16\n//   sqr([2,3,4]); // Returns: 29\n//   sqr([[1,2],[3,4]]);  // Returns [[7,10],[15,22]]\nfunction sqr(x) = \n    assert(is_finite(x) || is_vector(x) || is_matrix(x), \"Input is not a number nor a list of numbers.\")\n    x*x;\n\n\n// Function: log2()\n// Synopsis: Returns the log base 2 of the given value.\n// Topics: Math\n// See Also: hypot(), sqr()\n// Usage:\n//   val = log2(x);\n// Description:\n//   Returns the logarithm base 2 of the value given.\n// Example:\n//   log2(0.125);  // Returns: -3\n//   log2(16);     // Returns: 4\n//   log2(256);    // Returns: 8\nfunction log2(x) = \n    assert( is_finite(x), \"Input is not a number.\")\n    ln(x)/ln(2);\n\n// this may return NAN or INF; should it check x>0 ?\n\n// Function: hypot()\n// Synopsis: Returns the hypotenuse length of a 2D or 3D triangle.\n// Topics: Math\n// See Also: hypot(), sqr(), log2()\n// Usage:\n//   l = hypot(x, y, [z]);\n// Description:\n//   Calculate hypotenuse length of a 2D or 3D triangle.\n// Arguments:\n//   x = Length on the X axis.\n//   y = Length on the Y axis.\n//   z = Length on the Z axis.  Optional.\n// Example:\n//   l = hypot(3,4);  // Returns: 5\n//   l = hypot(3,4,5);  // Returns: ~7.0710678119\nfunction hypot(x,y,z=0) = \n    assert( is_vector([x,y,z]), \"Improper number(s).\")\n    norm([x,y,z]);\n\n\n// Function: factorial()\n// Synopsis: Returns the factorial of the given integer.\n// Topics: Math\n// See Also: hypot(), sqr(), log2()\n// Usage:\n//   x = factorial(n, [d]);\n// Description:\n//   Returns the factorial of the given integer value, or n!/d! if d is given.  \n// Arguments:\n//   n = The integer number to get the factorial of.  (n!)\n//   d = If given, the returned value will be (n! / d!)\n// Example:\n//   x = factorial(4);  // Returns: 24\n//   y = factorial(6);  // Returns: 720\n//   z = factorial(9);  // Returns: 362880\nfunction factorial(n,d=0) =\n    assert(is_int(n) && is_int(d) && n>=0 && d>=0, \"Factorial is defined only for non negative integers\")\n    assert(d<=n, \"d cannot be larger than n\")\n    product([1,for (i=[n:-1:d+1]) i]);\n\n\n// Function: binomial()\n// Synopsis: Returns the binomial coefficients of the integer `n`.\n// Topics: Math\n// See Also: hypot(), sqr(), log2(), factorial()\n// Usage:\n//   x = binomial(n);\n// Description:\n//   Returns the binomial coefficients of the integer `n`.  \n// Arguments:\n//   n = The integer to get the binomial coefficients of\n// Example:\n//   x = binomial(3);  // Returns: [1,3,3,1]\n//   y = binomial(4);  // Returns: [1,4,6,4,1]\n//   z = binomial(6);  // Returns: [1,6,15,20,15,6,1]\nfunction binomial(n) =\n    assert( is_int(n) && n>0, \"Input is not an integer greater than 0.\")\n    [for( c = 1, i = 0; \n        i<=n; \n         c = c*(n-i)/(i+1), i = i+1\n        ) c ] ;\n\n\n// Function: binomial_coefficient()\n// Synopsis: Returns the `k`-th binomial coefficient of the integer `n`.\n// Topics: Math\n// See Also: hypot(), sqr(), log2(), factorial()\n// Usage:\n//   x = binomial_coefficient(n, k);\n// Description:\n//   Returns the `k`-th binomial coefficient of the integer `n`.\n// Arguments:\n//   n = The integer to get the binomial coefficient of\n//   k = The binomial coefficient index\n// Example:\n//   x = binomial_coefficient(3,2);  // Returns: 3\n//   y = binomial_coefficient(10,6); // Returns: 210\nfunction binomial_coefficient(n,k) =\n    assert( is_int(n) && is_int(k), \"Some input is not a number.\")\n    k < 0 || k > n ? 0 :\n    k ==0 || k ==n ? 1 :\n    let( k = min(k, n-k),\n         b = [for( c = 1, i = 0; \n                   i<=k; \n                   c = c*(n-i)/(i+1), i = i+1\n                 ) c] )\n    b[len(b)-1];\n\n\n// Function: gcd()\n// Synopsis: Returns the Greatest Common Divisor/Factor of two integers.\n// Topics: Math\n// See Also: hypot(), sqr(), log2(), factorial(), binomial(), gcd(), lcm()\n// Usage:\n//   x = gcd(a,b)\n// Description:\n//   Computes the Greatest Common Divisor/Factor of `a` and `b`.  \nfunction gcd(a,b) =\n    assert(is_int(a) && is_int(b),\"Arguments to gcd must be integers\")\n    b==0 ? abs(a) : gcd(b,a % b);\n\n\n// Computes lcm for two integers\nfunction _lcm(a,b) =\n    assert(is_int(a) && is_int(b), \"Invalid non-integer parameters to lcm\")\n    assert(a!=0 && b!=0, \"Arguments to lcm should not be zero\")\n    abs(a*b) / gcd(a,b);\n\n\n// Computes lcm for a list of values\nfunction _lcmlist(a) =\n    len(a)==1 ? a[0] :\n    _lcmlist(concat(lcm(a[0],a[1]),list_tail(a,2)));\n\n\n// Function: lcm()\n// Synopsis: Returns the Least Common Multiple of two or more integers.\n// Topics: Math\n// See Also: hypot(), sqr(), log2(), factorial(), binomial(), gcd(), lcm()\n// Usage:\n//   div = lcm(a, b);\n//   divs = lcm(list);\n// Description:\n//   Computes the Least Common Multiple of the two arguments or a list of arguments.  Inputs should\n//   be non-zero integers.  The output is always a positive integer.  It is an error to pass zero\n//   as an argument.  \nfunction lcm(a,b=[]) =\n    !is_list(a) && !is_list(b) \n    ?   _lcm(a,b) \n    :   let( arglist = concat(force_list(a),force_list(b)) )\n        assert(len(arglist)>0, \"Invalid call to lcm with empty list(s)\")\n        _lcmlist(arglist);\n\n// Function rational_approx()\n// Usage:\n//   pq = rational_approx(x, maxq);\n// Description:\n//   Finds the best rational approximation p/q to the number x so that q<=maxq.  Returns\n//   the result as `[p,q]`.  If the input is zero, then returns `[0,1]`.  \n// Example:\n//   pq1 = rational_approx(PI,10);        // Returns: [22,7]\n//   pq2 = rational_approx(PI,10000);     // Returns: [355, 113]\n//   pq3 = rational_approx(221/323,500);  // Returns: [13,19]\n//   pq4 = rational_approx(0,50);         // Returns: [0,1]\nfunction rational_approx(x, maxq, cfrac=[], p, q) =\n  let(\n       next = floor(x),\n       fracpart = x-next,\n       cfrac = [each cfrac, next],\n       pq = _cfrac_to_pq(cfrac)\n  )\n    approx(fracpart,0) ? pq \n  : pq[1]>maxq ? [p,q]\n  : rational_approx(1/fracpart,maxq,cfrac, pq[0], pq[1]);\n\n\n// Converts a continued fraction given as a list with leading integer term\n// into a fraction in the form p / q, returning [p,q]. \nfunction _cfrac_to_pq(cfrac,p=0,q=1,ind) =\n    is_undef(ind) ? _cfrac_to_pq(cfrac,p,q,len(cfrac)-1)\n  : ind==0 ? [p+q*cfrac[0], q]\n  : _cfrac_to_pq(cfrac, q, cfrac[ind]*q+p, ind-1);\n\n\n// Section: Hyperbolic Trigonometry\n\n// Function: sinh()\n// Synopsis: Returns the hyperbolic sine of the given value.\n// Topics: Math, Trigonometry\n// See Also: sinh(), cosh(), tanh(), asinh(), acosh(), atanh()\n// Usage:\n//   a = sinh(x);\n// Description: Takes a value `x`, and returns the hyperbolic sine of it.\nfunction sinh(x) =\n    assert(is_finite(x), \"The input must be a finite number.\")\n    (exp(x)-exp(-x))/2;\n\n\n// Function: cosh()\n// Synopsis: Returns the hyperbolic cosine of the given value.\n// Topics: Math, Trigonometry\n// See Also: sinh(), cosh(), tanh(), asinh(), acosh(), atanh()\n// Usage:\n//   a = cosh(x);\n// Description: Takes a value `x`, and returns the hyperbolic cosine of it.\nfunction cosh(x) =\n    assert(is_finite(x), \"The input must be a finite number.\")\n    (exp(x)+exp(-x))/2;\n\n\n// Function: tanh()\n// Synopsis: Returns the hyperbolic tangent of the given value.\n// Topics: Math, Trigonometry\n// See Also: sinh(), cosh(), tanh(), asinh(), acosh(), atanh()\n// Usage:\n//   a = tanh(x);\n// Description: Takes a value `x`, and returns the hyperbolic tangent of it.\nfunction tanh(x) =\n    assert(is_finite(x), \"The input must be a finite number.\")\n    sinh(x)/cosh(x);\n\n\n// Function: asinh()\n// Synopsis: Returns the hyperbolic arc-sine of the given value.\n// Topics: Math, Trigonometry\n// See Also: sinh(), cosh(), tanh(), asinh(), acosh(), atanh()\n// Usage:\n//   a = asinh(x);\n// Description: Takes a value `x`, and returns the inverse hyperbolic sine of it.\nfunction asinh(x) =\n    assert(is_finite(x), \"The input must be a finite number.\")\n    ln(x+sqrt(x*x+1));\n\n\n// Function: acosh()\n// Synopsis: Returns the hyperbolic arc-cosine of the given value.\n// Topics: Math, Trigonometry\n// See Also: sinh(), cosh(), tanh(), asinh(), acosh(), atanh()\n// Usage:\n//   a = acosh(x);\n// Description: Takes a value `x`, and returns the inverse hyperbolic cosine of it.\nfunction acosh(x) =\n    assert(is_finite(x), \"The input must be a finite number.\")\n    ln(x+sqrt(x*x-1));\n\n\n// Function: atanh()\n// Synopsis: Returns the hyperbolic arc-tangent of the given value.\n// Topics: Math, Trigonometry\n// See Also: sinh(), cosh(), tanh(), asinh(), acosh(), atanh()\n// Usage:\n//   a = atanh(x);\n// Description: Takes a value `x`, and returns the inverse hyperbolic tangent of it.\nfunction atanh(x) =\n    assert(is_finite(x), \"The input must be a finite number.\")\n    ln((1+x)/(1-x))/2;\n\n\n// Section: Quantization\n\n// Function: quant()\n// Synopsis: Returns `x` quantized to the nearest integer multiple of `y`.\n// Topics: Math, Quantization\n// See Also: quant(), quantdn(), quantup()\n// Usage:\n//   num = quant(x, y);\n// Description:\n//   Quantize a value `x` to an integer multiple of `y`, rounding to the nearest multiple.\n//   The value of `y` does NOT have to be an integer.  If `x` is a list, then every item\n//   in that list will be recursively quantized.\n// Arguments:\n//   x = The value or list to quantize.\n//   y = Positive quantum to quantize to\n// Example:\n//   a = quant(12,4);    // Returns: 12\n//   b = quant(13,4);    // Returns: 12\n//   c = quant(13.1,4);  // Returns: 12\n//   d = quant(14,4);    // Returns: 16\n//   e = quant(14.1,4);  // Returns: 16\n//   f = quant(15,4);    // Returns: 16\n//   g = quant(16,4);    // Returns: 16\n//   h = quant(9,3);     // Returns: 9\n//   i = quant(10,3);    // Returns: 9\n//   j = quant(10.4,3);  // Returns: 9\n//   k = quant(10.5,3);  // Returns: 12\n//   l = quant(11,3);    // Returns: 12\n//   m = quant(12,3);    // Returns: 12\n//   n = quant(11,2.5);  // Returns: 10\n//   o = quant(12,2.5);  // Returns: 12.5\n//   p = quant([12,13,13.1,14,14.1,15,16],4);  // Returns: [12,12,12,16,16,16,16]\n//   q = quant([9,10,10.4,10.5,11,12],3);      // Returns: [9,9,9,12,12,12]\n//   r = quant([[9,10,10.4],[10.5,11,12]],3);  // Returns: [[9,9,9],[12,12,12]]\nfunction quant(x,y) =\n    assert( is_finite(y) && y>0, \"The quantum `y` must be a positive value.\")\n    is_num(x) ? round(x/y)*y \n              : _roundall(x/y)*y;\n\nfunction _roundall(data) =\n    [for(x=data) is_list(x) ? _roundall(x) : round(x)];\n\n\n// Function: quantdn()\n// Synopsis: Returns `x` quantized down to an integer multiple of `y`.\n// Topics: Math, Quantization\n// See Also: quant(), quantdn(), quantup()\n// Usage:\n//   num = quantdn(x, y);\n// Description:\n//   Quantize a value `x` to an integer multiple of `y`, rounding down to the previous multiple.\n//   The value of `y` does NOT have to be an integer.  If `x` is a list, then every item in that\n//   list will be recursively quantized down.\n// Arguments:\n//   x = The value or list to quantize.\n//   y = Postive quantum to quantize to. \n// Example:\n//   a = quantdn(12,4);    // Returns: 12\n//   b = quantdn(13,4);    // Returns: 12\n//   c = quantdn(13.1,4);  // Returns: 12\n//   d = quantdn(14,4);    // Returns: 12\n//   e = quantdn(14.1,4);  // Returns: 12\n//   f = quantdn(15,4);    // Returns: 12\n//   g = quantdn(16,4);    // Returns: 16\n//   h = quantdn(9,3);     // Returns: 9\n//   i = quantdn(10,3);    // Returns: 9\n//   j = quantdn(10.4,3);  // Returns: 9\n//   k = quantdn(10.5,3);  // Returns: 9\n//   l = quantdn(11,3);    // Returns: 9\n//   m = quantdn(12,3);    // Returns: 12\n//   n = quantdn(11,2.5);  // Returns: 10\n//   o = quantdn(12,2.5);  // Returns: 10\n//   p = quantdn([12,13,13.1,14,14.1,15,16],4);  // Returns: [12,12,12,12,12,12,16]\n//   q = quantdn([9,10,10.4,10.5,11,12],3);      // Returns: [9,9,9,9,9,12]\n//   r = quantdn([[9,10,10.4],[10.5,11,12]],3);  // Returns: [[9,9,9],[9,9,12]]\nfunction quantdn(x,y) =\n    assert( is_finite(y) && y>0, \"The quantum `y` must be a positive value.\")\n    is_num(x) ? floor(x/y)*y \n              : _floorall(x/y)*y;\n\nfunction _floorall(data) =\n    [for(x=data) is_list(x) ? _floorall(x) : floor(x)];\n\n\n// Function: quantup()\n// Synopsis: Returns `x` quantized uo to an integer multiple of `y`.\n// Topics: Math, Quantization\n// See Also: quant(), quantdn(), quantup()\n// Usage:\n//   num = quantup(x, y);\n// Description:\n//   Quantize a value `x` to an integer multiple of `y`, rounding up to the next multiple.\n//   The value of `y` does NOT have to be an integer.  If `x` is a list, then every item in\n//   that list will be recursively quantized up.\n// Arguments:\n//   x = The value or list to quantize.\n//   y = Positive quantum to quantize to.\n// Example:\n//   a = quantup(12,4);    // Returns: 12\n//   b = quantup(13,4);    // Returns: 16\n//   c = quantup(13.1,4);  // Returns: 16\n//   d = quantup(14,4);    // Returns: 16\n//   e = quantup(14.1,4);  // Returns: 16\n//   f = quantup(15,4);    // Returns: 16\n//   g = quantup(16,4);    // Returns: 16\n//   h = quantup(9,3);     // Returns: 9\n//   i = quantup(10,3);    // Returns: 12\n//   j = quantup(10.4,3);  // Returns: 12\n//   k = quantup(10.5,3);  // Returns: 12\n//   l = quantup(11,3);    // Returns: 12\n//   m = quantup(12,3);    // Returns: 12\n//   n = quantdn(11,2.5);  // Returns: 12.5\n//   o = quantdn(12,2.5);  // Returns: 12.5\n//   p = quantup([12,13,13.1,14,14.1,15,16],4);  // Returns: [12,16,16,16,16,16,16]\n//   q = quantup([9,10,10.4,10.5,11,12],3);      // Returns: [9,12,12,12,12,12]\n//   r = quantup([[9,10,10.4],[10.5,11,12]],3);  // Returns: [[9,12,12],[12,12,12]]\nfunction quantup(x,y) =\n    assert( is_finite(y) && y>0, \"The quantum `y` must be a positive value.\")\n    is_num(x) ? ceil(x/y)*y \n              : _ceilall(x/y)*y;\n\nfunction _ceilall(data) =\n    [for(x=data) is_list(x) ? _ceilall(x) : ceil(x)];\n\n\n// Section: Constraints and Modulos\n\n// Function: constrain()\n// Synopsis: Returns a value constrained between `minval` and `maxval`, inclusive.\n// Topics: Math\n// See Also: posmod(), modang()\n// Usage:\n//   val = constrain(v, minval, maxval);\n// Description:\n//   Constrains value to a range of values between minval and maxval, inclusive.\n// Arguments:\n//   v = value to constrain.\n//   minval = minimum value to return, if out of range.\n//   maxval = maximum value to return, if out of range.\n// Example:\n//   a = constrain(-5, -1, 1);   // Returns: -1\n//   b = constrain(5, -1, 1);    // Returns: 1\n//   c = constrain(0.3, -1, 1);  // Returns: 0.3\n//   d = constrain(9.1, 0, 9);   // Returns: 9\n//   e = constrain(-0.1, 0, 9);  // Returns: 0\nfunction constrain(v, minval, maxval) = \n    assert( is_finite(v+minval+maxval), \"Input must be finite number(s).\")\n    min(maxval, max(minval, v));\n\n\n// Function: posmod()\n// Synopsis: Returns the positive modulo of a value.\n// Topics: Math\n// See Also: constrain(), posmod(), modang()\n// Usage:\n//   mod = posmod(x, m)\n// Description:\n//   Returns the positive modulo `m` of `x`.  Value returned will be in the range 0 ... `m`-1.\n// Arguments:\n//   x = The value to constrain.\n//   m = Modulo value.\n// Example:\n//   a = posmod(-700,360);  // Returns: 340\n//   b = posmod(-270,360);  // Returns: 90\n//   c = posmod(-120,360);  // Returns: 240\n//   d = posmod(120,360);   // Returns: 120\n//   e = posmod(270,360);   // Returns: 270\n//   f = posmod(700,360);   // Returns: 340\n//   g = posmod(3,2.5);     // Returns: 0.5\nfunction posmod(x,m) = \n    assert( is_finite(x) && is_finite(m) && !approx(m,0) , \"Input must be finite numbers. The divisor cannot be zero.\")\n    (x%m+m)%m;\n\n\n// Function: modang()\n// Synopsis: Returns an angle normalized to between -180\u00ba and 180\u00ba.\n// Topics: Math\n// See Also: constrain(), posmod(), modang()\n// Usage:\n//   ang = modang(x);\n// Description:\n//   Takes an angle in degrees and normalizes it to an equivalent angle value between -180 and 180.\n// Example:\n//   a1 = modang(-700);  // Returns: 20\n//   a2 = modang(-270);  // Returns: 90\n//   a3 = modang(-120);  // Returns: -120\n//   a4 = modang(120);   // Returns: 120\n//   a5 = modang(270);   // Returns: -90\n//   a6 = modang(700);   // Returns: -20\nfunction modang(x) =\n    assert( is_finite(x), \"Input must be a finite number.\")\n    let(xx = posmod(x,360)) xx<180? xx : xx-360;\n\n\n\n// Section: Operations on Lists (Sums, Mean, Products)\n\n// Function: sum()\n// Synopsis: Returns the sum of a list of values.\n// Topics: Math\n// See Also: mean(), median(), product(), cumsum()\n// Usage:\n//   x = sum(v, [dflt]);\n// Description:\n//   Returns the sum of all entries in the given consistent list.\n//   If passed an array of vectors, returns the sum the vectors.\n//   If passed an array of matrices, returns the sum of the matrices.\n//   If passed an empty list, the value of `dflt` will be returned.\n// Arguments:\n//   v = The list to get the sum of.\n//   dflt = The default value to return if `v` is an empty list.  Default: 0\n// Example:\n//   sum([1,2,3]);  // returns 6.\n//   sum([[1,2,3], [3,4,5], [5,6,7]]);  // returns [9, 12, 15]\nfunction sum(v, dflt=0) =\n    v==[]? dflt :\n    assert(is_consistent(v), \"Input to sum is non-numeric or inconsistent\")\n    is_finite(v[0]) || is_vector(v[0]) ? [for(i=v) 1]*v :\n    _sum(v,v[0]*0);\n\nfunction _sum(v,_total,_i=0) = _i>=len(v) ? _total : _sum(v,_total+v[_i], _i+1);\n\n\n\n\n// Function: mean()\n// Synopsis: Returns the mean value of a list of values.\n// Topics: Math, Statistics\n// See Also: sum(), mean(), median(), product()\n// Usage:\n//   x = mean(v);\n// Description:\n//   Returns the arithmetic mean/average of all entries in the given array.\n//   If passed a list of vectors, returns a vector of the mean of each part.\n// Arguments:\n//   v = The list of values to get the mean of.\n// Example:\n//   mean([2,3,4]);  // returns 3.\n//   mean([[1,2,3], [3,4,5], [5,6,7]]);  // returns [3, 4, 5]\nfunction mean(v) = \n    assert(is_list(v) && len(v)>0, \"Invalid list.\")\n    sum(v)/len(v);\n\n\n\n// Function: median()\n// Synopsis: Returns the median value of a list of values.\n// Topics: Math, Statistics\n// See Also: sum(), mean(), median(), product()\n// Usage:\n//   middle = median(v)\n// Description:\n//   Returns the median of the given vector.  \nfunction median(v) =\n    assert(is_vector(v), \"Input to median must be a vector\")\n    len(v)%2 ? max( list_smallest(v, ceil(len(v)/2)) ) :\n    let( lowest = list_smallest(v, len(v)/2 + 1),\n         max  = max(lowest),\n         imax = search(max,lowest,1),\n         max2 = max([for(i=idx(lowest)) if(i!=imax[0]) lowest[i] ])\n    )\n    (max+max2)/2;\n\n\n// Function: deltas()\n// Synopsis: Returns the deltas between a list of values.\n// Topics: Math, Statistics\n// See Also: sum(), mean(), median(), product()\n// Usage:\n//   delts = deltas(v,[wrap]);\n// Description:\n//   Returns a list with the deltas of adjacent entries in the given list, optionally wrapping back to the front.\n//   The list should be a consistent list of numeric components (numbers, vectors, matrix, etc).\n//   Given [a,b,c,d], returns [b-a,c-b,d-c].\n// Arguments:\n//   v = The list to get the deltas of.\n//   wrap = If true, wrap back to the start from the end.  ie: return the difference between the last and first items as the last delta.  Default: false\n// Example:\n//   deltas([2,5,9,17]);  // returns [3,4,8].\n//   deltas([[1,2,3], [3,6,8], [4,8,11]]);  // returns [[2,4,5], [1,2,3]]\nfunction deltas(v, wrap=false) = \n    assert( is_consistent(v) && len(v)>1 , \"Inconsistent list or with length<=1.\")\n    [for (p=pair(v,wrap)) p[1]-p[0]] ;\n\n\n// Function: cumsum()\n// Synopsis: Returns the running cumulative sum of a list of values.\n// Topics: Math, Statistics\n// See Also: sum(), mean(), median(), product()\n// Usage:\n//   sums = cumsum(v);\n// Description:\n//   Returns a list where each item is the cumulative sum of all items up to and including the corresponding entry in the input list.\n//   If passed an array of vectors, returns a list of cumulative vectors sums.\n// Arguments:\n//   v = The list to get the sum of.\n// Example:\n//   cumsum([1,1,1]);  // returns [1,2,3]\n//   cumsum([2,2,2]);  // returns [2,4,6]\n//   cumsum([1,2,3]);  // returns [1,3,6]\n//   cumsum([[1,2,3], [3,4,5], [5,6,7]]);  // returns [[1,2,3], [4,6,8], [9,12,15]]\nfunction cumsum(v) =\n    assert(is_consistent(v), \"The input is not consistent.\" )\n    len(v)<=1 ? v :\n    _cumsum(v,_i=1,_acc=[v[0]]);\n\nfunction _cumsum(v,_i=0,_acc=[]) =\n   _i>=len(v) ? _acc :\n    _cumsum( v, _i+1, [ each _acc, _acc[len(_acc)-1] + v[_i] ] );\n\n\n\n// Function: product()\n// Synopsis: Returns the multiplicative product of a list of values.\n// Topics: Math, Statistics\n// See Also: sum(), mean(), median(), product(), cumsum()\n// Usage:\n//   x = product(v);\n// Description:\n//   Returns the product of all entries in the given list.\n//   If passed a list of vectors of same dimension, returns a vector of products of each part.\n//   If passed a list of square matrices, returns the resulting product matrix.\n// Arguments:\n//   v = The list to get the product of.\n// Example:\n//   product([2,3,4]);  // returns 24.\n//   product([[1,2,3], [3,4,5], [5,6,7]]);  // returns [15, 48, 105]\nfunction product(v) = \n    assert( is_vector(v) || is_matrix(v) || ( is_matrix(v[0],square=true) && is_consistent(v)), \n    \"Invalid input.\")\n    _product(v, 1, v[0]);\n\nfunction _product(v, i=0, _tot) = \n    i>=len(v) ? _tot :\n    _product( v, \n              i+1, \n              ( is_vector(v[i])? v_mul(_tot,v[i]) : _tot*v[i] ) );\n               \n\n\n// Function: cumprod()\n// Synopsis: Returns the running cumulative product of a list of values.\n// Topics: Math, Statistics\n// See Also: sum(), mean(), median(), product(), cumsum()\n// Usage:\n//   prod_list = cumprod(list, [right]);\n// Description:\n//   Returns a list where each item is the cumulative product of all items up to and including the corresponding entry in the input list.\n//   If passed an array of vectors, returns a list of elementwise vector products.  If passed a list of square matrices by default returns matrix\n//   products multiplying on the left, so a list `[A,B,C]` will produce the output `[A,BA,CBA]`.  If you set `right=true` then it returns\n//   the product of multiplying on the right, so a list `[A,B,C]` will produce the output `[A,AB,ABC]` in that case.\n// Arguments:\n//   list = The list to get the cumulative product of.\n//   right = if true multiply matrices on the right\n// Example:\n//   cumprod([1,3,5]);  // returns [1,3,15]\n//   cumprod([2,2,2]);  // returns [2,4,8]\n//   cumprod([[1,2,3], [3,4,5], [5,6,7]]));  // returns [[1, 2, 3], [3, 8, 15], [15, 48, 105]]\nfunction cumprod(list,right=false) =\n   is_vector(list) ? _cumprod(list) :\n   assert(is_consistent(list), \"Input must be a consistent list of scalars, vectors or square matrices\")\n   assert(is_bool(right))\n   is_matrix(list[0]) ? assert(len(list[0])==len(list[0][0]), \"Matrices must be square\") _cumprod(list,right) \n                      : _cumprod_vec(list);\n\nfunction _cumprod(v,right,_i=0,_acc=[]) = \n    _i==len(v) ? _acc :\n    _cumprod(\n        v, right, _i+1,\n        concat(\n            _acc,\n            [\n              _i==0 ? v[_i]\n             : right? _acc[len(_acc)-1]*v[_i]\n             : v[_i]*_acc[len(_acc)-1]\n            ]\n        )\n    );\n\nfunction _cumprod_vec(v,_i=0,_acc=[]) =\n    _i==len(v) ? _acc :\n    _cumprod_vec(\n        v, _i+1,\n        concat(\n            _acc,\n            [_i==0 ? v[_i] : v_mul(_acc[len(_acc)-1],v[_i])]\n        )\n    );\n\n\n\n// Function: convolve()\n// Synopsis: Returns the convolution of `p` and `q`.\n// Topics: Math, Statistics\n// See Also: sum(), mean(), median(), product(), cumsum()\n// Usage:\n//   x = convolve(p,q);\n// Description:\n//   Given two vectors, or one vector and a path or\n//   two paths of the same dimension, finds the convolution of them.\n//   If both parameter are vectors, returns the vector convolution.\n//   If one parameter is a vector and the other a path,\n//   convolves using products by scalars and returns a path. \n//   If both parameters are paths, convolve using scalar products\n//   and returns a vector.\n//   The returned vector or path has length len(p)+len(q)-1.\n// Arguments:\n//   p = The first vector or path.\n//   q = The second vector or path.\n// Example:\n//   a = convolve([1,1],[1,2,1]); // Returns: [1,3,3,1]\n//   b = convolve([1,2,3],[1,2,1])); // Returns: [1,4,8,8,3]\n//   c = convolve([[1,1],[2,2],[3,1]],[1,2,1])); // Returns: [[1,1],[4,4],[8,6],[8,4],[3,1]]\n//   d = convolve([[1,1],[2,2],[3,1]],[[1,2],[2,1]])); // Returns:  [3,9,11,7]\nfunction convolve(p,q) =\n    p==[] || q==[] ? [] :\n    assert( (is_vector(p) || is_matrix(p))\n            && ( is_vector(q) || (is_matrix(q) && ( !is_vector(p[0]) || (len(p[0])==len(q[0])) ) ) ) ,\n            \"The inputs should be vectors or paths all of the same dimension.\")\n    let( n = len(p),\n         m = len(q))\n    [for(i=[0:n+m-2], k1 = max(0,i-n+1), k2 = min(i,m-1) )\n       sum([for(j=[k1:k2]) p[i-j]*q[j] ]) \n    ];\n\n\n\n// Function: sum_of_sines()\n// Synopsis: Returns the sum of one or more sine waves at a given angle.\n// Topics: Math, Statistics\n// See Also: sum(), mean(), median(), product(), cumsum()\n// Usage:\n//   sum_of_sines(a,sines)\n// Description:\n//   Given a list of sine waves, returns the sum of the sines at the given angle.\n//   Each sine wave is given as an `[AMPLITUDE, FREQUENCY, PHASE_ANGLE]` triplet.\n//   - `AMPLITUDE` is the height of the sine wave above (and below) `0`.\n//   - `FREQUENCY` is the number of times the sine wave repeats in 360\u00ba.\n//   - `PHASE_ANGLE` is the offset in degrees of the sine wave.\n// Arguments:\n//   a = Angle to get the value for.\n//   sines = List of [amplitude, frequency, phase_angle] items, where the frequency is the number of times the cycle repeats around the circle.\n// Example:\n//   v = sum_of_sines(30, [[10,3,0], [5,5.5,60]]);\nfunction sum_of_sines(a, sines) =\n    assert( is_finite(a) && is_matrix(sines,undef,3), \"Invalid input.\")\n    sum([ for (s = sines) \n            let(\n              ss=point3d(s),\n              v=ss[0]*sin(a*ss[1]+ss[2])\n            ) v\n        ]);\n\n\n\n// Section: Random Number Generation\n\n// Function: rand_int()\n// Synopsis: Returns a random integer.\n// Topics: Random\n// See Also: rand_int(), random_points(), gaussian_rands(), random_polygon(), spherical_random_points(), exponential_rands()\n// Usage:\n//   rand_int(minval, maxval, n, [seed]);\n// Description:\n//   Return a list of random integers in the range of minval to maxval, inclusive.\n// Arguments:\n//   minval = Minimum integer value to return.\n//   maxval = Maximum integer value to return.\n//   N = Number of random integers to return.\n//   seed = If given, sets the random number seed.\n// Example:\n//   ints = rand_int(0,100,3);\n//   int = rand_int(-10,10,1)[0];\nfunction rand_int(minval, maxval, n, seed=undef) =\n    assert( is_finite(minval+maxval+n) && (is_undef(seed) || is_finite(seed) ), \"Input must be finite numbers.\")\n    assert(maxval >= minval, \"Max value cannot be smaller than minval\")\n    let (rvect = is_def(seed) ? rands(minval,maxval+1,n,seed) : rands(minval,maxval+1,n))\n    [for(entry = rvect) floor(entry)];\n\n\n// Function: random_points()\n// Synopsis: Returns a list of random points.\n// Topics: Random, Points\n// See Also: rand_int(), random_points(), random_polygon(), spherical_random_points()\n// Usage:\n//    points = random_points(n, dim, [scale], [seed]);\n// Description:\n//    Generate `n` uniform random points of dimension `dim` with data ranging from -scale to +scale.  \n//    The `scale` may be a number, in which case the random data lies in a cube,\n//    or a vector with dimension `dim`, in which case each dimension has its own scale.  \n// Arguments:\n//    n = number of points to generate. Default: 1\n//    dim = dimension of the points. Default: 2\n//    scale = the scale of the point coordinates. Default: 1\n//    seed = an optional seed for the random generation.\nfunction random_points(n, dim, scale=1, seed) =\n    assert( is_int(n) && n>=0, \"The number of points should be a non-negative integer.\")\n    assert( is_int(dim) && dim>=1, \"The point dimensions should be an integer greater than 1.\")\n    assert( is_finite(scale) || is_vector(scale,dim), \"The scale should be a number or a vector with length equal to d.\")\n    let( \n        rnds =   is_undef(seed) \n                ? rands(-1,1,n*dim)\n                : rands(-1,1,n*dim, seed) )\n    is_num(scale) \n    ? scale*[for(i=[0:1:n-1]) [for(j=[0:dim-1]) rnds[i*dim+j] ] ]\n    : [for(i=[0:1:n-1]) [for(j=[0:dim-1]) scale[j]*rnds[i*dim+j] ] ];\n\n\n// Function: gaussian_rands()\n// Synopsis: Returns a list of random numbers with a gaussian distribution.\n// Topics: Random, Statistics\n// See Also: rand_int(), random_points(), gaussian_rands(), random_polygon(), spherical_random_points(), exponential_rands()\n// Usage:\n//   arr = gaussian_rands([n],[mean], [cov], [seed]);\n// Description:\n//   Returns a random number or vector with a Gaussian/normal distribution.\n// Arguments:\n//   n = the number of points to return.  Default: 1\n//   mean = The average of the random value (a number or vector).  Default: 0\n//   cov = covariance matrix of the random numbers, or variance in the 1D case. Default: 1\n//   seed = If given, sets the random number seed.\nfunction gaussian_rands(n=1, mean=0, cov=1, seed=undef) =\n    assert(is_num(mean) || is_vector(mean))\n    let(\n        dim = is_num(mean) ? 1 : len(mean)\n    )\n    assert((dim==1 && is_num(cov)) || is_matrix(cov,dim,dim),\"mean and covariance matrix not compatible\")\n    assert(is_undef(seed) || is_finite(seed))\n    let(\n         nums = is_undef(seed)? rands(0,1,dim*n*2) : rands(0,1,dim*n*2,seed),\n         rdata = [for (i = count(dim*n,0,2)) sqrt(-2*ln(nums[i]))*cos(360*nums[i+1])]\n    )\n    dim==1 ? add_scalar(sqrt(cov)*rdata,mean) :\n    assert(is_matrix_symmetric(cov),\"Supplied covariance matrix is not symmetric\")\n    let(\n        L = cholesky(cov)\n    )\n    assert(is_def(L), \"Supplied covariance matrix is not positive definite\")\n    move(mean,list_to_matrix(rdata,dim)*transpose(L));\n\n\n// Function: exponential_rands()\n// Synopsis: Returns a list of random numbers with an exponential distribution.\n// Topics: Random, Statistics\n// See Also: rand_int(), random_points(), gaussian_rands(), random_polygon(), spherical_random_points()\n// Usage:\n//   arr = exponential_rands([n], [lambda], [seed])\n// Description:\n//   Returns random numbers with an exponential distribution with parameter lambda, and hence mean 1/lambda.  \n// Arguments:\n//   n = number of points to return.  Default: 1\n//   lambda = distribution parameter.  The mean will be 1/lambda.  Default: 1\nfunction exponential_rands(n=1, lambda=1, seed) =\n    assert( is_int(n) && n>=1, \"The number of points should be an integer greater than zero.\")\n    assert( is_num(lambda) && lambda>0, \"The lambda parameter must be a positive number.\")\n    let(\n         unif = is_def(seed) ? rands(0,1,n,seed=seed) : rands(0,1,n)\n    )\n    -(1/lambda) * [for(x=unif) x==1 ? 708.3964185322641 : ln(1-x)];  // Use ln(min_float) when x is 1\n\n\n// Function: spherical_random_points()\n// Synopsis: Returns a list of random points on the surface of a sphere.\n// Topics: Random, Points\n// See Also: rand_int(), random_points(), gaussian_rands(), random_polygon(), spherical_random_points()\n// Usage:\n//    points = spherical_random_points([n], [radius], [seed]);\n// Description:\n//    Generate `n` 3D uniformly distributed random points lying on a sphere centered at the origin with radius equal to `radius`.\n// Arguments:\n//    n = number of points to generate. Default: 1\n//    radius = the sphere radius. Default: 1\n//    seed = an optional seed for the random generation.\n\n// See https://mathworld.wolfram.com/SpherePointPicking.html\nfunction spherical_random_points(n=1, radius=1, seed) =\n    assert( is_int(n) && n>=1, \"The number of points should be an integer greater than zero.\")\n    assert( is_num(radius) && radius>0, \"The radius should be a non-negative number.\")\n    let( theta = is_undef(seed) \n                ? rands(0,360,n)\n                : rands(0,360,n, seed),\n         cosphi = rands(-1,1,n))\n    [for(i=[0:1:n-1]) let(\n                          sin_phi=sqrt(1-cosphi[i]*cosphi[i])\n                      )\n                      radius*[sin_phi*cos(theta[i]),sin_phi*sin(theta[i]), cosphi[i]]];\n\n\n\n// Function: random_polygon()\n// Synopsis: Returns the CCW path of a simple random polygon.\n// Topics: Random, Polygon\n// See Also: random_points(), spherical_random_points()\n// Usage:\n//    points = random_polygon([n], [size], [seed]);\n// Description:\n//    Generate the `n` vertices of a random counter-clockwise simple 2d polygon \n//    inside a circle centered at the origin with radius `size`.\n// Arguments:\n//    n = number of vertices of the polygon. Default: 3\n//    size = the radius of a circle centered at the origin containing the polygon. Default: 1\n//    seed = an optional seed for the random generation.\nfunction random_polygon(n=3,size=1, seed) =\n    assert( is_int(n) && n>2, \"Improper number of polygon vertices.\")\n    assert( is_num(size) && size>0, \"Improper size.\")\n    let( \n        seed = is_undef(seed) ? rands(0,1,1)[0] : seed,\n        cumm = cumsum(rands(0.1,10,n+1,seed)),\n        angs = 360*cumm/cumm[n-1],\n        rads = rands(.01,size,n,seed+cumm[0])\n      )\n    [for(i=count(n)) rads[i]*[cos(angs[i]), sin(angs[i])] ];\n\n\n\n// Section: Calculus\n\n// Function: deriv()\n// Synopsis: Returns the first derivative estimate of a list of data.\n// Topics: Math, Calculus\n// See Also: deriv(), deriv2(), deriv3()\n// Usage:\n//   x = deriv(data, [h], [closed])\n// Description:\n//   Computes a numerical derivative estimate of the data, which may be scalar or vector valued.\n//   The `h` parameter gives the step size of your sampling so the derivative can be scaled correctly. \n//   If the `closed` parameter is true the data is assumed to be defined on a loop with data[0] adjacent to\n//   data[len(data)-1].  This function uses a symetric derivative approximation\n//   for internal points, f'(t) = (f(t+h)-f(t-h))/2h.  For the endpoints (when closed=false) the algorithm\n//   uses a two point method if sufficient points are available: f'(t) = (3*(f(t+h)-f(t)) - (f(t+2*h)-f(t+h)))/2h.\n//   .\n//   If `h` is a vector then it is assumed to be nonuniform, with h[i] giving the sampling distance\n//   between data[i+1] and data[i], and the data values will be linearly resampled at each corner\n//   to produce a uniform spacing for the derivative estimate.  At the endpoints a single point method\n//   is used: f'(t) = (f(t+h)-f(t))/h.  \n// Arguments:\n//   data = the list of the elements to compute the derivative of.\n//   h = the parametric sampling of the data.\n//   closed = boolean to indicate if the data set should be wrapped around from the end to the start.\nfunction deriv(data, h=1, closed=false) =\n    assert( is_consistent(data) , \"Input list is not consistent or not numerical.\") \n    assert( len(data)>=2, \"Input `data` should have at least 2 elements.\") \n    assert( is_finite(h) || is_vector(h), \"The sampling `h` must be a number or a list of numbers.\" )\n    assert( is_num(h) || len(h) == len(data)-(closed?0:1),\n            str(\"Vector valued `h` must have length \",len(data)-(closed?0:1)))\n    is_vector(h) ? _deriv_nonuniform(data, h, closed=closed) :\n    let( L = len(data) )\n    closed\n    ? [\n        for(i=[0:1:L-1])\n        (data[(i+1)%L]-data[(L+i-1)%L])/2/h\n      ]\n    : let(\n        first = L<3 ? data[1]-data[0] : \n                3*(data[1]-data[0]) - (data[2]-data[1]),\n        last = L<3 ? data[L-1]-data[L-2]:\n               (data[L-3]-data[L-2])-3*(data[L-2]-data[L-1])\n         ) \n      [\n        first/2/h,\n        for(i=[1:1:L-2]) (data[i+1]-data[i-1])/2/h,\n        last/2/h\n      ];\n\n\nfunction _dnu_calc(f1,fc,f2,h1,h2) =\n    let(\n        f1 = h2<h1 ? lerp(fc,f1,h2/h1) : f1 , \n        f2 = h1<h2 ? lerp(fc,f2,h1/h2) : f2\n       )\n    (f2-f1) / 2 / min(h1,h2);\n\n\nfunction _deriv_nonuniform(data, h, closed) =\n    let( L = len(data) )\n    closed\n    ? [for(i=[0:1:L-1])\n          _dnu_calc(data[(L+i-1)%L], data[i], data[(i+1)%L], select(h,i-1), h[i]) ]\n    : [\n        (data[1]-data[0])/h[0],\n        for(i=[1:1:L-2]) _dnu_calc(data[i-1],data[i],data[i+1], h[i-1],h[i]),\n        (data[L-1]-data[L-2])/h[L-2]                            \n      ];\n\n\n// Function: deriv2()\n// Synopsis: Returns the second derivative estimate of a list of data.\n// Topics: Math, Calculus\n// See Also: deriv(), deriv2(), deriv3()\n// Usage:\n//   x = deriv2(data, [h], [closed])\n// Description:\n//   Computes a numerical estimate of the second derivative of the data, which may be scalar or vector valued.\n//   The `h` parameter gives the step size of your sampling so the derivative can be scaled correctly. \n//   If the `closed` parameter is true the data is assumed to be defined on a loop with data[0] adjacent to\n//   data[len(data)-1].  For internal points this function uses the approximation \n//   f''(t) = (f(t-h)-2*f(t)+f(t+h))/h^2.  For the endpoints (when closed=false),\n//   when sufficient points are available, the method is either the four point expression\n//   f''(t) = (2*f(t) - 5*f(t+h) + 4*f(t+2*h) - f(t+3*h))/h^2 or \n//   f''(t) = (35*f(t) - 104*f(t+h) + 114*f(t+2*h) - 56*f(t+3*h) + 11*f(t+4*h)) / 12h^2\n//   if five points are available.\n// Arguments:\n//   data = the list of the elements to compute the derivative of.\n//   h = the constant parametric sampling of the data.\n//   closed = boolean to indicate if the data set should be wrapped around from the end to the start.\nfunction deriv2(data, h=1, closed=false) =\n    assert( is_consistent(data) , \"Input list is not consistent or not numerical.\") \n    assert( is_finite(h), \"The sampling `h` must be a number.\" )\n    let( L = len(data) )\n    assert( L>=3, \"Input list has less than 3 elements.\") \n    closed\n    ? [\n        for(i=[0:1:L-1])\n        (data[(i+1)%L]-2*data[i]+data[(L+i-1)%L])/h/h\n      ]\n    :\n    let(\n        first = \n            L==3? data[0] - 2*data[1] + data[2] :\n            L==4? 2*data[0] - 5*data[1] + 4*data[2] - data[3] :\n            (35*data[0] - 104*data[1] + 114*data[2] - 56*data[3] + 11*data[4])/12, \n        last = \n            L==3? data[L-1] - 2*data[L-2] + data[L-3] :\n            L==4? -2*data[L-1] + 5*data[L-2] - 4*data[L-3] + data[L-4] :\n            (35*data[L-1] - 104*data[L-2] + 114*data[L-3] - 56*data[L-4] + 11*data[L-5])/12\n    ) [\n        first/h/h,\n        for(i=[1:1:L-2]) (data[i+1]-2*data[i]+data[i-1])/h/h,\n        last/h/h\n    ];\n\n\n// Function: deriv3()\n// Synopsis: Returns the third derivative estimate of a list of data.\n// Topics: Math, Calculus\n// See Also: deriv(), deriv2(), deriv3()\n// Usage:\n//   x = deriv3(data, [h], [closed])\n// Description:\n//   Computes a numerical third derivative estimate of the data, which may be scalar or vector valued.\n//   The `h` parameter gives the step size of your sampling so the derivative can be scaled correctly. \n//   If the `closed` parameter is true the data is assumed to be defined on a loop with data[0] adjacent to\n//   data[len(data)-1].  This function uses a five point derivative estimate, so the input data must include \n//   at least five points:\n//   f'''(t) = (-f(t-2*h)+2*f(t-h)-2*f(t+h)+f(t+2*h)) / 2h^3.  At the first and second points from the end\n//   the estimates are f'''(t) = (-5*f(t)+18*f(t+h)-24*f(t+2*h)+14*f(t+3*h)-3*f(t+4*h)) / 2h^3 and\n//   f'''(t) = (-3*f(t-h)+10*f(t)-12*f(t+h)+6*f(t+2*h)-f(t+3*h)) / 2h^3.\n// Arguments:\n//   data = the list of the elements to compute the derivative of.\n//   h = the constant parametric sampling of the data.\n//   closed = boolean to indicate if the data set should be wrapped around from the end to the start.\nfunction deriv3(data, h=1, closed=false) =\n    assert( is_consistent(data) , \"Input list is not consistent or not numerical.\") \n    assert( len(data)>=5, \"Input list has less than 5 elements.\") \n    assert( is_finite(h), \"The sampling `h` must be a number.\" )\n    let(\n        L = len(data),\n        h3 = h*h*h\n    )\n    closed? [\n        for(i=[0:1:L-1])\n        (-data[(L+i-2)%L]+2*data[(L+i-1)%L]-2*data[(i+1)%L]+data[(i+2)%L])/2/h3\n    ] :\n    let(\n        first=(-5*data[0]+18*data[1]-24*data[2]+14*data[3]-3*data[4])/2,\n        second=(-3*data[0]+10*data[1]-12*data[2]+6*data[3]-data[4])/2,\n        last=(5*data[L-1]-18*data[L-2]+24*data[L-3]-14*data[L-4]+3*data[L-5])/2,\n        prelast=(3*data[L-1]-10*data[L-2]+12*data[L-3]-6*data[L-4]+data[L-5])/2\n    ) [\n        first/h3,\n        second/h3,\n        for(i=[2:1:L-3]) (-data[i-2]+2*data[i-1]-2*data[i+1]+data[i+2])/2/h3,\n        prelast/h3,\n        last/h3\n    ];\n\n\n// Section: Complex Numbers\n\n\n// Function: complex()\n// Synopsis: Replaces scalars in a list or matrix with complex number 2-vectors.\n// Topics: Math, Complex Numbers\n// See Also: c_mul(), c_div(), c_conj(), c_real(), c_imag(), c_ident(), c_norm()\n// Usage:\n//   z = complex(list)\n// Description:\n//   Converts a real valued number, vector or matrix into its complex analog\n//   by replacing all entries with a 2-vector that has zero imaginary part.\nfunction complex(list) =\n   is_num(list) ? [list,0] :\n   [for(entry=list) is_num(entry) ? [entry,0] : complex(entry)];\n\n\n// Function: c_mul()\n// Synopsis: Multiplies two complex numbers.\n// Topics: Math, Complex Numbers\n// See Also: complex(), c_mul(), c_div(), c_conj(), c_real(), c_imag(), c_ident(), c_norm()\n// Usage:\n//   c = c_mul(z1,z2)\n// Description:\n//   Multiplies two complex numbers, vectors or matrices, where complex numbers\n//   or entries are represented as vectors: [REAL, IMAGINARY].  Note that all\n//   entries in both arguments must be complex.  \n// Arguments:\n//   z1 = First complex number, vector or matrix\n//   z2 = Second complex number, vector or matrix\nfunction c_mul(z1,z2) =\n    is_matrix([z1,z2],2,2) ? _c_mul(z1,z2) :\n    _combine_complex(_c_mul(_split_complex(z1), _split_complex(z2)));\n\n\nfunction _split_complex(data) =\n    is_vector(data,2) ? data\n    : is_num(data[0][0]) ? [data*[1,0], data*[0,1]]\n    : [\n      [for(vec=data) vec * [1,0]],\n      [for(vec=data) vec * [0,1]]\n     ];\n\n\nfunction _combine_complex(data) =\n    is_vector(data,2) ? data\n    : is_num(data[0][0]) ? [for(i=[0:len(data[0])-1]) [data[0][i],data[1][i]]]\n    : [for(i=[0:1:len(data[0])-1])\n          [for(j=[0:1:len(data[0][0])-1])  \n              [data[0][i][j], data[1][i][j]]]];\n\n\nfunction _c_mul(z1,z2) = \n    [ z1.x*z2.x - z1.y*z2.y, z1.x*z2.y + z1.y*z2.x ];\n\n\n// Function: c_div()\n// Synopsis: Divides two complex numbers.\n// Topics: Math, Complex Numbers\n// See Also: complex(), c_mul(), c_div(), c_conj(), c_real(), c_imag(), c_ident(), c_norm()\n// Usage:\n//   x = c_div(z1,z2)\n// Description:\n//   Divides two complex numbers represented by 2D vectors.  \n//   Returns a complex number as a 2D vector [REAL, IMAGINARY].\n// Arguments:\n//   z1 = First complex number, given as a 2D vector [REAL, IMAGINARY]\n//   z2 = Second complex number, given as a 2D vector [REAL, IMAGINARY]\nfunction c_div(z1,z2) = \n    assert( is_vector(z1,2) && is_vector(z2), \"Complex numbers should be represented by 2D vectors.\" )\n    assert( !approx(z2,0), \"The divisor `z2` cannot be zero.\" ) \n    let(den = z2.x*z2.x + z2.y*z2.y)\n    [(z1.x*z2.x + z1.y*z2.y)/den, (z1.y*z2.x - z1.x*z2.y)/den];\n\n\n// Function: c_conj()\n// Synopsis: Returns the complex conjugate of the input.\n// Topics: Math, Complex Numbers\n// See Also: complex(), c_mul(), c_div(), c_conj(), c_real(), c_imag(), c_ident(), c_norm()\n// Usage:\n//   w = c_conj(z)\n// Description:\n//   Computes the complex conjugate of the input, which can be a complex number,\n//   complex vector or complex matrix.  \nfunction c_conj(z) =\n   is_vector(z,2) ? [z.x,-z.y] :\n   [for(entry=z) c_conj(entry)];\n\n\n// Function: c_real()\n// Synopsis: Returns the real part of a complex number, vector or matrix..\n// Topics: Math, Complex Numbers\n// See Also: complex(), c_mul(), c_div(), c_conj(), c_real(), c_imag(), c_ident(), c_norm()\n// Usage:\n//   x = c_real(z)\n// Description:\n//   Returns real part of a complex number, vector or matrix.\nfunction c_real(z) = \n     is_vector(z,2) ? z.x\n   : is_num(z[0][0]) ? z*[1,0]\n   : [for(vec=z) vec * [1,0]];\n\n\n// Function: c_imag()\n// Synopsis: Returns the imaginary part of a complex number, vector or matrix..\n// Topics: Math, Complex Numbers\n// See Also: complex(), c_mul(), c_div(), c_conj(), c_real(), c_imag(), c_ident(), c_norm()\n// Usage:\n//   x = c_imag(z)\n// Description:\n//   Returns imaginary part of a complex number, vector or matrix.\nfunction c_imag(z) = \n     is_vector(z,2) ? z.y\n   : is_num(z[0][0]) ? z*[0,1]\n   : [for(vec=z) vec * [0,1]];\n\n\n// Function: c_ident()\n// Synopsis: Returns an n by n complex identity matrix.\n// Topics: Math, Complex Numbers\n// See Also: complex(), c_mul(), c_div(), c_conj(), c_real(), c_imag(), c_ident(), c_norm()\n// Usage:\n//   I = c_ident(n)\n// Description:\n//   Produce an n by n complex identity matrix\nfunction c_ident(n) = [for (i = [0:1:n-1]) [for (j = [0:1:n-1]) (i==j)?[1,0]:[0,0]]];\n\n\n// Function: c_norm()\n// Synopsis: Returns the norm of a complex number or vector.\n// Topics: Math, Complex Numbers\n// See Also: complex(), c_mul(), c_div(), c_conj(), c_real(), c_imag(), c_ident(), c_norm()\n// Usage:\n//   n = c_norm(z)\n// Description:\n//   Compute the norm of a complex number or vector. \nfunction c_norm(z) = norm_fro(z);\n\n\n// Section: Polynomials\n\n// Function: quadratic_roots()\n// Synopsis: Computes roots for the quadratic equation.\n// Topics: Math, Geometry, Complex Numbers\n// See Also: quadratic_roots(), polynomial(), poly_mult(), poly_div(), poly_add()\n// Usage:\n//    roots = quadratic_roots(a, b, c, [real])\n// Description:\n//    Computes roots of the quadratic equation a*x^2+b*x+c==0, where the\n//    coefficients are real numbers.  If real is true then returns only the\n//    real roots.  Otherwise returns a pair of complex values.  This method\n//    may be more reliable than the general root finder at distinguishing\n//    real roots from complex roots.  \n//    Algorithm from: https://people.csail.mit.edu/bkph/articles/Quadratics.pdf\nfunction quadratic_roots(a,b,c,real=false) =\n  real ? [for(root = quadratic_roots(a,b,c,real=false)) if (root.y==0) root.x]\n  :\n  is_undef(b) && is_undef(c) && is_vector(a,3) ? quadratic_roots(a[0],a[1],a[2]) :\n  assert(is_num(a) && is_num(b) && is_num(c))\n  assert(a!=0 || b!=0 || c!=0, \"Quadratic must have a nonzero coefficient\")\n  a==0 && b==0 ? [] :     // No solutions\n  a==0 ? [[-c/b,0]] : \n  let(\n      descrim = b*b-4*a*c,\n      sqrt_des = sqrt(abs(descrim))\n  )\n  descrim < 0 ?             // Complex case\n     [[-b, sqrt_des],\n      [-b, -sqrt_des]]/2/a :\n  b<0 ?                     // b positive\n     [[2*c/(-b+sqrt_des),0],\n      [(-b+sqrt_des)/a/2,0]]\n      :                     // b negative\n     [[(-b-sqrt_des)/2/a, 0],\n      [2*c/(-b-sqrt_des),0]];\n\n\n// Function: polynomial() \n// Synopsis: Calculates a polynomial equation at a given value.\n// Topics: Math, Complex Numbers\n// See Also: quadratic_roots(), polynomial(), poly_mult(), poly_div(), poly_add(), poly_roots()\n// Usage:\n//   x = polynomial(p, z)\n// Description:\n//   Evaluates specified real polynomial, p, at the complex or real input value, z.\n//   The polynomial is specified as p=[a_n, a_{n-1},...,a_1,a_0]\n//   where a_n is the z^n coefficient.  Polynomial coefficients are real.\n//   The result is a number if `z` is a number and a complex number otherwise.\nfunction polynomial(p,z,k,total) =\n  is_undef(k)\n  ? assert( is_vector(p) , \"Input polynomial coefficients must be a vector.\" )\n    assert( is_finite(z) || is_vector(z,2), \"The value of `z` must be a real or a complex number.\" )\n    polynomial( _poly_trim(p), z, 0, is_num(z) ? 0 : [0,0])\n  : k==len(p) ? total\n  : polynomial(p,z,k+1, is_num(z) ? total*z+p[k] : c_mul(total,z)+[p[k],0]);\n\n\n// Function: poly_mult()\n// Synopsis: Returns the polynomial result of multiplying two polynomial equations.\n// Topics: Math\n// See Also: quadratic_roots(), polynomial(), poly_mult(), poly_div(), poly_add(), poly_roots()\n// Usage:\n//   x = polymult(p,q)\n//   x = polymult([p1,p2,p3,...])\n// Description:\n//   Given a list of polynomials represented as real algebraic coefficient lists, with the highest degree coefficient first, \n//   computes the coefficient list of the product polynomial.  \nfunction poly_mult(p,q) = \n  is_undef(q) ?\n    len(p)==2 \n        ? poly_mult(p[0],p[1]) \n    : poly_mult(p[0], poly_mult(list_tail(p)))\n  :\n  assert( is_vector(p) && is_vector(q),\"Invalid arguments to poly_mult\")\n    p*p==0 || q*q==0\n    ? [0]\n    : _poly_trim(convolve(p,q));\n\n    \n// Function: poly_div()\n// Synopsis: Returns the polynomial quotient and remainder results of dividing two polynomial equations.\n// Topics: Math\n// See Also: quadratic_roots(), polynomial(), poly_mult(), poly_div(), poly_add(), poly_roots()\n// Usage:\n//    [quotient,remainder] = poly_div(n,d)\n// Description:\n//    Computes division of the numerator polynomial by the denominator polynomial and returns\n//    a list of two polynomials, [quotient, remainder].  If the division has no remainder then\n//    the zero polynomial [0] is returned for the remainder.  Similarly if the quotient is zero\n//    the returned quotient will be [0].  \nfunction poly_div(n,d) =\n    assert( is_vector(n) && is_vector(d) , \"Invalid polynomials.\" )\n    let( d = _poly_trim(d), \n         n = _poly_trim(n) )\n    assert( d!=[0] , \"Denominator cannot be a zero polynomial.\" )\n    n==[0]\n    ? [[0],[0]]\n    : _poly_div(n,d,q=[]);\n\nfunction _poly_div(n,d,q) =\n    len(n)<len(d) ? [q,_poly_trim(n)] : \n    let(\n      t = n[0] / d[0], \n      newq = concat(q,[t]),\n      newn = [for(i=[1:1:len(n)-1]) i<len(d) ? n[i] - t*d[i] : n[i]]\n    )  \n    _poly_div(newn,d,newq);\n\n\n/// Internal Function: _poly_trim()\n/// Usage:\n///    _poly_trim(p, [eps])\n/// Description:\n///    Removes leading zero terms of a polynomial.  By default zeros must be exact,\n///    or give epsilon for approximate zeros. Returns [0] for a zero polynomial.\nfunction _poly_trim(p,eps=0) =\n    let( nz = [for(i=[0:1:len(p)-1]) if ( !approx(p[i],0,eps)) i])\n    len(nz)==0 ? [0] : list_tail(p,nz[0]);\n\n\n// Function: poly_add()\n// Synopsis: Returns the polynomial sum of adding two polynomial equations.\n// Topics: Math\n// See Also: quadratic_roots(), polynomial(), poly_mult(), poly_div(), poly_add(), poly_roots()\n// Usage:\n//    sum = poly_add(p,q)\n// Description:\n//    Computes the sum of two polynomials.  \nfunction poly_add(p,q) = \n    assert( is_vector(p) && is_vector(q), \"Invalid input polynomial(s).\" )\n    let(  plen = len(p),\n          qlen = len(q),\n          long = plen>qlen ? p : q,\n          short = plen>qlen ? q : p\n       )\n     _poly_trim(long + concat(repeat(0,len(long)-len(short)),short));\n\n\n// Function: poly_roots()\n// Synopsis: Returns all complex number roots of the given real polynomial.\n// Topics: Math, Complex Numbers\n// See Also: quadratic_roots(), polynomial(), poly_mult(), poly_div(), poly_add(), poly_roots()\n// Usage:\n//   roots = poly_roots(p, [tol]);\n// Description:\n//   Returns all complex roots of the specified real polynomial p.\n//   The polynomial is specified as p=[a_n, a_{n-1},...,a_1,a_0]\n//   where a_n is the z^n coefficient.  The tol parameter gives\n//   the stopping tolerance for the iteration.  The polynomial\n//   must have at least one non-zero coefficient.  Convergence is poor\n//   if the polynomial has any repeated roots other than zero.  \n// Arguments:\n//   p = polynomial coefficients with higest power coefficient first\n//   tol = tolerance for iteration.  Default: 1e-14\n\n// Uses the Aberth method https://en.wikipedia.org/wiki/Aberth_method\n//\n// Dario Bini. \"Numerical computation of polynomial zeros by means of Aberth's Method\", Numerical Algorithms, Feb 1996.\n// https://www.researchgate.net/publication/225654837_Numerical_computation_of_polynomial_zeros_by_means_of_Aberth's_method\nfunction poly_roots(p,tol=1e-14,error_bound=false) =\n    assert( is_vector(p), \"Invalid polynomial.\" )\n    let( p = _poly_trim(p,eps=0) )\n    assert( p!=[0], \"Input polynomial cannot be zero.\" )\n    p[len(p)-1] == 0 ?                                       // Strip trailing zero coefficients\n        let( solutions = poly_roots(list_head(p),tol=tol, error_bound=error_bound))\n        (error_bound ? [ [[0,0], each solutions[0]], [0, each solutions[1]]]\n                    : [[0,0], each solutions]) :\n    len(p)==1 ? (error_bound ? [[],[]] : []) :               // Nonzero constant case has no solutions\n    len(p)==2 ? let( solution = [[-p[1]/p[0],0]])            // Linear case needs special handling\n                (error_bound ? [solution,[0]] : solution)\n    : \n    let(\n        n = len(p)-1,   // polynomial degree\n        pderiv = [for(i=[0:n-1]) p[i]*(n-i)],\n           \n        s = [for(i=[0:1:n]) abs(p[i])*(4*(n-i)+1)],  // Error bound polynomial from Bini\n\n        // Using method from: http://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/0915-24.pdf\n        beta = -p[1]/p[0]/n,\n        r = 1+pow(abs(polynomial(p,beta)/p[0]),1/n),\n        init = [for(i=[0:1:n-1])                // Initial guess for roots       \n                 let(angle = 360*i/n+270/n/PI)\n                 [beta,0]+r*[cos(angle),sin(angle)]\n               ],\n        roots = _poly_roots(p,pderiv,s,init,tol=tol),\n        error = error_bound ? [for(xi=roots) n * (norm(polynomial(p,xi))+tol*polynomial(s,norm(xi))) /\n                                  abs(norm(polynomial(pderiv,xi))-tol*polynomial(s,norm(xi)))] : 0\n      )\n      error_bound ? [roots, error] : roots;\n\n// Internal function\n// p = polynomial\n// pderiv = derivative polynomial of p\n// z = current guess for the roots\n// tol = root tolerance\n// i=iteration counter\nfunction _poly_roots(p, pderiv, s, z, tol, i=0) =\n    assert(i<45, str(\"Polyroot exceeded iteration limit.  Current solution:\", z))\n    let(\n        n = len(z),\n        svals = [for(zk=z) tol*polynomial(s,norm(zk))],\n        p_of_z = [for(zk=z) polynomial(p,zk)],\n        done = [for(k=[0:n-1]) norm(p_of_z[k])<=svals[k]],\n        newton = [for(k=[0:n-1]) c_div(p_of_z[k], polynomial(pderiv,z[k]))],\n        zdiff = [for(k=[0:n-1]) sum([for(j=[0:n-1]) if (j!=k) c_div([1,0], z[k]-z[j])])],\n        w = [for(k=[0:n-1]) done[k] ? [0,0] : c_div( newton[k],\n                                                     [1,0] - c_mul(newton[k], zdiff[k]))]\n    )\n    all(done) ? z : _poly_roots(p,pderiv,s,z-w,tol,i+1);\n\n\n// Function: real_roots()\n// Synopsis: Returns all real roots of the given real polynomial.\n// Topics: Math, Complex Numbers\n// See Also: quadratic_roots(), polynomial(), poly_mult(), poly_div(), poly_add(), poly_roots()\n// Usage:\n//   roots = real_roots(p, [eps], [tol])\n// Description:\n//   Returns the real roots of the specified real polynomial p.\n//   The polynomial is specified as p=[a_n, a_{n-1},...,a_1,a_0]\n//   where a_n is the x^n coefficient.  This function works by\n//   computing the complex roots and returning those roots where\n//   the imaginary part is closed to zero.  By default it uses a computed\n//   error bound from the polynomial solver to decide whether imaginary\n//   parts are zero.  You can specify eps, in which case the test is\n//   z.y/(1+norm(z)) < eps.  Because\n//   of poor convergence and higher error for repeated roots, such roots may\n//   be missed by the algorithm because their imaginary part is large.\n// Arguments:\n//   p = polynomial to solve as coefficient list, highest power term first\n//   eps = used to determine whether imaginary parts of roots are zero\n//   tol = tolerance for the complex polynomial root finder\n\nfunction real_roots(p,eps=undef,tol=1e-14) =\n    assert( is_vector(p), \"Invalid polynomial.\" )\n    let( p = _poly_trim(p,eps=0) )\n    assert( p!=[0], \"Input polynomial cannot be zero.\" )\n    let( \n       roots_err = poly_roots(p,error_bound=true),\n       roots = roots_err[0],\n       err = roots_err[1]\n    )\n    is_def(eps) \n    ? [for(z=roots) if (abs(z.y)/(1+norm(z))<eps) z.x]\n    : [for(i=idx(roots)) if (abs(roots[i].y)<=err[i]) roots[i].x];\n\n\n// Section: Operations on Functions\n\n// Function: root_find()\n// Synopsis: Finds a root of the given continuous function.\n// Topics: Math\n// See Also: quadratic_roots(), polynomial(), poly_mult(), poly_div(), poly_add(), poly_roots()\n// Usage:\n//    x = root_find(f, x0, x1, [tol])\n// Description:\n//    Find a root of the continuous function f where the sign of f(x0) is different\n//    from the sign of f(x1).  The function f is a function literal accepting one\n//    argument.  You must have a version of OpenSCAD that supports function literals\n//    (2021.01 or newer).  The tolerance (tol) specifies the accuracy of the solution:\n//    abs(f(x)) < tol * yrange, where yrange is the range of observed function values.\n//    This function can only find roots that cross the x axis:  it cannot find the\n//    the root of x^2.\n// Arguments:\n//    f = function literal for a scalar-valued single variable function\n//    x0 = endpoint of interval to search for root\n//    x1 = second endpoint of interval to search for root\n//    tol = tolerance for solution.  Default: 1e-15\n\n//   The algorithm is based on Brent's method and is a combination of\n//   bisection and inverse quadratic approximation, where bisection occurs\n//   at every step, with refinement using inverse quadratic approximation\n//   only when that approximation gives a good result.  The detail\n//   of how to decide when to use the quadratic came from an article\n//   by Crenshaw on \"The World's Best Root Finder\".\n//   https://www.embedded.com/worlds-best-root-finder/\nfunction root_find(f,x0,x1,tol=1e-15) =\n   let(\n        y0 = f(x0),\n        y1 = f(x1),\n        yrange = y0<y1 ? [y0,y1] : [y1,y0]\n   )\n   // Check endpoints\n   y0==0 || _rfcheck(x0, y0,yrange,tol) ? x0 :\n   y1==0 || _rfcheck(x1, y1,yrange,tol) ? x1 :\n   assert(y0*y1<0, \"Sign of function must be different at the interval endpoints\")\n   _rootfind(f,[x0,x1],[y0,y1],yrange,tol);\n\nfunction _rfcheck(x,y,range,tol) =\n   assert(is_finite(y), str(\"Function not finite at \",x))\n   abs(y) < tol*(range[1]-range[0]);\n\n// xpts and ypts are arrays whose first two entries contain the\n// interval bracketing the root.  Extra entries are ignored.\n// yrange is the total observed range of y values (used for the\n// tolerance test).  \nfunction _rootfind(f, xpts, ypts, yrange, tol, i=0) =\n    assert(i<100, \"root_find did not converge to a solution\")\n    let(\n         xmid = (xpts[0]+xpts[1])/2,\n         ymid = f(xmid),\n         yrange = [min(ymid, yrange[0]), max(ymid, yrange[1])]\n    )\n    _rfcheck(xmid, ymid, yrange, tol) ? xmid :\n    let(\n         // Force root to be between x0 and midpoint\n         y = ymid * ypts[0] < 0 ? [ypts[0], ymid, ypts[1]]\n                                : [ypts[1], ymid, ypts[0]],\n         x = ymid * ypts[0] < 0 ? [xpts[0], xmid, xpts[1]]\n                                : [xpts[1], xmid, xpts[0]],\n         v = y[2]*(y[2]-y[0]) - 2*y[1]*(y[1]-y[0])\n    )\n    v <= 0 ? _rootfind(f,x,y,yrange,tol,i+1)  // Root is between first two points, extra 3rd point doesn't hurt\n    :\n    let(  // Do quadratic approximation\n        B = (x[1]-x[0]) / (y[1]-y[0]),\n        C = y*[-1,2,-1] / (y[2]-y[1]) / (y[2]-y[0]),\n        newx = x[0] - B * y[0] *(1-C*y[1]),\n        newy = f(newx),\n        new_yrange = [min(yrange[0],newy), max(yrange[1], newy)],\n        // select interval that contains the root by checking sign\n        yinterval = newy*y[0] < 0 ? [y[0],newy] : [newy,y[1]],\n        xinterval = newy*y[0] < 0 ? [x[0],newx] : [newx,x[1]]\n     )\n     _rfcheck(newx, newy, new_yrange, tol)\n        ? newx\n        : _rootfind(f, xinterval, yinterval, new_yrange, tol, i+1);\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-25", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: metric_screws.scad\n//   Screws, Bolts, and Nuts.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/metric_screws.scad>\n// FileGroup: Threaded Parts\n// FileSummary: Metric screws, nuts, and screwholes.\n//////////////////////////////////////////////////////////////////////\n\n\ninclude <threading.scad>\ninclude <screw_drive.scad>\n\nwarn = echo(\"*** WARNING: metric_screws.scad is deprecated and may be removed in the future.  Use screws.scad instead. ***\");\n\n\n// Section: Functions\n\n\n// Function: get_metric_bolt_head_size()\n// Description: Returns the diameter of a typical metric bolt's head, based on the bolt `size`.\nfunction get_metric_bolt_head_size(size) = lookup(size, [\n        [ 3.0,  5.5],\n        [ 4.0,  7.0],\n        [ 5.0,  8.0],\n        [ 6.0, 10.0],\n        [ 7.0, 11.0],\n        [ 8.0, 13.0],\n        [10.0, 17.0],\n        [12.0, 19.0],\n        [14.0, 22.0],\n        [16.0, 24.0],\n        [18.0, 27.0],\n        [20.0, 30.0],\n        [24.0, 36.0],\n        [30.0, 46.0],\n        [36.0, 55.0],\n        [42.0, 65.0],\n        [48.0, 75.0],\n        [56.0, 85.0],\n        [64.0, 95.0]\n    ]);\n\n\n// Function: get_metric_bolt_head_height()\n// Description: Returns the height of a typical metric bolt's head, based on the bolt `size`.\nfunction get_metric_bolt_head_height(size) = lookup(size, [\n        [ 1.6,  1.23],\n        [ 2.0,  1.53],\n        [ 2.5,  1.83],\n        [ 3.0,  2.13],\n        [ 4.0,  2.93],\n        [ 5.0,  3.65],\n        [ 6.0,  4.15],\n        [ 8.0,  5.45],\n        [10.0,  6.58],\n        [12.0,  7.68],\n        [14.0,  8.98],\n        [16.0, 10.18],\n        [20.0, 12.72],\n        [24.0, 15.35],\n        [30.0, 19.12],\n        [36.0, 22.92],\n        [42.0, 26.42],\n        [48.0, 30.42],\n        [56.0, 35.50],\n        [64.0, 40.50]\n    ]);\n\n\n// Function: get_metric_socket_cap_diam()\n// Description: Returns the diameter of a typical metric socket cap bolt's head, based on the bolt `size`.\nfunction get_metric_socket_cap_diam(size) = lookup(size, [\n        [ 1.6,  3.0],\n        [ 2.0,  3.8],\n        [ 2.5,  4.5],\n        [ 3.0,  5.5],\n        [ 4.0,  7.0],\n        [ 5.0,  8.5],\n        [ 6.0, 10.0],\n        [ 8.0, 13.0],\n        [10.0, 16.0],\n        [12.0, 18.0],\n        [14.0, 21.0],\n        [16.0, 24.0],\n        [18.0, 27.0],\n        [20.0, 30.0],\n        [22.0, 33.0],\n        [24.0, 36.0],\n        [27.0, 40.0],\n        [30.0, 45.0],\n        [33.0, 50.0],\n        [36.0, 54.0],\n        [42.0, 63.0],\n        [48.0, 72.0],\n        [56.0, 84.0],\n        [64.0, 96.0]\n    ]);\n\n\n// Function: get_metric_socket_cap_height()\n// Description: Returns the height of a typical metric socket cap bolt's head, based on the bolt `size`.\nfunction get_metric_socket_cap_height(size) = lookup(size, [\n        [ 1.6,  1.7],\n        [ 2.0,  2.0],\n        [ 2.5,  2.5],\n        [ 3.0,  3.0],\n        [ 4.0,  4.0],\n        [ 5.0,  5.0],\n        [ 6.0,  6.0],\n        [ 8.0,  8.0],\n        [10.0, 10.0],\n        [12.0, 12.0],\n        [14.0, 14.0],\n        [16.0, 16.0],\n        [18.0, 18.0],\n        [20.0, 20.0],\n        [22.0, 22.0],\n        [24.0, 24.0],\n        [27.0, 27.0],\n        [30.0, 30.0],\n        [33.0, 33.0],\n        [36.0, 36.0],\n        [42.0, 42.0],\n        [48.0, 48.0],\n        [56.0, 56.0],\n        [64.0, 64.0]\n    ]);\n\n\n// Function: get_metric_socket_cap_socket_size()\n// Description: Returns the diameter of a typical metric socket cap bolt's hex drive socket, based on the bolt `size`.\nfunction get_metric_socket_cap_socket_size(size) = lookup(size, [\n        [ 1.6,  1.5],\n        [ 2.0,  1.5],\n        [ 2.5,  2.0],\n        [ 3.0,  2.5],\n        [ 4.0,  3.0],\n        [ 5.0,  4.0],\n        [ 6.0,  5.0],\n        [ 8.0,  6.0],\n        [10.0,  8.0],\n        [12.0, 10.0],\n        [14.0, 12.0],\n        [16.0, 14.0],\n        [18.0, 14.0],\n        [20.0, 17.0],\n        [22.0, 17.0],\n        [24.0, 19.0],\n        [27.0, 19.0],\n        [30.0, 22.0],\n        [33.0, 24.0],\n        [36.0, 27.0],\n        [42.0, 32.0],\n        [48.0, 36.0],\n        [56.0, 41.0],\n        [64.0, 46.0]\n    ]);\n\n\n// Function: get_metric_socket_cap_socket_depth()\n// Description: Returns the depth of a typical metric socket cap bolt's hex drive socket, based on the bolt `size`.\nfunction get_metric_socket_cap_socket_depth(size) = lookup(size, [\n        [ 1.6,  0.7],\n        [ 2.0,  1.0],\n        [ 2.5,  1.1],\n        [ 3.0,  1.3],\n        [ 4.0,  2.0],\n        [ 5.0,  2.5],\n        [ 6.0,  3.0],\n        [ 8.0,  4.0],\n        [10.0,  5.0],\n        [12.0,  6.0],\n        [14.0,  7.0],\n        [16.0,  8.0],\n        [18.0,  9.0],\n        [20.0, 10.0],\n        [22.0, 11.0],\n        [24.0, 12.0],\n        [27.0, 13.5],\n        [30.0, 15.5],\n        [33.0, 18.0],\n        [36.0, 19.0],\n        [42.0, 24.0],\n        [48.0, 28.0],\n        [56.0, 34.0],\n        [64.0, 38.0]\n    ]);\n\n\n// Function: get_metric_iso_coarse_thread_pitch()\n// Description: Returns the ISO metric standard coarse threading pitch for a given bolt `size`.\nfunction get_metric_iso_coarse_thread_pitch(size) = lookup(size, [\n        [ 1.6, 0.35],\n        [ 2.0, 0.40],\n        [ 2.5, 0.45],\n        [ 3.0, 0.50],\n        [ 4.0, 0.70],\n        [ 5.0, 0.80],\n        [ 6.0, 1.00],\n        [ 7.0, 1.00],\n        [ 8.0, 1.25],\n        [10.0, 1.50],\n        [12.0, 1.75],\n        [14.0, 2.00],\n        [16.0, 2.00],\n        [18.0, 2.50],\n        [20.0, 2.50],\n        [22.0, 2.50],\n        [24.0, 3.00],\n        [27.0, 3.00],\n        [30.0, 3.50],\n        [33.0, 3.50],\n        [36.0, 4.00],\n        [39.0, 4.00],\n        [42.0, 4.50],\n        [45.0, 4.50],\n        [48.0, 5.00],\n        [56.0, 5.50],\n        [64.0, 6.00]\n    ]);\n\n\n// Function: get_metric_iso_fine_thread_pitch()\n// Description: Returns the ISO metric standard fine threading pitch for a given bolt `size`.\nfunction get_metric_iso_fine_thread_pitch(size) = lookup(size, [\n        [ 1.6, 0.35],\n        [ 2.0, 0.40],\n        [ 2.5, 0.45],\n        [ 3.0, 0.50],\n        [ 4.0, 0.70],\n        [ 5.0, 0.80],\n        [ 6.0, 1.00],\n        [ 7.0, 1.00],\n        [ 8.0, 1.00],\n        [10.0, 1.25],\n        [12.0, 1.50],\n        [14.0, 1.50],\n        [16.0, 2.00],\n        [18.0, 2.50],\n        [20.0, 2.50],\n        [22.0, 2.50],\n        [24.0, 3.00],\n        [27.0, 3.00],\n        [30.0, 3.50],\n        [33.0, 3.50],\n        [36.0, 4.00],\n        [39.0, 4.00],\n        [42.0, 4.50],\n        [45.0, 4.50],\n        [48.0, 5.00],\n        [56.0, 5.50],\n        [64.0, 6.00]\n    ]);\n\n\n// Function: get_metric_iso_superfine_thread_pitch()\n// Description: Returns the ISO metric standard superfine threading pitch for a given bolt `size`.\nfunction get_metric_iso_superfine_thread_pitch(size) = lookup(size, [\n        [ 1.6, 0.35],\n        [ 2.0, 0.40],\n        [ 2.5, 0.45],\n        [ 3.0, 0.50],\n        [ 4.0, 0.70],\n        [ 5.0, 0.80],\n        [ 6.0, 1.00],\n        [ 7.0, 1.00],\n        [ 8.0, 1.00],\n        [10.0, 1.00],\n        [12.0, 1.25],\n        [14.0, 1.50],\n        [16.0, 2.00],\n        [18.0, 2.50],\n        [20.0, 2.50],\n        [22.0, 2.50],\n        [24.0, 3.00],\n        [27.0, 3.00],\n        [30.0, 3.50],\n        [33.0, 3.50],\n        [36.0, 4.00],\n        [39.0, 4.00],\n        [42.0, 4.50],\n        [45.0, 4.50],\n        [48.0, 5.00],\n        [56.0, 5.50],\n        [64.0, 6.00]\n    ]);\n\n\n// Function: get_metric_jis_thread_pitch()\n// Description: Returns the JIS metric standard threading pitch for a given bolt `size`.\nfunction get_metric_jis_thread_pitch(size) = lookup(size, [\n        [ 2.0, 0.40],\n        [ 2.5, 0.45],\n        [ 3.0, 0.50],\n        [ 4.0, 0.70],\n        [ 5.0, 0.80],\n        [ 6.0, 1.00],\n        [ 7.0, 1.00],\n        [ 8.0, 1.25],\n        [10.0, 1.25],\n        [12.0, 1.25],\n        [14.0, 1.50],\n        [16.0, 1.50],\n        [18.0, 1.50],\n        [20.0, 1.50]\n    ]);\n\n\n// Function: get_metric_nut_size()\n// Description: Returns the typical metric nut flat-to-flat diameter for a given bolt `size`.\nfunction get_metric_nut_size(size) = lookup(size, [\n        [ 2.0,  4.0],\n        [ 2.5,  5.0],\n        [ 3.0,  5.5],\n        [ 4.0,  7.0],\n        [ 5.0,  8.0],\n        [ 6.0, 10.0],\n        [ 7.0, 11.0],\n        [ 8.0, 13.0],\n        [10.0, 17.0],\n        [12.0, 19.0],\n        [14.0, 22.0],\n        [16.0, 24.0],\n        [18.0, 27.0],\n        [20.0, 30.0]\n    ]);\n\n\n// Function: get_metric_nut_thickness()\n// Description: Returns the typical metric nut thickness for a given bolt `size`.\nfunction get_metric_nut_thickness(size) = lookup(size, [\n        [ 1.6,  1.3],\n        [ 2.0,  1.6],\n        [ 2.5,  2.0],\n        [ 3.0,  2.4],\n        [ 4.0,  3.2],\n        [ 5.0,  4.0],\n        [ 6.0,  5.0],\n        [ 7.0,  5.5],\n        [ 8.0,  6.5],\n        [10.0,  8.0],\n        [12.0, 10.0],\n        [14.0, 11.0],\n        [16.0, 13.0],\n        [18.0, 15.0],\n        [20.0, 16.0],\n        [24.0, 21.5],\n        [30.0, 25.6],\n        [36.0, 31.0],\n        [42.0, 34.0],\n        [48.0, 38.0],\n        [56.0, 45.0],\n        [64.0, 51.0]\n    ]);\n\n\n\n// Section: Modules\n\n\n// Module: generic_screw()\n// Description:\n//   Makes a very simple screw model, useful for making screwholes.\n// Usage:\n//   generic_screw(screwsize, screwlen, headsize, headlen)\n// Arguments:\n//   screwsize = diameter of threaded part of screw.\n//   screwlen = length of threaded part of screw.\n//   headsize = diameter of the screw head.\n//   headlen = length of the screw head.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Extra Anchors:\n//   \"base\" = At the base of the head.\n//   \"countersunk\" = At the head height that would be just barely exposed when countersunk.\n// Examples:\n//   generic_screw(screwsize=3,screwlen=10,headsize=6,headlen=3, anchor=\"countersunk\");\n//   generic_screw(screwsize=3,screwlen=10,headsize=6,headlen=3, anchor=\"base\");\n// Example(FlatSpin,VPD=75): Standard Anchors\n//   generic_screw(screwsize=3,screwlen=10,headsize=6,headlen=3)\n//       show_anchors(5, custom=false);\n// Example(FlatSpin,VPD=55): Custom Named Anchors\n//   expose_anchors()\n//     generic_screw(screwsize=3,screwlen=10,headsize=6,headlen=3)\n//       show_anchors(5, std=false);\nmodule generic_screw(\n    screwsize=3,\n    screwlen=10,\n    headsize=6,\n    headlen=3,\n    pitch=undef,\n    anchor=\"base\",\n    spin=0,\n    orient=UP\n) {\n    sides = max(12, segs(screwsize/2));\n    anchors = [\n        named_anchor(\"countersunk\", [0,0,(headlen+screwlen)/2-0.01]),\n        named_anchor(\"base\", [0,0,-headlen/2+screwlen/2])\n    ];\n    attachable(anchor,spin,orient, d=screwsize, l=headlen+screwlen, anchors=anchors) {\n        down(headlen/2-screwlen/2) {\n            down(screwlen/2) {\n                if (pitch == undef) {\n                    cylinder(r=screwsize/2, h=screwlen+0.05, center=true, $fn=sides);\n                } else {\n                    threaded_rod(d=screwsize, l=screwlen+0.05, pitch=pitch, $fn=sides);\n                }\n            }\n            cylinder(r=headsize/2, h=headlen, center=false, $fn=sides*2);\n        }\n        children();\n    }\n}\n\n\n// Module: metric_bolt()\n// Description:\n//   Makes a standard metric screw model.\n// Arguments:\n//   size = Diameter of threaded part of screw.\n//   headtype = One of `\"hex\"`, `\"pan\"`, `\"button\"`, `\"round\"`, `\"countersunk\"`, `\"oval\"`, `\"socket`\".  Default: `\"socket\"`\n//   l = Length of screw, except for the head.\n//   shank = Length of unthreaded portion of the shaft.\n//   pitch = If given, render threads of the given pitch.  If 0, then no threads.  Overrides coarse argument.\n//   details = If true model should be rendered with extra details.  (Default: false)\n//   coarse = If true, make coarse threads instead of fine threads.  Default = true\n//   flange = Radius of flange beyond the head.  Default = 0 (no flange)\n//   phillips = If given, the size of the phillips drive hole to add.  (ie: \"#1\", \"#2\", or \"#3\")\n//   torx = If given, the size of the torx drive hole to add.  (ie: 10, 20, 30, etc.)\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Extra Anchors:\n//   \"base\" = At the base of the head.\n//   \"countersunk\" = At the head height that would be just barely exposed when countersunk.\n//   \"shank\" = At the bottom start of the unthreaded shank.\n// Example: Bolt Head Types\n//   ydistribute(40) {\n//       xdistribute(30) {\n//           // Front Row, Left to Right\n//           metric_bolt(headtype=\"pan\", size=10, l=15, details=true, phillips=\"#2\");\n//           metric_bolt(headtype=\"button\", size=10, l=15, details=true, phillips=\"#2\");\n//           metric_bolt(headtype=\"round\", size=10, l=15, details=true, phillips=\"#2\");\n//       }\n//       xdistribute(30) {\n//           // Back Row, Left to Right\n//           metric_bolt(headtype=\"socket\", size=10, l=15, details=true);\n//           metric_bolt(headtype=\"hex\", size=10, l=15, details=true, phillips=\"#2\");\n//           metric_bolt(headtype=\"countersunk\", size=10, l=15, details=true, phillips=\"#2\");\n//           metric_bolt(headtype=\"oval\", size=10, l=15, details=true, phillips=\"#2\");\n//       }\n//   }\n// Example: Details\n//   metric_bolt(size=10, l=15, details=true, $fn=32);\n// Example: No Details Except Threads\n//   metric_bolt(size=10, l=15);\n// Example: No Details, No Threads\n//   metric_bolt(size=10, l=15, pitch=0);\n// Example: Fine Threads\n//   metric_bolt(size=10, l=15, coarse=false);\n// Example: Flange\n//   metric_bolt(size=10, l=15, flange=5);\n// Example: Shank\n//   metric_bolt(size=10, l=25, shank=10);\n// Example: Hex Head with Phillips\n//   metric_bolt(headtype=\"hex\", size=10, l=15, phillips=\"#2\");\n// Example: Hex Head with Torx\n//   metric_bolt(headtype=\"hex\", size=10, l=15, torx=50);\n// Example(FlatSpin,VPD=100): Standard Anchors\n//   metric_bolt(headtype=\"oval\", size=10, l=15, shank=5, details=true, phillips=\"#2\")\n//       show_anchors(5, custom=false);\n// Example(FlatSpin,VPD=100): Custom Named Anchors\n//   expose_anchors(0.125)\n//     metric_bolt(headtype=\"oval\", size=10, l=15, shank=5, details=true, phillips=\"#2\")\n//       show_anchors(5, std=false);\nmodule metric_bolt(\n    headtype=\"socket\",\n    size=3,\n    l=12,\n    shank=0,\n    pitch=undef,\n    details=false,\n    coarse=true,\n    phillips=undef,\n    torx=undef,\n    flange=0,\n    anchor=\"base\",\n    spin=0,\n    orient=UP\n) {\n    D = headtype != \"hex\"?\n        get_metric_socket_cap_diam(size) :\n        get_metric_bolt_head_size(size);\n    H = headtype == \"socket\"?\n        get_metric_socket_cap_height(size) :\n        get_metric_bolt_head_height(size);\n    P = coarse?\n        (pitch==undef? get_metric_iso_coarse_thread_pitch(size) : pitch) :\n        (pitch==undef? get_metric_iso_fine_thread_pitch(size) : pitch);\n    tlen = l - min(l, shank);\n    sides = max(12, segs(size/2));\n    tcirc = D/cos(30);\n    bevtop = (tcirc-D)/2;\n    bevbot = P/2;\n\n    headlen = (\n        (headtype == \"pan\" || headtype == \"round\" || headtype == \"button\")? H*0.75 :\n        (headtype == \"countersunk\")? (D-size)/2 :\n        (headtype == \"oval\")? ((D-size)/2 + D/2/3) :\n        H\n    );\n    base = l/2 - headlen/2;\n    sunklen = (\n        (headtype == \"oval\")? (D-size)/2 :\n        headlen-0.001\n    );\n\n    anchors = [\n        named_anchor(\"countersunk\", [0,0,base+sunklen]),\n        named_anchor(\"base\",   [0,0,base]),\n        named_anchor(\"shank\",  [0,0,base-shank])\n    ];\n\n    //color(\"silver\")\n    attachable(anchor,spin,orient, d=size, l=headlen+l, anchors=anchors) {\n        up(base) {\n            difference() {\n                union() {\n                    // Head\n                    if (headtype == \"hex\") {\n                        difference() {\n                            cylinder(d=tcirc, h=H, $fn=6);\n\n                            // Bevel hex nut top\n                            if (details) {\n                                up(H-bevtop) {\n                                    difference() {\n                                        cube([tcirc+1, tcirc+1, bevtop+0.5], anchor=BOTTOM);\n                                        down(0.01) cylinder(d1=tcirc, d2=tcirc-bevtop*2, h=bevtop+0.02, center=false);\n                                    }\n                                }\n                            }\n                        }\n                    } else if (headtype == \"socket\") {\n                        sockw = get_metric_socket_cap_socket_size(size);\n                        sockd = get_metric_socket_cap_socket_depth(size);\n                        difference() {\n                            cylinder(d=D, h=H);\n                            up(H-sockd) cylinder(h=sockd+0.1, d=sockw/cos(30), $fn=6);\n                            if (details) {\n                                kcnt = 36;\n                                zrot_copies(n=kcnt, r=D/2) up(H/3) cube([PI*D/kcnt/2, PI*D/kcnt/2, H], anchor=BOTTOM);\n                            }\n                        }\n                    } else if (headtype == \"pan\") {\n                        cyl(l=H*0.75, d=D, rounding2=H*0.75/2, anchor=DOWN);\n                    } else if (headtype == \"round\") {\n                        top_half(D) zscale(H*0.75/D*2) sphere(d=D);\n                    } else if (headtype == \"button\") {\n                        up(H*0.75/3) top_half(D) zscale(H*0.75*2/3/D*2) sphere(d=D);\n                        cylinder(d=D, h=H*0.75/3+0.01, center=false);\n                    } else if (headtype == \"countersunk\") {\n                        cylinder(h=(D-size)/2, d1=size, d2=D);\n                    } else if (headtype == \"oval\") {\n                        up((D-size)/2) top_half(D) zscale(0.333) sphere(d=D);\n                        cylinder(h=(D-size)/2, d1=size, d2=D);\n                    }\n\n                    // Flange\n                    if (flange>0) {\n                        up(headtype == \"countersunk\" || headtype == \"oval\"? (D-size)/2 : 0) {\n                            cylinder(d=D+flange, h=H/8, center=false);\n                            up(H/8) cylinder(d1=D+flange, d2=D, h=H/8, center=false);\n                        }\n                    }\n\n                    // Unthreaded Shank\n                    if (tlen < l) {\n                        down(l-tlen) cylinder(d=size, h=l-tlen+0.05, center=false, $fn=sides);\n                    }\n\n                    // Threads\n                    down(l) {\n                        difference() {\n                            up(tlen/2+0.05) {\n                                if (tlen > 0) {\n                                    if (P > 0) {\n                                        threaded_rod(d=size, l=tlen+0.05, pitch=P, $fn=sides);\n                                    } else {\n                                        cylinder(d=size, h=tlen+0.05, $fn=sides, center=true);\n                                    }\n                                }\n                            }\n\n                            // Bevel bottom end of threads\n                            if (details) {\n                                difference() {\n                                    down(0.5) cube([size+1, size+1, bevbot+0.5], anchor=BOTTOM);\n                                    cylinder(d1=size-bevbot*2, d2=size, h=bevbot+0.01, center=false);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Phillips drive hole\n                if (headtype != \"socket\" && phillips != undef) {\n                    down(headtype != \"hex\"? H/6 : 0) {\n                        phillips_mask(size=phillips); //, shaft=D);\n                    }\n                }\n\n                // Torx drive hole\n                if (headtype != \"socket\" && torx != undef) {\n                    up(1) torx_mask(size=torx, l=H+0.1, center=false);\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: metric_nut()\n// Description:\n//   Makes a model of a standard nut for a standard metric screw.\n// Arguments:\n//   size = standard metric screw size in mm. (Default: 3)\n//   hole = include the hole in the nut.  (Default: true)\n//   pitch = pitch of threads in the hole.  No threads if not given.\n//   flange = radius of flange beyond the head.  Default = 0 (no flange)\n//   details = true if model should be rendered with extra details.  (Default: false)\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   center = If true, centers the nut at the origin.  If false, sits on top of XY plane.  Overrides `anchor` if given.\n// Example: No details, No Hole.  Useful for a mask.\n//   metric_nut(size=10, hole=false);\n// Example:  Hole, with No Threads\n//   metric_nut(size=10, hole=true);\n// Example:  Threads\n//   metric_nut(size=10, hole=true, pitch=1.5);\n// Example:  Details\n//   metric_nut(size=10, hole=true, pitch=1.5, details=true);\n// Example:  Centered\n//   metric_nut(size=10, hole=true, pitch=1.5, details=true, center=true);\n// Example:  Flange\n//   metric_nut(size=10, hole=true, pitch=1.5, flange=3, details=true);\nmodule metric_nut(\n    size=3,\n    hole=true,\n    pitch=undef,\n    details=false,\n    flange=0,\n    center,\n    anchor,\n    spin=0,\n    orient=UP\n) {\n    H = get_metric_nut_thickness(size);\n    D = get_metric_nut_size(size);\n    boltfn = max(12, segs(size/2));\n    nutfn = max(12, segs(D/2));\n    dcirc = D/cos(30);\n    bevtop = (dcirc - D)/2;\n\n    //color(\"silver\")\n    anchor = get_anchor(anchor,center,BOT,CENTER);\n    attachable(anchor,spin,orient, d=dcirc+flange, l=H) {\n        difference() {\n            union() {\n                difference() {\n                    cylinder(d=dcirc, h=H, center=true, $fn=6);\n                    if (details) {\n                        up(H/2-bevtop) {\n                            difference() {\n                                cube([dcirc+1, dcirc+1, bevtop+0.5], anchor=BOTTOM);\n                                down(0.01) cylinder(d1=dcirc, d2=dcirc-bevtop*2, h=bevtop+0.02, center=false, $fn=nutfn);\n                            }\n                        }\n                        if (flange == 0) {\n                            down(H/2) {\n                                difference() {\n                                    down(0.5) cube([dcirc+1, dcirc+1, bevtop+0.5], anchor=BOTTOM);\n                                    down(0.01) cylinder(d1=dcirc-bevtop*2, d2=dcirc, h=bevtop+0.02, center=false, $fn=nutfn);\n                                }\n                            }\n                        }\n                    }\n                }\n                if (flange>0) {\n                    down(H/2) {\n                        cylinder(d=D+flange, h=H/8, center=false);\n                        up(H/8) cylinder(d1=D+flange, d2=D, h=H/8, center=false);\n                    }\n                }\n            }\n            if (hole == true) {\n                if (pitch == undef) {\n                    cylinder(r=size/2, h=H+0.5, center=true, $fn=boltfn);\n                } else {\n                    threaded_rod(d=size, l=H+0.5, pitch=pitch, $fn=boltfn);\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-26", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////////\n// LibFile: modular_hose.scad\n//   Modular hose segment and attachment ends. \n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/modular_hose.scad>\n// FileGroup: Parts\n// FileSummary: Modular flexible hose segments.\n//////////////////////////////////////////////////////////////////////////\n\n// Section: Modular Hose Parts\n\n_modhose_small_end = [\n             turtle([\n                     \"left\", 90-38.5,            //   1/4\" hose\n                     \"arcsteps\", 12, \n                     \"arcleft\", 6.38493, 62.15,\n                     \"arcsteps\", 4,\n                     \"arcleft\", .5, 90+38.5-62.15,\n                     \"move\", .76,\n                     \"left\", 67.5,\n                     \"move\", .47,\n                     \"left\", 90-67.5,\n                     \"move\", 4.165,\n                     \"right\", 30,\n                     \"move\", 2.1\n                    ],\n                    state=[4.864,0]),\n             turtle([                            //   1/2\" hose\n                     \"left\", 90-41,\n                     \"arcsteps\", 16, \n                     \"arcleft\", 10.7407, 64.27,\n                     \"arcsteps\", 4,\n                     \"arcleft\", .5, 90+41-64.27,\n                     \"move\", .95-.4,\n                     \"left\", 45,\n                     \"move\", .4*sqrt(2), \n                     \"left\",45,\n                     \"move\", 7.643-.4,\n                     \"right\", 30,\n                     \"move\", 4.06\n                   ],\n                   state=[8.1, 0]),\n             turtle([                            //   3/4\" hose\n                     \"left\", 90-30.4,\n                     \"arcsteps\", 16,\n                     \"arcleft\", 13.99219,53,\n                     \"arcsteps\", 4, \n                     \"arcleft\", .47,90-53+30.4,\n                     \"move\", .597,\n                     \"left\", \n                     \"move\", 9.908-1.905/tan(25) +3.81*cos(30),  // Change to 25 deg angle\n                     \"right\", 25,                                // to remove narrow point in wall\n                     \"move\",1.905 /sin(25),\n                  ],\n                  state=[11.989,0])\n            ];\n  \n\n_modhose_big_end = [\n           turtle([                            //   1/4\" hose\n                   \"left\", 90-22,\n                   \"move\", 6.5,\n                   \"left\",.75,\n                   \"arcsteps\", 8,\n                   \"arcleft\", 6.5, 37.3,\n                   \"setdir\",90,\n                   \"move\", .21,\n                   \"right\",\n                   \"move\", 1.24,\n                   \"right\", 45,\n                   \"move\", .7835,\n                   \"right\", 19, \n                   \"move\", 1.05,\n                   \"setdir\", -90,\n                   \"move\", 1,\n                   \"right\", 22,\n                   \"move\", 8.76\n                  ],\n                  state = [3.268,0]),\n           turtle([                            //   1/2\" hose\n                   \"left\",     \n                   \"right\", 22,\n                   \"move\", 9,\n                   \"arcsteps\", 8,\n                   \"arcleft\", 11, 36.5,\n                   \"setdir\",90,\n                   \"move\",2-1.366,\n                   \"right\",\n                   \"move\",.91,\n                   \"arcsteps\", 4, \n                   \"arcright\", 1.25, 90,\n                   \"move\", 2.2,\n                   \"arcsteps\", 8, \n                   \"arcright\", 13, 22.4,\n                   \"move\", 8.73\n                  ],\n                  state=[6.42154, 0]),\n           turtle([                            //   3/4\" hose\n                   \"left\", 90-22, \n                   \"move\", 7.633,\n                   \"arcsteps\", 16,\n                   \"arcleft\", 13.77, 35.27,\n                   \"setdir\", 90,\n                   \"move\", 1.09,\n                   \"right\",\n                   \"move\",1.0177,\n                   \"right\", 45,\n                   \"move\", 1.009,\n                   \"right\", 77.8-45,\n                   \"move\", .3,\n                   \"arcright\", 15.5, 34.2,\n                   \"move\", 6.47\n                  ],\n                  state=[9.90237,0])\n        ];\n\n\n_modhose_waist = [1.7698, 1.8251, 3.95998];\n\n\n// Module: modular_hose()\n// Synopsis: Creates modular hose parts.\n// Topics: Modular Hose, Parts\n// See Also: modular_hose_radius(), tube()\n// Usage:\n//    modular_hose(size, type, [clearance], [waist_len], [anchor], [spin], [orient]) [ATTACHMENTS];\n// Description:\n//    Construct moduler hose segments or modular hose ends for connection to standard\n//    modular hose systems.  The 1/4\", 1/2\" and 3/4\" sizes are supported and you can\n//    produce just one end to make a mount or end attachment to a modular hose,\n//    or you can make modular hose segments.  To make assembly possible with printed\n//    parts you can add clearances that make the ball end smaller and the socket end\n//    larger.  These work by simply increasing the radius of the whole end by the specified\n//    amount.  On a Prusa printer with PETG, a clearance of 0.05 allows the 3/4\" hose parts to mate\n//    with standard modular hose or itself.  A clearance of 0.05 to 0.1 allows the 1/2\" parts to mate with\n//    standard hose, and with clearance 0 the 1/4\" parts will mate with standard hose.  Note that clearance values\n//    are different for the different sizes.  You will have to experiment with your machine and materials.  Small\n//    adjustments will change the stiffness of the connection.\n// Arguments:\n//    size = size of modular hose part, must be 1/4, 1/2 or 3/4.\n//    type = type of part to make, either \"segment\", \"socket\" (or \"big\"), or \"ball\" (or \"small\")\n//    clearance = clearance to make assembly possible.  Either a scalar to apply the same to both ends or a vector [small,large] to apply different clearances to the two ends.  Default: 0\n//    waist_len = size of central \"waist\" of the part.  Default: standard length.\n// Example:\n//    modular_hose(1/4,\"segment\");\n//    right(25)modular_hose(1/2,\"segment\");\n//    right(60)modular_hose(3/4,\"segment\");\n// Example: A mount point for modular hose\n//    cylinder(h=10, r=20)\n//       attach(TOP) modular_hose(1/2, \"ball\", waist_len=15);\n// Example: Mounting plate for something at the end of the hose\n//    cuboid([50,50,5])\n//       attach(TOP) modular_hose(3/4, \"socket\", waist_len=0);\nfunction modular_hose(size, type, clearance=0, waist_len, anchor=BOTTOM, spin=0,orient=UP) = no_function(\"modular_hose\");\nmodule modular_hose(size, type, clearance=0, waist_len, anchor=BOTTOM, spin=0,orient=UP)\n{\n  clearance = force_list(clearance,2);\n  ind = search([size],[1/4, 1/2, 3/4])[0];\n  sbound =\n    assert(ind!=[], \"Must specify size as 1/4, 1/2 or 3/4\")\n    pointlist_bounds(_modhose_small_end[ind]);\n  bbound = pointlist_bounds(_modhose_big_end[ind]);\n  smallend =\n    assert(is_vector(clearance,2), \"Clearance must be a scalar or length 2 vector\")\n    move([-clearance[0],-sbound[0].y],p=_modhose_small_end[ind]);\n  bigend = move([clearance[1], -bbound[0].y], p=_modhose_big_end[ind]);\n\n  midlength = first_defined([waist_len, _modhose_waist[ind]]);\n  dummy = assert(midlength>=0,\"midlength must be nonnegative\");\n\n  goodtypes = [\"small\",\"big\",\"segment\",\"socket\",\"ball\"];\n  shape =\n    assert(in_list(type,goodtypes), str(\"type must be one of \",goodtypes))\n    type==\"segment\"? concat(back(midlength,p=smallend),yflip(p=bigend))\n  : type==\"small\" || type==\"ball\" ?\n          concat(back(midlength,p=smallend),\n                 [[last(smallend).x,0],[ smallend[0].x,0]])\n  : concat( back(midlength,p=bigend), \n                  [[last(bigend).x,0],[ bigend[0].x,0]]);\n  bounds = pointlist_bounds(shape);\n  center = mean(bounds);\n  attachable(anchor,spin,orient,l=bounds[1].y-bounds[0].y, r=bounds[1].x)\n  {\n    rotate_extrude(convexity=4)\n      polygon(fwd(center.y,p=shape));\n    children();\n  }  \n}\n\n\n// Function: modular_hose_radius()\n// Synopsis: Returns the waist radius of the given modular hose size.\n// Topics: Modular Hose, Parts\n// See Also: modular_hose(), tube()\n// Usage:\n//   r = modular_hose_radius(size, [outer]);\n// Description:\n//   Returns the inner (or outer) diameter of the waist section\n//   of the modular hose to enable hollowing out connecting channels.\n//   Note: diameter is accurate to about 1e-4.  \n// Arguments:\n//   size = size of hose part, must be 1/4, 1/2 or 3/4\n//   outer = set to true to get the outer diameter. \n// Example(3D):\n//   $fn=64;\n//   back_half()\n//      diff(\"remove\")\n//        cuboid(50){\n//          attach(TOP) modular_hose(1/2, \"ball\");\n//          up(0.01)position(TOP+RIGHT)tag(\"remove\")\n//            rot(180)\n//            xrot(-90)\n//            rotate_extrude(angle=135)\n//            right(25)\n//            circle(r=modular_hose_radius(1/2));\n//        }\nfunction modular_hose_radius(size, outer=false) =\n  let(\n      ind = search([size],[1/4, 1/2, 3/4])[0]\n  )\n  assert(ind!=[], \"Must specify size as 1/4, 1/2 or 3/4\")\n  let(\n     b = select(_modhose_big_end[ind], [0,-1]),\n     s = select(_modhose_small_end[ind], [0,-1])\n  )\n  outer ? b[1][0] : b[0][0];\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-27", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: mutators.scad\n//   Functions and modules to mutate children in various ways.\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: Modules and Functions to mutate items.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n// Section: Bounding Box\n//////////////////////////////////////////////////////////////////////\n\n// Module: bounding_box()\n// Synopsis: Creates the smallest bounding box that contains all the children.\n// SynTags: Geom\n// Topics: Mutators, Bounds, Bounding Boxes\n// See Also: pointlist_bounds()\n// Usage:\n//   bounding_box([excess],[planar]) CHILDREN;\n// Description:\n//   Returns the smallest axis-aligned square (or cube) shape that contains all the 2D (or 3D)\n//   children given.  The module children() must 3d when planar=false and\n//   2d when planar=true, or you will get a warning of mixing dimension\n//   or scaling by 0.\n// Arguments:\n//   excess = The amount that the bounding box should be larger than needed to bound the children, in each axis.\n//   planar = If true, creates a 2D bounding rectangle.  Is false, creates a 3D bounding cube.  Default: false\n// Example(3D):\n//   module shapes() {\n//       translate([10,8,4]) cube(5);\n//       translate([3,0,12]) cube(2);\n//   }\n//   #bounding_box() shapes();\n//   shapes();\n// Example(2D):\n//   module shapes() {\n//       translate([10,8]) square(5);\n//       translate([3,0]) square(2);\n//   }\n//   #bounding_box(planar=true) shapes();\n//   shapes();\nmodule bounding_box(excess=0, planar=false) {\n    // a 3d (or 2d when planar=true) approx. of the children projection on X axis\n    module _xProjection() {\n        if (planar) {\n            projection()\n                rotate([90,0,0])\n                    linear_extrude(1, center=true)\n                        hull()\n                            children();\n        } else {\n            xs = excess<.1? 1: excess;\n            linear_extrude(xs, center=true)\n                projection()\n                    rotate([90,0,0])\n                        linear_extrude(xs, center=true)\n                            projection()\n                                hull()\n                                    children();\n        }\n    }\n\n    // a bounding box with an offset of 1 in all axis\n    module _oversize_bbox() {\n        if (planar) {\n            minkowski() {\n                _xProjection() children(); // x axis\n                rotate(-90) _xProjection() rotate(90) children(); // y axis\n            }\n        } else {\n            minkowski() {\n                _xProjection() children(); // x axis\n                rotate(-90) _xProjection() rotate(90) children(); // y axis\n                rotate([0,-90,0]) _xProjection() rotate([0,90,0]) children(); // z axis\n            }\n        }\n    }\n\n    // offsets a cube by `excess`\n    module _shrink_cube() {\n        intersection() {\n            translate((1-excess)*[ 1, 1, 1]) children();\n            translate((1-excess)*[-1,-1,-1]) children();\n        }\n    }\n\n    req_children($children);\n    attachable(){\n      if(planar) {\n          offset(excess-1/2) _oversize_bbox() children();\n      } else {\n          render(convexity=2)\n          if (excess>.1) {\n              _oversize_bbox() children();\n          } else {\n              _shrink_cube() _oversize_bbox() children();\n          }\n      }\n      union();\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Warp Mutators\n//////////////////////////////////////////////////////////////////////\n\n\n// Module: chain_hull()\n// Synopsis: Performs the union of hull operations between consecutive pairs of children.\n// SynTags: Geom\n// Topics: Mutators\n// See Also: hull()\n// Usage:\n//   chain_hull() CHILDREN;\n//\n// Description:\n//   Performs hull operations between consecutive pairs of children,\n//   then unions all of the hull results.  This can be a very slow\n//   operation, but it can provide results that are hard to get\n//   otherwise.\n//\n// Side Effects:\n//   `$idx` is set to the index value of the first child of each hulling pair, and can be used to modify each child pair individually.\n//   `$primary` is set to true when the child is the first in a chain pair.\n//\n// Example:\n//   chain_hull() {\n//       cube(5, center=true);\n//       translate([30, 0, 0]) sphere(d=15);\n//       translate([60, 30, 0]) cylinder(d=10, h=20);\n//       translate([60, 60, 0]) cube([10,1,20], center=false);\n//   }\n// Example: Using `$idx` and `$primary`\n//   chain_hull() {\n//       zrot(  0) right(100) if ($primary) cube(5+3*$idx,center=true); else sphere(r=10+3*$idx);\n//       zrot( 45) right(100) if ($primary) cube(5+3*$idx,center=true); else sphere(r=10+3*$idx);\n//       zrot( 90) right(100) if ($primary) cube(5+3*$idx,center=true); else sphere(r=10+3*$idx);\n//       zrot(135) right(100) if ($primary) cube(5+3*$idx,center=true); else sphere(r=10+3*$idx);\n//       zrot(180) right(100) if ($primary) cube(5+3*$idx,center=true); else sphere(r=10+3*$idx);\n//   }\nmodule chain_hull()\n{\n    req_children($children);\n    attachable(){\n        if ($children == 1) {\n            children();\n        }\n        else {\n            for (i =[1:1:$children-1]) {\n                $idx = i;\n                hull() {\n                    let($primary=true) children(i-1);\n                    let($primary=false) children(i);\n                }\n            }\n        }\n        union();\n    }\n}\n\n\n// Module: path_extrude2d()\n// Synopsis: Extrudes 2D children along a 2D path.\n// SynTags: Geom\n// Topics: Mutators, Extrusion \n// See Also: path_sweep(), path_extrude()\n// Usage:\n//   path_extrude2d(path, [caps=], [closed=], [s=], [convexity=]) 2D-CHILDREN;\n// Description:\n//   Extrudes 2D children along the given 2D path, with optional rounded endcaps.\n//   It works by constructing straight sections corresponding to each segment of the path and inserting rounded joints at each corner.\n//   If the children are symmetric across the Y axis line then you can set caps=true to produce rounded caps on the ends of the profile.\n//   If you set caps to true for asymmetric children then incorrect caps will be generated.\n// Arguments:\n//   path = The 2D path to extrude the geometry along.\n//   ---\n//   caps = If true, caps each end of the path with a rounded copy of the children.  Children must by symmetric across the Y axis, or results are wrong.  Default: false\n//   closed = If true, connect the starting point of the path to the ending point.  Default: false\n//   convexity = The max number of times a line could pass though a wall.  Default: 10\n//   s = Mask size to use.  Use a number larger than twice your object's largest axis.  If you make this too large, it messes with centering your view.  Default: The length of the diagonal of the path's bounding box.\n// Example:\n//   path = [\n//       each right(50, p=arc(d=100,angle=[90,180])),\n//       each left(50, p=arc(d=100,angle=[0,-90])),\n//   ];\n//   path_extrude2d(path,caps=false) {\n//       fwd(2.5) square([5,6],center=true);\n//       fwd(6) square([10,5],center=true);\n//   }\n// Example:\n//   path_extrude2d(arc(d=100,angle=[180,270]),caps=true)\n//       trapezoid(w1=10, w2=5, h=10, anchor=BACK);\n// Example:\n//   include <BOSL2/beziers.scad>\n//   path = bezpath_curve([\n//       [-50,0], [-25,50], [0,0], [50,0]\n//   ]);\n//   path_extrude2d(path, caps=false)\n//       trapezoid(w1=10, w2=3, h=5, anchor=BACK);\n// Example: Un-Closed Path\n//   $fn=16;\n//   spath = star(id=15,od=35,n=5);\n//   path_extrude2d(spath, caps=false, closed=false)\n//       move_copies([[-3.5,1.5],[0.0,3.0],[3.5,1.5]])\n//           circle(r=1.5);\n// Example: Complex Endcaps\n//   $fn=16;\n//   spath = star(id=15,od=35,n=5);\n//   path_extrude2d(spath, caps=true, closed=false)\n//       move_copies([[-3.5,1.5],[0.0,3.0],[3.5,1.5]])\n//           circle(r=1.5);\nmodule path_extrude2d(path, caps=false, closed=false, s, convexity=10) {\n    req_children($children);\n    extra_ang = 0.1; // Extra angle for overlap of joints\n    check =\n       assert(caps==false || closed==false, \"Cannot have caps on a closed extrusion\")\n       assert(is_path(path,2));\n    path = deduplicate(path);\n    s = s!=undef? s :\n        let(b = pointlist_bounds(path))\n        norm(b[1]-b[0]);\n    check2 = assert(is_finite(s));\n    L = len(path);\n    attachable(){\n      union(){\n        for (i = [0:1:L-(closed?1:2)]) {\n            seg = select(path, i, i+1);\n            segv = seg[1] - seg[0];\n            seglen = norm(segv);\n            translate((seg[0]+seg[1])/2) {\n                rot(from=BACK, to=segv) {\n                    difference() {\n                        xrot(90) {\n                            linear_extrude(height=seglen, center=true, convexity=convexity) {\n                                children();\n                            }\n                        }\n                        if (closed || i>0) {\n                            pt = select(path, i-1);\n                            pang = v_theta(rot(from=-segv, to=RIGHT, p=pt - seg[0]));\n                            fwd(seglen/2+0.01) zrot(pang/2) cube(s, anchor=BACK);\n                        }\n                        if (closed || i<L-2) {\n                            pt = select(path, i+2);\n                            pang = v_theta(rot(from=segv, to=RIGHT, p=pt - seg[1]));\n                            back(seglen/2+0.01) zrot(pang/2) cube(s, anchor=FWD);\n                        }\n                    }\n                }\n            }\n        }\n        for (t=triplet(path,wrap=closed)) {\n            ang = -(180-vector_angle(t)) * sign(_point_left_of_line2d(t[2],[t[0],t[1]]));\n            delt = point3d(t[2] - t[1]);\n            if (ang!=0)\n                translate(t[1]) {\n                    frame_map(y=delt, z=UP)\n                        rotate(-sign(ang)*extra_ang/2)\n                            rotate_extrude(angle=ang+sign(ang)*extra_ang)\n                                if (ang<0)\n                                    right_half(planar=true) children();\n                                else\n                                    left_half(planar=true) children();                          \n                }\n                    \n        }\n        if (caps) {\n            bseg = select(path,0,1);\n            move(bseg[0])\n                rot(from=BACK, to=bseg[0]-bseg[1])\n                    rotate_extrude(angle=180)\n                        right_half(planar=true) children();\n            eseg = select(path,-2,-1);\n            move(eseg[1])\n                rot(from=BACK, to=eseg[1]-eseg[0])\n                    rotate_extrude(angle=180)\n                        right_half(planar=true) children();\n        }\n      }\n      union();\n    }\n}\n\n\n// Module: cylindrical_extrude()\n// Synopsis: Extrudes 2D children outwards around a cylinder.\n// SynTags: Geom\n// Topics: Mutators, Extrusion, Rotation\n// See Also: heightfield(), cylindrical_heightfield(), cyl()\n// Usage:\n//   cylindrical_extrude(ir|id=, or|od=, [size=], [convexity=], [spin=], [orient=]) 2D-CHILDREN;\n// Description:\n//   Extrudes its 2D children outwards, curved around a cylindrical shape.  Uses $fn/$fa/$fs to\n//   control the faceting of the extrusion.  \n// Arguments:\n//   ir = The inner radius to extrude from.\n//   or = The outer radius to extrude to.\n//   ---\n//   od = The outer diameter to extrude to.\n//   id = The inner diameter to extrude from.\n//   size = The [X,Y] size of the 2D children to extrude.  Default: [1000,1000]\n//   convexity = The max number of times a line could pass though a wall.  Default: 10\n//   spin = Amount in degrees to spin around cylindrical axis.  Default: 0\n//   orient = The orientation of the cylinder to wrap around, given as a vector.  Default: UP\n// Example:\n//   cylindrical_extrude(or=50, ir=45)\n//       text(text=\"Hello World!\", size=10, halign=\"center\", valign=\"center\");\n// Example: Spin Around the Cylindrical Axis\n//   cylindrical_extrude(or=50, ir=45, spin=90)\n//       text(text=\"Hello World!\", size=10, halign=\"center\", valign=\"center\");\n// Example: Orient to the Y Axis.\n//   cylindrical_extrude(or=40, ir=35, orient=BACK)\n//       text(text=\"Hello World!\", size=10, halign=\"center\", valign=\"center\");\nmodule cylindrical_extrude(ir, or, od, id, size=1000, convexity=10, spin=0, orient=UP) {\n    req_children($children);\n    check1 = assert(is_num(size) || is_vector(size,2));\n    size = is_num(size)? [size,size] : size;\n    ir = get_radius(r=ir,d=id);\n    or = get_radius(r=or,d=od);\n    check2 = assert(all_positive([ir,or]), \"Must supply positive inner and outer radius or diameter\");\n    index_r = or;\n    circumf = 2 * PI * index_r;\n    width = min(size.x, circumf);\n    check3 = assert(width <= circumf, \"Shape would more than completely wrap around.\");\n    sides = segs(or);\n    step = circumf / sides;\n    steps = ceil(width / step);\n    attachable() {\n      rot(from=UP, to=orient) rot(spin) {\n          for (i=[0:1:steps-2]) {\n              x = (i+0.5-steps/2) * step;\n              zrot(360 * x / circumf) {\n                  fwd(or*cos(180/sides)) {\n                      xrot(-90) {\n                          linear_extrude(height=or-ir, scale=[ir/or,1], center=false, convexity=convexity) {\n                              yflip()\n                              intersection() {\n                                  left(x) children();\n                                  rect([quantup(step,pow(2,-15)),size.y]);\n                              }\n                          }\n                      }\n                  }\n              }\n          }\n      }\n      union();\n    }\n}\n\n\n// Module: extrude_from_to()\n// Synopsis: Extrudes 2D children between two points in 3D space.\n// SynTags: Geom\n// Topics: Extrusion, Mutators\n// See Also: path_sweep(), path_extrude2d()\n// Usage:\n//   extrude_from_to(pt1, pt2, [convexity=], [twist=], [scale=], [slices=]) 2D-CHILDREN;\n// Description:\n//   Extrudes the 2D children linearly between the 3d points pt1 and pt2.  The origin of the 2D children are placed on\n//   pt1 and pt2, and oriented perpendicular to the line between the points.  \n// Arguments:\n//   pt1 = starting point of extrusion.\n//   pt2 = ending point of extrusion.\n//   ---\n//   convexity = max number of times a line could intersect a wall of the 2D shape being extruded.\n//   twist = number of degrees to twist the 2D shape over the entire extrusion length.\n//   scale = scale multiplier for end of extrusion compared the start.\n//   slices = Number of slices along the extrusion to break the extrusion into.  Useful for refining `twist` extrusions.\n// Example(FlatSpin,VPD=200,VPT=[0,0,15]):\n//   extrude_from_to([0,0,0], [10,20,30], convexity=4, twist=360, scale=3.0, slices=40) {\n//       xcopies(3) circle(3, $fn=32);\n//   }\nmodule extrude_from_to(pt1, pt2, convexity, twist, scale, slices) {\n    req_children($children);\n    check =\n      assert(is_vector(pt1),\"First point must be a vector\")\n      assert(is_vector(pt2),\"Second point must be a vector\");\n    pt1 = point3d(pt1);\n    pt2 = point3d(pt2);\n    rtp = xyz_to_spherical(pt2-pt1);\n    attachable()\n    {\n      translate(pt1) {\n          rotate([0, rtp[2], rtp[1]]) {\n              if (rtp[0] > 0) {\n                  linear_extrude(height=rtp[0], convexity=convexity, center=false, slices=slices, twist=twist, scale=scale) {\n                      children();\n                  }\n              }\n          }\n      }\n      union();\n    }\n}\n\n\n\n// Module: path_extrude()\n// Synopsis: Extrudes 2D children along a 3D path.\n// SynTags: Geom\n// Topics: Paths, Extrusion, Mutators\n// See Also: path_sweep(), path_extrude2d()\n// Usage:\n//   path_extrude(path, [convexity], [clipsize]) 2D-CHILDREN;\n// Description:\n//   Extrudes 2D children along a 3D path.  This may be slow and can have problems with twisting.  \n// Arguments:\n//   path = Array of points for the bezier path to extrude along.\n//   convexity = Maximum number of walls a ray can pass through.\n//   clipsize = Increase if artifacts are left.  Default: 100\n// Example(FlatSpin,VPD=600,VPT=[75,16,20]):\n//   path = [ [0, 0, 0], [33, 33, 33], [66, 33, 40], [100, 0, 0], [150,0,0] ];\n//   path_extrude(path) circle(r=10, $fn=6);\nmodule path_extrude(path, convexity=10, clipsize=100) {\n    req_children($children);\n    rotmats = cumprod([\n       for (i = idx(path,e=-2)) let(\n           vec1 = i==0? UP : unit(path[i]-path[i-1], UP),\n           vec2 = unit(path[i+1]-path[i], UP)\n       ) rot(from=vec1,to=vec2)\n    ]);\n    // This adds a rotation midway between each item on the list\n    interp = rot_resample(rotmats,n=2,method=\"count\");\n    epsilon = 0.0001;  // Make segments ever so slightly too long so they overlap.\n    ptcount = len(path);\n    attachable(){\n       for (i = [0:1:ptcount-2]) {\n           pt1 = path[i];\n           pt2 = path[i+1];\n           dist = norm(pt2-pt1);\n           T = rotmats[i];\n           difference() {\n               translate(pt1) {\n                   multmatrix(T) {\n                       down(clipsize/2/2) {\n                           if ((dist+clipsize/2) > 0) {\n                               linear_extrude(height=dist+clipsize/2, convexity=convexity) {\n                                   children();\n                               }\n                           }\n                       }\n                   }\n               }\n               translate(pt1) {\n                   hq = (i > 0)? interp[2*i-1] : T;\n                   multmatrix(hq) down(clipsize/2+epsilon) cube(clipsize, center=true);\n               }\n               translate(pt2) {\n                   hq = (i < ptcount-2)? interp[2*i+1] : T;\n                   multmatrix(hq) up(clipsize/2+epsilon) cube(clipsize, center=true);\n               }\n           }\n       }\n       union();\n    }\n}\n\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Offset Mutators\n//////////////////////////////////////////////////////////////////////\n\n// Module: minkowski_difference()\n// Synopsis: Removes diff shapes from base shape surface.\n// SynTags: Geom\n// Topics: Mutators\n// See Also: offset3d()\n// Usage:\n//   minkowski_difference() { BASE; DIFF1; DIFF2; ... }\n// Description:\n//   Takes a 3D base shape and one or more 3D diff shapes, carves out the diff shapes from the\n//   surface of the base shape, in a way complementary to how `minkowski()` unions shapes to the\n//   surface of its base shape.\n// Arguments:\n//   planar = If true, performs minkowski difference in 2D.  Default: false (3D)\n// Example:\n//   minkowski_difference() {\n//       union() {\n//           cube([120,70,70], center=true);\n//           cube([70,120,70], center=true);\n//           cube([70,70,120], center=true);\n//       }\n//       sphere(r=10);\n//   }\nmodule minkowski_difference(planar=false) {\n    req_children($children);\n    attachable(){\n         difference() {\n             bounding_box(excess=0, planar=planar) children(0);\n             render(convexity=20) {\n                 minkowski() {\n                     difference() {\n                         bounding_box(excess=1, planar=planar) children(0);\n                         children(0);\n                     }\n                     for (i=[1:1:$children-1]) children(i);\n                 }\n             }\n         }\n         union();\n    }\n}\n\n\n\n\n// Module: offset3d()\n// Synopsis: Expands or contracts the surface of a 3D object.\n// SynTags: Geom\n// Topics: Mutators\n// See Also: minkowski_difference(), round3d()\n// Usage:\n//   offset3d(r, [size], [convexity]) CHILDREN;\n// Description:\n//   Expands or contracts the surface of a 3D object by a given amount.  This is very, very slow.\n//   No really, this is unbearably slow.  It uses `minkowski()`.  Use this as a last resort.\n//   This is so slow that no example images will be rendered.\n// Arguments:\n//   r = Radius to expand object by.  Negative numbers contract the object. \n//   size = Maximum size of object to be contracted, given as a scalar.  Default: 100\n//   convexity = Max number of times a line could intersect the walls of the object.  Default: 10\nmodule offset3d(r, size=100, convexity=10) {\n    req_children($children);\n    n = quant(max(8,segs(abs(r))),4);\n    attachable(){\n      if (r==0) {\n          children();\n      } else if (r>0) {\n          render(convexity=convexity)\n          minkowski() {\n              children();\n              sphere(r, $fn=n);\n          }\n      } else {\n          size2 = size * [1,1,1];\n          size1 = size2 * 1.02;\n          render(convexity=convexity)\n          difference() {\n              cube(size2, center=true);\n              minkowski() {\n                  difference() {\n                      cube(size1, center=true);\n                      children();\n                  }\n                  sphere(-r, $fn=n);\n              }\n          }\n      }\n      union();\n    }\n}\n\n\n// Module: round3d()\n// Synopsis: Rounds arbitrary 3d objects.\n// SynTags: Geom\n// Topics: Rounding, Mutators\n// See Also: offset3d(), minkowski_difference()\n// Usage:\n//   round3d(r) CHILDREN;\n//   round3d(or) CHILDREN;\n//   round3d(ir) CHILDREN;\n//   round3d(or, ir) CHILDREN;\n// Description:\n//   Rounds arbitrary 3D objects.  Giving `r` rounds all concave and convex corners.  Giving just `ir`\n//   rounds just concave corners.  Giving just `or` rounds convex corners.  Giving both `ir` and `or`\n//   can let you round to different radii for concave and convex corners.  The 3D object must not have\n//   any parts narrower than twice the `or` radius.  Such parts will disappear.  This is an *extremely*\n//   slow operation.  I cannot emphasize enough just how slow it is.  It uses `minkowski()` multiple times.\n//   Use this as a last resort.  This is so slow that no example images will be rendered.\n// Arguments:\n//   r = Radius to round all concave and convex corners to.\n//   or = Radius to round only outside (convex) corners to.  Use instead of `r`.\n//   ir = Radius to round only inside (concave) corners to.  Use instead of `r`.\nmodule round3d(r, or, ir, size=100)\n{\n    req_children($children);\n    or = get_radius(r1=or, r=r, dflt=0);\n    ir = get_radius(r1=ir, r=r, dflt=0);\n    attachable(){\n       offset3d(or, size=size)\n           offset3d(-ir-or, size=size)\n               offset3d(ir, size=size)\n                   children();\n       union();\n    }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-28", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: nema_steppers.scad\n//   Mounting holes for NEMA motors, and simple motor models.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/nema_steppers.scad>\n// FileGroup: Parts\n// FileSummary: NEMA motor mounts and stepper motor models.\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Motor Models\n\n\n// Module: nema_stepper_motor()\n// Synopsis: Creates a NEMA standard stepper motor model.\n// SynTags: Geom\n// Topics: Parts, Motors\n// See Also: nema_stepper_motor(), nema_mount_mask()\n// Usage:\n//   nema_stepper_motor(size, h, shaft_len, [$slop=], ...) [ATTACHMENTS];\n// Description:\n//   Creates a model of a NEMA standard stepper motor.\n// Arguments:\n//   size = The NEMA standard size of the stepper motor.\n//   h = Length of motor body.  Default: 24mm\n//   shaft_len = Length of shaft protruding out the top of the stepper motor.  Default: 20mm\n//   ---\n//   details = If false, creates a very rough motor shape, suitable for using as a mask.  Default: true\n//   atype = The attachment set type to use when anchoring.  Default: `\"body\"`\n//   $slop = If details is false then increase size of the model by double this amount (for use as a mask)\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `TOP`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Anchor Types:\n//   \"shaft\" = Anchor relative to the shaft.\n//   \"plinth\" = Anchor relative to the plinth.\n//   \"body\" = Anchor relative to the motor body.\n//   \"screws\" = Anchor relative to the screw hole centers.  ie: TOP+RIGHT+FRONT is the center-top of the front-right screwhole.\n// Examples:\n//   nema_stepper_motor(size=8, h=24, shaft_len=15);\n//   nema_stepper_motor(size=11, h=24, shaft_len=20);\n//   nema_stepper_motor(size=17, h=40, shaft_len=30);\n//   nema_stepper_motor(size=23, h=50, shaft_len=40);\n//   nema_stepper_motor(size=23, h=50, shaft_len=40, details=false);\nmodule nema_stepper_motor(size=17, h=24, shaft_len=20, details=true, atype=\"body\", anchor=TOP, spin=0, orient=UP)\n{\n    info = nema_motor_info(size);\n    motor_width   = info[0];\n    plinth_height = info[1];\n    plinth_diam   = info[2];\n    screw_spacing = info[3];\n    screw_size    = info[4];\n    screw_depth   = info[5];\n    shaft_diam    = info[6];\n    geom = atype==\"shaft\"? attach_geom(r=shaft_diam/2, h=shaft_len-plinth_height, cp=[0,0,h/2+plinth_height/2+shaft_len/2]) :\n        atype==\"plinth\"? attach_geom(r=plinth_diam/2, h=plinth_height, cp=[0,0,h/2+plinth_height/2]) :\n        atype==\"body\"? attach_geom(size=[motor_width, motor_width, h]) :\n        atype==\"screws\"? attach_geom(size=[screw_spacing, screw_spacing, screw_depth], cp=[0,0,h/2-screw_depth/2]) :\n        assert(in_list(atype, [\"shaft\", \"plinth\", \"body\", \"screws\"]));\n    attachable(anchor,spin,orient, geom=geom) {\n        up(h/2) {\n            if (details == false) {\n                slop = get_slop();\n                color([0.4, 0.4, 0.4]) \n                    cuboid(size=[motor_width+2*slop, motor_width+2*slop, h+slop], anchor=TOP);\n                color([0.6, 0.6, 0.6])\n                    cylinder(h=plinth_height+slop, d=plinth_diam+2*slop);\n                color(\"silver\")\n                    cylinder(h=shaft_len+slop, d=shaft_diam+2*slop, $fn=max(12,segs(shaft_diam/2)));\n            } else if (size < 23) {\n                difference() {\n                    color([0.4, 0.4, 0.4]) \n                        cuboid(size=[motor_width, motor_width, h], chamfer=size>=8? 2 : 0.5, edges=\"Z\", anchor=TOP);\n                    color(\"silver\")\n                        xcopies(screw_spacing)\n                            ycopies(screw_spacing)\n                                cyl(r=screw_size/2, h=screw_depth*2, $fn=max(12,segs(screw_size/2)));\n                }\n                color([0.6, 0.6, 0.6]) {\n                    difference() {\n                        cylinder(h=plinth_height, d=plinth_diam);\n                        cyl(h=plinth_height*3, d=shaft_diam+0.75);\n                    }\n                }\n                color(\"silver\") cylinder(h=shaft_len, d=shaft_diam, $fn=max(12,segs(shaft_diam/2)));\n            } else {\n                difference() {\n                    union() {\n                        color([0.4, 0.4, 0.4])\n                            cuboid([motor_width, motor_width, h], rounding=screw_size, edges=\"Z\", anchor=TOP);\n                        color([0.6, 0.6, 0.6]) {\n                            difference() {\n                                cylinder(h=plinth_height, d=plinth_diam);\n                                cyl(h=plinth_height*3, d=shaft_diam+0.75);\n                            }\n                        }\n                        color(\"silver\")\n                            cylinder(h=shaft_len, d=shaft_diam, $fn=max(12,segs(shaft_diam/2)));\n                    }\n                    color([0.4, 0.4, 0.4]) {\n                        xcopies(screw_spacing) {\n                            ycopies(screw_spacing) {\n                                cyl(d=screw_size, h=screw_depth*3, $fn=max(12,segs(screw_size/2)));\n                                down(screw_depth) cuboid([screw_size*2, screw_size*2, h], anchor=TOP);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n\n// Section: Masking Modules\n\n\n// Module: nema_mount_mask()\n// Synopsis: Creates a standard NEMA mount holes mask.\n// SynTags: Geom\n// Topics: Parts, Motors\n// See Also: nema_stepper_motor(), nema_mount_mask()\n// Usage:\n//   nema_mount_mask(size, depth, l, [$slop], ...);\n// Description: Creates a mask to use when making standard NEMA stepper motor mounts.\n// Arguments:\n//   size = The standard NEMA motor size to make a mount for.\n//   depth = The thickness of the mounting hole mask.  Default: 5\n//   l = The length of the slots, for making an adjustable motor mount.  Default: 5\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value to make parts fit just right.\n// Anchor Types:\n//   \"full\" = Anchor relative the full mask.\n//   \"screws\" = Anchor relative to the screw hole centers.  ie: TOP+RIGHT+FRONT is the center-top of the front-right screwhole.\n// Examples:\n//   nema_mount_mask(size=14, depth=5, l=5);\n//   nema_mount_mask(size=17, depth=5, l=5);\n//   nema_mount_mask(size=17, depth=5, l=0);\nmodule nema_mount_mask(size, depth=5, l=5, atype=\"full\", anchor=CENTER, spin=0, orient=UP)\n{\n    slop = get_slop();\n    info = nema_motor_info(size);\n    motor_width   = info[0];\n    plinth_height = info[1];\n    plinth_diam   = info[2] + slop;\n    screw_spacing = info[3];\n    screw_size    = info[4] + slop;\n    screw_depth   = info[5];\n    shaft_diam    = info[6];\n    screwfn = quantup(max(8,segs(screw_size/2)),4);\n    plinthfn = quantup(max(8,segs(plinth_diam/2)),4);\n    s = atype==\"full\"? [screw_spacing+screw_size, screw_spacing+screw_size+l, depth] :\n        atype==\"screws\"? [screw_spacing, screw_spacing, depth] :\n        assert(in_list(atype, [\"full\", \"screws\"]));\n    attachable(anchor,spin,orient, size=s) {\n        union() {\n            xcopies(screw_spacing) {\n                ycopies(screw_spacing) {\n                    if (l > 0) {\n                        ycopies(l) cyl(h=depth, d=screw_size, $fn=screwfn);\n                        cube([screw_size, l, depth], center=true);\n                    } else {\n                        cyl(h=depth, d=screw_size, $fn=screwfn);\n                    }\n                }\n            }\n            if (l > 0) {\n                ycopies(l) cyl(h=depth, d=plinth_diam, $fn=plinthfn);\n                cube([plinth_diam, l, depth], center=true);\n            } else {\n                cyl(h=depth, d=plinth_diam, $fn=plinthfn);\n            }\n        }\n        children();\n    }\n}\n\n\n\n// Section: Functions\n\n\n// Function: nema_motor_info()\n// Synopsis: Returns dimension info for a given NEMA motor size.\n// Topics: Parts, Motors\n// See Also: nema_stepper_motor(), nema_mount_mask()\n// Usage:\n//   info = nema_motor_info(size);\n// Description:\n//   Gets various dimension info for a NEMA stepper motor of a specific size.\n//   Returns a list of scalar values, containing, in order:\n//   - MOTOR_WIDTH: The full width and length of the motor.\n//   - PLINTH_HEIGHT: The height of the circular plinth on the face of the motor.\n//   - PLINTH_DIAM: The diameter of the circular plinth on the face of the motor.\n//   - SCREW_SPACING: The spacing between screwhole centers in both X and Y axes.\n//   - SCREW_SIZE: The diameter of the screws.\n//   - SCREW_DEPTH: The depth of the screwholes.\n//   - SHAFT_DIAM: The diameter of the motor shaft.\n// Arguments:\n//   size = The standard NEMA motor size.\nfunction nema_motor_info(size) =\n    let(\n        info_arr = [\n            [ 6, [ 14.0, 1.50, 11.0, 11.50, 1.6,  2.5,  4.00]],\n            [ 8, [ 20.3, 1.50, 16.0, 15.40, 2.0,  2.5,  4.00]],\n            [11, [ 28.2, 1.50, 22.0, 23.11, 2.6,  3.0,  5.00]],\n            [14, [ 35.2, 2.00, 22.0, 26.00, 3.0,  4.5,  5.00]],\n            [17, [ 42.3, 2.00, 22.0, 31.00, 3.0,  4.5,  5.00]],\n            [23, [ 57.0, 1.60, 38.1, 47.00, 5.1,  4.8,  6.35]],\n            [34, [ 86.0, 2.00, 73.0, 69.60, 6.5, 10.0, 14.00]],\n            [42, [110.0, 1.50, 55.5, 88.90, 8.5, 12.7, 19.00]],\n        ],\n        found = [for(info=info_arr) if(info[0]==size) info[1]]\n    )\n    assert(found, \"Unsupported NEMA size.\")\n    found[0];\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-29", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: partitions.scad\n//   Cut objects with a plane, or partition them into interlocking pieces for easy printing of large objects. \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: Cut objects with a plane or partition them into interlocking pieces.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Planar Cutting\n\n// Function&Module: half_of()\n// Synopsis: Masks half of an object at a cut plane.\n// SynTags: Geom, VNF, Path, Region\n// Topics: Partitions, Masking\n// See Also: back_half(), front_half(), left_half(), right_half(), top_half(), bottom_half(), intersection()\n//\n// Usage: as module\n//   half_of(v, [cp], [s], [planar]) CHILDREN;\n// Usage: as function\n//   result = half_of(p,v,[cp]);\n//\n// Description:\n//   Slices an object at a cut plane, and masks away everything that is on one side.  The v parameter\n//   is either a plane specification or a normal vector.  The `s` parameter is needed for the module\n//   version to control the size of the masking cube.  If `s` is too large then the preview display\n//   will flip around and display the wrong half, but if it is too small it won't fully mask your\n//   model.  When called as a function, you must supply a vnf, path or region in p.  If planar is set\n//   to true for the module version the operation is performed in 2D and UP and DOWN are treated as\n//   equivalent to BACK and FWD respectively.\n//\n// Arguments:\n//   p = path, region or VNF to slice.  (Function version)\n//   v = Normal of plane to slice at.  Keeps everything on the side the normal points to.  Default: [0,0,1] (UP)\n//   cp = If given as a scalar, moves the cut plane along the normal by the given amount.  If given as a point, specifies a point on the cut plane.  Default: [0,0,0]\n//   s = Mask size to use.  Use a number larger than twice your object's largest axis.  If you make this too large, OpenSCAD's preview rendering may display the wrong half.  (Module version)  Default: 100\n//   planar = If true, perform a 2D operation.  When planar, a `v` of `UP` or `DOWN` becomes equivalent of `BACK` and `FWD` respectively.  (Module version).  Default: false.  \n//\n// Examples:\n//   half_of(DOWN+BACK, cp=[0,-10,0]) cylinder(h=40, r1=10, r2=0, center=false);\n//   half_of(DOWN+LEFT, s=200) sphere(d=150);\n// Example(2D):\n//   half_of([1,1], planar=true) circle(d=50);\nmodule half_of(v=UP, cp, s=100, planar=false)\n{\n    req_children($children);\n    cp = is_vector(v,4)? assert(cp==undef, \"Don't use cp with plane definition.\") plane_normal(v) * v[3] :\n        is_vector(cp)? cp :\n        is_num(cp)? cp*unit(v) :\n        [0,0,0];\n    v = is_vector(v,4)? plane_normal(v) : v;\n    if (cp != [0,0,0]) {\n        translate(cp) half_of(v=v, s=s, planar=planar) translate(-cp) children();\n    } else if (planar) {\n        v = (v==UP)? BACK : (v==DOWN)? FWD : v;\n        ang = atan2(v.y, v.x);\n        difference() {\n            children();\n            rotate(ang+90) {\n                back(s/2) square(s, center=true);\n            }\n        }\n    } else {\n        difference() {\n            children();\n            rot(from=UP, to=-v) {\n                up(s/2) cube(s, center=true);\n            }\n        }\n    }\n}\n\nfunction half_of(p, v=UP, cp) =\n    is_vnf(p) ?\n       assert(is_vector(v) && (len(v)==3 || len(v)==4),str(\"Must give 3-vector or plane specification\",v))\n       assert(select(v,0,2)!=[0,0,0], \"vector v must be nonzero\")\n       let(\n            plane = is_vector(v,4) ? assert(cp==undef, \"Don't use cp with plane definition.\") v\n                  : is_undef(cp) ? [each v, 0]\n                  : is_num(cp) ? [each v, cp*(v*v)/norm(v)]\n                  : assert(is_vector(cp,3),\"Centerpoint must be a 3-vector\")\n                    [each v, cp*v]\n       )\n       vnf_halfspace(plane, p)\n   : is_path(p) || is_region(p) ?\n      let(\n          v = (v==UP)? BACK : (v==DOWN)? FWD : v,\n          cp = is_undef(cp) ? [0,0]\n             : is_num(cp) ? v*cp\n             : assert(is_vector(cp,2) || (is_vector(cp,3) && cp.z==0),\"Centerpoint must be 2-vector\")\n               cp\n      )\n      assert(is_vector(v,2) || (is_vector(v,3) && v.z==0),\"Must give 2-vector\")\n      assert(!all_zero(v), \"Vector v must be nonzero\")\n      let(\n          v=unit(v), \n          bounds = pointlist_bounds(is_region(p)?flatten(p):p),\n          L = 2*max(norm(bounds[0]-cp), norm(bounds[1]-cp)),\n          u = [-v.y,v.x],\n          box = [cp+u*L, cp+(v+u)*L, cp+(v-u)*L, cp-u*L]\n      )\n      intersection(box,p)\n   : assert(false, \"Input must be a region, path or VNF\");\n\n\n\n/*  This code cut 3d paths but leaves behind connecting line segments\n    is_path(p) ?\n        //assert(len(p[0]) == d, str(\"path must have dimension \", d))\n        let(z = [for(x=p) (x-cp)*v])\n        [ for(i=[0:len(p)-1]) each concat(z[i] >= 0 ? [p[i]] : [],\n            // we assume a closed path here;\n            // to make this correct for an open path,\n            // just replace this by [] when i==len(p)-1:\n            let(j=(i+1)%len(p))\n            // the remaining path may have flattened sections, but this cannot\n            // create self-intersection or whiskers:\n            z[i]*z[j] >= 0 ? [] : [(z[j]*p[i]-z[i]*p[j])/(z[j]-z[i])]) ]\n        :\n*/\n\n\n// Function&Module: left_half()\n// Synopsis: Masks the right half of an object along the Y-Z plane, leaving the left half.\n// SynTags: Geom, VNF, Path, Region\n// Topics: Partitions, Masking\n// See Also: back_half(), front_half(), right_half(), top_half(), bottom_half(), half_of(), intersection()\n//\n// Usage: as module\n//   left_half([s], [x]) CHILDREN;\n//   left_half(planar=true, [s], [x]) CHILDREN;\n// Usage: as function\n//   result = left_half(p, [x]);\n//\n// Description:\n//   Slices an object at a vertical Y-Z cut plane, and masks away everything that is right of it.\n//   The `s` parameter is needed for the module version to control the size of the masking cube.\n//   If `s` is too large then the preview display will flip around and display the wrong half,\n//   but if it is too small it won't fully mask your model.  \n//\n// Arguments:\n//   p = VNF, region or path to slice (function version)\n//   s = Mask size to use.  Use a number larger than twice your object's largest axis.  If you make this too large, OpenSCAD's preview rendering may display the wrong half.  (Module version)  Default: 100\n//   x = The X coordinate of the cut-plane.  Default: 0\n//   planar = If true, perform a 2D operation.  (Module version)  Default: false. \n// Examples:\n//   left_half() sphere(r=20);\n//   left_half(x=-8) sphere(r=20);\n// Example(2D):\n//   left_half(planar=true) circle(r=20);\nmodule left_half(s=100, x=0, planar=false)\n{\n    req_children($children);\n    dir = LEFT;\n    difference() {\n        children();\n        translate([x,0,0]-dir*s/2) {\n            if (planar) {\n                square(s, center=true);\n            } else {\n                cube(s, center=true);\n            }\n        }\n    }\n}\nfunction left_half(p,x=0) = half_of(p, LEFT, [x,0,0]);\n\n\n\n// Function&Module: right_half()\n// SynTags: Geom, VNF, Path, Region\n// Synopsis: Masks the left half of an object along the Y-Z plane, leaving the right half.\n// Topics: Partitions, Masking\n// See Also: back_half(), front_half(), left_half(), top_half(), bottom_half(), half_of(), intersection()\n//\n// Usage: as module\n//   right_half([s=], [x=]) CHILDREN;\n//   right_half(planar=true, [s=], [x=]) CHILDREN;\n// Usage: as function\n//   result = right_half(p, [x=]);\n//\n// Description:\n//   Slices an object at a vertical Y-Z cut plane, and masks away everything that is left of it.\n//   The `s` parameter is needed for the module version to control the size of the masking cube.\n//   If `s` is too large then the preview display will flip around and display the wrong half,\n//   but if it is too small it won't fully mask your model.  \n// Arguments:\n//   p = VNF, region or path to slice (function version)\n//   s = Mask size to use.  Use a number larger than twice your object's largest axis.  If you make this too large, OpenSCAD's preview rendering may display the wrong half.  (Module version)  Default: 100\n//   x = The X coordinate of the cut-plane.  Default: 0\n//   planar = If true, perform a 2D operation.  (Module version)  Default: false. \n// Examples(FlatSpin,VPD=175):\n//   right_half() sphere(r=20);\n//   right_half(x=-5) sphere(r=20);\n// Example(2D):\n//   right_half(planar=true) circle(r=20);\nmodule right_half(s=100, x=0, planar=false)\n{\n    dir = RIGHT;\n    difference() {\n        children();\n        translate([x,0,0]-dir*s/2) {\n            if (planar) {\n                square(s, center=true);\n            } else {\n                cube(s, center=true);\n            }\n        }\n    }\n}\nfunction right_half(p,x=0) = half_of(p, RIGHT, [x,0,0]);\n\n\n\n// Function&Module: front_half()\n// Synopsis: Masks the back half of an object along the X-Z plane, leaving the front half.\n// SynTags: Geom, VNF, Path, Region\n// Topics: Partitions, Masking\n// See Also: back_half(), left_half(), right_half(), top_half(), bottom_half(), half_of(), intersection()\n//\n// Usage:\n//   front_half([s], [y]) CHILDREN;\n//   front_half(planar=true, [s], [y]) CHILDREN;\n// Usage: as function\n//   result = front_half(p, [y]);\n//\n// Description:\n//   Slices an object at a vertical X-Z cut plane, and masks away everything that is behind it.\n//   The `s` parameter is needed for the module version to control the size of the masking cube.\n//   If `s` is too large then the preview display will flip around and display the wrong half,\n//   but if it is too small it won't fully mask your model.  \n// Arguments:\n//   p = VNF, region or path to slice (function version)\n//   s = Mask size to use.  Use a number larger than twice your object's largest axis.  If you make this too large, OpenSCAD's preview rendering may display the wrong half.  (Module version)  Default: 100\n//   y = The Y coordinate of the cut-plane.  Default: 0\n//   planar = If true, perform a 2D operation.  (Module version)  Default: false. \n// Examples(FlatSpin,VPD=175):\n//   front_half() sphere(r=20);\n//   front_half(y=5) sphere(r=20);\n// Example(2D):\n//   front_half(planar=true) circle(r=20);\nmodule front_half(s=100, y=0, planar=false)\n{\n    req_children($children);\n    dir = FWD;\n    difference() {\n        children();\n        translate([0,y,0]-dir*s/2) {\n            if (planar) {\n                square(s, center=true);\n            } else {\n                cube(s, center=true);\n            }\n        }\n    }\n}\nfunction front_half(p,y=0) = half_of(p, FRONT, [0,y,0]);\n\n\n\n// Function&Module: back_half()\n// Synopsis: Masks the front half of an object along the X-Z plane, leaving the back half.\n// SynTags: Geom, VNF, Path, Region\n// Topics: Partitions, Masking\n// See Also: front_half(), left_half(), right_half(), top_half(), bottom_half(), half_of(), intersection()\n//\n// Usage:\n//   back_half([s], [y]) CHILDREN;\n//   back_half(planar=true, [s], [y]) CHILDREN;\n// Usage: as function\n//   result = back_half(p, [y]);\n//\n// Description:\n//   Slices an object at a vertical X-Z cut plane, and masks away everything that is in front of it.\n//   The `s` parameter is needed for the module version to control the size of the masking cube.\n//   If `s` is too large then the preview display will flip around and display the wrong half,\n//   but if it is too small it won't fully mask your model.  \n// Arguments:\n//   p = VNF, region or path to slice (function version)\n//   s = Mask size to use.  Use a number larger than twice your object's largest axis.  If you make this too large, OpenSCAD's preview rendering may display the wrong half.  (Module version)  Default: 100\n//   y = The Y coordinate of the cut-plane.  Default: 0\n//   planar = If true, perform a 2D operation.  (Module version)  Default: false. \n// Examples:\n//   back_half() sphere(r=20);\n//   back_half(y=8) sphere(r=20);\n// Example(2D):\n//   back_half(planar=true) circle(r=20);\nmodule back_half(s=100, y=0, planar=false)\n{\n    req_children($children);\n    dir = BACK;\n    difference() {\n        children();\n        translate([0,y,0]-dir*s/2) {\n            if (planar) {\n                square(s, center=true);\n            } else {\n                cube(s, center=true);\n            }\n        }\n    }\n}\nfunction back_half(p,y=0) = half_of(p, BACK, [0,y,0]);\n\n\n\n// Function&Module: bottom_half()\n// Synopsis: Masks the top half of an object along the X-Y plane, leaving the bottom half.\n// SynTags: Geom, VNF, Path, Region\n// Topics: Partitions, Masking\n// See Also: back_half(), front_half(), left_half(), right_half(), top_half(), half_of(), intersection()\n//\n// Usage:\n//   bottom_half([s], [z]) CHILDREN;\n// Usage: as function\n//   result = bottom_half(p, [z]);\n//\n// Description:\n//   Slices an object at a horizontal X-Y cut plane, and masks away everything that is above it.\n//   The `s` parameter is needed for the module version to control the size of the masking cube.\n//   If `s` is too large then the preview display will flip around and display the wrong half,\n//   but if it is too small it won't fully mask your model. \n// Arguments:\n//   p = VNF, region or path to slice (function version)\n//   s = Mask size to use.  Use a number larger than twice your object's largest axis.  If you make this too large, OpenSCAD's preview rendering may display the wrong half.  (Module version)  Default: 100\n//   z = The Z coordinate of the cut-plane.  Default: 0\n// Examples:\n//   bottom_half() sphere(r=20);\n//   bottom_half(z=-10) sphere(r=20);\nmodule bottom_half(s=100, z=0)\n{\n    req_children($children);\n    dir = DOWN;\n    difference() {\n        children();\n        translate([0,0,z]-dir*s/2) {\n            cube(s, center=true);\n        }\n    }\n}\nfunction bottom_half(p,z=0) = half_of(p,BOTTOM,[0,0,z]);\n\n\n\n// Function&Module: top_half()\n// Synopsis: Masks the bottom half of an object along the X-Y plane, leaving the top half.\n// SynTags: Geom, VNF, Path, Region\n// Topics: Partitions, Masking\n// See Also: back_half(), front_half(), left_half(), right_half(), bottom_half(), half_of(), intersection()\n//\n// Usage: as module\n//   top_half([s], [z]) CHILDREN;\n// Usage: as function\n//   result = top_half(p, [z]);\n//\n// Description:\n//   Slices an object at a horizontal X-Y cut plane, and masks away everything that is below it.\n//   The `s` parameter is needed for the module version to control the size of the masking cube.\n//   If `s` is too large then the preview display will flip around and display the wrong half,\n//   but if it is too small it won't fully mask your model.  \n// Arguments:\n//   p = VNF, region or path to slice (function version)\n//   s = Mask size to use.  Use a number larger than twice your object's largest axis.  If you make this too large, OpenSCAD's preview rendering may display the wrong half.  (Module version)  Default: 100\n//   z = The Z coordinate of the cut-plane.  Default: 0\n// Examples(Spin,VPD=175):\n//   top_half() sphere(r=20);\n//   top_half(z=5) sphere(r=20);\nmodule top_half(s=100, z=0)\n{\n    req_children($children);\n    dir = UP;\n    difference() {\n        children();\n        translate([0,0,z]-dir*s/2) {\n            cube(s, center=true);\n        }\n    }\n}\nfunction top_half(p,z=0) = half_of(p,UP,[0,0,z]);\n\n\n\n// Section: Partioning into Interlocking Pieces\n\n\nfunction _partition_subpath(type) =\n    type==\"flat\"?  [[0,0],[1,0]] :\n    type==\"sawtooth\"? [[0,-0.5], [0.5,0.5], [1,-0.5]] :\n    type==\"sinewave\"? [for (a=[0:5:360]) [a/360,sin(a)/2]] :\n    type==\"comb\"?   let(dx=0.5*sin(2))  [[0,0],[0+dx,0.5],[0.5-dx,0.5],[0.5+dx,-0.5],[1-dx,-0.5],[1,0]] :\n    type==\"finger\"? let(dx=0.5*sin(20)) [[0,0],[0+dx,0.5],[0.5-dx,0.5],[0.5+dx,-0.5],[1-dx,-0.5],[1,0]] :\n    type==\"dovetail\"? [[0,-0.5], [0.3,-0.5], [0.2,0.5], [0.8,0.5], [0.7,-0.5], [1,-0.5]] :\n    type==\"hammerhead\"? [[0,-0.5], [0.35,-0.5], [0.35,0], [0.15,0], [0.15,0.5], [0.85,0.5], [0.85,0], [0.65,0], [0.65,-0.5],[1,-0.5]] :\n    type==\"jigsaw\"? concat(\n                        arc(r=5/16, cp=[0,-3/16],  start=270, angle=125),\n                        arc(r=5/16, cp=[1/2,3/16], start=215, angle=-250),\n                        arc(r=5/16, cp=[1,-3/16],  start=145, angle=125)\n                    ) :\n    assert(false, str(\"Unsupported cutpath type: \", type));\n\n\nfunction _partition_cutpath(l, h, cutsize, cutpath, gap) =\n    let(\n        check = assert(is_finite(l))\n            assert(is_finite(h))\n            assert(is_finite(gap))\n            assert(is_finite(cutsize) || is_vector(cutsize,2))\n            assert(is_string(cutpath) || is_path(cutpath,2)),\n        cutsize = is_vector(cutsize)? cutsize : [cutsize*2, cutsize],\n        cutpath = is_path(cutpath)? cutpath :\n            _partition_subpath(cutpath),\n        reps = ceil(l/(cutsize.x+gap)),\n        cplen = (cutsize.x+gap) * reps,\n        path = deduplicate(concat(\n            [[-l/2, cutpath[0].y*cutsize.y]],\n            [for (i=[0:1:reps-1], pt=cutpath) v_mul(pt,cutsize)+[i*(cutsize.x+gap)+gap/2-cplen/2,0]],\n            [[ l/2, cutpath[len(cutpath)-1].y*cutsize.y]]\n        )),\n        stidxs = [for (i = idx(path)) if (path[i].x < -l/2) i],\n        enidxs = [for (i = idx(path)) if (path[i].x > +l/2) i],\n        stidx = stidxs? last(stidxs) : 0,\n        enidx = enidxs? enidxs[0] : -1,\n        trunc = select(path, stidx, enidx)\n    ) trunc;\n\n\n// Module: partition_mask()\n// Synopsis: Creates a mask to remove half an object with the remaining half suitable for reassembly.\n// SynTags: Geom\n// Topics: Partitions, Masking, Paths\n// See Also: partition_cut_mask(), partition()\n// Usage:\n//   partition_mask(l, w, h, [cutsize], [cutpath], [gap], [inverse], [$slop=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n// Description:\n//   Creates a mask that you can use to difference or intersect with an object to remove half of it,\n//   leaving behind a side designed to allow assembly of the sub-parts.\n// Arguments:\n//   l = The length of the cut axis.\n//   w = The width of the part to be masked, back from the cut plane.\n//   h = The height of the part to be masked.\n//   cutsize = The width of the cut pattern to be used.\n//   cutpath = The cutpath to use.  Standard named paths are \"flat\", \"sawtooth\", \"sinewave\", \"comb\", \"finger\", \"dovetail\", \"hammerhead\", and \"jigsaw\".  Alternatively, you can give a cutpath as a 2D path, where X is between 0 and 1, and Y is between -0.5 and 0.5.\n//   gap = Empty gaps between cutpath iterations.  Default: 0\n//   inverse = If true, create a cutpath that is meant to mate to a non-inverted cutpath.\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The amount to shrink the mask by, to correct for printer-specific fitting.\n// Examples:\n//   partition_mask(w=50, gap=0, cutpath=\"jigsaw\");\n//   partition_mask(w=50, gap=30, cutpath=\"jigsaw\");\n//   partition_mask(w=50, gap=30, cutpath=\"jigsaw\", inverse=true);\n//   partition_mask(w=50, gap=30, cutsize=15, cutpath=\"jigsaw\");\n//   partition_mask(w=50, cutsize=[20,20], gap=30, cutpath=\"jigsaw\");\n// Examples(2D):\n//   partition_mask(w=20, cutpath=\"sawtooth\");\n//   partition_mask(w=20, cutpath=\"sinewave\");\n//   partition_mask(w=20, cutpath=\"comb\");\n//   partition_mask(w=20, cutpath=\"finger\");\n//   partition_mask(w=20, cutpath=\"dovetail\");\n//   partition_mask(w=20, cutpath=\"hammerhead\");\n//   partition_mask(w=20, cutpath=\"jigsaw\");\nmodule partition_mask(l=100, w=100, h=100, cutsize=10, cutpath=\"jigsaw\", gap=0, inverse=false, anchor=CENTER, spin=0, orient=UP)\n{\n    cutsize = is_vector(cutsize)? point2d(cutsize) : [cutsize*2, cutsize];\n    path = _partition_cutpath(l, h, cutsize, cutpath, gap);\n    midpath = select(path,1,-2);\n    sizepath = concat([path[0]+[-get_slop(),0]], midpath, [last(path)+[get_slop(),0]], [[+(l/2+get_slop()), (w+get_slop())*(inverse?-1:1)], [-(l/2+get_slop()), (w+get_slop())*(inverse?-1:1)]]);\n    bnds = pointlist_bounds(sizepath);\n    fullpath = concat(path, [[last(path).x, w*(inverse?-1:1)], [path[0].x, w*(inverse?-1:1)]]);\n    attachable(anchor,spin,orient, size=point3d(bnds[1]-bnds[0],h)) {\n        linear_extrude(height=h, center=true, convexity=10) {\n            intersection() {\n                offset(delta=-get_slop()) polygon(fullpath);\n                square([l, w*2], center=true);\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: partition_cut_mask()\n// Synopsis: Creates a mask to cut an object into two subparts that can be reassembled.\n// SynTags: Geom\n// Topics: Partitions, Masking, Paths\n// See Also: partition_mask(), partition()\n// Usage:\n//   partition_cut_mask(l, w, h, [cutsize], [cutpath], [gap], [inverse], [$slop=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n// Description:\n//   Creates a mask that you can use to difference with an object to cut it into two sub-parts that can be assembled.\n//   The `$slop` value is important to get the proper fit and should probably be smaller than 0.2.  The examples below\n//   use larger values to make the mask easier to see.  \n// Arguments:\n//   l = The length of the cut axis.\n//   w = The width of the part to be masked, back from the cut plane.\n//   h = The height of the part to be masked.\n//   cutsize = The width of the cut pattern to be used.\n//   cutpath = The cutpath to use.  Standard named paths are \"flat\", \"sawtooth\", \"sinewave\", \"comb\", \"finger\", \"dovetail\", \"hammerhead\", and \"jigsaw\".  Alternatively, you can give a cutpath as a 2D path, where X is between 0 and 1, and Y is between -0.5 and 0.5.  Default: \"jigsaw\"\n//   gap = Empty gaps between cutpath iterations.  Default: 0\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The width of the cut mask, to correct for printer-specific fitting. \n// Examples:\n//   partition_cut_mask(gap=0, cutpath=\"dovetail\");\n//   partition_cut_mask(gap=30, cutpath=\"dovetail\");\n//   partition_cut_mask(gap=30, cutsize=15, cutpath=\"dovetail\");\n//   partition_cut_mask(gap=30, cutsize=[20,20], cutpath=\"dovetail\");\n// Examples(2DMed):\n//   partition_cut_mask(cutpath=\"sawtooth\",$slop=0.5);\n//   partition_cut_mask(cutpath=\"sinewave\",$slop=0.5);\n//   partition_cut_mask(cutpath=\"comb\",$slop=0.5);\n//   partition_cut_mask(cutpath=\"finger\",$slop=0.5);\n//   partition_cut_mask(cutpath=\"dovetail\",$slop=1);\n//   partition_cut_mask(cutpath=\"hammerhead\",$slop=1);\n//   partition_cut_mask(cutpath=\"jigsaw\",$slop=0.5);\nmodule partition_cut_mask(l=100, h=100, cutsize=10, cutpath=\"jigsaw\", gap=0, anchor=CENTER, spin=0, orient=UP)\n{\n    cutsize = is_vector(cutsize)? cutsize : [cutsize*2, cutsize];\n    path = _partition_cutpath(l, h, cutsize, cutpath, gap);\n    attachable(anchor,spin,orient, size=[l,cutsize.y,h]) {\n        linear_extrude(height=h, center=true, convexity=10) {\n            stroke(path, width=max(0.1, get_slop()*2));\n        }\n        children();\n    }\n}\n\n\n// Module: partition()\n// Synopsis: Cuts an object in two with matched joining edges, then separates the parts.\n// SynTags: Geom, VNF, Path, Region\n// Topics: Partitions, Masking, Paths\n// See Also: partition_cut_mask(), partition_mask()\n// Usage:\n//   partition(size, [spread], [cutsize], [cutpath], [gap], [spin], [$slop=]) CHILDREN;\n// Description:\n//   Partitions an object into two parts, spread apart a small distance, with matched joining edges.\n// Arguments:\n//   size = The [X,Y,Z] size of the object to partition.\n//   spread = The distance to spread the two parts by.\n//   cutsize = The width of the cut pattern to be used.\n//   cutpath = The cutpath to use.  Standard named paths are \"flat\", \"sawtooth\", \"sinewave\", \"comb\", \"finger\", \"dovetail\", \"hammerhead\", and \"jigsaw\".  Alternatively, you can give a cutpath as a 2D path, where X is between 0 and 1, and Y is between -0.5 and 0.5.\n//   gap = Empty gaps between cutpath iterations.  Default: 0\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   ---\n//   $slop = Extra gap to leave to correct for printer-specific fitting. \n// Examples(Med):\n//   partition(spread=12, cutpath=\"dovetail\") cylinder(h=50, d=80, center=false);\n//   partition(spread=12, gap=30, cutpath=\"dovetail\") cylinder(h=50, d=80, center=false);\n//   partition(spread=20, gap=20, cutsize=15, cutpath=\"dovetail\") cylinder(h=50, d=80, center=false);\n//   partition(spread=25, gap=15, cutsize=[20,20], cutpath=\"dovetail\") cylinder(h=50, d=80, center=false);\n// Examples(2DMed):\n//   partition(cutpath=\"sawtooth\") cylinder(h=50, d=80, center=false);\n//   partition(cutpath=\"sinewave\") cylinder(h=50, d=80, center=false);\n//   partition(cutpath=\"comb\") cylinder(h=50, d=80, center=false);\n//   partition(cutpath=\"finger\") cylinder(h=50, d=80, center=false);\n//   partition(spread=12, cutpath=\"dovetail\") cylinder(h=50, d=80, center=false);\n//   partition(spread=12, cutpath=\"hammerhead\") cylinder(h=50, d=80, center=false);\n//   partition(cutpath=\"jigsaw\") cylinder(h=50, d=80, center=false);\nmodule partition(size=100, spread=10, cutsize=10, cutpath=\"jigsaw\", gap=0, spin=0)\n{\n    req_children($children);\n    size = is_vector(size)? size : [size,size,size];\n    cutsize = is_vector(cutsize)? cutsize : [cutsize*2, cutsize];\n    rsize = v_abs(rot(spin,p=size));\n    vec = rot(spin,p=BACK)*spread/2;\n    move(vec) {\n        intersection() {\n            children();\n            partition_mask(l=rsize.x, w=rsize.y, h=rsize.z, cutsize=cutsize, cutpath=cutpath, gap=gap, spin=spin);\n        }\n    }\n    move(-vec) {\n        intersection() {\n            children();\n            partition_mask(l=rsize.x, w=rsize.y, h=rsize.z, cutsize=cutsize, cutpath=cutpath, gap=gap, inverse=true, spin=spin);\n        }\n    }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-30", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: paths.scad\n//   A `path` is a list of points of the same dimensions, usually 2D or 3D, that can\n//   be connected together to form a sequence of line segments or a polygon.\n//   A `region` is a list of paths that represent polygons, and the functions\n//   in this file work on paths and also 1-regions, which are regions\n//   that include exactly one path.  When you pass a 1-region to a function, the default\n//   value for `closed` is always `true` because regions represent polygons.  \n//   Capabilities include computing length of paths, computing\n//   path tangents and normals, resampling of paths, and cutting paths up into smaller paths.  \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Advanced Modeling\n// FileSummary: Operations on paths: length, resampling, tangents, splitting into subpaths\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n// Section: Utility Functions\n\n// Function: is_path()\n// Synopsis: Returns True if 'list' is a path.\n// Topics: Paths\n// See Also: is_region(), is_vnf()\n// Usage:\n//   is_path(list, [dim], [fast])\n// Description:\n//   Returns true if `list` is a path.  A path is a list of two or more numeric vectors (AKA points).\n//   All vectors must of the same size, and may only contain numbers that are not inf or nan.\n//   By default the vectors in a path must be 2d or 3d.  Set the `dim` parameter to specify a list\n//   of allowed dimensions, or set it to `undef` to allow any dimension.  (Note that this function\n//   returns `false` on 1-regions.)  \n// Example:\n//   bool1 = is_path([[3,4],[5,6]]);    // Returns true\n//   bool2 = is_path([[3,4]]);          // Returns false\n//   bool3 = is_path([[3,4],[4,5]],2);  // Returns true\n//   bool4 = is_path([[3,4,3],[5,4,5]],2);  // Returns false\n//   bool5 = is_path([[3,4,3],[5,4,5]],2);  // Returns false\n//   bool6 = is_path([[3,4,5],undef,[4,5,6]]);  // Returns false\n//   bool7 = is_path([[3,5],[undef,undef],[4,5]]);  // Returns false\n//   bool8 = is_path([[3,4],[5,6],[5,3]]);     // Returns true\n//   bool9 = is_path([3,4,5,6,7,8]);           // Returns false\n//   bool10 = is_path([[3,4],[5,6]], dim=[2,3]);// Returns true\n//   bool11 = is_path([[3,4],[5,6]], dim=[1,3]);// Returns false\n//   bool12 = is_path([[3,4],\"hello\"], fast=true); // Returns true\n//   bool13 = is_path([[3,4],[3,4,5]]);            // Returns false\n//   bool14 = is_path([[1,2,3,4],[2,3,4,5]]);      // Returns false\n//   bool15 = is_path([[1,2,3,4],[2,3,4,5]],undef);// Returns true\n// Arguments:\n//   list = list to check\n//   dim = list of allowed dimensions of the vectors in the path.  Default: [2,3]\n//   fast = set to true for fast check that only looks at first entry.  Default: false\nfunction is_path(list, dim=[2,3], fast=false) =\n    fast\n    ?   is_list(list) && is_vector(list[0]) \n    :   is_matrix(list) \n        && len(list)>1 \n        && len(list[0])>0\n        && (is_undef(dim) || in_list(len(list[0]), force_list(dim)));\n\n// Function: is_1region()\n// Synopsis: Returns true if path is a region with one component.\n// Topics: Paths, Regions\n// See Also: force_path()\n// Usage:\n//   bool = is_1region(path, [name])\n// Description:\n//   If `path` is a region with one component (a 1-region) then return true.  If path is a region with more components\n//   then display an error message about the parameter `name` requiring a path or a single component region.  If the input\n//   is not a region then return false.  This function helps path functions accept 1-regions.\n// Arguments:\n//   path = input to process\n//   name = name of parameter to use in error message.  Default: \"path\"\nfunction is_1region(path, name=\"path\") = \n     !is_region(path)? false\n    :assert(len(path)==1,str(\"Parameter \\\"\",name,\"\\\" must be a path or singleton region, but is a multicomponent region\"))\n     true;\n\n\n// Function: force_path()\n// Synopsis: Checks that path is a region with one component.\n// SynTags: Path\n// Topics: Paths, Regions\n// See Also: is_1region()\n// Usage:\n//   outpath = force_path(path, [name])\n// Description:\n//   If `path` is a region with one component (a 1-region) then returns that component as a path.\n//   If path is a region with more components then displays an error message about the parameter\n//   `name` requiring a path or a single component region.  If the input is not a region then\n//   returns the input without any checks.  This function helps path functions accept 1-regions.\n// Arguments:\n//   path = input to process\n//   name = name of parameter to use in error message.  Default: \"path\"\nfunction force_path(path, name=\"path\") =\n   is_region(path) ?\n       assert(len(path)==1, str(\"Parameter \\\"\",name,\"\\\" must be a path or singleton region, but is a multicomponent region\"))\n       path[0]\n   : path;\n\n\n/// Internal Function: _path_select()\n/// Usage:\n///   _path_select(path,s1,u1,s2,u2,[closed]):\n/// Description:\n///   Returns a portion of a path, from between the `u1` part of segment `s1`, to the `u2` part of\n///   segment `s2`.  Both `u1` and `u2` are values between 0.0 and 1.0, inclusive, where 0 is the start\n///   of the segment, and 1 is the end.  Both `s1` and `s2` are integers, where 0 is the first segment.\n/// Arguments:\n///   path = The path to get a section of.\n///   s1 = The number of the starting segment.\n///   u1 = The proportion along the starting segment, between 0.0 and 1.0, inclusive.\n///   s2 = The number of the ending segment.\n///   u2 = The proportion along the ending segment, between 0.0 and 1.0, inclusive.\n///   closed = If true, treat path as a closed polygon.\nfunction _path_select(path, s1, u1, s2, u2, closed=false) =\n    let(\n        lp = len(path),\n        l = lp-(closed?0:1),\n        u1 = s1<0? 0 : s1>l? 1 : u1,\n        u2 = s2<0? 0 : s2>l? 1 : u2,\n        s1 = constrain(s1,0,l),\n        s2 = constrain(s2,0,l),\n        pathout = concat(\n            (s1<l && u1<1)? [lerp(path[s1],path[(s1+1)%lp],u1)] : [],\n            [for (i=[s1+1:1:s2]) path[i]],\n            (s2<l && u2>0)? [lerp(path[s2],path[(s2+1)%lp],u2)] : []\n        )\n    ) pathout;\n\n\n\n// Function: path_merge_collinear()\n// Synopsis: Removes unnecessary points from a path.\n// SynTags: Path\n// Topics: Paths, Regions\n// Description:\n//   Takes a path and removes unnecessary sequential collinear points.\n// Usage:\n//   path_merge_collinear(path, [eps])\n// Arguments:\n//   path = A path of any dimension or a 1-region\n//   closed = treat as closed polygon.  Default: false\n//   eps = Largest positional variance allowed.  Default: `EPSILON` (1-e9)\nfunction path_merge_collinear(path, closed, eps=EPSILON) =\n    is_1region(path) ? path_merge_collinear(path[0], default(closed,true), eps) :\n    let(closed=default(closed,false))\n    assert(is_bool(closed))\n    assert( is_path(path), \"Invalid path in path_merge_collinear.\" )\n    assert( is_undef(eps) || (is_finite(eps) && (eps>=0) ), \"Invalid tolerance.\" )    \n    len(path)<=2 ? path :\n    let(\n        indices = [\n            0,\n            for (i=[1:1:len(path)-(closed?1:2)]) \n                if (!is_collinear(path[i-1], path[i], select(path,i+1), eps=eps)) i, \n            if (!closed) len(path)-1 \n        ]\n    ) [for (i=indices) path[i]];\n\n\n\n// Section: Path length calculation\n\n\n// Function: path_length()\n// Synopsis: Returns the path length.\n// Topics: Paths\n// See Also: path_segment_lengths(), path_length_fractions()\n// Usage:\n//   path_length(path,[closed])\n// Description:\n//   Returns the length of the path.\n// Arguments:\n//   path = Path of any dimension or 1-region. \n//   closed = true if the path is closed.  Default: false\n// Example:\n//   path = [[0,0], [5,35], [60,-25], [80,0]];\n//   echo(path_length(path));\nfunction path_length(path,closed) =\n    is_1region(path) ? path_length(path[0], default(closed,true)) :\n    assert(is_path(path), \"Invalid path in path_length\")\n    let(closed=default(closed,false))\n    assert(is_bool(closed))\n    len(path)<2? 0 :\n    sum([for (i = [0:1:len(path)-2]) norm(path[i+1]-path[i])])+(closed?norm(path[len(path)-1]-path[0]):0);\n\n\n// Function: path_segment_lengths()\n// Synopsis: Returns a list of the lengths of segments in a path.\n// Topics: Paths\n// See Also: path_length(), path_length_fractions()\n// Usage:\n//   path_segment_lengths(path,[closed])\n// Description:\n//   Returns list of the length of each segment in a path\n// Arguments:\n//   path = path in any dimension or 1-region\n//   closed = true if the path is closed.  Default: false\nfunction path_segment_lengths(path, closed) =\n    is_1region(path) ? path_segment_lengths(path[0], default(closed,true)) :\n    let(closed=default(closed,false))\n    assert(is_path(path),\"Invalid path in path_segment_lengths.\")\n    assert(is_bool(closed))\n    [\n        for (i=[0:1:len(path)-2]) norm(path[i+1]-path[i]),\n        if (closed) norm(path[0]-last(path))\n    ]; \n\n\n// Function: path_length_fractions()\n// Synopsis: Returns the fractional distance of each point along the length of a path.\n// Topics: Paths\n// See Also: path_length(), path_segment_lengths()\n// Usage:\n//   fracs = path_length_fractions(path, [closed]);\n// Description:\n//    Returns the distance fraction of each point in the path along the path, so the first\n//    point is zero and the final point is 1.  If the path is closed the length of the output\n//    will have one extra point because of the final connecting segment that connects the last\n//    point of the path to the first point.\n// Arguments:\n//    path = path in any dimension or a 1-region\n//    closed = set to true if path is closed.  Default: false\nfunction path_length_fractions(path, closed) =\n    is_1region(path) ? path_length_fractions(path[0], default(closed,true)):\n    let(closed=default(closed, false))\n    assert(is_path(path))\n    assert(is_bool(closed))\n    let(\n        lengths = [\n            0,\n            each path_segment_lengths(path,closed)\n        ],\n        partial_len = cumsum(lengths),\n        total_len = last(partial_len)\n    )\n    partial_len / total_len;\n\n\n\n/// Internal Function: _path_self_intersections()\n/// Usage:\n///   isects = _path_self_intersections(path, [closed], [eps]);\n/// Description:\n///   Locates all self intersection points of the given path.  Returns a list of intersections, where\n///   each intersection is a list like [POINT, SEGNUM1, PROPORTION1, SEGNUM2, PROPORTION2] where\n///   POINT is the coordinates of the intersection point, SEGNUMs are the integer indices of the\n///   intersecting segments along the path, and the PROPORTIONS are the 0.0 to 1.0 proportions\n///   of how far along those segments they intersect at.  A proportion of 0.0 indicates the start\n///   of the segment, and a proportion of 1.0 indicates the end of the segment.\n///   .\n///   Note that this function does not return self-intersecting segments, only the points\n///   where non-parallel segments intersect.  \n/// Arguments:\n///   path = The path to find self intersections of.\n///   closed = If true, treat path like a closed polygon.  Default: true\n///   eps = The epsilon error value to determine whether two points coincide.  Default: `EPSILON` (1e-9)\n/// Example(2D):\n///   path = [\n///       [-100,100], [0,-50], [100,100], [100,-100], [0,50], [-100,-100]\n///   ];\n///   isects = _path_self_intersections(path, closed=true);\n///   // isects == [[[-33.3333, 0], 0, 0.666667, 4, 0.333333], [[33.3333, 0], 1, 0.333333, 3, 0.666667]]\n///   stroke(path, closed=true, width=1);\n///   for (isect=isects) translate(isect[0]) color(\"blue\") sphere(d=10);\nfunction _path_self_intersections(path, closed=true, eps=EPSILON) =\n    let(\n        path = closed ? list_wrap(path,eps=eps) : path,\n        plen = len(path)\n    )\n    [ for (i = [0:1:plen-3]) let(\n          a1 = path[i],\n          a2 = path[i+1], \n          seg_normal = unit([-(a2-a1).y, (a2-a1).x],[0,0]),\n          vals = path*seg_normal,\n          ref  = a1*seg_normal,\n            // The value of vals[j]-ref is positive if vertex j is one one side of the\n            // line [a1,a2] and negative on the other side. Only a segment with opposite\n            // signs at its two vertices can have an intersection with segment\n            // [a1,a2]. The variable signals is zero when abs(vals[j]-ref) is less than\n            // eps and the sign of vals[j]-ref otherwise.  \n          signals = [for(j=[i+2:1:plen-(i==0 && closed? 2: 1)]) \n                        abs(vals[j]-ref) <  eps ? 0 : sign(vals[j]-ref) ]\n        )\n        if(max(signals)>=0 && min(signals)<=0 ) // some remaining edge intersects line [a1,a2]\n        for(j=[i+2:1:plen-(i==0 && closed? 3: 2)])\n            if( signals[j-i-2]*signals[j-i-1]<=0 ) let( // segm [b1,b2] intersects line [a1,a2]\n                b1 = path[j],\n                b2 = path[j+1],\n                isect = _general_line_intersection([a1,a2],[b1,b2],eps=eps) \n            )\n            if (isect \n                && isect[1]>=-eps\n                && isect[1]<= 1+eps\n                && isect[2]>= -eps \n                && isect[2]<= 1+eps)\n                [isect[0], i, isect[1], j, isect[2]]\n    ];\n\n// Section: Resampling - changing the number of points in a path\n\n\n// Input `data` is a list that sums to an integer. \n// Returns rounded version of input data so that every \n// entry is rounded to an integer and the sum is the same as\n// that of the input.  Works by rounding an entry in the list\n// and passing the rounding error forward to the next entry.\n// This will generally distribute the error in a uniform manner. \nfunction _sum_preserving_round(data, index=0) =\n    index == len(data)-1 ? list_set(data, len(data)-1, round(data[len(data)-1])) :\n    let(\n        newval = round(data[index]),\n        error = newval - data[index]\n    ) _sum_preserving_round(\n        list_set(data, [index,index+1], [newval, data[index+1]-error]),\n        index+1\n    );\n\n\n// Function: subdivide_path()\n// Synopsis: Subdivides a path to produce a more finely sampled path.\n// SynTags: Path\n// Topics: Paths, Path Subdivision\n// See Also: subdivide_and_slice(), resample_path(), jittered_poly()\n// Usage:\n//   newpath = subdivide_path(path, n|refine=|maxlen=, [method=], [closed=], [exact=]);\n// Description:\n//   Takes a path as input (closed or open) and subdivides the path to produce a more\n//   finely sampled path.  You control the subdivision process by using the `maxlen` arg\n//   to specify a maximum segment length, or by specifying `n` or `refine`, which request\n//   a certain point count in the output.\n//   .\n//   You can specify the point count using the `n` option, where\n//   you give the number of points you want in the output, or you can use\n//   the `refine` option, where you specify a resampling factor.  If `refine=3` then\n//   the number of points would increase by a factor of three, so a four point square would\n//   have 12 points after subdivision.  With point-count subdivision, the new points can be distributed\n//   proportional to length (`method=\"length\"`), which is the default, or they can be divided up evenly among all the path segments\n//   (`method=\"segment\"`).  If the extra points don't fit evenly on the path then the\n//   algorithm attempts to distribute them as uniformly as possible, but the result may be uneven.\n//   The `exact` option, which is true by default, requires that the final point count is\n//   exactly as requested.  For example, if you subdivide a four point square and request `n=13` then one edge will have\n//   an extra point compared to the others.  \n//   If you set `exact=false` then the\n//   algorithm will favor uniformity and the output path may have a different number of\n//   points than you requested, but the sampling will be uniform.   In our example of the\n//   square with `n=13`, you will get only 12 points output, with the same number of points on each edge.\n//   .\n//   The points are always distributed uniformly on each segment.  The `method=\"length\"` option does\n//   means that the number of points on a segment is based on its length, but the points are still\n//   distributed uniformly on each segment, independent of the other segments.  \n//   With the `\"segment\"` method you can also give `n` as a vector of counts.  This \n//   specifies the desired point count on each segment: with vector valued `n` the `subdivide_path`\n//   function places `n[i]-1` points on segment `i`.  The reason for the -1 is to avoid\n//   double counting the endpoints, which are shared by pairs of segments, so that for\n//   a closed polygon the total number of points will be sum(n).  Note that with an open\n//   path there is an extra point at the end, so the number of points will be sum(n)+1.\n//   .\n//   If you use the `maxlen` option then you specify the maximum length segment allowed in the output.\n//   Each segment is subdivided into the largest number of segments meeting your requirement.  As above,\n//   the sampling is uniform on each segment, independent of the other segments.  With the `maxlen` option\n//   you cannot specify `method` or `exact`.    \n// Arguments:\n//   path = path in any dimension or a 1-region\n//   n = scalar total number of points desired or with `method=\"segment\"` can be a vector requesting `n[i]-1` new points added to segment i.\n//   ---\n//   refine = increase total number of points by this factor (Specify only one of n, refine and maxlen)\n//   maxlen = maximum length segment in the output (Specify only one of n, refine and maxlen)\n//   closed = set to false if the path is open.  Default: True\n//   exact = if true return exactly the requested number of points, possibly sacrificing uniformity.  If false, return uniform point sample that may not match the number of points requested.  (Not allowed with maxlen.) Default: true\n//   method = One of `\"length\"` or `\"segment\"`.  If `\"length\"`, adds vertices in proportion to segment length, so short segments get fewer points.  If `\"segment\"`, add points evenly among the segments, so all segments get the same number of points.  (Not allowed with maxlen.) Default: `\"length\"`\n// Example(2D):\n//   mypath = subdivide_path(square([2,2],center=true), 12);\n//   move_copies(mypath)circle(r=.1,$fn=32);\n// Example(2D):\n//   mypath = subdivide_path(square([8,2],center=true), 12);\n//   move_copies(mypath)circle(r=.2,$fn=32);\n// Example(2D):\n//   mypath = subdivide_path(square([8,2],center=true), 12, method=\"segment\");\n//   move_copies(mypath)circle(r=.2,$fn=32);\n// Example(2D):\n//   mypath = subdivide_path(square([2,2],center=true), 17, closed=false);\n//   move_copies(mypath)circle(r=.1,$fn=32);\n// Example(2D): Specifying different numbers of points on each segment\n//   mypath = subdivide_path(hexagon(side=2), [2,3,4,5,6,7], method=\"segment\");\n//   move_copies(mypath)circle(r=.1,$fn=32);\n// Example(2D): Requested point total is 14 but 15 points output due to extra end point\n//   mypath = subdivide_path(pentagon(side=2), [3,4,3,4], method=\"segment\", closed=false);\n//   move_copies(mypath)circle(r=.1,$fn=32);\n// Example(2D): Since 17 is not divisible by 5, a completely uniform distribution is not possible. \n//   mypath = subdivide_path(pentagon(side=2), 17);\n//   move_copies(mypath)circle(r=.1,$fn=32);\n// Example(2D): With `exact=false` a uniform distribution, but only 15 points\n//   mypath = subdivide_path(pentagon(side=2), 17, exact=false);\n//   move_copies(mypath)circle(r=.1,$fn=32);\n// Example(2D): With `exact=false` you can also get extra points, here 20 instead of requested 18\n//   mypath = subdivide_path(pentagon(side=2), 18, exact=false);\n//   move_copies(mypath)circle(r=.1,$fn=32);\n// Example(2D): Using refine in this example multiplies the point count by 3 by adding 2 points to each edge\n//   mypath = subdivide_path(pentagon(side=2), refine=3);\n//   move_copies(mypath)circle(r=.1,$fn=32);\n// Example(2D): But note that refine doesn't distribute evenly by segment unless you change the method.  with the default method set to `\"length\"`, the points are distributed with more on the long segments in this example using refine.  \n//   mypath = subdivide_path(square([8,2],center=true), refine=3);\n//   move_copies(mypath)circle(r=.2,$fn=32);\n// Example(2D): In this example with maxlen, every side gets a different number of new points\n//   path = [[0,0],[0,4],[10,6],[10,0]];\n//   spath = subdivide_path(path, maxlen=2, closed=true);\n//   move_copies(spath) circle(r=.25,$fn=12);\n// Example(FlatSpin,VPD=15,VPT=[0,0,1.5]): Three-dimensional paths also work\n//   mypath = subdivide_path([[0,0,0],[2,0,1],[2,3,2]], 12);\n//   move_copies(mypath)sphere(r=.1,$fn=32);\nfunction subdivide_path(path, n, refine, maxlen, closed=true, exact, method) =\n    let(path = force_path(path))\n    assert(is_path(path))\n    assert(num_defined([n,refine,maxlen]),\"Must give exactly one of n, refine, and maxlen\")\n    refine==1 || n==len(path) ? path :\n    is_def(maxlen) ?\n        assert(is_undef(method), \"Cannot give method with maxlen\")\n        assert(is_undef(exact), \"Cannot give exact with maxlen\")\n        [\n         for (p=pair(path,closed))\n           let(steps = ceil(norm(p[1]-p[0])/maxlen))\n           each lerpn(p[0], p[1], steps, false),\n         if (!closed) last(path)\n        ]               \n    :\n    let(\n        exact = default(exact, true),\n        method = default(method, \"length\")\n    )\n    assert(method==\"length\" || method==\"segment\")\n    let(\n        n = !is_undef(n)? n :\n            !is_undef(refine)? len(path) * refine :\n            undef\n    )\n    assert((is_num(n) && n>0) || is_vector(n),\"Parameter n to subdivide_path must be postive number or vector\")\n    let(\n        count = len(path) - (closed?0:1), \n        add_guess = method==\"segment\"?\n                       (\n                          is_list(n)\n                          ? assert(len(n)==count,\"Vector parameter n to subdivide_path has the wrong length\")\n                            add_scalar(n,-1)\n                          : repeat((n-len(path)) / count, count)\n                       )\n                  : // method==\"length\"\n                    assert(is_num(n),\"Parameter n to subdivide path must be a number when method=\\\"length\\\"\")\n                    let(\n                        path_lens = path_segment_lengths(path,closed),\n                        add_density = (n - len(path)) / sum(path_lens)\n                    )\n                    path_lens * add_density,\n        add = exact? _sum_preserving_round(add_guess)\n                   : [for (val=add_guess) round(val)]\n    )\n    [\n        for (i=[0:1:count-1]) \n           each lerpn(path[i],select(path,i+1), 1+add[i],endpoint=false),\n        if (!closed) last(path)\n    ];\n\n\n\n\n// Function: resample_path()\n// Synopsis: Returns an equidistant set of points along a path.\n// SynTags: Path\n// Topics: Paths\n// See Also: subdivide_path()\n// Usage:\n//   newpath = resample_path(path, n|spacing=, [closed=]);\n// Description:\n//   Compute a uniform resampling of the input path.  If you specify `n` then the output path will have n\n//   points spaced uniformly (by linear interpolation along the input path segments).  The only points of the\n//   input path that are guaranteed to appear in the output path are the starting and ending points, and any\n//   points that have an angular deflection of at least the number of degrees given in `keep_corners`.\n//   If you specify `spacing` then the length you give will be rounded to the nearest spacing that gives\n//   a uniform sampling of the path and the resulting uniformly sampled path is returned.\n//   Note that because this function operates on a discrete input path the quality of the output depends on\n//   the sampling of the input.  If you want very accurate output, use a lot of points for the input.\n// Arguments:\n//   path = path in any dimension or a 1-region\n//   n = Number of points in output\n//   ---\n//   spacing = Approximate spacing desired\n//   keep_corners = If given a scalar, path vertices with deflection angle greater than this are preserved in the output.\n//   closed = set to true if path is closed.  Default: true\n// Example(2D):  Subsampling lots of points from a smooth curve\n//   path = xscale(2,circle($fn=250, r=10));\n//   sampled = resample_path(path, 16);\n//   stroke(path);\n//   color(\"red\")move_copies(sampled) circle($fn=16);\n// Example(2D): Specified spacing is rounded to make a uniform sampling\n//   path = xscale(2,circle($fn=250, r=10));\n//   sampled = resample_path(path, spacing=17);\n//   stroke(path);\n//   color(\"red\")move_copies(sampled) circle($fn=16);\n// Example(2D): Notice that the corners are excluded.\n//   path = square(20);\n//   sampled = resample_path(path, spacing=6);\n//   stroke(path,closed=true);\n//   color(\"red\")move_copies(sampled) circle($fn=16);\n// Example(2D): Forcing preservation of corners.\n//   path = square(20);\n//   sampled = resample_path(path, spacing=6, keep_corners=90);\n//   stroke(path,closed=true);\n//   color(\"red\")move_copies(sampled) circle($fn=16);\n// Example(2D): Closed set to false\n//   path = square(20);\n//   sampled = resample_path(path, spacing=6,closed=false);\n//   stroke(path);\n//   color(\"red\")move_copies(sampled) circle($fn=16);\n\nfunction resample_path(path, n, spacing, keep_corners, closed=true) =\n    let(path = force_path(path))\n    assert(is_path(path))\n    assert(num_defined([n,spacing])==1,\"Must define exactly one of n and spacing\")\n    assert(n==undef || (is_integer(n) && n>0))\n    assert(spacing==undef || (is_finite(spacing) && spacing>0))\n    assert(is_bool(closed))\n    let(\n        corners = is_undef(keep_corners)\n          ? [0, len(path)-(closed?0:1)]\n          : [\n                0,\n                for (i = [1:1:len(path)-(closed?1:2)])\n                    let( ang = abs(modang(vector_angle(select(path,i-1,i+1))-180)) )\n                    if (ang >= keep_corners) i,\n                len(path)-(closed?0:1),\n            ],\n        pcnt = len(path),\n        plen = path_length(path, closed=closed),\n        subpaths = [ for (p = pair(corners)) [for(i = [p.x:1:p.y]) path[i%pcnt]] ],\n        n = is_undef(n)? undef : closed? n+1 : n\n    )\n    assert(n==undef || n >= len(corners), \"There are nore than `n=` corners whose angle is greater than `keep_corners=`.\")\n    let(\n        lens = [for (subpath = subpaths) path_length(subpath)],\n        part_ns = is_undef(n)\n          ? [for (i=idx(subpaths)) max(1,round(lens[i]/spacing)-1)]\n          : let(\n                ccnt = len(corners),\n                parts = [for (l=lens) (n-ccnt) * l/plen]\n            )\n            _sum_preserving_round(parts),\n        out = [\n            for (i = idx(subpaths))\n                let(\n                    subpath = subpaths[i],\n                    splen = lens[i],\n                    pn = part_ns[i] + 1,\n                    distlist = lerpn(0, splen, pn, false),\n                    cuts = path_cut_points(subpath, distlist, closed=false)\n                )\n                each column(cuts,0),\n            if (!closed) last(path)\n        ]\n    ) out;\n\n\n// Section: Path Geometry\n\n// Function: is_path_simple()\n// Synopsis: Returns true if a path has no self intersections.\n// Topics: Paths\n// See Also: is_path()\n// Usage:\n//   bool = is_path_simple(path, [closed], [eps]);\n// Description:\n//   Returns true if the given 2D path is simple, meaning that it has no self-intersections.\n//   Repeated points are not considered self-intersections: a path with such points can\n//   still be simple.  \n//   If closed is set to true then treat the path as a polygon.\n// Arguments:\n//   path = 2D path or 1-region\n//   closed = set to true to treat path as a polygon.  Default: false\n//   eps = Epsilon error value used for determine if points coincide.  Default: `EPSILON` (1e-9)\nfunction is_path_simple(path, closed, eps=EPSILON) =\n    is_1region(path) ? is_path_simple(path[0], default(closed,true), eps) :\n    let(closed=default(closed,false))\n    assert(is_path(path, 2),\"Must give a 2D path\")\n    assert(is_bool(closed))\n    let(\n        path = deduplicate(path,closed=closed,eps=eps)\n    )\n    // check for path reversals\n    [for(i=[0:1:len(path)-(closed?2:3)])\n         let(v1=path[i+1]-path[i],\n             v2=select(path,i+2)-path[i+1],\n             normv1 = norm(v1),\n             normv2 = norm(v2)\n             )\n         if (approx(v1*v2/normv1/normv2,-1)) 1\n    ]  == [] \n    &&\n    _path_self_intersections(path,closed=closed,eps=eps) == [];\n\n\n// Function: path_closest_point()\n// Synopsis: Returns the closest place on a path to a given point.\n// Topics: Paths\n// See Also: point_line_distance(), line_closest_point()\n// Usage:\n//   index_pt = path_closest_point(path, pt);\n// Description:\n//   Finds the closest path segment, and point on that segment to the given point.\n//   Returns `[SEGNUM, POINT]`\n// Arguments:\n//   path = Path of any dimension or a 1-region.\n//   pt = The point to find the closest point to.\n//   closed = If true, the path is considered closed.\n// Example(2D):\n//   path = circle(d=100,$fn=6);\n//   pt = [20,10];\n//   closest = path_closest_point(path, pt);\n//   stroke(path, closed=true);\n//   color(\"blue\") translate(pt) circle(d=3, $fn=12);\n//   color(\"red\") translate(closest[1]) circle(d=3, $fn=12);\nfunction path_closest_point(path, pt, closed=true) =\n    let(path = force_path(path))\n    assert(is_path(path), \"Input must be a path\")\n    assert(is_vector(pt, len(path[0])), \"Input pt must be a compatible vector\")\n    assert(is_bool(closed))\n    let(\n        pts = [for (seg=pair(path,closed)) line_closest_point(seg,pt,SEGMENT)],\n        dists = [for (p=pts) norm(p-pt)],\n        min_seg = min_index(dists)\n    ) [min_seg, pts[min_seg]];\n\n\n// Function: path_tangents()\n// Synopsis: Returns tangent vectors for each point along a path.\n// Topics: Paths\n// See Also: path_normals()\n// Usage:\n//   tangs = path_tangents(path, [closed], [uniform]);\n// Description:\n//   Compute the tangent vector to the input path.  The derivative approximation is described in deriv().\n//   The returns vectors will be normalized to length 1.  If any derivatives are zero then\n//   the function fails with an error.  If you set `uniform` to false then the sampling is\n//   assumed to be non-uniform and the derivative is computed with adjustments to produce corrected\n//   values.\n// Arguments:\n//   path = path of any dimension or a 1-region\n//   closed = set to true of the path is closed.  Default: false\n//   uniform = set to false to correct for non-uniform sampling.  Default: true\n// Example(2D): A shape with non-uniform sampling gives distorted derivatives that may be undesirable.  Note that derivatives tilt towards the long edges of the rectangle.  \n//   rect = square([10,3]);\n//   tangents = path_tangents(rect,closed=true);\n//   stroke(rect,closed=true, width=0.25);\n//   color(\"purple\")\n//       for(i=[0:len(tangents)-1])\n//           stroke([rect[i]-tangents[i], rect[i]+tangents[i]],width=.25, endcap2=\"arrow2\");\n// Example(2D): Setting uniform to false corrects the distorted derivatives for this example:\n//   rect = square([10,3]);\n//   tangents = path_tangents(rect,closed=true,uniform=false);\n//   stroke(rect,closed=true, width=0.25);\n//   color(\"purple\")\n//       for(i=[0:len(tangents)-1])\n//           stroke([rect[i]-tangents[i], rect[i]+tangents[i]],width=.25, endcap2=\"arrow2\");\nfunction path_tangents(path, closed, uniform=true) =\n    is_1region(path) ? path_tangents(path[0], default(closed,true), uniform) :\n    let(closed=default(closed,false))\n    assert(is_bool(closed))\n    assert(is_path(path))\n    !uniform ? [for(t=deriv(path,closed=closed, h=path_segment_lengths(path,closed))) unit(t)]\n             : [for(t=deriv(path,closed=closed)) unit(t)];\n\n\n// Function: path_normals()\n// Synopsis: Returns normal vectors for each point along a path.\n// Topics: Paths\n// See Also: path_tangents()\n// Usage:\n//   norms = path_normals(path, [tangents], [closed]);\n// Description:\n//   Compute the normal vector to the input path.  This vector is perpendicular to the\n//   path tangent and lies in the plane of the curve.  For 3d paths we define the plane of the curve\n//   at path point i to be the plane defined by point i and its two neighbors.  At the endpoints of open paths\n//   we use the three end points.  For 3d paths the computed normal is the one lying in this plane that points\n//   towards the center of curvature at that path point.  For 2d paths, which lie in the xy plane, the normal\n//   is the path pointing to the right of the direction the path is traveling.  If points are collinear then\n//   a 3d path has no center of curvature, and hence the \n//   normal is not uniquely defined.  In this case the function issues an error.\n//   For 2d paths the plane is always defined so the normal fails to exist only\n//   when the derivative is zero (in the case of repeated points).\n// Arguments:\n//   path = 2D or 3D path or a 1-region\n//   tangents = path tangents optionally supplied\n//   closed = if true path is treated as a polygon.  Default: false\nfunction path_normals(path, tangents, closed) =\n    is_1region(path) ? path_normals(path[0], tangents, default(closed,true)) :\n    let(closed=default(closed,false))\n    assert(is_path(path,[2,3]))\n    assert(is_bool(closed))\n    let(\n         tangents = default(tangents, path_tangents(path,closed)),\n         dim=len(path[0])\n    )\n    assert(is_path(tangents) && len(tangents[0])==dim,\"Dimensions of path and tangents must match\")\n    [\n     for(i=idx(path))\n         let(\n             pts = i==0 ? (closed? select(path,-1,1) : select(path,0,2))\n                 : i==len(path)-1 ? (closed? select(path,i-1,i+1) : select(path,i-2,i))\n                 : select(path,i-1,i+1)\n        )\n        dim == 2 ? [tangents[i].y,-tangents[i].x]\n                 : let( v=cross(cross(pts[1]-pts[0], pts[2]-pts[0]),tangents[i]))\n                   assert(norm(v)>EPSILON, \"3D path contains collinear points\")\n                   unit(v)\n    ];\n\n\n// Function: path_curvature()\n// Synopsis: Returns the estimated numerical curvature of the path.\n// Topics: Paths\n// See Also: path_tangents(), path_normals(), path_torsion()\n// Usage:\n//   curvs = path_curvature(path, [closed]);\n// Description:\n//   Numerically estimate the curvature of the path (in any dimension).\n// Arguments:\n//   path = path in any dimension or a 1-region\n//   closed = if true then treat the path as a polygon.  Default: false\nfunction path_curvature(path, closed) =\n    is_1region(path) ? path_curvature(path[0], default(closed,true)) :\n    let(closed=default(closed,false))\n    assert(is_bool(closed))\n    assert(is_path(path))\n    let( \n        d1 = deriv(path, closed=closed),\n        d2 = deriv2(path, closed=closed)\n    ) [\n        for(i=idx(path))\n        sqrt(\n            sqr(norm(d1[i])*norm(d2[i])) -\n            sqr(d1[i]*d2[i])\n        ) / pow(norm(d1[i]),3)\n    ];\n\n\n// Function: path_torsion()\n// Synopsis: Returns the estimated numerical torsion of the path.\n// Topics: Paths\n// See Also: path_tangents(), path_normals(), path_curvature()\n// Usage:\n//   torsions = path_torsion(path, [closed]);\n// Description:\n//   Numerically estimate the torsion of a 3d path.\n// Arguments:\n//   path = 3D path\n//   closed = if true then treat path as a polygon.  Default: false\nfunction path_torsion(path, closed=false) =\n    assert(is_path(path,3), \"Input path must be a 3d path\")\n    assert(is_bool(closed))\n    let(\n        d1 = deriv(path,closed=closed),\n        d2 = deriv2(path,closed=closed),\n        d3 = deriv3(path,closed=closed)\n    ) [\n        for (i=idx(path)) let(\n            crossterm = cross(d1[i],d2[i])\n        ) crossterm * d3[i] / sqr(norm(crossterm))\n    ];\n\n\n// Section: Breaking paths up into subpaths\n\n\n\n// Function: path_cut()\n// Synopsis: Cuts a path into subpaths at various points.\n// SynTags: PathList\n// Topics: Paths, Path Subdivision\n// See Also: split_path_at_self_crossings(), path_cut_points()\n// Usage:\n//   path_list = path_cut(path, cutdist, [closed]);\n// Description:\n//   Given a list of distances in `cutdist`, cut the path into\n//   subpaths at those lengths, returning a list of paths.\n//   If the input path is closed then the final path will include the\n//   original starting point.  The list of cut distances must be\n//   in ascending order and should not include the endpoints: 0 \n//   or len(path).  If you repeat a distance you will get an\n//   empty list in that position in the output.  If you give an\n//   empty cutdist array you will get the input path as output\n//   (without the final vertex doubled in the case of a closed path).\n// Arguments:\n//   path = path of any dimension or a 1-region\n//   cutdist = Distance or list of distances where path is cut\n//   closed = If true, treat the path as a closed polygon.  Default: false\n// Example(2D,NoAxes):\n//   path = circle(d=100);\n//   segs = path_cut(path, [50, 200], closed=true);\n//   rainbow(segs) stroke($item, endcaps=\"butt\", width=3);\nfunction path_cut(path,cutdist,closed) =\n  is_num(cutdist) ? path_cut(path,[cutdist],closed) :\n  is_1region(path) ? path_cut(path[0], cutdist, default(closed,true)):\n  let(closed=default(closed,false))\n  assert(is_bool(closed))\n  assert(is_vector(cutdist))\n  assert(last(cutdist)<path_length(path,closed=closed)-EPSILON,\"Cut distances must be smaller than the path length\")\n  assert(cutdist[0]>EPSILON, \"Cut distances must be strictly positive\")\n  let(\n      cutlist = path_cut_points(path,cutdist,closed=closed)\n  )\n  _path_cut_getpaths(path, cutlist, closed);\n\n\nfunction _path_cut_getpaths(path, cutlist, closed) =\n  let(\n      cuts = len(cutlist)\n  )\n  [\n      [ each list_head(path,cutlist[0][1]-1),\n        if (!approx(cutlist[0][0], path[cutlist[0][1]-1])) cutlist[0][0]\n      ],\n      for(i=[0:1:cuts-2])\n          cutlist[i][0]==cutlist[i+1][0] && cutlist[i][1]==cutlist[i+1][1] ? []\n          :\n          [ if (!approx(cutlist[i][0], select(path,cutlist[i][1]))) cutlist[i][0],\n            each slice(path, cutlist[i][1], cutlist[i+1][1]-1),\n            if (!approx(cutlist[i+1][0], select(path,cutlist[i+1][1]-1))) cutlist[i+1][0],\n          ],\n      [\n        if (!approx(cutlist[cuts-1][0], select(path,cutlist[cuts-1][1]))) cutlist[cuts-1][0],\n        each select(path,cutlist[cuts-1][1],closed ? 0 : -1)\n      ]\n  ];\n\n\n\n// Function: path_cut_points()\n// Synopsis: Returns a list of cut points at a list of distances from the first point in a path.\n// Topics: Paths, Path Subdivision\n// See Also: path_cut(), split_path_at_self_crossings()\n// Usage:\n//   cuts = path_cut_points(path, cutdist, [closed=], [direction=]);\n//\n// Description:\n//   Cuts a path at a list of distances from the first point in the path.  Returns a list of the cut\n//   points and indices of the next point in the path after that point.  So for example, a return\n//   value entry of [[2,3], 5] means that the cut point was [2,3] and the next point on the path after\n//   this point is path[5].  If the path is too short then path_cut_points returns undef.  If you set\n//   `direction` to true then `path_cut_points` will also return the tangent vector to the path and a normal\n//   vector to the path.  It tries to find a normal vector that is coplanar to the path near the cut\n//   point.  If this fails it will return a normal vector parallel to the xy plane.  The output with\n//   direction vectors will be `[point, next_index, tangent, normal]`.\n//   .\n//   If you give the very last point of the path as a cut point then the returned index will be\n//   one larger than the last index (so it will not be a valid index).  If you use the closed\n//   option then the returned index will be equal to the path length for cuts along the closing\n//   path segment, and if you give a point equal to the path length you will get an\n//   index of len(path)+1 for the index.  \n//\n// Arguments:\n//   path = path to cut\n//   cutdist = distances where the path should be cut (a list) or a scalar single distance\n//   ---\n//   closed = set to true if the curve is closed.  Default: false\n//   direction = set to true to return direction vectors.  Default: false\n//\n// Example(NORENDER):\n//   square=[[0,0],[1,0],[1,1],[0,1]];\n//   path_cut_points(square, [.5,1.5,2.5]);   // Returns [[[0.5, 0], 1], [[1, 0.5], 2], [[0.5, 1], 3]]\n//   path_cut_points(square, [0,1,2,3]);      // Returns [[[0, 0], 1], [[1, 0], 2], [[1, 1], 3], [[0, 1], 4]]\n//   path_cut_points(square, [0,0.8,1.6,2.4,3.2], closed=true);  // Returns [[[0, 0], 1], [[0.8, 0], 1], [[1, 0.6], 2], [[0.6, 1], 3], [[0, 0.8], 4]]\n//   path_cut_points(square, [0,0.8,1.6,2.4,3.2]);               // Returns [[[0, 0], 1], [[0.8, 0], 1], [[1, 0.6], 2], [[0.6, 1], 3], undef]\nfunction path_cut_points(path, cutdist, closed=false, direction=false) =\n    let(long_enough = len(path) >= (closed ? 3 : 2))\n    assert(long_enough,len(path)<2 ? \"Two points needed to define a path\" : \"Closed path must include three points\")\n    is_num(cutdist) ? path_cut_points(path, [cutdist],closed, direction)[0] :\n    assert(is_vector(cutdist))\n    assert(is_increasing(cutdist), \"Cut distances must be an increasing list\")\n    let(cuts = path_cut_points_recurse(path,cutdist,closed))\n    !direction\n       ? cuts\n       : let(\n             dir = _path_cuts_dir(path, cuts, closed),\n             normals = _path_cuts_normals(path, cuts, dir, closed)\n         )\n         hstack(cuts, list_to_matrix(dir,1), list_to_matrix(normals,1));\n\n// Main recursive path cut function\nfunction path_cut_points_recurse(path, dists, closed=false, pind=0, dtotal=0, dind=0, result=[]) =\n    dind == len(dists) ? result :\n    let(\n        lastpt = len(result)==0? [] : last(result)[0],       // location of last cut point\n        dpartial = len(result)==0? 0 : norm(lastpt-select(path,pind)),  // remaining length in segment\n        nextpoint = dists[dind] < dpartial+dtotal  // Do we have enough length left on the current segment?\n           ? [lerp(lastpt,select(path,pind),(dists[dind]-dtotal)/dpartial),pind] \n           : _path_cut_single(path, dists[dind]-dtotal-dpartial, closed, pind)\n    ) \n    path_cut_points_recurse(path, dists, closed, nextpoint[1], dists[dind],dind+1, concat(result, [nextpoint]));\n\n\n// Search for a single cut point in the path\nfunction _path_cut_single(path, dist, closed=false, ind=0, eps=1e-7) =\n    // If we get to the very end of the path (ind is last point or wraparound for closed case) then\n    // check if we are within epsilon of the final path point.  If not we're out of path, so we fail\n    ind==len(path)-(closed?0:1) ?\n       assert(dist<eps,\"Path is too short for specified cut distance\")\n       [select(path,ind),ind+1]\n    :let(d = norm(path[ind]-select(path,ind+1))) d > dist ?\n        [lerp(path[ind],select(path,ind+1),dist/d), ind+1] :\n        _path_cut_single(path, dist-d,closed, ind+1, eps);\n\n// Find normal directions to the path, coplanar to local part of the path\n// Or return a vector parallel to the x-y plane if the above fails\nfunction _path_cuts_normals(path, cuts, dirs, closed=false) =\n    [for(i=[0:len(cuts)-1])\n        len(path[0])==2? [-dirs[i].y, dirs[i].x]\n          : \n            let(\n                plane = len(path)<3 ? undef :\n                let(start = max(min(cuts[i][1],len(path)-1),2)) _path_plane(path, start, start-2)\n            )\n            plane==undef?\n                ( dirs[i].x==0 && dirs[i].y==0 ? [1,0,0]  // If it's z direction return x vector\n                                               : unit([-dirs[i].y, dirs[i].x,0])) // otherwise perpendicular to projection\n                : unit(cross(dirs[i],cross(plane[0],plane[1])))\n    ];\n\n// Scan from the specified point (ind) to find a noncoplanar triple to use\n// to define the plane of the path.\nfunction _path_plane(path, ind, i,closed) =\n    i<(closed?-1:0) ? undef :\n    !is_collinear(path[ind],path[ind-1], select(path,i))?\n        [select(path,i)-path[ind-1],path[ind]-path[ind-1]] :\n        _path_plane(path, ind, i-1);\n\n// Find the direction of the path at the cut points\nfunction _path_cuts_dir(path, cuts, closed=false, eps=1e-2) =\n    [for(ind=[0:len(cuts)-1])\n        let(\n            zeros = path[0]*0,\n            nextind = cuts[ind][1],\n            nextpath = unit(select(path, nextind+1)-select(path, nextind),zeros),\n            thispath = unit(select(path, nextind) - select(path,nextind-1),zeros),\n            lastpath = unit(select(path,nextind-1) - select(path, nextind-2),zeros),\n            nextdir =\n                nextind==len(path) && !closed? lastpath :\n                (nextind<=len(path)-2 || closed) && approx(cuts[ind][0], path[nextind],eps)\n                   ? unit(nextpath+thispath)\n              : (nextind>1 || closed) && approx(cuts[ind][0],select(path,nextind-1),eps)\n                   ? unit(thispath+lastpath)\n              :  thispath\n        ) nextdir\n    ];\n\n\n// internal function\n// converts pathcut output form to a [segment, u]\n// form list that works withi path_select\nfunction _cut_to_seg_u_form(pathcut, path, closed) =\n  let(lastind = len(path) - (closed?0:1))\n  [for(entry=pathcut)\n    entry[1] > lastind ? [lastind,0] :\n    let(\n        a = path[entry[1]-1],\n        b = path[entry[1]],\n        c = entry[0],\n        i = max_index(v_abs(b-a)),\n        factor = (c[i]-a[i])/(b[i]-a[i])\n    )\n    [entry[1]-1,factor]\n  ];\n\n\n\n// Function: split_path_at_self_crossings()\n// Synopsis: Split a 2D path wherever it crosses itself.\n// SynTags: PathList\n// Topics: Paths, Path Subdivision\n// See Also: path_cut(), path_cut_points()\n// Usage:\n//   paths = split_path_at_self_crossings(path, [closed], [eps]);\n// Description:\n//   Splits a 2D path into sub-paths wherever the original path crosses itself.\n//   Splits may occur mid-segment, so new vertices will be created at the intersection points.\n//   Returns a list of the resulting subpaths.  \n// Arguments:\n//   path = A 2D path or a 1-region.\n//   closed = If true, treat path as a closed polygon.  Default: true\n//   eps = Acceptable variance.  Default: `EPSILON` (1e-9)\n// Example(2D,NoAxes):\n//   path = [ [-100,100], [0,-50], [100,100], [100,-100], [0,50], [-100,-100] ];\n//   paths = split_path_at_self_crossings(path);\n//   rainbow(paths) stroke($item, closed=false, width=3);\nfunction split_path_at_self_crossings(path, closed=true, eps=EPSILON) =\n    let(path = force_path(path))\n    assert(is_path(path,2), \"Must give a 2D path\")\n    assert(is_bool(closed))\n    let(\n        path = list_unwrap(path, eps=eps),\n        isects = deduplicate(\n            eps=eps,\n            concat(\n                [[0, 0]],\n                sort([\n                    for (\n                        a = _path_self_intersections(path, closed=closed, eps=eps),\n                        ss = [ [a[1],a[2]], [a[3],a[4]] ]\n                    ) if (ss[0] != undef) ss\n                ]),\n                [[len(path)-(closed?1:2), 1]]\n            )\n        )\n    ) [\n        for (p = pair(isects))\n            let(\n                s1 = p[0][0],\n                u1 = p[0][1],\n                s2 = p[1][0],\n                u2 = p[1][1],\n                section = _path_select(path, s1, u1, s2, u2, closed=closed),\n                outpath = deduplicate(eps=eps, section)\n            )\n            if (len(outpath)>1) outpath\n    ];\n\n\nfunction _tag_self_crossing_subpaths(path, nonzero, closed=true, eps=EPSILON) =\n    let(\n        subpaths = split_path_at_self_crossings(\n            path, closed=true, eps=eps\n        )\n    ) [\n        for (subpath = subpaths) let(\n            seg = select(subpath,0,1),\n            mp = mean(seg),\n            n = line_normal(seg) / 2048,\n            p1 = mp + n,\n            p2 = mp - n,\n            p1in = point_in_polygon(p1, path, nonzero=nonzero) >= 0,\n            p2in = point_in_polygon(p2, path, nonzero=nonzero) >= 0,\n            tag = (p1in && p2in)? \"I\" : \"O\"\n        ) [tag, subpath]\n    ];\n\n\n// Function: polygon_parts()\n// Synopsis: Parses a self-intersecting polygon into a list of non-intersecting polygons.\n// SynTags: PathList\n// Topics: Paths, Polygons\n// See Also: split_path_at_self_crossings(), path_cut(), path_cut_points()\n// Usage:\n//   splitpolys = polygon_parts(poly, [nonzero], [eps]);\n// Description:\n//   Given a possibly self-intersecting 2d polygon, constructs a representation of the original polygon as a list of\n//   non-intersecting simple polygons.  If nonzero is set to true then it uses the nonzero method for defining polygon membership.\n//   For simple cases, such as the pentagram, this will produce the outer perimeter of a self-intersecting polygon.  \n// Arguments:\n//   poly = a 2D polygon or 1-region\n//   nonzero = If true use the nonzero method for checking if a point is in a polygon.  Otherwise use the even-odd method.  Default: false\n//   eps = The epsilon error value to determine whether two points coincide.  Default: `EPSILON` (1e-9)\n// Example(2D,NoAxes):  This cross-crossing polygon breaks up into its 3 components (regardless of the value of nonzero).\n//   poly = [\n//       [-100,100], [0,-50], [100,100],\n//       [100,-100], [0,50], [-100,-100]\n//   ];\n//   splitpolys = polygon_parts(poly);\n//   rainbow(splitpolys) stroke($item, closed=true, width=3);\n// Example(2D,NoAxes): With nonzero=false you get even-odd mode which matches OpenSCAD, so the pentagram breaks apart into its five points.\n//   pentagram = turtle([\"move\",100,\"left\",144], repeat=4);\n//   left(100)polygon(pentagram);\n//   rainbow(polygon_parts(pentagram,nonzero=false))\n//     stroke($item,closed=true,width=2.5);\n// Example(2D,NoAxes): With nonzero=true you get only the outer perimeter.  You can use this to create the polygon using the nonzero method, which is not supported by OpenSCAD.\n//   pentagram = turtle([\"move\",100,\"left\",144], repeat=4);\n//   outside = polygon_parts(pentagram,nonzero=true);\n//   left(100)region(outside);\n//   rainbow(outside)\n//     stroke($item,closed=true,width=2.5);\n// Example(2D,NoAxes): \n//   N=12;\n//   ang=360/N;\n//   sr=10;\n//   poly = turtle([\"angle\", 90+ang/2,\n//                  \"move\", sr, \"left\",\n//                  \"move\", 2*sr*sin(ang/2), \"left\",\n//                  \"repeat\", 4,\n//                     [\"move\", 2*sr, \"left\",\n//                      \"move\", 2*sr*sin(ang/2), \"left\"],\n//                  \"move\", sr]);\n//   stroke(poly, width=.3);\n//   right(20)rainbow(polygon_parts(poly)) polygon($item);\n// Example(2D,NoAxes): overlapping poly segments disappear\n//   poly = [[0,0], [10,0], [10,10], [0,10],[0,20], [20,10],[10,10], [0,10],[0,0]];\n//   stroke(poly,width=0.3);\n//   right(22)stroke(polygon_parts(poly)[0], width=0.3, closed=true);\n// Example(2D,NoAxes): Poly segments disappear outside as well\n//   poly = turtle([\"repeat\", 3, [\"move\", 17, \"left\", \"move\", 10, \"left\", \"move\", 7, \"left\", \"move\", 10, \"left\"]]);\n//   back(2)stroke(poly,width=.5);\n//   fwd(12)rainbow(polygon_parts(poly)) stroke($item, closed=true, width=0.5);\n// Example(2D,NoAxes):  This shape has six components\n//   poly = turtle([\"repeat\", 3, [\"move\", 15, \"left\", \"move\", 7, \"left\", \"move\", 10, \"left\", \"move\", 17, \"left\"]]);\n//   polygon(poly);\n//   right(22)rainbow(polygon_parts(poly)) polygon($item);\n// Example(2D,NoAxes): When the loops of the shape overlap then nonzero gives a different result than the even-odd method.\n//   poly = turtle([\"repeat\", 3, [\"move\", 15, \"left\", \"move\", 7, \"left\", \"move\", 10, \"left\", \"move\", 10, \"left\"]]);\n//   polygon(poly);\n//   right(27)rainbow(polygon_parts(poly)) polygon($item);\n//   move([16,-14])rainbow(polygon_parts(poly,nonzero=true)) polygon($item);\nfunction polygon_parts(poly, nonzero=false, eps=EPSILON) =\n    let(poly = force_path(poly))\n    assert(is_path(poly,2), \"Must give 2D polygon\")\n    assert(is_bool(nonzero))    \n    let(\n        poly = list_unwrap(poly, eps=eps),\n        tagged = _tag_self_crossing_subpaths(poly, nonzero=nonzero, closed=true, eps=eps),\n        kept = [for (sub = tagged) if(sub[0] == \"O\") sub[1]],\n        outregion = _assemble_path_fragments(kept, eps=eps)\n    ) outregion;\n\n\nfunction _extreme_angle_fragment(seg, fragments, rightmost=true, eps=EPSILON) =\n    !fragments? [undef, []] :\n    let(\n        delta = seg[1] - seg[0],\n        segang = atan2(delta.y,delta.x),\n        frags = [\n            for (i = idx(fragments)) let(\n                fragment = fragments[i],\n                fwdmatch = approx(seg[1], fragment[0], eps=eps),\n                bakmatch =  approx(seg[1], last(fragment), eps=eps)\n            ) [\n                fwdmatch,\n                bakmatch,\n                bakmatch? reverse(fragment) : fragment\n            ]\n        ],\n        angs = [\n            for (frag = frags)\n                (frag[0] || frag[1])? let(\n                    delta2 = frag[2][1] - frag[2][0],\n                    segang2 = atan2(delta2.y, delta2.x)\n                ) modang(segang2 - segang) : (\n                    rightmost? 999 : -999\n                )\n        ],\n        fi = rightmost? min_index(angs) : max_index(angs)\n    ) abs(angs[fi]) > 360? [undef, fragments] : let(\n        remainder = [for (i=idx(fragments)) if (i!=fi) fragments[i]],\n        frag = frags[fi],\n        foundfrag = frag[2]\n    ) [foundfrag, remainder];\n\n\n/// Internal Function: _assemble_a_path_from_fragments()\n/// Usage:\n///   _assemble_a_path_from_fragments(subpaths);\n/// Description:\n///   Given a list of paths, assembles them together into one complete closed polygon path, and\n///   remainder fragments.  Returns [PATH, FRAGMENTS] where FRAGMENTS is the list of remaining\n///   unused path fragments.\n/// Arguments:\n///   fragments = List of paths to be assembled into complete polygons.\n///   rightmost = If true, assemble paths using rightmost turns. Leftmost if false.\n///   startfrag = The fragment to start with.  Default: 0\n///   eps = The epsilon error value to determine whether two points coincide.  Default: `EPSILON` (1e-9)\nfunction _assemble_a_path_from_fragments(fragments, rightmost=true, startfrag=0, eps=EPSILON) =\n    len(fragments)==0? [[],[]] :\n    len(fragments)==1? [fragments[0],[]] :\n    let(\n        path = fragments[startfrag],\n        newfrags = [for (i=idx(fragments)) if (i!=startfrag) fragments[i]]\n    ) are_ends_equal(path, eps=eps)? (\n        // starting fragment is already closed\n        [path, newfrags]\n    ) : let(\n        // Find rightmost/leftmost continuation fragment\n        seg = select(path,-2,-1),\n        extrema = _extreme_angle_fragment(seg=seg, fragments=newfrags, rightmost=rightmost, eps=eps),\n        foundfrag = extrema[0],\n        remainder = extrema[1]\n    ) is_undef(foundfrag)? (\n        // No remaining fragments connect!  INCOMPLETE PATH!\n        // Treat it as complete.\n        [path, remainder]\n    ) : are_ends_equal(foundfrag, eps=eps)? (\n        // Found fragment is already closed\n        [foundfrag, concat([path], remainder)]\n    ) : let(\n        fragend = last(foundfrag),\n        hits = [for (i = idx(path,e=-2)) if(approx(path[i],fragend,eps=eps)) i]\n    ) hits? (\n        let(\n            // Found fragment intersects with initial path\n            hitidx = last(hits),\n            newpath = list_head(path,hitidx),\n            newfrags = concat(len(newpath)>1? [newpath] : [], remainder),\n            outpath = concat(slice(path,hitidx,-2), foundfrag)\n        )\n        [outpath, newfrags]\n    ) : let(\n        // Path still incomplete.  Continue building it.\n        newpath = concat(path, list_tail(foundfrag)),\n        newfrags = concat([newpath], remainder)\n    )\n    _assemble_a_path_from_fragments(\n        fragments=newfrags,\n        rightmost=rightmost,\n        eps=eps\n    );\n\n\n/// Internal Function: _assemble_path_fragments()\n/// Usage:\n///   _assemble_path_fragments(subpaths);\n/// Description:\n///   Given a list of paths, assembles them together into complete closed polygon paths if it can.\n///   Polygons with area < eps will be discarded and not returned.  \n/// Arguments:\n///   fragments = List of paths to be assembled into complete polygons.\n///   eps = The epsilon error value to determine whether two points coincide.  Default: `EPSILON` (1e-9)\nfunction _assemble_path_fragments(fragments, eps=EPSILON, _finished=[]) =\n    len(fragments)==0? _finished :\n    let(\n        minxidx = min_index([\n            for (frag=fragments) min(column(frag,0))\n        ]),\n        result_l = _assemble_a_path_from_fragments(\n            fragments=fragments,\n            startfrag=minxidx,\n            rightmost=false,\n            eps=eps\n        ),\n        result_r = _assemble_a_path_from_fragments(\n            fragments=fragments,\n            startfrag=minxidx,\n            rightmost=true,\n            eps=eps\n        ),\n        l_area = abs(polygon_area(result_l[0])),\n        r_area = abs(polygon_area(result_r[0])),\n        result = l_area < r_area? result_l : result_r,\n        newpath = list_unwrap(result[0]),\n        remainder = result[1],\n        finished = min(l_area,r_area)<eps ? _finished : concat(_finished, [newpath])\n    ) _assemble_path_fragments(\n        fragments=remainder,\n        eps=eps,\n        _finished=finished\n    );\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-31", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: polyhedra.scad\n//   Generate Platonic solids, Archimedian solids, Catalan polyhedra, the trapezohedron, and some stellated polyhedra.\n//   You can also stellate any of the polyhedra, select polyhedra by their characterics and position objects on polyhedra faces. \n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/polyhedra.scad>\n// FileGroup: Parts\n// FileSummary: Platonic, Archimidean, Catalan, and stellated polyhedra\n//////////////////////////////////////////////////////////////////////\n\n\n// CommonCode:\n//   $fn=96;\n\n\n// Section: Polyhedra\n\n\n// Groups entries in \"arr\" into groups of equal values and returns index lists of those groups\n\nfunction _unique_groups(m) = [\n    for (i=[0:1:len(m)-1]) let(\n        s = search([m[i]], m, 0)[0]\n    ) if (s[0]==i) s\n];\n\n\n// TODO\n//\n// Use volume info?\n// Support choosing a face number down\n// Support multiple inspheres/outspheres when appropriate?\n// face order for children?\n// orient faces so an edge is parallel to the x-axis\n//\n\n\n// Module: regular_polyhedron()\n// Synopsis: Creates a regular polyhedron with optional rounding.\n// SynTags: Geom\n// Topics: Polyhedra, Shapes, Parts\n// See Also: regular_polyhedron_info()\n// Usage: Selecting a polyhedron\n//   regular_polyhedron([name],[index=],[type=],[faces=],[facetype=],[hasfaces=],...) [CHILDREN];\n// Usage: Controlling the size and position of the polyhedron\n//   regular_polyhedron(..., [or=|r=|d=],[ir=],[mr=],[side=],[facedown=],[anchor=], ...) [CHILDREN];]\n// Usage: Other options that change the polyhedron or handling of children\n//   regular_polyhedron(..., [draw=], [rounding=], [stellate=], [repeat=], [rotate_children=]) [CHILDREN];\n// Usage: options only for the trapezohedron\n//   regular_polyhedron(\"trapezohedron\", [longside=],[h=], ...) [CHILDREN];\n// Description:\n//   Creates a regular polyhedron with optional rounding.  Children are placed on the polyhedron's faces.  (Note that this is not attachable.)\n//   The regular_polyhedron module knows about many different regular and semi-regular polyhedra.  You can refer to them\n//   by name.  The complete list with their names appears below in the examples.  You can also search the polyhedra\n//   for ones that meet various critera using `type=`, `faces=`, `facetype=` or `hasfaces=`.  This will result in a list of polyhedra in a\n//   canonical order that might include several options.  By default if you give specifications that produce several polyhedra, the first\n//   one will be returned.  You can use the `index=` argument to select others from your list of hits.  Examples of polyhedron selection appear\n//   after the full list of polyhedra below.  \n//   .\n//   **Selecting the polyhedron:**\n//   You constrain the polyhedra list by specifying different characteristics, that must all be met\n//   * `name`: e.g. `\"dodecahedron\"` or `\"pentagonal icositetrahedron\"`.  The name fully identifies the polyhedron, so no other characteristic should be given.\n//   * `type`: Options are `\"platonic\"`, `\"archimedean\"` and `\"catalan\"`\n//   * `faces`: The required number of faces\n//   * `facetype`: The required face type(s).  List of vertex counts for the faces.  Exactly the listed types of faces must appear:\n//     * `facetype = 3`: polyhedron with all triangular faces.\n//     * `facetype = [5,6]`: polyhedron with only pentagons and hexagons. (Must have both!)\n//   * hasfaces: The list of vertex counts for faces; at least one listed type must appear:\n//     * `hasfaces = 3`: polygon has at least one triangular face\n//     * `hasfaces = [5,6]`: polygon has a hexagonal or a pentagonal face\n//   .\n//   The result is a list of selected polyhedra.  You then specify `index` to choose which one of the\n//   remaining polyhedra you want.  If you don't give `index` the first one on the list is created.\n//   Two examples:\n//   * `faces=12, index=2`:  Creates the 3rd solid with 12 faces\n//   * `type=\"archimedean\", faces=14`: Creates the first archimedean solid with 14 faces (there are 3)\n//   .\n//   **Choosing the size of your polyhedron:**\n//   The default is to create a polyhedron whose smallest edge has length 1.  You can specify the\n//   smallest edge length with the size option.  Alternatively you can specify the size of the\n//   inscribed sphere, midscribed sphere, or circumscribed sphere using `ir`, `mr` and `cr` respectively.\n//   If you specify `cr=3` then the outermost points of the polyhedron will be 3 units from the center.\n//   If you specify `ir=3` then the innermost faces of the polyhedron will be 3 units from the center.\n//   For the platonic solids every face meets the inscribed sphere and every corner touches the\n//   circumscribed sphere.  For the Archimedean solids the inscribed sphere will touch only some of\n//   the faces and for the Catalan solids the circumscribed sphere meets only some of the corners.\n//   .\n//   **Orientation:**\n//   Orientation is controled by the facedown parameter.  Set this to false to get the canonical orientation.\n//   Set it to true to get the largest face oriented down.  If you set it to a number the module searches for\n//   a face with the specified number of vertices and orients that face down.\n//   .\n//   **Rounding:**\n//   If you specify the rounding parameter the module makes a rounded polyhedron by first creating an\n//   undersized model and then expanding it with `minkowski()`.  This only produces the correct result\n//   if the in-sphere contacts all of the faces of the polyhedron, which is true for the platonic, the\n//   catalan solids and the trapezohedra but false for the archimedean solids.\n//   .\n//   **Children:**\n//   The module places children on the faces of the polyhedron.  The child coordinate system is\n//   positioned so that the origin is the center of the face.  If `rotate_children` is true (default)\n//   then the coordinate system is oriented so the z axis is normal to the face, which lies in the xy\n//   plane.  If you give `repeat=true` (default) the children are cycled through to cover all faces.\n//   With `repeat=false` each child is used once.  You can specify `draw=false` to suppress drawing of\n//   the polyhedron, e.g. to use for `difference()` operations.  The module sets various parameters\n//   you can use in your children (see the side effects list below).\n//   .\n//   **Stellation:**\n//   Technically stellation is an operation of shifting the polyhedron's faces to produce a new shape\n//   that may have self-intersecting faces.  OpenSCAD cannot handle self-intersecting faces, so we\n//   instead erect a pyramid on each face, a process technically referred to as augmentation.  The\n//   height of the pyramid is given by the `stellate` argument.  If `stellate` is `false` or `0` then\n//   no stellation is performed.  Otherwise stellate gives the pyramid height as a multiple of the\n//   edge length.  A negative pyramid height can be used to perform excavation, where a pyramid is\n//   removed from each face.\n//   .\n//   **Special Polyhedra:**\n//   These can be selected only by name and may require different parameters, or ignore some standard\n//   parameters.\n//   * Trapezohedron: a family of solids with an even number of kite shaped sides.\n//     One example of a trapezohedron is the d10 die, which is a 10 face trapezohedron.\n//     You must specify exactly two of `side`, `longside`, `h` (or `height`), and `r` (or `d`).\n//     You cannot create trapezohedron shapes using `mr`, `ir`, or `or`.\n//     * `side`: Length of the short side.\n//     * `longside`: Length of the long side that extends to the apex.\n//     * `h` or `height`: Distance from the center to the apex.\n//     * `r`: Radius of the polygon that defines the equatorial vertices.\n//     * `d`: Diameter of the polygon that defines the equatorial vertices.\n//   .\n//   * Named stellations: various polyhedra such as three of the four Kepler-Poinsot solids are stellations with\n//    specific pyramid heights.  To make them easier to generate you can specify them by name.\n//    This is equivalent to giving the name of the appropriate base solid and the magic stellate\n//    parameter needed to produce that shape.  The supported solids are:\n//     * `\"great dodecahedron\"`\n//     * `\"small stellated dodecahedron\"`\n//     * `\"great stellated dodecahedron\"`\n//     * `\"small triambic icosahedron\"` (not a Kepler-Poinsot solid)\n//\n// Arguments:\n//   name = Name of polyhedron to create.\n//   ---\n//   type = Type of polyhedron: \"platonic\", \"archimedean\", \"catalan\".\n//   faces = Number of faces.\n//   facetype = Scalar or vector listing required type of faces as vertex count.  Polyhedron must have faces of every type listed and no other types.\n//   hasfaces = Scalar of vector list face vertex counts.  Polyhedron must have at least one of the listed types of face.\n//   index = Index to select from polyhedron list.  Default: 0.\n//   side = Length of the smallest edge of the polyhedron.  Default: 1 (if no radius or diameter is given).  \n//   ir = inner radius.  Polyhedron is scaled so it has the specified inner radius. \n//   mr = middle radius.  Polyhedron is scaled so it has the specified middle radius.  \n//   or / r / d = outer radius.   Polyhedron is scaled so it has the specified outer radius. \n//   anchor = Side of the origin to anchor to.  The bounding box of the polyhedron is aligned as specified.  Default: `CENTER`\n//   facedown = If false display the solid in native orientation.  If true orient it with a largest face down.  If set to a vertex count, orient it so a face with the specified number of vertices is down.  Default: true.\n//   rounding = Specify a rounding radius for the shape.  Note that depending on $fn the dimensions of the shape may have small dimensional errors.\n//   repeat = If true then repeat the children to fill all the faces.  If false use only the available children and stop.  Default: true.\n//   draw = If true then draw the polyhedron.  If false, draw the children but not the polyhedron.  Default: true.\n//   rotate_children = If true then orient children normal to their associated face.  If false orient children to the parent coordinate system.  Default: true.\n//   stellate = Set to a number to erect a pyramid of that height on every face of your polyhedron.  The height is a multiple of the side length.  Default: false.\n//   longside = Specify the long side length for a trapezohedron.  Invalid for other shapes.\n//   h = Specify the height of the apex for a trapezohedron.  Invalid for other shapes.\n//\n// Side Effects:\n//   `$faceindex` - Index number of the face\n//   `$face` - Coordinates of the face (2d if rotate_children==true, 3d if not)\n//   `$center` - Face center in the child coordinate system\n//\n// Examples: All of the available polyhedra by name in their native orientation\n//   regular_polyhedron(\"tetrahedron\", facedown=false);\n//   regular_polyhedron(\"cube\", facedown=false);\n//   regular_polyhedron(\"octahedron\", facedown=false);\n//   regular_polyhedron(\"dodecahedron\", facedown=false);\n//   regular_polyhedron(\"icosahedron\", facedown=false);\n//   regular_polyhedron(\"truncated tetrahedron\", facedown=false);\n//   regular_polyhedron(\"truncated octahedron\", facedown=false);\n//   regular_polyhedron(\"truncated cube\", facedown=false);\n//   regular_polyhedron(\"truncated icosahedron\", facedown=false);\n//   regular_polyhedron(\"truncated dodecahedron\", facedown=false);\n//   regular_polyhedron(\"cuboctahedron\", facedown=false);\n//   regular_polyhedron(\"icosidodecahedron\", facedown=false);\n//   regular_polyhedron(\"rhombicuboctahedron\", facedown=false);\n//   regular_polyhedron(\"rhombicosidodecahedron\", facedown=false);\n//   regular_polyhedron(\"truncated cuboctahedron\", facedown=false);\n//   regular_polyhedron(\"truncated icosidodecahedron\", facedown=false);\n//   regular_polyhedron(\"snub cube\", facedown=false);\n//   regular_polyhedron(\"snub dodecahedron\", facedown=false);\n//   regular_polyhedron(\"triakis tetrahedron\", facedown=false);\n//   regular_polyhedron(\"tetrakis hexahedron\", facedown=false);\n//   regular_polyhedron(\"triakis octahedron\", facedown=false);\n//   regular_polyhedron(\"pentakis dodecahedron\", facedown=false);\n//   regular_polyhedron(\"triakis icosahedron\", facedown=false);\n//   regular_polyhedron(\"rhombic dodecahedron\", facedown=false);\n//   regular_polyhedron(\"rhombic triacontahedron\", facedown=false);\n//   regular_polyhedron(\"deltoidal icositetrahedron\", facedown=false);\n//   regular_polyhedron(\"deltoidal hexecontahedron\", facedown=false);\n//   regular_polyhedron(\"disdyakis dodecahedron\", facedown=false);\n//   regular_polyhedron(\"disdyakis triacontahedron\", facedown=false);\n//   regular_polyhedron(\"pentagonal icositetrahedron\", facedown=false);\n//   regular_polyhedron(\"pentagonal hexecontahedron\", facedown=false);\n//   regular_polyhedron(\"trapezohedron\",faces=10, side=1, longside=2.25, facedown=false);\n//   regular_polyhedron(\"great dodecahedron\");\n//   regular_polyhedron(\"small stellated dodecahedron\");\n//   regular_polyhedron(\"great stellated dodecahedron\");\n//   regular_polyhedron(\"small triambic icosahedron\");\n// Example: Third Archimedean solid\n//   regular_polyhedron(type=\"archimedean\", index=2);\n// Example(Med): Solids that have at least one face with either 8 vertices or 10 vertices\n//   N = len(regular_polyhedron_info(\"index set\", hasfaces=[8,10]));\n//   for(i=[0:N-1]) right(3*i)\n//     regular_polyhedron(hasfaces=[8,10], index=i, mr=1);\n// Example(Big): Solids that include a quadrilateral face\n//   N = len(regular_polyhedron_info(\"index set\", hasfaces=4));\n//   for(i=[0:N-1]) right(3*i)\n//     regular_polyhedron(hasfaces=4, index=i, mr=1);\n// Example(Med): Solids with only quadrilateral faces\n//   N = len(regular_polyhedron_info(\"index set\", facetype=4));\n//   for(i=[0:N-1]) right(3*i)\n//     regular_polyhedron(facetype=4, index=i, mr=1);\n// Example: Solids that have both pentagons and hexagons and no other face types\n//   N = len(regular_polyhedron_info(\"index set\", facetype=[5,6]));\n//   for(i=[0:N-1]) right(3*i)\n//     regular_polyhedron(facetype=[5,6], index=i, mr=1);\n// Example: Rounded octahedron\n//   regular_polyhedron(\"octahedron\", side=1, rounding=.2);\n// Example: Rounded catalon solid\n//   regular_polyhedron(\"rhombic dodecahedron\", side=1, rounding=0.2);\n// Example(Med): Rounded Archimedean solid compared to unrounded version.  The small faces are shifted back from their correct position.\n//   %regular_polyhedron(type=\"archimedean\", mr=1, rounding=0);\n//   regular_polyhedron(type=\"archimedean\", mr=1, rounding=0.3);\n// Example: Two children are distributed arbitrarily over the faces\n//   regular_polyhedron(faces=12,index=2,repeat=true) {\n//     color(\"red\") sphere(r=.1);\n//     color(\"green\") sphere(r=.1);\n//   }\n// Example(FlatSpin,VPD=100): Difference the children from the polyhedron; children depend on $faceindex\n//   difference(){\n//     regular_polyhedron(\"tetrahedron\", side=25);\n//     regular_polyhedron(\"tetrahedron\", side=25,draw=false)\n//       down(.3) linear_extrude(height=1)\n//         text(str($faceindex),halign=\"center\",valign=\"center\");\n//   }\n// Example(Big): With `rotate_children` you can control direction of the children.\n//   regular_polyhedron(name=\"tetrahedron\", anchor=UP, rotate_children=true)\n//     cylinder(r=.1, h=.5);\n//   right(2) regular_polyhedron(name=\"tetrahedron\", anchor=UP, rotate_children=false)\n//     cylinder(r=.1, h=.5);\n// Example(FlatSpin,Med,VPD=15): Using `$face` you can have full control of the construction of your children.  This example constructs the Great Icosahedron, the one Kepler-Poinsot solid that cannot be made directly with {{regular_polyhedron()}}.  \n//   module makestar(pts) {    // Make a star from a point list\n//       polygon(\n//         [\n//           for(i=[0:len(pts)-1]) let(\n//             p0=select(pts,i),\n//             p1=select(pts,i+1),\n//             center=(p0+p1)/2,\n//             v=sqrt(7/4-PHI)*(p1-p0)\n//           ) each [p0, [v.y+center.x, -v.x+center.y]]\n//         ]\n//       );\n//   }\n//   regular_polyhedron(\"dodecahedron\", side=1, repeat=true)\n//   linear_extrude(scale=0, height=sqrt((5+2*sqrt(5))/5)) makestar($face);\n// Example(Med): The spheres are all radius 1 and the octahedra are sized to match the in-sphere, mid-sphere and out-sphere.  The sphere size is slightly adjusted for the in-sphere and out-sphere so you can see the relationship: the sphere is tangent to the faces for the former and the corners poke out for the latter.  Note also the difference in the size of the three octahedra.\n//   sphere(r=1.005);\n//   %regular_polyhedron(\"octahedron\", ir=1, facedown=false);\n//   right(3.5) {\n//     sphere(r=1);\n//     %regular_polyhedron(\"octahedron\", mr=1, facedown=false);\n//   }\n//   right(6.5) {\n//     %sphere(r=.95);  // Slightly undersized sphere means the points poke out a bit\n//     regular_polyhedron(\"octahedron\", or=1,facedown=false);\n//   }\n// Example(Med): For the Archimdean solids the in-sphere does not touch all of the faces, as shown by this example, but the circumscribed sphere meets every vertex.  (This explains the problem for rounding over these solids because the rounding method uses the in-sphere.)\n//   sphere(r=1.005);\n//   %regular_polyhedron(\"snub dodecahedron\", ir=1, facedown=false);\n//   right(3) {\n//     sphere(r=1);\n//     %regular_polyhedron(\"snub dodecahedron\", mr=1, facedown=false);\n//   }\n//   right(6) {\n//     %sphere(r=.99);\n//     regular_polyhedron(\"snub dodecahedron\", or=1,facedown=false);\n//   }\n// Example(Med): For a Catalan solid the in-sphere touches every face but the circumscribed sphere only touches some vertices.\n//   sphere(r=1.002);\n//   %regular_polyhedron(\"pentagonal hexecontahedron\", ir=1, facedown=false);\n//   right(3) {\n//     sphere(r=1);\n//     %regular_polyhedron(\"pentagonal hexecontahedron\", mr=1, facedown=false);\n//   }\n//   right(6) {\n//     %sphere(r=.98);\n//     regular_polyhedron(\"pentagonal hexecontahedron\", or=1,facedown=false);\n//   }\n// Example: Stellate an Archimedian solid, which has mixed faces\n//   regular_polyhedron(\"truncated icosahedron\",stellate=1.5,or=1);\n// Example: Stellate a Catalan solid where faces are not regular\n//   regular_polyhedron(\"triakis tetrahedron\",stellate=0.5,or=1);\nmodule regular_polyhedron(\n    name=undef,\n    index=undef,\n    type=undef,\n    faces=undef,\n    facetype=undef,\n    hasfaces=undef,\n    side=undef,\n    ir=undef,\n    mr=undef,\n    or=undef,\n    r=undef,\n    d=undef,\n    anchor=CENTER,\n    rounding=0,\n    repeat=true,\n    facedown=true,\n    draw=true,\n    rotate_children=true,\n    stellate = false,\n    longside=undef,       // special parameter for trapezohedron\n    h=undef,height=undef  // special parameter for trapezohedron\n) {\n    dummy=assert(is_num(rounding) && rounding>=0, \"'rounding' must be nonnegative\");\n    entry = regular_polyhedron_info(\n        \"fullentry\", name=name, index=index,\n        type=type, faces=faces, facetype=facetype,\n        hasfaces=hasfaces, side=side,\n        ir=ir, mr=mr, or=or,\n        r=r, d=d,\n        anchor=anchor, \n        facedown=facedown,\n        stellate=stellate,\n        longside=longside, h=h, height=height\n    );\n    scaled_points = entry[0];\n    translation = entry[1];\n    face_triangles = entry[2];\n    faces = entry[3];\n    face_normals = entry[4];\n    in_radius = entry[5];\n    translate(translation){\n        if (draw){\n            if (rounding==0)\n                polyhedron(scaled_points, faces = face_triangles);\n            else {\n                fn = segs(rounding);\n                rounding = rounding/cos(180/fn);\n                adjusted_scale = 1 - rounding / in_radius;\n                minkowski(){\n                    sphere(r=rounding, $fn=fn);\n                    polyhedron(adjusted_scale*scaled_points, faces = face_triangles);\n                }\n            }\n        }\n        if ($children>0) {\n            maxrange = repeat ? len(faces)-1 : $children-1;\n            for(i=[0:1:maxrange]) {\n                // Would like to orient so an edge (longest edge?) is parallel to x axis\n                facepts = select(scaled_points, faces[i]);\n                $center = -mean(facepts);\n                cfacepts = move($center, p=facepts);\n                $face = rotate_children\n                          ? path2d(frame_map(z=face_normals[i], x=facepts[0]-facepts[1], reverse=true, p=cfacepts))\n                          : cfacepts;\n                $faceindex = i;\n                translate(-$center)\n                if (rotate_children) {\n                    frame_map(z=face_normals[i], x=facepts[0]-facepts[1])\n                    children(i % $children);\n                } else {\n                    children(i % $children);\n                }\n            }\n        }\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n//\n// Some internal functions used to generate polyhedra data\n//\n// All permutations and even permutations of three items\n//\nfunction _even_perms(v) = [v, [v[2], v[0], v[1]], [v[1],v[2],v[0]]];\nfunction _all_perms(v) = [v, [v[2], v[0], v[1]], [v[1],v[2],v[0]], [v[1],v[0],v[2]],[v[2],v[1],v[0]],[v[0],v[2],v[1]]];\n//\n// Point reflections across all planes.    In the unconstrained case, this means one point becomes 8 points.\n//\n// sign==\"even\" means an even number of minus signs (odd number of plus signs)\n// sign==\"odd\" means an odd number of minus signs (even number of plus signs)\n//\nfunction _point_ref(points, sign=\"both\") =\n    unique([\n        for(i=[-1,1],j=[-1,1],k=[-1,1])\n            if (sign==\"both\" || sign==\"even\" && i*j*k>0 || sign==\"odd\" && i*j*k<0)\n                each [for(point=points) v_mul(point,[i,j,k])]\n    ]);\n//\n_tribonacci=(1+4*cosh(acosh(2+3/8)/3))/3;\n//\n/////////////////////////////////////////////////////////////////////////////\n//\n// Polyhedra data table.\n// The polyhedra information is from Wikipedia and http://dmccooey.com/polyhedra/\n//\n_polyhedra_ = [\n    // Platonic Solids\n\n    [\"tetrahedron\", \"platonic\", 4,[3], 2*sqrt(2), sqrt(6)/12, sqrt(2)/4, sqrt(6)/4, 1/6/sqrt(2),\n            _point_ref([[1,1,1]], sign=\"even\")],\n    [\"cube\", \"platonic\", 6, [4], 2, 1/2, 1/sqrt(2), sqrt(3)/2, 1,\n            _point_ref([[1,1,1]])],\n    [\"octahedron\", \"platonic\", 8, [3], sqrt(2), sqrt(6)/6, 1/2, sqrt(2)/2, sqrt(2)/3,\n            _point_ref(_even_perms([1,0,0]))],\n    [\"dodecahedron\", \"platonic\", 12, [5], 2/PHI, sqrt(5/2+11*sqrt(5)/10)/2, (3+sqrt(5))/4, sqrt(3)*PHI/2, (15+7*sqrt(5))/4,\n            _point_ref(concat([[1,1,1]],_even_perms([0,PHI,1/PHI])))],\n    [\"icosahedron\", \"platonic\", 20, [3], 2, PHI*PHI/2/sqrt(3), cos(36), sin(72), 5*(3+sqrt(5))/12,\n            _point_ref(_even_perms([0,1,PHI]))],\n\n    // Archimedian Solids, listed in order by Wenniger number, W6-W18\n\n    [\"truncated tetrahedron\", \"archimedean\", 8,[6,3], sqrt(8), sqrt(6)/4, 3*sqrt(2)/4, sqrt(11/8), 23*sqrt(2)/12,\n            _point_ref(_all_perms([1,1,3]),sign=\"even\")],\n    [\"truncated octahedron\", \"archimedean\", 14, [6,4], sqrt(2), sqrt(6)/2, 1.5, sqrt(10)/2, 8*sqrt(2),\n            _point_ref(_all_perms([0,1,2]))],\n    [\"truncated cube\", \"archimedean\", 14, [8,3], 2*(sqrt(2)-1), (1+sqrt(2))/2, 1+sqrt(2)/2, sqrt(7+4*sqrt(2))/2, 7+14*sqrt(2)/3,\n            _point_ref(_all_perms([1,1,sqrt(2)-1]))],\n    [\"truncated icosahedron\", \"archimedean\", 32, [6, 5], 2, (3*sqrt(3)+sqrt(15))/4, 3*PHI/2, sqrt(58+18*sqrt(5))/4, (125+43*sqrt(5))/4,\n            _point_ref(concat(\n                _even_perms([0,1,3*PHI]),\n                _even_perms([1,2+PHI,2*PHI]),\n                _even_perms([PHI,2,PHI*PHI*PHI])\n            ))],\n    [\"truncated dodecahedron\", \"archimedean\", 32, [10, 3], 2*PHI-2, sqrt(7+11*PHI)/2, (3*PHI+1)/2,sqrt(11+PHI*15)/2, 5*(99+47*sqrt(5))/12,\n            _point_ref(concat(\n                _even_perms([0,1/PHI, 2+PHI]),\n                _even_perms([1/PHI,PHI,2*PHI]),\n                _even_perms([PHI,2,PHI+1])\n            ))],\n    [\"cuboctahedron\", \"archimedean\", 14, [4,3], sqrt(2), sqrt(2)/2, sqrt(3)/2, 1, 5*sqrt(2)/3,\n            _point_ref(_all_perms([1,1,0]))],\n    [\"icosidodecahedron\", \"archimedean\", 32, [5,3], 1, sqrt(5*(5+2*sqrt(5)))/5,sqrt(5+2*sqrt(5))/2, PHI, (14+17*PHI)/3,\n            _point_ref(concat(_even_perms([0,0,PHI]),_even_perms([1/2,PHI/2,PHI*PHI/2])))],\n    [\"rhombicuboctahedron\", \"archimedean\", 26, [4, 3], 2, (1+sqrt(2))/2, sqrt(2*(2+sqrt(2)))/2, sqrt(5+2*sqrt(2))/2, 4+10*sqrt(2)/3,\n            _point_ref(_even_perms([1,1,1+sqrt(2)]))],\n    [\"rhombicosidodecahedron\", \"archimedean\", 62, [5,4,3], 2, 3/10*sqrt(15+20*PHI), sqrt(3/2+2*PHI), sqrt(8*PHI+7)/2, (31+58*PHI)/3,\n            _point_ref(concat(\n                _even_perms([1,1,PHI*PHI*PHI]),\n                _even_perms([PHI*PHI,PHI,2*PHI]),\n                _even_perms([2+PHI,0,PHI*PHI])\n            ))],\n    [\"truncated cuboctahedron\", \"archimedean\", 26, [8, 6, 4], 2, (1+2*sqrt(2))/2, sqrt(6*(2+sqrt(2)))/2, sqrt(13+6*sqrt(2))/2, (22+14*sqrt(2)),\n            _point_ref(_all_perms([1,1+sqrt(2), 1+2*sqrt(2)]))],\n    [\"truncated icosidodecahedron\", \"archimedean\", 62, [10,6,4], 2*PHI - 2, sqrt(15/4+5*PHI),sqrt(9/2+6*PHI),sqrt(19/4+6*PHI), 95+50*sqrt(5),\n            _point_ref(concat(\n                _even_perms([1/PHI,1/PHI,3+PHI]),\n                _even_perms([2/PHI,PHI,1+2*PHI]),\n                _even_perms([1/PHI,PHI*PHI,3*PHI-1]),\n                _even_perms([2*PHI-1,2,2+PHI]),\n                _even_perms([PHI,3,2*PHI])\n            ))],\n    [\"snub cube\", \"archimedean\",    38, [4,3], 1.60972,1.14261350892596209,1.24722316799364325, 1.34371337374460170,\n            sqrt((613*_tribonacci+203)/(9*(35*_tribonacci-62))),\n            concat(\n                _point_ref(_even_perms([1,1/_tribonacci,_tribonacci]), sign=\"odd\"),\n                _point_ref(_even_perms([1,_tribonacci,1/_tribonacci]), sign=\"even\")\n            )],\n    [\"snub dodecahedron\", \"archimedean\", 92, [5, 3], 1, 1.98091594728184,2.097053835252087,2.155837375115, 37.61664996273336,\n            concat(\n                _point_ref(_even_perms([0.374821658114562,0.330921024729844,2.097053835252088]), sign=\"odd\"),\n                _point_ref(_even_perms([0.192893711352359,1.249503788463027,1.746186440985827]), sign=\"odd\"),\n                _point_ref(_even_perms([1.103156835071754,0.847550046789061,1.646917940690374]), sign=\"odd\"),\n                _point_ref(_even_perms([0.567715369466922,0.643029605914072,1.977838965420219]), sign=\"even\"),\n                _point_ref(_even_perms([1.415265416255982,0.728335176957192,1.454024229338015]), sign=\"even\")\n            )],\n\n    // Catalan Solids, the duals to the Archimedean solids, listed in the corresponding order\n\n    [\"triakis tetrahedron\",\"catalan\", 12, [3], 9/5, 5*sqrt(22)/44, 5*sqrt(2)/12, 5*sqrt(6)/12, 25*sqrt(2)/36,\n            concat(\n                _point_ref([9*sqrt(2)/20*[1,1,1]],sign=\"even\"),\n                _point_ref([3*sqrt(2)/4*[1,1,1]],sign=\"odd\")\n            )],\n    [\"tetrakis hexahedron\", \"catalan\", 24, [3], 1, 2/sqrt(5), 2*sqrt(2)/3, 2/sqrt(3), 32/9,\n            _point_ref(concat([[2/3,2/3,2/3]],_even_perms([1,0,0])))],\n    [\"triakis octahedron\", \"catalan\", 24, [3], 2, sqrt(17*(23+16*sqrt(2)))/34, 1/2+sqrt(2)/4,(1+sqrt(2))/2,3/2+sqrt(2),\n            _point_ref(concat([[1,1,1]],_even_perms([1+sqrt(2),0,0])))],\n    [\"pentakis dodecahedron\", \"catalan\", 60, [3], 1,sqrt(477/436+97*sqrt(5)/218), sqrt(5)/4+11/12, sqrt(7/4+sqrt(5)/3), 125*sqrt(5)/36+205/36,\n            _point_ref(concat(\n                _even_perms([0,(5-PHI)/6, PHI/2+2/3]),\n                _even_perms([0,(PHI+1)/2,PHI/2]),[(4*PHI-1)/6 * [1,1,1]]\n            ))],\n    [\"triakis icosahedron\", \"catalan\", 60, [3], 1, sqrt((139+199*PHI)/244), (8*PHI+1)/10, sqrt(13/8+19/8/sqrt(5)), (13*PHI+3)/2,\n            _point_ref(concat(\n                _even_perms([(PHI+7)/10, 0, (8*PHI+1)/10]),\n                _even_perms([0, 1/2, (PHI+1)/2]),[PHI/2*[1,1,1]]\n            ))],\n    [\"rhombic dodecahedron\", \"catalan\", 12, [4], sqrt(3), sqrt(2/3), 2*sqrt(2)/3, 2/sqrt(3), 16*sqrt(3)/9,\n            _point_ref(concat([[1,1,1]], _even_perms([2,0,0])))],\n    [\"rhombic triacontahedron\", \"catalan\", 30,[4], 1, sqrt(1+2/sqrt(5)), 1+1/sqrt(5), (1+sqrt(5))/2, 4*sqrt(5+2*sqrt(5)),\n            concat(\n                _point_ref(_even_perms([0,sqrt(1+2/sqrt(5)), sqrt((5+sqrt(5))/10)])),\n                _point_ref(_even_perms([0,sqrt(2/(5+sqrt(5))), sqrt(1+2/sqrt(5))])),\n                _point_ref([sqrt((5+sqrt(5))/10)*[1,1,1]])\n            )],\n    [\"deltoidal icositetrahedron\", \"catalan\", 24, [4], 2*sqrt(10-sqrt(2))/7, 7*sqrt((7+4*sqrt(2))/(34 * (10-sqrt(2)))),\n            7*sqrt(2*(2+sqrt(2)))/sqrt(10-sqrt(2))/4, 7*sqrt(2)/sqrt(10-sqrt(2))/2,\n            (14+21*sqrt(2))/sqrt(10-sqrt(2)),\n            _point_ref(concat(\n                _even_perms([0,1,1]), _even_perms([sqrt(2),0,0]),\n                _even_perms((4+sqrt(2))/7*[1,1,1])\n            ))],\n    [\"deltoidal hexecontahedron\", \"catalan\", 60, [4], sqrt(5*(85-31*sqrt(5)))/11, sqrt(571/164+1269/164/sqrt(5)), 5/4+13/4/sqrt(5),\n            sqrt(147+65*sqrt(5))/6, sqrt(29530+13204*sqrt(5))/3,\n            _point_ref(concat(\n                _even_perms([0,0,sqrt(5)]),\n                _even_perms([0,(15+sqrt(5))/22, (25+9*sqrt(5))/22]),\n                _even_perms([0,(5+3*sqrt(5))/6, (5+sqrt(5))/6]),\n                _even_perms([(5-sqrt(5))/4, sqrt(5)/2, (5+sqrt(5))/4]),\n                [(5+4*sqrt(5))/11*[1,1,1]]\n            ))],\n    [\"disdyakis dodecahedron\", \"catalan\", 48, [3], 1,sqrt(249/194+285/194/sqrt(2)) ,(2+3*sqrt(2))/4, sqrt(183/98+213/98/sqrt(2)),\n            sqrt(6582+4539*sqrt(2))/7,\n            _point_ref(concat(\n                _even_perms([sqrt(183/98+213/98/sqrt(2)),0,0]),\n                _even_perms(sqrt(3+3/sqrt(2))/2 * [1,1,0]),[7/sqrt(6*(10-sqrt(2)))*[1,1,1]]\n            ))],\n    [\"disdyakis triacontahedron\",\"catalan\", 120, [3], sqrt(15*(85-31*sqrt(5)))/11, sqrt(3477/964+7707/964/sqrt(5)), 5/4+13/4/sqrt(5),\n            sqrt(441+195*sqrt(5))/10,sqrt(17718/5+39612/5/sqrt(5)),\n            _point_ref(concat(\n                _even_perms([0,0,3*(5+4*sqrt(5))/11]),\n                _even_perms([0,(5-sqrt(5))/2,(5+sqrt(5))/2]),\n                _even_perms([0,(15+9*sqrt(5))/10,3*(5+sqrt(5))/10]),\n                _even_perms([3*(15+sqrt(5))/44,3*(5+4*sqrt(5))/22, (75+27*sqrt(5))/44]), [sqrt(5)*[1,1,1]]\n            ))],\n    [\"pentagonal icositetrahedron\",\"catalan\",24, [5], 0.593465355971, 1.950681331784, 2.1015938932963, 2.29400105368695, 35.6302020120713,\n            concat(\n                _point_ref(_even_perms([0.21879664300048044,0.740183741369857,1.0236561781126901]),sign=\"even\"),\n                _point_ref(_even_perms([0.21879664300048044,1.0236561781126901,0.740183741369857]),sign=\"odd\"),\n                _point_ref(_even_perms([1.3614101519264425,0,0])),\n                _point_ref([0.7401837413698572*[1,1,1]])\n            )],\n    [\"pentagonal hexecontahedron\", \"catalan\", 60,[5], 0.58289953474498, 3.499527848905764,3.597624822551189,3.80854772878239, 189.789852066885,\n            concat(\n                _point_ref(_even_perms([0.192893711352359,0.218483370127321,2.097053835252087]), sign=\"even\"),\n                _point_ref(_even_perms([0,0.7554672605165955,1.9778389654202186])),\n                _point_ref(_even_perms([0,1.888445389283669154,1.1671234364753339])),\n                _point_ref(_even_perms([0.56771536946692131,0.824957552676275846,1.8654013108176956657]),sign=\"odd\"),\n                _point_ref(_even_perms([0.37482165811456229,1.13706613386050418,1.746186440985826345]), sign=\"even\"),\n                _point_ref(_even_perms([0.921228888309550,0.95998770139158,1.6469179406903744]),sign=\"even\"),\n                _point_ref(_even_perms([0.7283351769571914773,1.2720962825758121,1.5277030708585051]),sign=\"odd\"),\n                _point_ref([1.222371704903623092*[1,1,1]])\n            )],\n];\n\n\n_stellated_polyhedra_ = [\n    [\"great dodecahedron\", \"icosahedron\", -sqrt(5/3-PHI)],\n    [\"small stellated dodecahedron\", \"dodecahedron\", sqrt((5+2*sqrt(5))/5)],\n    [\"great stellated dodecahedron\", \"icosahedron\", sqrt(2/3+PHI)],\n    [\"small triambic icosahedron\", \"icosahedron\", sqrt(3/5) - 1/sqrt(3)]\n];\n\n\n// Function: regular_polyhedron_info()\n// Synopsis: Returns info used to create a regular polyhedron.\n// Topics: Polyhedra, Shapes, Parts\n// See Also: regular_polyhedron()\n//\n// Usage:\n//   info = regular_polyhedron_info(info, ...);\n//\n// Description:\n//   Calculate characteristics of regular polyhedra or the selection set for regular_polyhedron().\n//   Invoke with the same polyhedron selection and size arguments used by {{regular_polyhedron()}} and use the `info` argument to\n//   request the desired return value. Set `info` to:\n//     * `\"vnf\"`: vnf for the selected polyhedron\n//     * `\"vertices\"`: vertex list for the selected polyhedron\n//     * `\"faces\"`: list of faces for the selected polyhedron, where each entry on the list is a list of point index values to be used with the vertex list\n//     * `\"face normals\"`: list of normal vectors for each face\n//     * `\"in_radius\"`: in-sphere radius for the selected polyhedron\n//     * `\"mid_radius\"`: mid-sphere radius for the selected polyhedron\n//     * `\"out_radius\"`: circumscribed sphere radius for the selected polyhedron\n//     * `\"index set\"`: index set selected by your specifications; use its length to determine the valid range for `index`.\n//     * `\"face vertices\"`: number of vertices on the faces of the selected polyhedron (always a list)\n//     * `\"edge length\"`: length of the smallest edge of the selected polyhedron\n//     * `\"center\"`: center for the polyhedron\n//     * `\"type\"`: polyhedron type, one of \"platonic\", \"archimedean\", \"catalan\", or \"trapezohedron\"\n//     * `\"name\"`: name of selected polyhedron\n//\n// Arguments:\n//   info = Desired information to return for the polyhedron\n//   name = Name of polyhedron to create.\n//   ---\n//   type = Type of polyhedron: \"platonic\", \"archimedean\", \"catalan\".\n//   faces = Number of faces.\n//   facetype = Scalar or vector listing required type of faces as vertex count.  Polyhedron must have faces of every type listed and no other types.\n//   hasfaces = Scalar of vector list face vertex counts.  Polyhedron must have at least one of the listed types of face.\n//   index = Index to select from polyhedron list.  Default: 0.\n//   side = Length of the smallest edge of the polyhedron.  Default: 1 (if no radius or diameter is given).\n//   or / r / d = outer radius.   Polyhedron is scaled so it has the specified outer radius or diameter. \n//   mr = middle radius.  Polyhedron is scaled so it has the specified middle radius.  \n//   ir = inner radius.  Polyhedron is scaled so it has the specified inner radius. \n//   anchor = Side of the origin to anchor to.  The bounding box of the polyhedron is aligned as specified.  Default: `CENTER`\n//   facedown = If false display the solid in native orientation.  If true orient it with a largest face down.  If set to a vertex count, orient it so a face with the specified number of vertices is down.  Default: true.\n//   stellate = Set to a number to erect a pyramid of that height on every face of your polyhedron.  The height is a multiple of the side length.  Default: false.\n//   longside = Specify the long side length for a trapezohedron.  Invalid for other shapes.\n//   h = Specify the height of the apex for a trapezohedron.  Invalid for other shapes.\nfunction regular_polyhedron_info(\n    info=undef, name=undef,\n    index=undef, type=undef,\n    faces=undef, facetype=undef,\n    hasfaces=undef, side=undef,\n    ir=undef, mr=undef, or=undef,\n    r=undef, d=undef,\n    anchor=CENTER,\n    facedown=true, stellate=false,\n    longside=undef, h=undef, height=undef  // special parameters for trapezohedron\n) = let(\n        argcount = num_defined([side,ir,mr,or,r,d])\n    )\n    assert(name==\"trapezohedron\" || argcount<=1, \"You must specify only one of 'side', 'ir', 'mr', 'or', 'r', and 'd'\")\n    assert(name!=\"trapezohedron\" || num_defined([ir,mr,or])==0, \"Trapezohedron does not accept 'ir', 'mr' or 'or'\")\n    let(  \n        //////////////////////\n        //Index values into the _polyhedra_ array\n        //\n        pname = 0,        // name of polyhedron\n        class = 1,        // class name (e.g. platonic, archimedean)\n        facecount = 2,    // number of faces\n        facevertices = 3, // vertices on the faces, e.g. [3] for all triangles, [3,4] for triangles and squares\n        edgelen = 4,      // length of the edge for the vertex list in the database\n        in_radius = 5,    // in radius for unit polyhedron (shortest side 1)\n        mid_radius = 6,   // mid radius for unit polyhedron\n        out_radius = 7,   // out radius for unit polyhedron\n        volume = 8,       // volume of unit polyhedron (data not validated, not used right now)\n        vertices = 9,     // vertex list (in arbitrary order)\n        //////////////////////\n        or = get_radius(r=r,r1=or,d=d),\n        stellate_index = search([name], _stellated_polyhedra_, 1, 0)[0],\n        name = stellate_index==[] ? name : _stellated_polyhedra_[stellate_index][1],\n        stellate = stellate_index==[] ? stellate : _stellated_polyhedra_[stellate_index][2],\n        indexlist = (\n            name==\"trapezohedron\" ? [0] : [  // dumy list of one item\n                for(i=[0:1:len(_polyhedra_)-1]) (\n                    if (\n                        (is_undef(name) || _polyhedra_[i][pname]==name) &&\n                        (is_undef(type) || _polyhedra_[i][class]==type) &&\n                        (is_undef(faces) || _polyhedra_[i][facecount]==faces) &&\n                        (\n                            is_undef(facetype) || 0==compare_lists(\n                                is_list(facetype)? reverse(sort(facetype)) : [facetype],\n                                _polyhedra_[i][facevertices]\n                            )\n                        ) &&\n                        (is_undef(hasfaces) || any([for (ft=hasfaces) in_list(ft,_polyhedra_[i][facevertices])]))\n                    ) i\n                )\n            ]\n        )\n    )\n    assert(len(indexlist)>0, \"No polyhedra meet your specification\")\n    let(validindex = is_undef(index) || (index>=0 && index<len(indexlist)))\n    assert(validindex, str(\n        len(indexlist),\n        \" polyhedra meet specifications, so 'index' must be in [0,\",\n        len(indexlist)-1,\n        \"], but 'index' is \",\n        index\n    ))\n    let(\n        entry = (\n            name == \"trapezohedron\"? (\n                _trapezohedron(faces=faces, side=side, longside=longside, h=h, r=r, d=d, height=height)\n            ) : (\n                _polyhedra_[!is_undef(index)?\n                    indexlist[index] :\n                    indexlist[0]]\n            )\n        ),\n        valid_facedown = is_bool(facedown) || in_list(facedown, entry[facevertices])\n    )\n    assert(name == \"trapezohedron\" || num_defined([longside,h,height])==0, \"The 'longside', 'h' and 'height' parameters are only allowed with trapezohedrons\")\n    assert(valid_facedown,str(\"'facedown' set to \",facedown,\" but selected polygon only has faces with size(s) \",entry[facevertices]))\n    let(\n        scalefactor = (\n            name==\"trapezohedron\" ? 1 : (\n                argcount == 0? 1     // Default side=1 if no size info given\n              : is_def(side) ? side  \n              : is_def(ir) ? ir/entry[in_radius] \n              : is_def(mr) ? mr/entry[mid_radius] \n              :              or/entry[out_radius]\n            ) / entry[edgelen]\n        ),\n        face_triangles = hull(entry[vertices]),\n        faces_normals_vertices = _stellate_faces(\n            entry[edgelen], stellate, entry[vertices],\n            entry[facevertices]==[3]?\n                [face_triangles, [for(face=face_triangles) _facenormal(entry[vertices],face)]] :\n                _full_faces(entry[vertices], face_triangles)\n        ),\n        faces = faces_normals_vertices[0],\n        faces_vertex_count = [for(face=faces) len(face)],\n        facedown = facedown == true ? (stellate==false? entry[facevertices][0] : 3) : facedown,\n        down_direction = facedown == false?  [0,0,-1] :\n            faces_normals_vertices[1][search(facedown, faces_vertex_count)[0]],\n        scaled_points = scalefactor * rot(p=faces_normals_vertices[2], from=down_direction, to=[0,0,-1]),\n        bounds = pointlist_bounds(scaled_points),\n        boundtable = [bounds[0], [0,0,0], bounds[1]],\n        translation = [for(i=[0:2]) -boundtable[1+anchor[i]][i]],\n        face_normals = rot(p=faces_normals_vertices[1], from=down_direction, to=[0,0,-1]),\n        radius_scale = name==\"trapezohedron\" ? 1 : scalefactor * entry[edgelen]\n    )\n    info == \"fullentry\" ? [\n        scaled_points,\n        translation,\n        stellate ? faces : face_triangles,\n        faces,\n        face_normals,\n        radius_scale*entry[in_radius]\n    ] :\n    info == \"vnf\" ? [move(translation,p=scaled_points), faces] :\n    info == \"vertices\" ? move(translation,p=scaled_points) :\n    info == \"faces\" ? faces :\n    info == \"face normals\" ? face_normals :\n    info == \"in_radius\" ? radius_scale * entry[in_radius] :\n    info == \"mid_radius\" ? radius_scale * entry[mid_radius] :\n    info == \"out_radius\" ? radius_scale * entry[out_radius] :\n    info == \"index set\" ? indexlist :\n    info == \"face vertices\" ? (stellate==false? entry[facevertices] : [3]) :\n    info == \"edge length\" ? scalefactor * entry[edgelen] :\n    info == \"center\" ? translation :\n    info == \"type\" ? entry[class] :\n    info == \"name\" ? entry[pname] :\n    assert(false, str(\"Unknown info type '\",info,\"' requested\"));\n\n\nfunction _stellate_faces(scalefactor,stellate,vertices,faces_normals) =\n    (stellate == false || stellate == 0)? concat(faces_normals,[vertices]) :\n    let(\n        faces = [for(face=faces_normals[0]) select(face,hull(select(vertices,face)))],\n        direction = [for(i=[0:1:len(faces)-1]) _facenormal(vertices, faces[i])*faces_normals[1][i]>0 ? 1 : -1],\n        maxvertex = len(vertices),\n        newpts = [for(i=[0:1:len(faces)-1]) mean(select(vertices,faces[i]))+stellate*scalefactor*faces_normals[1][i]],\n        newfaces = [for(i=[0:1:len(faces)-1], j=[0:len(faces[i])-1]) concat([i+maxvertex],select(faces[i], [j, j+direction[i]]))],\n        allpts = concat(vertices, newpts),\n        normals = [for(face=newfaces) _facenormal(allpts,face)]\n    ) [newfaces, normals, allpts];\n\n\nfunction _trapezohedron(faces, r, side, longside, h, height, d) =\n    assert(faces%2==0, \"Must set 'faces' to an even number for trapezohedron\")\n    assert(is_undef(h) || is_undef(height), \"Cannot define both 'h' and 'height'\")\n    let(\n        r = get_radius(r=r, d=d),\n        h = first_defined([h,height]),\n        N = faces/2,\n        parmcount = num_defined([r,side,longside,h])\n    )\n    assert(parmcount==2,\"Must define exactly two of 'r' (or 'd'), 'side', 'longside', and 'h' (or 'height')\")\n    let(       \n        separation = (     // z distance between non-apex vertices that aren't in the same plane\n            !is_undef(h) ? 2*h*sqr(tan(90/N)) :\n            (!is_undef(r) && !is_undef(side))? sqrt(side*side+2*r*r*(cos(180/N)-1)) :\n            (!is_undef(r) && !is_undef(longside))? 2 * sqrt(sqr(longside)-sqr(r)) / (1-sqr(tan(90/N))) * sqr(tan(90/N)) :\n            2*sqr(sin(90/N))*sqrt((sqr(side) + 2*sqr(longside)*(cos(180/N)-1)) / (cos(180/N)-1) / (cos(180/N)+cos(360/N)))\n        )\n    )\n    assert(separation==separation, \"Impossible trapezohedron specification\")\n    let(\n        h = !is_undef(h) ? h : 0.5*separation / sqr(tan(90/N)),\n        r = (\n            !is_undef(r) ? r :\n            !is_undef(side) ? sqrt((sqr(separation) - sqr(side))/2/(cos(180/N)-1)) :\n            sqrt(sqr(longside) - sqr(h-separation/2))\n        ),\n        top = [for(i=[0:1:N-1]) [r*cos(360/N*i), r*sin(360/N*i),separation/2]],\n        bot = [for(i=[0:1:N-1]) [r*cos(180/N+360/N*i), r*sin(180/N+360/N*i),-separation/2]],\n        vertices = concat([[0,0,h],[0,0,-h]],top,bot)\n    ) [  \n        \"trapezohedron\", \"trapezohedron\", faces, [4],\n        !is_undef(side)? side : sqrt(sqr(separation)-2*r*(cos(180/N)-1)),  // actual side length\n        h*r/sqrt(r*r+sqr(h+separation/2)),     // in_radius\n        h*r/sqrt(r*r+sqr(h-separation/2)),     // mid_radius\n        max(h,sqrt(r*r+sqr(separation/2))),  // out_radius\n        undef,                               // volume\n        vertices\n    ];\n\n\nfunction _facenormal(pts, face) = unit(cross(pts[face[2]]-pts[face[0]], pts[face[1]]-pts[face[0]]));\n\n// hull() function returns triangulated faces.    This function identifies the vertices that belong to each face\n// by grouping together the face triangles that share normal vectors.    The output gives the face polygon\n// point indices in arbitrary order (not usable as input to a polygon call) and a normal vector.  Finally\n// the faces are ordered based on angle with their center (will always give a valid order for convex polygons).\n// Final return is [ordered_faces, facenormals] where the first is a list of indices into the point list\n// and the second is a list of vectors.  \n\nfunction _full_faces(pts,faces) =\n    let(\n        normals = [for(face=faces) quant(_facenormal(pts,face),1e-12)],\n        groups = _unique_groups(normals),\n        faces = [for(entry=groups) unique(flatten(select(faces, entry)))],\n        facenormals = [for(entry=groups) normals[entry[0]]],\n        ordered_faces = [\n            for(i=idx(faces))\n              let(\n                  facepts = select(pts, faces[i]),\n                  center = mean(facepts),\n                  rotatedface = rot(from=facenormals[i], to=[0,0,1], p=move(-center, p=facepts)),\n                  clockwise = sortidx([for(pt=rotatedface) -atan2(pt.y,pt.x)])\n              )\n            select(faces[i],clockwise)\n        ]\n    ) [ordered_faces, facenormals];\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-32", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: regions.scad\n//   This file provides 2D Boolean set operations on polygons, where you can\n//   compute, for example, the intersection or union of the shape defined by point lists, producing\n//   a new point list.  Of course, such operations may produce shapes with multiple\n//   components.  To handle that, we use \"regions\" which are lists of paths representing the polygons.\n//   In addition to set operations, you can calculate offsets, determine whether a point is in a\n//   region and you can decompose a region into parts.  \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Advanced Modeling\n// FileSummary: Offsets and Boolean geometry of 2D paths and regions.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// CommonCode:\n//   include <BOSL2/rounding.scad>\n\n\n// Section: Regions\n//   A region is a list of polygons meeting these conditions:\n//   .\n//   - Every polygon on the list is simple, meaning it does not intersect itself\n//   - Two polygons on the list do not cross each other\n//   - A vertex of one polygon never meets the edge of another one except at a vertex\n//   .\n//   Note that this means vertex-vertex touching between two polygons is acceptable\n//   to define a region.  Note, however, that regions with vertex-vertex contact usually\n//   cannot be rendered with CGAL.  See {{is_valid_region()}} for examples of valid regions and\n//   lists of polygons that are not regions.  Note that {{is_region_simple()}} will identify\n//   regions with no polygon intersections at all, which should render successfully witih CGAL.  \n//   .\n//   The actual geometry of the region is defined by XORing together\n//   all of the polygons in the list.  This may sound obscure, but it simply means that nested\n//   boundaries make rings in the obvious fashion, and non-nested shapes simply union together.\n//   Checking that a list of polygons is a valid region, meaning that it satisfies all of the conditions\n//   above, can be a time consuming test, so it is not done automatically.  It is your responsibility to ensure that your regions are\n//   compliant.  You can construct regions by making a suitable list of polygons, or by using\n//   set operation function such as union() or difference(), which all acccept polygons, as\n//   well as regions, as their inputs.  And if you must you can clean up an ill-formed region using make_region(),\n//   which will break up self-intersecting polygons and polygons that cross each other.  \n\n\n// Function: is_region()\n// Synopsis: Returns true if the input appears to be a region.\n// Topics: Regions, Paths, Polygons, List Handling\n// See Also: is_valid_region(), is_1region(), is_region_simple()\n// Usage:\n//   bool = is_region(x);\n// Description:\n//   Returns true if the given item looks like a region.  A region is a list of non-crossing simple polygons.  This test just checks\n//   that the argument is a list whose first entry is a path.  \nfunction is_region(x) = is_list(x) && is_path(x.x);\n\n\n// Function: is_valid_region()\n// Synopsis: Returns true if the input is a valid region.\n// Topics: Regions, Paths, Polygons, List Handling\n// See Also: is_region(), is_1region(), is_region_simple()\n// Usage:\n//   bool = is_valid_region(region, [eps]);\n// Description:\n//   Returns true if the input is a valid region, meaning that it is a list of simple polygons whose segments do not cross each other.\n//   This test can be time consuming with regions that contain many points.\n//   It differs from `is_region()` which simply checks that the object is a list whose first entry is a path\n//   because it searches all the list polygons for any self-intersections or intersections with each other.  \n//   Will also return true if given a single simple polygon.  Use {{make_region()}} to convert sets of self-intersecting polygons into\n//   a region.  \n// Arguments:\n//   region = region to check\n//   eps = tolerance for geometric comparisons.  Default: `EPSILON` = 1e-9\n// Example(2D,NoAxes):  In all of the examples each polygon in the region appears in a different color.  Two non-intersecting squares make a valid region.\n//   region = [square(10), right(11,square(8))];\n//   rainbow(region)stroke($item, width=.2,closed=true);\n//   back(11)text(is_valid_region(region) ? \"region\" : \"non-region\", size=2);\n// Example(2D,NoAxes):  Nested squares form a region\n//   region = [for(i=[3:2:10]) square(i,center=true)];\n//   rainbow(region)stroke($item, width=.2,closed=true);\n//   back(6)text(is_valid_region(region) ? \"region\" : \"non-region\", size=2,halign=\"center\");\n// Example(2D,NoAxes):  Also a region:\n//   region= [square(10,center=true), square(5,center=true), right(10,square(7))];\n//   rainbow(region)stroke($item, width=.2,closed=true);\n//   back(8)text(is_valid_region(region) ? \"region\" : \"non-region\", size=2);\n// Example(2D,NoAxes):  The squares cross each other, so not a region\n//   object = [square(10), move([8,8], square(8))];\n//   rainbow(object)stroke($item, width=.2,closed=true);\n//   back(17)text(is_valid_region(object) ? \"region\" : \"non-region\", size=2);\n// Example(2D,NoAxes): A union is one way to fix the above example and get a region.  (Note that union is run here on two simple polygons, which are valid regions themselves and hence acceptable inputs to union.\n//   region = union([square(10), move([8,8], square(8))]);\n//   rainbow(region)stroke($item, width=.25,closed=true);\n//   back(12)text(is_valid_region(region) ? \"region\" : \"non-region\", size=2);\n// Example(2D,NoAxes):  Not a region due to a self-intersecting (non-simple) hourglass polygon\n//   object = [move([-2,-2],square(14)), [[0,0],[10,0],[0,10],[10,10]]];\n//   rainbow(object)stroke($item, width=.2,closed=true);\n//   move([-1.5,13])text(is_valid_region(object) ? \"region\" : \"non-region\", size=2);\n// Example(2D,NoAxes):  Breaking hourglass in half fixes it.  Now it's a region:\n//   region = [move([-2,-2],square(14)), [[0,0],[10,0],[5,5]], [[5,5],[0,10],[10,10]]];\n//   rainbow(region)stroke($item, width=.2,closed=true);\n// Example(2D,NoAxes):  A single polygon corner touches an edge, so not a region:\n//   object = [[[-10,0], [-10,10], [20,10], [20,-20], [-10,-20],\n//              [-10,-10], [0,0], [10,-10], [10,0]]];\n//   rainbow(object)stroke($item, width=.3,closed=true);\n//   move([-4,12])text(is_valid_region(object) ? \"region\" : \"non-region\", size=3);\n// Example(2D,NoAxes):  Corners touch in the same polygon, so the polygon is not simple and the object is not a region.\n//   object = [[[0,0],[10,0],[10,10],[-10,10],[-10,0],[0,0],[-5,5],[5,5]]];\n//   rainbow(object)stroke($item, width=.3,closed=true);\n//   move([-10,12])text(is_valid_region(object) ? \"region\" : \"non-region\", size=3);\n// Example(2D,NoAxes):  The shape above as a valid region with two polygons:\n//   region = [  [[0,0],[10,0],[10,10],[-10,10],[-10,0]],\n//               [[0,0],[5,5],[-5,5]]  ];\n//   rainbow(region)stroke($item, width=.3,closed=true);\n//   move([-5.5,12])text(is_valid_region(region) ? \"region\" : \"non-region\", size=3);\n// Example(2D,NoAxes):  As with the \"broken\" hourglass, Touching at corners is OK.  This is a region.\n//   region = [square(10), move([10,10], square(8))];\n//   rainbow(region)stroke($item, width=.25,closed=true);\n//   back(12)text(is_valid_region(region) ? \"region\" : \"non-region\", size=2);\n// Example(2D,NoAxes): These two squares share part of an edge, hence not a region\n//   object = [square(10), move([10,2], square(7))];\n//   stroke(object[0], width=0.2,closed=true);\n//   color(\"red\")dashed_stroke(object[1], width=0.25,closed=true);\n//   back(12)text(is_valid_region(object) ? \"region\" : \"non-region\", size=2);\n// Example(2D,NoAxes): These two squares share a full edge, hence not a region\n//   object = [square(10), right(10, square(10))];\n//   stroke(object[0], width=0.2,closed=true);\n//   color(\"red\")dashed_stroke(object[1], width=0.25,closed=true);\n//   back(12)text(is_valid_region(object) ? \"region\" : \"non-region\", size=2);\n// Example(2D,NoAxes): Sharing on edge on the inside, also not a regionn\n//   object = [square(10), [[0,0], [2,2],[2,8],[0,10]]];\n//   stroke(object[0], width=0.2,closed=true);\n//   color(\"red\")dashed_stroke(object[1], width=0.25,closed=true);\n//   back(12)text(is_valid_region(object) ? \"region\" : \"non-region\", size=2);\n// Example(2D,NoAxes): Crossing at vertices is also bad\n//   object = [square(10), [[10,0],[0,10],[8,13],[13,8]]];\n//   rainbow(object)stroke($item, width=.2,closed=true);\n//   back(14)text(is_valid_region(object) ? \"region\" : \"non-region\", size=2);\n// Example(2D,NoAxes): One polygon touches another in the middle of an edge\n//   object = [square(10), [[10,5],[15,0],[15,10]]];\n//   rainbow(object)stroke($item, width=.2,closed=true);\n//   back(11)text(is_valid_region(object) ? \"region\" : \"non-region\", size=2);\n// Example(2D,NoAxes): The polygon touches the side, but the side has a vertex at the contact point so this is a region\n//   poly1 = [ each square(30,center=true), [15,0]];\n//   poly2 = right(10,circle(5,$fn=4));\n//   poly3 = left(0,circle(5,$fn=4));\n//   poly4 = move([0,-8],square([10,3]));\n//   region = [poly1,poly2,poly3,poly4];\n//   rainbow(region)stroke($item, width=.25,closed=true);\n//   move([-5,16.5])text(is_valid_region(region) ? \"region\" : \"non-region\", size=3);\n//   color(\"black\")move_copies(region[0]) circle(r=.4);\n// Example(2D,NoAxes): The polygon touches the side, but not at a vertex so this is not a region\n//   poly1 = fwd(4,[ each square(30,center=true), [15,0]]);\n//   poly2 = right(10,circle(5,$fn=4));\n//   poly3 = left(0,circle(5,$fn=4));\n//   poly4 = move([0,-8],square([10,3]));\n//   object = [poly1,poly2,poly3,poly4];\n//   rainbow(object)stroke($item, width=.25,closed=true);\n//   move([-9,12.5])text(is_valid_region(object) ? \"region\" : \"non-region\", size=3);\n//   color(\"black\")move_copies(object[0]) circle(r=.4);\n// Example(2D,NoAxes): The inner polygon touches the middle of the edges, so not a region\n//   poly1 = square(20,center=true);\n//   poly2 = circle(10,$fn=8);\n//   object=[poly1,poly2];\n//   rainbow(object)stroke($item, width=.25,closed=true);\n//   move([-10,11.4])text(is_valid_region(object) ? \"region\" : \"non-region\", size=3);\n// Example(2D,NoAxes): The above shape made into a region using {{difference()}} now has four components that touch at corners\n//   poly1 = square(20,center=true);\n//   poly2 = circle(10,$fn=8);\n//   region = difference(poly1,poly2);\n//   rainbow(region)stroke($item, width=.25,closed=true);\n//   move([-5,11.4])text(is_valid_region(region) ? \"region\" : \"non-region\", size=3);\nfunction is_valid_region(region, eps=EPSILON) =\n   let(region=force_region(region))\n   assert(is_region(region), \"Input is not a region\")\n   // no short paths\n   [for(p=region) if (len(p)<3) 1] == []\n   &&\n   // all paths are simple\n   [for(p=region) if (!is_path_simple(p,closed=true,eps=eps)) 1] == []\n   &&\n   // paths do not cross each other\n   [for(i=[0:1:len(region)-2])\n            if (_polygon_crosses_region(list_tail(region,i+1),region[i], eps=eps)) 1] == []\n   &&\n   // one path doesn't touch another in the middle of an edge\n   [for(i=idx(region), j=idx(region))\n       if (i!=j) for(v=region[i], edge=pair(region[j],wrap=true))\n           let(\n               v1 = edge[1]-edge[0],\n               v0 = v - edge[0],\n               t = v0*v1/(v1*v1)\n           )\n           if (abs(cross(v0,v1))<eps*norm(v1) && t>eps && t<1-eps) 1\n   ]==[];\n\n\n\n// internal function:\n// returns true if the polygon crosses the region so that part of the \n// polygon is inside the region and part is outside.  \nfunction _polygon_crosses_region(region, poly, eps=EPSILON) =\n    let(  \n        subpaths = flatten(split_region_at_region_crossings(region,[poly],eps=eps)[1])\n    )\n    [for(path=subpaths)\n      let(isect=\n         [for (subpath = subpaths)\n          let(\n                midpt = mean([subpath[0], subpath[1]]),\n                rel = point_in_region(midpt,region,eps=eps)\n          )\n          rel\n         ])\n       if (!all_equal(isect) || isect[0]==0) 1 ] != [];\n\n\n// Function: is_region_simple()\n// Synopsis: Returns true if the input is a region with no corner contact.\n// Topics: Regions, Paths, Polygons, List Handling\n// See Also: is_region(), is_valid_region(), is_1region()\n// Usage:\n//   bool = is_region_simple(region, [eps]);\n// Description:\n//   We extend the notion of the simple path to regions: a simple region is entirely\n//   non-self-intersecting, meaning that it is formed from a list of simple polygons that\n//   don't intersect each other at all&mdash;not even with corner contact points.\n//   Regions with corner contact are valid but may fail CGAL.  Simple regions\n//   should not create problems with CGAL.  \n// Arguments:\n//   region = region to check\n//   eps = tolerance for geometric comparisons.  Default: `EPSILON` = 1e-9\n// Example(2D,NoAxes):  Corner contact means it's not simple\n//   region = [move([-2,-2],square(14)), [[0,0],[10,0],[5,5]], [[5,5],[0,10],[10,10]]];\n//   rainbow(region)stroke($item, width=.2,closed=true);\n//   move([-1,13])text(is_region_simple(region) ? \"simple\" : \"not-simple\", size=2);\n// Example(2D,NoAxes):  Moving apart the triangles makes it simple:\n//   region = [move([-2,-2],square(14)), [[0,0],[10,0],[5,4.5]], [[5,5.5],[0,10],[10,10]]];\n//   rainbow(region)stroke($item, width=.2,closed=true);\n//   move([1,13])text(is_region_simple(region) ? \"simple\" : \"not-simple\", size=2);\nfunction is_region_simple(region, eps=EPSILON) =\n   let(region=force_region(region))\n   assert(is_region(region), \"Input is not a region\")\n   [for(p=region) if (!is_path_simple(p,closed=true,eps=eps)) 1] == []\n   &&\n   [for(i=[0:1:len(region)-2])\n       if (_region_region_intersections([region[i]], list_tail(region,i+1), eps=eps)[0][0] != []) 1\n   ] ==[];\n  \n  \n// Function: make_region()\n// Synopsis: Converts lists of intersecting polygons into valid regions.\n// SynTags: Region\n// Topics: Regions, Paths, Polygons, List Handling\n// See Also: force_region(), region()\n// \n// Usage:\n//   region = make_region(polys, [nonzero], [eps]);\n// Description:\n//   Takes a list of polygons that may intersect themselves or cross each other \n//   and converts it into a properly defined region without these defects.\n// Arguments:\n//   polys = list of polygons to use\n//   nonzero = set to true to use nonzero rule for polygon membership.  Default: false\n//   eps = Epsilon for geometric comparisons.  Default: `EPSILON` (1e-9)\n// Example(2D,NoAxes):  The pentagram is self-intersecting, so it is not a region.  Here it becomes five triangles:\n//   pentagram = turtle([\"move\",100,\"left\",144], repeat=4);\n//   region = make_region(pentagram);\n//   rainbow(region)stroke($item, width=1,closed=true);\n// Example(2D,NoAxes):  Alternatively with the nonzero option you can get the perimeter:\n//   pentagram = turtle([\"move\",100,\"left\",144], repeat=4);\n//   region = make_region(pentagram,nonzero=true);\n//   rainbow(region)stroke($item, width=1,closed=true);\n// Example(2D,NoAxes):  Two crossing squares become two L-shaped components\n//   region = make_region([square(10), move([5,5],square(8))]);\n//   rainbow(region)stroke($item, width=.3,closed=true);\n\nfunction make_region(polys,nonzero=false,eps=EPSILON) =\n     let(polys=force_region(polys))\n     assert(is_region(polys), \"Input is not a region\")\n     exclusive_or(\n                  [for(poly=polys) each polygon_parts(poly,nonzero,eps)],\n                  eps=eps);\n\n// Function: force_region()\n// Synopsis: Given a polygon returns a region.\n// SynTags: Region\n// Topics: Regions, Paths, Polygons, List Handling\n// See Also: make_region(), region()\n// Usage:\n//   region = force_region(poly)\n// Description:\n//   If the input is a polygon then return it as a region.  Otherwise return it unaltered.\n// Arguments:\n//   poly = polygon to turn into a region\nfunction force_region(poly) = is_path(poly) ? [poly] : poly;\n\n\n// Section: Turning a region into geometry\n\n// Module: region()\n// Synopsis: Creates the 2D polygons described by the given region or list of polygons.\n// SynTags: Geom\n// Topics: Regions, Paths, Polygons, List Handling\n// See Also: make_region(), region()\n// Usage:\n//   region(r, [anchor], [spin=], [cp=], [atype=]) [ATTACHMENTS];\n// Description:\n//   Creates the 2D polygons described by the given region or list of polygons.  This module works on\n//   arbitrary lists of polygons that cross each other and hence do not define a valid region.  The\n//   displayed result is the exclusive-or of the polygons listed in the input. \n// Arguments:\n//   r = region to create as geometry\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `\"origin\"`\n//   ---\n//   spin = Rotate this many degrees after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   cp = Centerpoint for determining intersection anchors or centering the shape.  Determintes the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 2D point.  Default: \"centroid\"\n//   atype = Set to \"hull\" or \"intersect\" to select anchor type.  Default: \"hull\"\n// Example(2D): Displaying a region\n//   region([circle(d=50), square(25,center=true)]);\n// Example(2D): Displaying a list of polygons that intersect each other, which is not a region\n//   rgn = concat(\n//       [for (d=[50:-10:10]) circle(d=d-5)],\n//       [square([60,10], center=true)]\n//   );\n//   region(rgn);\nmodule region(r, anchor=\"origin\", spin=0, cp=\"centroid\", atype=\"hull\")\n{\n    assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\");\n    r = force_region(r);\n    dummy=assert(is_region(r), \"Input is not a region\");\n    points = flatten(r);\n    lengths = [for(path=r) len(path)];\n    starts = [0,each cumsum(lengths)];\n    paths = [for(i=idx(r)) count(s=starts[i], n=lengths[i])];\n    attachable(anchor, spin, two_d=true, region=r, extent=atype==\"hull\", cp=cp){\n      polygon(points=points, paths=paths);\n      children();\n    }\n}\n\n\n\n// Section: Geometrical calculations with regions\n\n// Function: point_in_region()\n// Synopsis: Tests if a point is inside, outside, or on the border of a region. \n// Topics: Regions, Points, Comparison\n// See Also: region_area(), are_regions_equal()\n// Usage:\n//   check = point_in_region(point, region, [eps]);\n// Description:\n//   Tests if a point is inside, outside, or on the border of a region.  \n//   Returns -1 if the point is outside the region.\n//   Returns 0 if the point is on the boundary.\n//   Returns 1 if the point lies inside the region.\n// Arguments:\n//   point = The point to test.\n//   region = The region to test against, as a list of polygon paths.\n//   eps = Acceptable variance.  Default: `EPSILON` (1e-9)\n// Example(2D,Med):  Red points are in the region.\n//   region = [for(i=[2:4:10]) hexagon(r=i)];\n//   color(\"#ff7\") region(region);\n//   for(x=[-10:10], y=[-10:10])\n//     if (point_in_region([x,y], region)>=0)\n//       move([x,y]) color(\"red\") circle(0.15, $fn=12);\n//     else\n//       move([x,y]) color(\"#ddf\") circle(0.1, $fn=12);\nfunction point_in_region(point, region, eps=EPSILON) =\n    let(region=force_region(region))\n    assert(is_region(region), \"Region given to point_in_region is not a region\")\n    assert(is_vector(point,2), \"Point must be a 2D point in point_in_region\")\n    _point_in_region(point, region, eps);\n\nfunction _point_in_region(point, region, eps=EPSILON, i=0, cnt=0) =\n      i >= len(region) ? ((cnt%2==1)? 1 : -1)\n    : let(\n          pip = point_in_polygon(point, region[i], eps=eps)\n      )\n      pip == 0 ? 0\n   : _point_in_region(point, region, eps=eps, i=i+1, cnt = cnt + (pip>0? 1 : 0));\n\n\n// Function: region_area()\n// Synopsis: Computes the area of the specified valid region.\n// Topics: Regions, Area\n// Usage:\n//   area = region_area(region);\n// Description:\n//   Computes the area of the specified valid region. (If the region is invalid and has self intersections\n//   the result is meaningless.)\n// Arguments:\n//   region = region whose area to compute\n// Examples:\n//   area = region_area([square(10), right(20,square(8))]);  // Returns 164\nfunction region_area(region) =\n  assert(is_region(region), \"Input must be a region\")\n  let(\n      parts = region_parts(region)\n  )\n  -sum([for(R=parts, poly=R) polygon_area(poly,signed=true)]);\n\n\n\nfunction _clockwise_region(r) = [for(p=r) clockwise_polygon(p)];\n\n// Function: are_regions_equal()\n// Synopsis: Returns true if given regions are the same polygons.\n// Topics: Regions, Polygons, Comparison\n// Usage:\n//    b = are_regions_equal(region1, region2, [either_winding])\n// Description:\n//    Returns true if the components of region1 and region2 are the same polygons (in any order). \n// Arguments:\n//    region1 = first region\n//    region2 = second region\n//    either_winding = if true then two shapes test equal if they wind in opposite directions.  Default: false\nfunction are_regions_equal(region1, region2, either_winding=false) =\n    let(\n        region1=force_region(region1),\n        region2=force_region(region2)\n    )\n    assert(is_region(region1) && is_region(region2), \"One of the inputs is not a region\")\n    len(region1) != len(region2)? false :\n    __are_regions_equal(either_winding?_clockwise_region(region1):region1,\n                        either_winding?_clockwise_region(region2):region2,\n                        0);\n\nfunction __are_regions_equal(region1, region2, i) =\n    i >= len(region1)? true :\n    !_is_polygon_in_list(region1[i], region2)? false :\n    __are_regions_equal(region1, region2, i+1);\n\n\n/// Internal Function: _region_region_intersections()\n/// Usage:\n///    risect = _region_region_intersections(region1, region2, [closed1], [closed2], [eps]\n/// Description:\n///    Returns a pair of sorted lists such that risect[0] is a list of intersection\n///    points for every path in region1, and similarly risect[1] is a list of intersection\n///    points for the paths in region2.  For each path the intersection list is\n///    a sorted list of the form [PATHIND, SEGMENT, U].  You can specify that the paths in either\n///    region be regarded as open paths if desired.  Default is to treat them as\n///    regions and hence the paths as closed polygons.\n///    .\n///    Included as intersection points are points where region1 touches itself at a vertex or\n///    region2 touches itself at a vertex.  (The paths are assumed to have no self crossings.\n///    Self crossings of the paths in the regions are not returned.)\nfunction _region_region_intersections(region1, region2, closed1=true,closed2=true, eps=EPSILON) =\n   let(\n       intersections =   [\n           for(p1=idx(region1))\n              let(\n                  path = closed1?list_wrap(region1[p1]):region1[p1]\n              )\n              for(i = [0:1:len(path)-2])\n                  let(\n                      a1 = path[i],\n                      a2 = path[i+1],\n                      nrm = norm(a1-a2)\n                  )\n                  if( nrm>eps )  // ignore zero-length path edges\n                       let( \n                           seg_normal = [-(a2-a1).y, (a2-a1).x]/nrm,\n                           ref = a1*seg_normal\n                       )\n                           // `signs[j]` is the sign of the signed distance from\n                           // poly vertex j to the line [a1,a2] where near zero\n                           // distances are snapped to zero;  poly edges \n                           //  with equal signs at its vertices cannot intersect\n                           // the path edge [a1,a2] or they are collinear and \n                           // further tests can be discarded.\n                       for(p2=idx(region2))\n                           let(\n                               poly  = closed2?list_wrap(region2[p2]):region2[p2],\n                               signs = [for(v=poly*seg_normal) abs(v-ref) < eps ? 0 : sign(v-ref) ]\n                           ) \n                           if(max(signs)>=0 && min(signs)<=0) // some edge intersects line [a1,a2]\n                               for(j=[0:1:len(poly)-2]) \n                                   if(signs[j]!=signs[j+1])\n                                        let( // exclude non-crossing and collinear segments\n                                            b1 = poly[j],\n                                            b2 = poly[j+1],\n                                            isect = _general_line_intersection([a1,a2],[b1,b2],eps=eps) \n                                        )\n                                        if (isect \n                                            && isect[1]>= -eps \n                                            && isect[1]<= 1+eps \n                                            && isect[2]>= -eps\n                                            && isect[2]<= 1+eps)       \n                                         [[p1,i,isect[1]], [p2,j,isect[2]]]\n         ],\n         regions=[region1,region2],\n         // Create a flattened index list corresponding to the points in region1 and region2\n         // that gives each point as an intersection point\n         ptind = [for(i=[0:1])   \n                    [for(p=idx(regions[i]))\n                       for(j=idx(regions[i][p])) [p,j,0]]],\n         points = [for(i=[0:1]) flatten(regions[i])],\n         // Corner points are those points where the region touches itself, hence duplicate\n         // points in the region's point set\n         cornerpts = [for(i=[0:1])\n                         [for(k=vector_search(points[i],eps,points[i]))\n                             each if (len(k)>1) select(ptind[i],k)]],\n         risect = [for(i=[0:1]) concat(column(intersections,i), cornerpts[i])],\n         counts = [count(len(region1)), count(len(region2))],\n         pathind = [for(i=[0:1]) search(counts[i], risect[i], 0)]\n       )\n       [for(i=[0:1]) [for(j=counts[i]) _sort_vectors(select(risect[i],pathind[i][j]))]];\n         \n\n// Section: Breaking up regions into subregions\n\n\n// Function: split_region_at_region_crossings()\n// Synopsis: Splits regions where polygons touch and at intersections.\n// Topics: Regions, Polygons, List Handling\n// See Also: region_parts()\n// \n// Usage:\n//   split_region = split_region_at_region_crossings(region1, region2, [closed1], [closed2], [eps])\n// Description:\n//   Splits region1 at the places where polygons in region1 touches each other at corners and at locations\n//   where region1 intersections region2.  Split region2 similarly with respect to region1.\n//   The return is a pair of results of the form [split1, split2] where split1=[frags1,frags2,...]\n//   and frags1 is a list of paths that when placed end to end (in the given order), give the first polygon of region1.\n//   Each path in the list is either entirely inside or entirely outside region2.  \n//   Then frags2 is the decomposition of the second polygon into path pieces, and so on.  Finally split2 is\n//   the same list, but for the polygons in region2.  \n//   You can pass a single polygon in for either region, but the output will be a singleton list, as if\n//   you passed in a singleton region.  If you set the closed parameters to false then the region components\n//   will be treated as open paths instead of polygons.  \n// Arguments:\n//   region1 = first region\n//   region2 = second region\n//   closed1 = if false then treat region1 as list of open paths.  Default: true\n//   closed2 = if false then treat region2 as list of open paths.  Default: true\n//   eps = Acceptable variance.  Default: `EPSILON` (1e-9)\n// Example(2D): \n//   path = square(50,center=false);\n//   region = [circle(d=80), circle(d=40)];\n//   paths = split_region_at_region_crossings(path, region);\n//   color(\"#aaa\") region(region);\n//   rainbow(paths[0][0]) stroke($item, width=2);\n//   right(110){\n//     color(\"#aaa\") region([path]);\n//     rainbow(flatten(paths[1])) stroke($item, width=2);\n//   }\nfunction split_region_at_region_crossings(region1, region2, closed1=true, closed2=true, eps=EPSILON) = \n    let(\n        region1=force_region(region1),\n        region2=force_region(region2)\n    )\n    assert(is_region(region1) && is_region(region2),\"One of the inputs is not a region\")\n    let(\n        xings = _region_region_intersections(region1, region2, closed1, closed2, eps),\n        regions = [region1,region2],\n        closed = [closed1,closed2]\n    )\n    [for(i=[0:1])\n      [for(p=idx(xings[i]))\n        let(\n            crossings = deduplicate([\n                                     [p,0,0],\n                                     each xings[i][p],\n                                     [p,len(regions[i][p])-(closed[i]?1:2), 1],\n                                    ],eps=eps),\n            subpaths = [\n                for (frag = pair(crossings)) \n                    deduplicate(\n                        _path_select(regions[i][p], frag[0][1], frag[0][2], frag[1][1], frag[1][2], closed=closed[i]),\n                        eps=eps\n                    )\n            ]\n        )\n        [for(s=subpaths) if (len(s)>1) s]\n       ]\n    ];\n                \n                \n\n// Function: region_parts()\n// Synopsis: Splits a region into a list of regions.\n// SynTags: RegList\n// Topics: Regions, List Handling\n// See Also: split_region_at_region_crossings()\n// Usage:\n//   rgns = region_parts(region);\n// Description:\n//   Divides a region into a list of connected regions.  Each connected region has exactly one clockwise outside boundary\n//   and zero or more counter-clockwise outlines defining internal holes.  Note that behavior is undefined on invalid regions whose\n//   components cross each other.\n// Example(2D,NoAxes):\n//   R = [for(i=[1:7]) square(i,center=true)];\n//   region_list = region_parts(R);\n//   rainbow(region_list) region($item);\n// Example(2D,NoAxes):\n//   R = [back(7,square(3,center=true)),\n//        square([20,10],center=true),\n//        left(5,square(8,center=true)),\n//        for(i=[4:2:8])\n//          right(5,square(i,center=true))];\n//   region_list = region_parts(R);\n//   rainbow(region_list) region($item);\nfunction region_parts(region) =\n   let(\n       region = force_region(region)\n   )\n   assert(is_region(region), \"Input is not a region\")\n   let(\n       inside = [for(i=idx(region))\n                    let(pt = mean([region[i][0], region[i][1]]))\n                    [for(j=idx(region))  i==j ? 0\n                                       : point_in_polygon(pt,region[j]) >=0 ? 1 : 0]\n                ],\n       level = inside*repeat(1,len(region))\n   )\n   [ for(i=idx(region))\n      if(level[i]%2==0)\n         let(\n             possible_children = search([level[i]+1],level,0)[0],\n             keep=search([1], select(inside,possible_children), 0, i)[0]\n         )\n         [\n           clockwise_polygon(region[i]),\n           for(good=keep)\n              ccw_polygon(region[possible_children[good]])\n         ]\n    ];\n\n\n\n\n// Section: Offset and 2D Boolean Set Operations\n\n\nfunction _offset_chamfer(center, points, delta) =\n    is_undef(points[1])?\n        let( points = select(points,[0,2]),\n             center = mean(points),\n             dir = sign(delta)*line_normal(points),\n             halfside = tan(22.5)*abs(delta)\n        )\n        [ points[0]+dir*halfside,\n          center + dir*abs(delta) + unit(points[0]-center)*halfside,\n          center + dir*abs(delta) + unit(points[1]-center)*halfside, \n          points[1]+dir*halfside\n        ]\n    :\n    let(\n        dist = sign(delta)*norm(center-line_intersection(select(points,[0,2]), [center, points[1]])),\n        endline = _shift_segment(select(points,[0,2]), delta-dist)\n    ) [\n        line_intersection(endline, select(points,[0,1])),\n        line_intersection(endline, select(points,[1,2]))\n    ];\n\n\nfunction _shift_segment(segment, d) =\n    assert(!approx(segment[0],segment[1]),\"Path has repeated points\")\n    move(d*line_normal(segment),segment);\n\n\n// Extend to segments to their intersection point.  First check if the segments already have a point in common,\n// which can happen if two colinear segments are input to the path variant of `offset()`\nfunction _segment_extension(s1,s2) =\n    norm(s1[1]-s2[0])<1e-6 ? s1[1] : line_intersection(s1,s2,LINE,LINE);\n\n\nfunction _makefaces(direction, startind, good, pointcount, closed) =\n    let(\n        lenlist = list_bset(good, pointcount),\n        numfirst = len(lenlist),\n        numsecond = sum(lenlist),\n        prelim_faces = _makefaces_recurse(startind, startind+len(lenlist), numfirst, numsecond, lenlist, closed)\n    )\n    direction? [for(entry=prelim_faces) reverse(entry)] : prelim_faces;\n\n\nfunction _makefaces_recurse(startind1, startind2, numfirst, numsecond, lenlist, closed, firstind=0, secondind=0, faces=[]) =\n    // We are done if *both* firstind and secondind reach their max value, which is the last point if !closed or one past\n    // the last point if closed (wrapping around).  If you don't check both you can leave a triangular gap in the output.\n    ((firstind == numfirst - (closed?0:1)) && (secondind == numsecond - (closed?0:1)))? faces :\n    _makefaces_recurse(\n        startind1, startind2, numfirst, numsecond, lenlist, closed, firstind+1, secondind+lenlist[firstind],\n        lenlist[firstind]==0? (\n            // point in original path has been deleted in offset path, so it has no match.  We therefore\n            // make a triangular face using the current point from the offset (second) path\n            // (The current point in the second path can be equal to numsecond if firstind is the last point)\n            concat(faces,[[secondind%numsecond+startind2, firstind+startind1, (firstind+1)%numfirst+startind1]])\n            // in this case a point or points exist in the offset path corresponding to the original path\n        ) : (\n            concat(faces,\n                // First generate triangular faces for all of the extra points (if there are any---loop may be empty)\n                [for(i=[0:1:lenlist[firstind]-2]) [firstind+startind1, secondind+i+1+startind2, secondind+i+startind2]],\n                // Finish (unconditionally) with a quadrilateral face\n                [\n                    [\n                        firstind+startind1,\n                        (firstind+1)%numfirst+startind1,\n                        (secondind+lenlist[firstind])%numsecond+startind2,\n                        (secondind+lenlist[firstind]-1)%numsecond+startind2\n                    ]\n                ]\n            )\n        )\n    );\n\n\n// Determine which of the shifted segments are good\nfunction _good_segments(path, d, shiftsegs, closed, quality) =\n    let(\n        maxind = len(path)-(closed ? 1 : 2),\n        pathseg = [for(i=[0:maxind]) select(path,i+1)-path[i]],\n        pathseg_len =  [for(seg=pathseg) norm(seg)],\n        pathseg_unit = [for(i=[0:maxind]) pathseg[i]/pathseg_len[i]],\n        // Order matters because as soon as a valid point is found, the test stops\n        // This order works better for circular paths because they succeed in the center\n        alpha = concat([for(i=[1:1:quality]) i/(quality+1)],[0,1])\n    ) [\n        for (i=[0:len(shiftsegs)-1])\n            (i>maxind)? true :\n            _segment_good(path,pathseg_unit,pathseg_len, d - 1e-7, shiftsegs[i], alpha)\n    ];\n\n\n// Determine if a segment is good (approximately)\n// Input is the path, the path segments normalized to unit length, the length of each path segment\n// the distance threshold, the segment to test, and the locations on the segment to test (normalized to [0,1])\n// The last parameter, index, gives the current alpha index.\n//\n// A segment is good if any part of it is farther than distance d from the path.  The test is expensive, so\n// we want to quit as soon as we find a point with distance > d, hence the recursive code structure.\n//\n// This test is approximate because it only samples the points listed in alpha.  Listing more points\n// will make the test more accurate, but slower.\nfunction _segment_good(path,pathseg_unit,pathseg_len, d, seg,alpha ,index=0) =\n    index == len(alpha) ? false :\n    _point_dist(path,pathseg_unit,pathseg_len, alpha[index]*seg[0]+(1-alpha[index])*seg[1]) > d ? true :\n    _segment_good(path,pathseg_unit,pathseg_len,d,seg,alpha,index+1);\n\n\n// Input is the path, the path segments normalized to unit length, the length of each path segment\n// and a test point.  Computes the (minimum) distance from the path to the point, taking into\n// account that the minimal distance may be anywhere along a path segment, not just at the ends.\nfunction _point_dist(path,pathseg_unit,pathseg_len,pt) =\n    min([\n        for(i=[0:len(pathseg_unit)-1]) let(\n            v = pt-path[i],\n            projection = v*pathseg_unit[i],\n            segdist = projection < 0? norm(pt-path[i]) :\n                projection > pathseg_len[i]? norm(pt-select(path,i+1)) :\n                norm(v-projection*pathseg_unit[i])\n        ) segdist\n    ]);\n\n\n// Function: offset()\n// Synopsis: Takes a 2D path, polygon or region and returns a path offset by an amount.\n// SynTags: Path, Region, Ext\n// Topics: Paths, Polygons, Regions\n// Usage:\n//   offsetpath = offset(path, [r=|delta=], [chamfer=], [closed=], [check_valid=], [quality=], [same_length=])\n//   path_faces = offset(path, return_faces=true, [r=|delta=], [chamfer=], [closed=], [check_valid=], [quality=], [firstface_index=], [flip_faces=])\n// Description:\n//   Takes a 2D input path, polygon or region and returns a path offset by the specified amount.  As with the built-in\n//   offset() module, you can use `r` to specify rounded offset and `delta` to specify offset with\n//   corners.  If you used `delta` you can set `chamfer` to true to get chamfers.\n//   For paths and polygons positive offsets make the polygons larger.  For paths, \n//   positive offsets shift the path to the left, relative to the direction of the path.\n//   .\n//   If you use `delta` without chamfers, the path must not include any 180 degree turns, where the path\n//   reverses direction.  Such reversals result in an offset with two parallel segments, so they cannot be\n//   extended to an intersection point.  If you select chamfering the reversals are permitted and will result\n//   in a single segment connecting the parallel segments.  With rounding, a semi-circle will connect the two offset segments.\n//   Note also that repeated points are always illegal in the input; remove them first with {{deduplicate()}}.  \n//   .\n//   When offsets shrink the path, segments cross and become invalid.  By default `offset()` checks\n//   for this situation.  To test validity the code checks that segments have distance larger than (r\n//   or delta) from the input path.  This check takes O(N^2) time and may mistakenly eliminate\n//   segments you wanted included in various situations, so you can disable it if you wish by setting\n//   check_valid=false.  When segments are mistakenly removed, you may get the wrong offset output, or you may\n//   get an error, depending on the effect of removing the segment.  \n//   The erroneous removal of segments is more common when your input\n//   contains very small segments and in this case can result in an invalid situation where the remaining\n//   valid segments are parallel and cannot be connected to form an offset curve.  If this happens, you\n//   will get an error message to this effect.  The only solutions are to either remove the small segments with {{deduplicate()}},\n//   or if your path permits it, to set check_valid to false.  \n//   .\n//   Another situation that can arise with validity testing is that the test is not sufficiently thorough and some\n//   segments persist that should be eliminated.  In this case, increase `quality` from its default of 1 to a value of 2 or 3.\n//   This increases the number of samples on the segment that are checked, so it will increase run time.  In\n//   some situations you may be able to decrease run time by setting quality to 0, which causes only\n//   segment ends to be checked.  \n//   .\n//   When invalid segments are eliminated, the path length decreases, and multiple points on the input path map to the same point\n//   on the offset path.  If you use chamfering or rounding, then\n//   the chamfers and roundings can increase the length of the output path.  Hence points in the output may be \n//   difficult to associate with the input.  If you want to maintain alignment between the points you\n//   can use the `same_length` option.  This option requires that you use `delta=` with `chamfer=false` to ensure\n//   that no points are added.  with `same_length`, when points collapse to a single point in the offset, the output includes\n//   that point repeated to preserve the correct length.  Generally repeated points will not appear in the offset output\n//   unless you set `same_length` to true, but in some rare circumstances involving very short segments, it is possible for the\n//   repeated points to occur in the output, even when `same_length=false`.  \n//   .\n//   Another way to obtain alignment information is to use the return_faces option, which can\n//   provide alignment information for all offset parameters: it returns a face list which lists faces between\n//   the original path and the offset path where the vertices are ordered with the original path\n//   first, starting at `firstface_index` and the offset path vertices appearing afterwords.  The\n//   direction of the faces can be flipped using `flip_faces`.  When you request faces the return\n//   value is a list: [offset_path, face_list].\n// Arguments:\n//   path = the path to process.  A list of 2d points.\n//   ---\n//   r = offset radius.  Distance to offset.  Will round over corners.\n//   delta = offset distance.  Distance to offset with pointed corners.\n//   chamfer = chamfer corners when you specify `delta`.  Default: false\n//   closed = if true path is treate as a polygon. Default: False.\n//   check_valid = perform segment validity check.  Default: True.\n//   quality = validity check quality parameter, a small integer.  Default: 1.\n//   same_length = return a path with the same length as the input.  Only compatible with `delta=`.  Default: false\n//   return_faces = return face list.  Default: False.\n//   firstface_index = starting index for face list.  Default: 0.\n//   flip_faces = flip face direction.  Default: false\n// Example(2D,NoAxes): Offset the red star out by 10 units.\n//   star = star(5, r=100, ir=30);\n//   stroke(closed=true, star, width=3, color=\"red\");\n//   stroke(closed=true, width=3, offset(star, delta=10, closed=true));\n// Example(2D,NoAxes):  Offset the star with chamfering\n//   star = star(5, r=100, ir=30);\n//   stroke(closed=true, star, width=3, color=\"red\");\n//   stroke(closed=true, width=3,\n//          offset(star, delta=10, chamfer=true, closed=true));\n// Example(2D,NoAxes):  Offset the star with rounding\n//   star = star(5, r=100, ir=30);\n//   stroke(closed=true, star, width=3, color=\"red\");\n//   stroke(closed=true, width=3,\n//          offset(star, r=10, closed=true));\n// Example(2D,NoAxes): Offset inward \n//   star = star(7, r=120, ir=50);\n//   stroke(closed=true, width=3, star, color=\"red\");\n//   stroke(closed=true, width=3,\n//          offset(star, delta=-15, closed=true));\n// Example(2D,NoAxes): Inward offset with chamfers\n//   star = star(7, r=120, ir=50);\n//   stroke(closed=true, width=3, star, color=\"red\");\n//   stroke(closed=true, width=3,\n//          offset(star, delta=-15, chamfer=true, closed=true));\n// Example(2D,NoAxes):  Inward offset with rounding\n//   star = star(7, r=120, ir=50);\n//   stroke(closed=true, width=3, star, color=\"red\");\n//   stroke(closed=true, width=3,\n//          offset(star, r=-15, closed=true, $fn=20));\n// Example(2D): Open path.  The red path moves from left to right as shown by the arrow and the positive offset shifts to the left of the initial red path.\n//   sinpath = 2*[for(theta=[-180:5:180]) [theta/4,45*sin(theta)]];\n//   stroke(sinpath, width=2, color=\"red\", endcap2=\"arrow2\");\n//   stroke(offset(sinpath, r=17.5),width=2);\n// Example(2D,NoAxes): An open path in red with with its positive offset in yellow and its negative offset in blue. \n//   seg = [[0,0],[0,50]];\n//   stroke(seg,color=\"red\",endcap2=\"arrow2\"); \n//   stroke(offset(seg,r=15,closed=false));\n//   stroke(offset(seg,r=-15,closed=false),color=\"blue\");\n// Example(2D,NoAxes): Offsetting the same line segment closed=true.  On the left, we use delta with chamfer=false, in the middle, chamfer=true, and on the right, rounding with r=.  A \"closed\" path here means that the path backtracks over itself.  When this happens, a flat end occurs in the first case, an end with chamfered corners if chamfering is on, or a semicircular rounding in the rounded case.  \n//   seg = [[0,0],[0,50]];\n//   stroke(seg,color=\"red\"); \n//   stroke([offset(seg,delta=15,closed=true)]);\n//   right(45){\n//     stroke(seg,color=\"red\");\n//     stroke([offset(seg,delta=15,chamfer=true,closed=true)]);\n//   }\n//   right(90){\n//     stroke(seg,color=\"red\");\n//     stroke([offset(seg,r=15,closed=true)]);\n//   }\n// Example(2D,NoAxes): Cutting a notch out of a square with a path reversal\n//   path = [[-10,-10],[-10,10],[0,10],[0,0],[0,10],[10,10],[10,-10]];\n//   stroke([path],width=.25,color=\"red\");\n//   stroke([offset(path, r=-2,$fn=32,closed=true)],width=.25);\n// Example(2D,NoAxes): A more complex example where the path turns back on itself several times.  \n//   $fn=32;\n//   path = [\n//           [0,0], [5,5],\n//           [10,0],[5,5],\n//           [11,8],[5,5],\n//           [5,10],[5,5],\n//           [-1,4],[5,5]\n//           ];\n//   op=offset(path, r=1.5,closed=true);\n//   stroke([path],width=.1,color=\"red\");\n//   stroke([op],width=.1);\n// Example(2D,NoAxes):  With the default quality value, this case produces the wrong answer.  This happens because the offset edge corresponding to the long left edge (shown in green) is erroneously flagged as invalid.  If you use `r=` instead of `delta=` then this will fail with an error.  \n//   test = [[0,0],[10,0],[10,7],[0,7], [-1,-3]];\n//   polygon(offset(test,delta=-1.9, closed=true)); \n//   stroke([test],width=.1,color=\"red\");\n//   stroke(select(test,-2,-1), width=.1, color=\"green\");\n// Example(2D,NoAxes):  Using `quality=2` produces the correct result\n//   test = [[0,0],[10,0],[10,7],[0,7], [-1,-3]];\n//   polygon(offset(test,r=-1.9, closed=true, quality=2));   \n//   stroke([test],width=.1,color=\"red\");\n// Example(2D,NoAxes): This case fails if `check_valid=true` when delta is large enough because segments are too close to the opposite side of the curve so they all get flagged as invalid and deleted from the output.  \n//   star = star(5, r=22, ir=13);\n//   stroke(star,width=.3,closed=true);                                                           \n//   color(\"green\")\n//     stroke(offset(star, delta=-9, closed=true),width=.3,closed=true); // Works with check_valid=true (the default)\n//   color(\"red\")\n//     stroke(offset(star, delta=-10, closed=true, check_valid=false),   // Fails if check_valid=true \n//            width=.3,closed=true); \n// Example(2D): But if you use rounding with offset then you need `check_valid=true` when `r` is big enough.  It works without the validity check as long as the offset shape retains a some of the straight edges at the star tip, but once the shape shrinks smaller than that, it fails.  There is no simple way to get a correct result for the case with `r=10`, because as in the previous example, it will fail if you turn on validity checks.  \n//   star = star(5, r=22, ir=13);\n//   color(\"green\")\n//     stroke(offset(star, r=-8, closed=true,check_valid=false), width=.1, closed=true);\n//   color(\"red\")\n//     stroke(offset(star, r=-10, closed=true,check_valid=false), width=.1, closed=true);\n// Example(2D,NoAxes): The extra triangles in this example show that the validity check cannot be skipped\n//   ellipse = scale([20,4], p=circle(r=1,$fn=64));\n//   stroke(ellipse, closed=true, width=0.3);\n//   stroke(offset(ellipse, r=-3, check_valid=false, closed=true),\n//          width=0.3, closed=true);\n// Example(2D,NoAxes): The triangles are removed by the validity check\n//   ellipse = scale([20,4], p=circle(r=1,$fn=64));\n//   stroke(ellipse, closed=true, width=0.3);\n//   stroke(offset(ellipse, r=-3, check_valid=true, closed=true),\n//          width=0.3, closed=true);\n// Example(2D,NoAxes): The region shown in red has the yellow offset region. \n//   rgn = difference(circle(d=100),\n//                    union(square([20,40], center=true),\n//                          square([40,20], center=true)));\n//   stroke(rgn, width=1, color=\"red\");\n//   region(offset(rgn, r=-5));\n// Example(2D,NoAxes): Using `same_length=true` to align the original curve to the offset.  Note that lots of points map to the corner at the top.\n//   closed=false;\n//   path = [for(angle=[0:5:180]) 10*[angle/100,2*sin(angle)]];\n//   opath = offset(path, delta=-3,same_length=true,closed=closed);\n//   stroke(path,closed=closed,width=.3);\n//   stroke(opath,closed=closed,width=.3);\n//   color(\"red\") for(i=idx(path)) stroke([path[i],opath[i]],width=.3);\n\nfunction offset(\n    path, r=undef, delta=undef, chamfer=false,\n    closed=false, check_valid=true,\n    quality=1, return_faces=false, firstface_index=0,\n    flip_faces=false, same_length=false\n) =\n    assert(!(same_length && return_faces), \"Cannot combine return_faces with same_length\")\n    is_region(path)?\n        assert(!return_faces, \"return_faces not supported for regions.\")\n        let(\n            ofsregs = [for(R=region_parts(path))\n                difference([for(i=idx(R)) offset(R[i], r=u_mul(i>0?-1:1,r), delta=u_mul(i>0?-1:1,delta),\n                                      chamfer=chamfer, check_valid=check_valid, quality=quality,same_length=same_length,closed=true)])]\n        )\n        union(ofsregs)\n    :\n    let(rcount = num_defined([r,delta]))\n    assert(rcount==1,\"Must define exactly one of 'delta' and 'r'\")\n    assert(!same_length || (is_def(delta) && !chamfer), \"Must specify delta, with chamfer=false, when same_length=true\")\n    assert(is_path(path), \"Input must be a path or region\")\n    let(\n        chamfer = is_def(r) ? false : chamfer,\n        quality = max(0,round(quality)),\n        flip_dir = closed && !is_polygon_clockwise(path)? -1 : 1,\n        d = flip_dir * (is_def(r) ? r : delta)\n    )\n    d==0 && !return_faces ? path :\n    let(\n        shiftsegs = [for(i=[0:len(path)-2]) _shift_segment([path[i],path[i+1]], d),\n                     if (closed) _shift_segment([last(path),path[0]],d)\n                     else [path[0],path[1]]  // dummy segment, not used\n                    ],\n        // good segments are ones where no point on the segment is less than distance d from any point on the path\n        good = check_valid ? _good_segments(path, abs(d), shiftsegs, closed, quality)\n                           : repeat(true,len(shiftsegs)),\n        goodsegs = bselect(shiftsegs, good),\n        goodpath = bselect(path,good)\n    )\n    assert(len(goodsegs)-(!closed && select(good,-1)?1:0)>0,\"Offset of path is degenerate\")\n    let(\n        // Extend the shifted segments to their intersection points.  For open curves the endpoints\n        // are simply the endpoints of the shifted segments.  If segments are parallel then the intersection\n        // points will be undef\n        sharpcorners = [for(i=[0:len(goodsegs)-1])\n                             !closed && i==0 ? goodsegs[0][0]\n                           : !closed && i==len(goodsegs)-1 ? goodsegs[len(goodsegs)-2][1]\n                           : _segment_extension(select(goodsegs,i-1), select(goodsegs,i))],\n\n        // true if sharpcorner has two parallel segments that go in the same direction \n        cornercheck = [for(i=idx(goodsegs)) (!closed && (i==0 || i==len(goodsegs)-1))\n                                          || is_def(sharpcorners[i])\n                                          || approx(unit(deltas(select(goodsegs,i-1))[0]) * unit(deltas(goodsegs[i])[0]),-1)],\n        dummyA = assert(len(sharpcorners)==2 || all(cornercheck),\"Two consecutive valid offset segments are parallel but do not meet at their ends, maybe because path contains very short segments that were mistakenly flagged as invalid; unable to compute offset\"),\n        reversecheck = \n            !same_length \n              || !(is_def(delta) && !chamfer)            // Reversals only a problem in delta mode without chamfers\n              || all_defined(sharpcorners),\n        dummyB = assert(reversecheck, \"Either validity check failed and removed a valid segment or the input 'path' contains a segment that reverses direction (180 deg turn).  Path reversals are not allowed when same_length is true because they increase path length.\"),\n        // This is a Boolean array that indicates whether a corner is an outside or inside corner\n        // For outside corners, the new corner is an extension (angle 0), for inside corners, it turns backward (angle 180)\n        // If either side turns back it is an inside corner---must check both.\n        // Outside corners can get rounded (if r is specified and there is space to round them)\n        // We flag endpoints of open paths as inside corners so that we don't try to round\n        outsidecorner =\n            len(sharpcorners)==2 ? [closed,closed]\n          : [for(i=idx(goodsegs))\n                !closed && (i==0 || i==len(goodsegs)-1) ? false  // endpoints of open path never get rounded\n              : is_undef(sharpcorners[i]) ? true\n              : let(prevseg=select(goodsegs,i-1))\n                (goodsegs[i][1]-goodsegs[i][0]) * (goodsegs[i][0]-sharpcorners[i]) > 0\n                  && (prevseg[1]-prevseg[0]) * (sharpcorners[i]-prevseg[1]) > 0\n            ],\n        steps = is_def(delta) ? undef\n              : [\n                 for(i=[0:len(goodsegs)-1])  \n                    r==0 ? 0\n                  : !closed && (i==0 || i==len(goodsegs)-1) ? 0    // We don't round ends of open paths\n                     // floor is important here to ensure we don't generate extra segments when nearly straight paths expand outward\n                  : let(vang = vector_angle(select(goodsegs,i-1)[1]-goodpath[i],\n                                            goodsegs[i][0]-goodpath[i]))\n                    assert(!outsidecorner[i] || vang!=0,    // If outsidecorner[i] is true then vang>0 needed to give valid step count\n                           \"Offset computation failed, probably because validity check mistakenly removed a valid segment.  Increasing quality might fix this.\")\n                    1+floor(segs(r)*vang/360)\n                ],\n        // newcorners is a list where each entry is a list of the points that correspond to a single point in the sharpcorners \n        // list: newcorners[i] is the point list that replaces goodpath[i].  Without rounding or chamfering (or reversals),\n        // this means each entry of newcorners is a singleton list.  But in the other cases, multiple points may appear at\n        // a given position; newcorners later gets flattened to produce the final list, but the structure is needed to\n        // establish point alignment for creating faces, or for duplicating points if same_length is true.  \n        newcorners =\n            [for(i=idx(goodsegs))\n                 let(\n                     basepts = [ select(goodsegs,i-1)[1], goodsegs[i][0] ]\n                 )\n                 is_def(sharpcorners[i]) &&\n                   ((is_def(steps) && steps[i] <=1)  // Don't round if steps is smaller than 2\n                     || !outsidecorner[i])           // Don't round inside corners\n                ? [sharpcorners[i]]\n                : chamfer ? _offset_chamfer(\n                                  goodpath[i], [\n                                      select(goodsegs,i-1)[1],\n                                      sharpcorners[i],\n                                      goodsegs[i][0]\n                                  ], d\n                              )\n                : is_def(delta) ?\n                      (\n                         is_def(sharpcorners[i]) ? [sharpcorners[i]]\n                       : let(normal = d*line_normal(basepts))\n                         basepts + [normal,normal]\n                      )\n                : // rounded case\n                  let(\n                      class =_tri_class( [ each select(goodsegs,i-1), goodsegs[i][0]]),\n                      cw = class==1,\n                      ccw = class==-1\n                  )\n                  arc(cp=goodpath[i], cw=cw, ccw=ccw,\n                      points=basepts,\n                      n=steps[i]+3)\n              ],\n        pointcount = [for(entry=newcorners) len(entry)],\n        edges = flatten(newcorners),\n        faces = !return_faces? []\n              : _makefaces(\n                           flip_faces, firstface_index, good,\n                           pointcount, closed\n                          ),\n        final_edges = same_length ? select(edges,\n                                           [0,\n                                            each list_head(cumsum([for(g=good) g?1:0]))\n                                           ]\n                                    )\n                                  : edges\n    ) return_faces? [edges,faces] : final_edges;\n\n\n\n/// Internal Function: _filter_region_parts()\n///\n/// splits region1 into subpaths where either it touches itself or crosses region2.  Classifies all of the\n/// subpaths as described below and keeps the ones listed in keep1.  A similar process is performed for region2.\n/// All of the kept subpaths are assembled into polygons and returned as a lst.\n/// .\n/// The four types of subpath from the region are defined relative to the second region:\n///    \"O\" - the subpath is outside the second region\n///    \"I\" - the subpath is in the second region's interior\n///    \"S\" - the subpath is on the 2nd region's border and the two regions interiors are on the same side of the subpath\n///    \"U\" - the subpath is on the 2nd region's border and the two regions meet at the subpath from opposite sides\n/// You specify which type of subpaths to keep with a string of the desired types such as \"OS\".  \nfunction _filter_region_parts(region1, region2, keep, eps=EPSILON) = \n    // We have to compute common vertices between paths in the region because\n    // they can be places where the path must be cut, even though they aren't\n    // found my the split_path function.  \n    let(\n        subpaths = split_region_at_region_crossings(region1,region2,eps=eps),\n        regions=[force_region(region1),\n                 force_region(region2)]\n    )        \n    _assemble_path_fragments(\n        [for(i=[0:1])\n           let(\n               keepS = search(\"S\",keep[i])!=[],\n               keepU = search(\"U\",keep[i])!=[],        \n               keepoutside = search(\"O\",keep[i]) !=[],\n               keepinside = search(\"I\",keep[i]) !=[],\n               all_subpaths = flatten(subpaths[i])\n           )\n           for (subpath = all_subpaths)\n               let(\n                   midpt = mean([subpath[0], subpath[1]]),\n                   rel = point_in_region(midpt,regions[1-i],eps=eps),\n                   keepthis = rel<0 ? keepoutside\n                            : rel>0 ? keepinside\n                            : !(keepS || keepU) ? false\n                            : let(\n                                  sidept = midpt + 0.01*line_normal(subpath[0],subpath[1]),\n                                  rel1 = point_in_region(sidept,regions[0],eps=eps)>0,\n                                  rel2 = point_in_region(sidept,regions[1],eps=eps)>0\n                              )\n                              rel1==rel2 ? keepS : keepU\n               )\n               if (keepthis) subpath\n        ]\n    );\n\n\nfunction _list_three(a,b,c) =\n   is_undef(b) ? a : \n   [\n     a,\n     if (is_def(b)) b,\n     if (is_def(c)) c\n   ];\n\n\n\n// Function&Module: union()\n// Synopsis: Performs a Boolean union operation.\n// SynTags: Geom, Region\n// Topics: Boolean Operations, Regions, Polygons, Shapes2D, Shapes3D\n// See Also: difference(), intersection(), diff(), intersect(), exclusive_or()\n// Usage:\n//   union() CHILDREN;\n//   region = union(regions);\n//   region = union(REGION1,REGION2);\n//   region = union(REGION1,REGION2,REGION3);\n// Description:\n//   When called as a function and given a list of regions or 2D polygons,\n//   returns the union of all given regions and polygons.  Result is a single region.\n//   When called as the built-in module, makes the union of the given children.\n// Arguments:\n//   regions = List of regions to union.\n// Example(2D):\n//   shape1 = move([-8,-8,0], p=circle(d=50));\n//   shape2 = move([ 8, 8,0], p=circle(d=50));\n//   color(\"green\") region(union(shape1,shape2));\n//   for (shape = [shape1,shape2]) color(\"red\") stroke(shape, width=0.5, closed=true);\nfunction union(regions=[],b=undef,c=undef,eps=EPSILON) =\n    let(regions=_list_three(regions,b,c))\n    len(regions)==0? [] :\n    len(regions)==1? regions[0] :\n    let(regions=[for (r=regions) is_path(r)? [r] : r])\n    union([\n           _filter_region_parts(regions[0],regions[1],[\"OS\", \"O\"], eps=eps),           \n           for (i=[2:1:len(regions)-1]) regions[i]\n          ],\n          eps=eps\n    );\n\n\n// Function&Module: difference()\n// Synopsis: Performs a Boolean difference operation.\n// SynTags: Geom, Region\n// Topics: Boolean Operations, Regions, Polygons, Shapes2D, Shapes3D\n// See Also: union(), intersection(), diff(), intersect(), exclusive_or()\n// Usage:\n//   difference() CHILDREN;\n//   region = difference(regions);\n//   region = difference(REGION1,REGION2);\n//   region = difference(REGION1,REGION2,REGION3);\n// Description:\n//   When called as a function, and given a list of regions or 2D polygons, \n//   takes the first region or polygon and differences away all other regions/polygons from it.  The resulting\n//   region is returned.\n//   When called as the built-in module, makes the set difference of the given children.\n// Arguments:\n//   regions = List of regions or polygons to difference.\n// Example(2D):\n//   shape1 = move([-8,-8,0], p=circle(d=50));\n//   shape2 = move([ 8, 8,0], p=circle(d=50));\n//   for (shape = [shape1,shape2]) color(\"red\") stroke(shape, width=0.5, closed=true);\n//   color(\"green\") region(difference(shape1,shape2));\nfunction difference(regions=[],b=undef,c=undef,eps=EPSILON) =\n     let(regions = _list_three(regions,b,c))\n     len(regions)==0? []\n   : len(regions)==1? regions[0]\n   : regions[0]==[] ? []\n   : let(regions=[for (r=regions) is_path(r)? [r] : r])\n     difference([\n                 _filter_region_parts(regions[0],regions[1],[\"OU\", \"I\"], eps=eps),                \n                 for (i=[2:1:len(regions)-1]) regions[i]\n                ],\n                eps=eps\n     );\n\n\n// Function&Module: intersection()\n// Synopsis: Performs a Boolean intersection operation.\n// SynTags: Geom, Region\n// Topics: Boolean Operations, Regions, Polygons, Shapes2D, Shapes3D\n// See Also: difference(), union(), diff(), intersect(), exclusive_or()\n// Usage:\n//   intersection() CHILDREN;\n//   region = intersection(regions);\n//   region = intersection(REGION1,REGION2);\n//   region = intersection(REGION1,REGION2,REGION3);\n// Description:\n//   When called as a function, and given a list of regions or polygons returns the\n//   intersection of all given regions.  Result is a single region.\n//   When called as the built-in module, makes the intersection of all the given children.\n// Arguments:\n//   regions = List of regions to intersect.\n// Example(2D):\n//   shape1 = move([-8,-8,0], p=circle(d=50));\n//   shape2 = move([ 8, 8,0], p=circle(d=50));\n//   for (shape = [shape1,shape2]) color(\"red\") stroke(shape, width=0.5, closed=true);\n//   color(\"green\") region(intersection(shape1,shape2));\nfunction intersection(regions=[],b=undef,c=undef,eps=EPSILON) =\n     let(regions = _list_three(regions,b,c))\n     len(regions)==0 ? []\n   : len(regions)==1? regions[0]\n   : regions[0]==[] || regions[1]==[] ? []   \n   : intersection([\n                   _filter_region_parts(regions[0],regions[1],[\"IS\",\"I\"],eps=eps),                       \n                   for (i=[2:1:len(regions)-1]) regions[i]\n                  ],\n                  eps=eps\n     );\n\n\n\n// Function&Module: exclusive_or()\n// Synopsis: Performs a Boolean exclusive-or operation.\n// SynTags: Geom, Region\n// Topics: Boolean Operations, Regions, Polygons, Shapes2D, Shapes3D\n// See Also: union(), difference(), intersection(), diff(), intersect()\n// Usage:\n//   exclusive_or() CHILDREN;\n//   region = exclusive_or(regions);\n//   region = exclusive_or(REGION1,REGION2);\n//   region = exclusive_or(REGION1,REGION2,REGION3);\n// Description:\n//   When called as a function and given a list of regions or 2D polygons, \n//   returns the exclusive_or of all given regions.  Result is a single region.\n//   When called as a module, performs a Boolean exclusive-or of up to 10 children.  Note that when\n//   the input regions cross each other the exclusive-or operator will produce shapes that\n//   meet at corners (non-simple regions), which do not render in CGAL.  \n// Arguments:\n//   regions = List of regions or polygons to exclusive_or\n// Example(2D): As Function.  A linear_sweep of this shape fails to render in CGAL.  \n//   shape1 = move([-8,-8,0], p=circle(d=50));\n//   shape2 = move([ 8, 8,0], p=circle(d=50));\n//   for (shape = [shape1,shape2])\n//       color(\"red\") stroke(shape, width=0.5, closed=true);\n//   color(\"green\") region(exclusive_or(shape1,shape2));\n// Example(2D): As Module.  A linear_extrude() of the resulting geometry fails to render in CGAL.  \n//   exclusive_or() {\n//       square(40,center=false);\n//       circle(d=40);\n//   }\nfunction exclusive_or(regions=[],b=undef,c=undef,eps=EPSILON) =\n     let(regions = _list_three(regions,b,c))\n     len(regions)==0? []\n   : len(regions)==1? force_region(regions[0])\n   : regions[0]==[] ? exclusive_or(list_tail(regions))\n   : regions[1]==[] ? exclusive_or(list_remove(regions,1))\n   : exclusive_or([\n                   _filter_region_parts(regions[0],regions[1],[\"IO\",\"IO\"],eps=eps),                  \n                   for (i=[2:1:len(regions)-1]) regions[i]\n                  ],\n                  eps=eps\n     );\n\n\nmodule exclusive_or() {\n    if ($children==1) {\n        children();\n    } else if ($children==2) {\n        difference() {\n            children(0);\n            children(1);\n        }\n        difference() {\n            children(1);\n            children(0);\n        }\n    } else if ($children==3) {\n        exclusive_or() {\n            exclusive_or() {\n                children(0);\n                children(1);\n            }\n            children(2);\n        }\n    } else if ($children==4) {\n        exclusive_or() {\n            exclusive_or() {\n                children(0);\n                children(1);\n            }\n            exclusive_or() {\n                children(2);\n                children(3);\n            }\n        }\n    } else if ($children==5) {\n        exclusive_or() {\n            exclusive_or() {\n                children(0);\n                children(1);\n                children(2);\n                children(3);\n            }\n            children(4);\n        }\n    } else if ($children==6) {\n        exclusive_or() {\n            exclusive_or() {\n                children(0);\n                children(1);\n                children(2);\n                children(3);\n            }\n            children(4);\n            children(5);\n        }\n    } else if ($children==7) {\n        exclusive_or() {\n            exclusive_or() {\n                children(0);\n                children(1);\n                children(2);\n                children(3);\n            }\n            children(4);\n            children(5);\n            children(6);\n        }\n    } else if ($children==8) {\n        exclusive_or() {\n            exclusive_or() {\n                children(0);\n                children(1);\n                children(2);\n                children(3);\n            }\n            exclusive_or() {\n                children(4);\n                children(5);\n                children(6);\n                children(7);\n            }\n        }\n    } else if ($children==9) {\n        exclusive_or() {\n            exclusive_or() {\n                children(0);\n                children(1);\n                children(2);\n                children(3);\n            }\n            exclusive_or() {\n                children(4);\n                children(5);\n                children(6);\n                children(7);\n            }\n            children(8);\n        }\n    } else if ($children==10) {\n        exclusive_or() {\n            exclusive_or() {\n                children(0);\n                children(1);\n                children(2);\n                children(3);\n            }\n            exclusive_or() {\n                children(4);\n                children(5);\n                children(6);\n                children(7);\n            }\n            children(8);\n            children(9);\n        }\n    } else {\n        assert($children<=10, \"exclusive_or() can only handle up to 10 children.\");\n    }\n}\n\n\n\n// Function&Module: hull_region()\n// Synopsis: Compute convex hull of region or 2d path\n// SynTags: Geom, Path\n// Topics: Regions, Polygons, Shapes2D\n// Usage:\n//    path = hull_region(region);\n//    hull_region(region);\n// Description:\n//   Given a path, or a region, compute the convex hull\n//   and return it as a path.  This differs from {{hull()}} and {{hull2d_path()}} which\n//   return an index list into the point list.  As a module invokes the native hull() on\n//   the specified region.  \n// Arguments:\n//   region = region or path listing points to compute the hull from.  \n// Example(2D, NoAxes):\n//   data = [star(id=10,od=20,n=9),\n//           right(30, star(id=12,od=25, n=7))];\n//   stroke(data);\n//   stroke([hull_region(data)],color=\"red\");\nfunction hull_region(region) =\n  assert(is_path(region) || is_region(region))\n  let(\n      pts = is_region(region) ? flatten(region)\n                              : region,\n      order = hull2d_path(pts)\n  )\n  select(pts,order);\n\nmodule hull_region(region)\n{\n  hull()region(region);\n}\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-33", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n/////////////////////////////////////////////////////////////////////\n// LibFile: rounding.scad\n//   Routines to create rounded corners, with either circular rounding,\n//   or continuous curvature rounding with no sudden curvature transitions.\n//   Provides rounding of corners or rounding that preserves corner points and curves the edges.\n//   Also provides some 3D rounding functions, and a powerful function for joining\n//   two prisms together with a rounded fillet at the joint.  \n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/rounding.scad>\n// FileGroup: Advanced Modeling\n// FileSummary: Round path corners, rounded prisms, rounded cutouts in tubes, filleted prism joints\n//////////////////////////////////////////////////////////////////////\ninclude <beziers.scad>\ninclude <structs.scad>\n\n// Section: Types of Roundovers\n//   The functions and modules in this file support two different types of roundovers and some different mechanisms for specifying\n//   the size of the roundover.  The usual circular roundover can produce a tactile \"bump\" where the curvature changes from flat to\n//   circular.  See https://hackernoon.com/apples-icons-have-that-shape-for-a-very-good-reason-720d4e7c8a14 for details.\n//   We compute continuous curvature rounding using 4th order Bezier curves.  This type of rounding, which we call \"smooth\" rounding,\n//   does not have a \"radius\" so we need different ways to specify the size of the roundover.  We introduce the `cut` and `joint`\n//   parameters for this purpose.  They can specify dimensions of circular roundovers, continuous curvature \"smooth\" roundovers, and even chamfers.  \n//   .\n//   The `cut` parameter specifies the distance from the unrounded corner to the rounded tip, so how\n//   much of the corner to \"cut\" off.  This can be easier to understand than setting a circular radius, which can be\n//   unexpectedly extreme when the corner is very sharp.  It also allows a systematic specification of\n//   corner treatments that are the same size for all corner treatments.\n//   .\n//   The `joint` parameter specifies the distance\n//   away from the corner along the path where the roundover or chamfer should start.  This parameter is good for ensuring that\n//   your roundover will fit on the polygon or polyhedron, since you can easily tell whether you have enough space, and whether\n//   adjacent corner treatments will interfere.\n//   .\n//   For circular rounding you can use the `radius` or `r` parameter to set the rounding radius.\n//   .\n//   For chamfers you can use `width` to set the width of the chamfer.  \n//   .\n//   The \"smooth\" rounding method also has a parameter that specifies how smooth the curvature match is.  This parameter, `k`,\n//   ranges from 0 to 1, with a default of 0.5.  Larger values gives a more \n//   abrupt transition and smaller ones a more gradual transition.  If you set the value much higher\n//   than 0.8 the curvature changes abruptly enough that though it is theoretically continuous, it may\n//   not be continuous in practice.  If you set it very small then the transition is so gradual that\n//   the length of the roundover may be extremely long, and the actual rounded part of the curve may be very small.  \n// Figure(2D,Med,NoAxes):  Parameters of a \"circle\" roundover\n//   h = 18;\n//   w = 12.6;\n//   strokewidth = .3;\n//   example = [[0,0],[w,h],[2*w,0]];\n//   stroke(example, width=strokewidth*1.5);\n//   textangle = 90-vector_angle(example)/2;\n//   theta = vector_angle(example)/2;\n//   color(\"green\"){ stroke([[w,h], [w,h-18*(1-sin(theta))/cos(theta)]], width=strokewidth, endcaps=\"arrow2\");\n//                   translate([w-1.75,h-7])scale(.1)rotate(textangle)text(\"cut\",size=14); }\n//   ll=lerp([w,h], [0,0],18/norm([w,h]-[0,0]) );\n//   color(\"blue\"){ stroke(_shift_segment([[w,h], ll], -.7), width=strokewidth,endcaps=\"arrow2\");\n//                  translate([w/2-1.3,h/2+.6])  scale(.1)rotate(textangle)text(\"joint\",size=14);}\n//   color(\"red\")stroke(\n//         select(round_corners(example, joint=18, method=\"circle\",$fn=64,closed=false),1,-2),\n//         width=strokewidth);\n//   r=18*tan(theta);\n//   color(\"black\"){\n//     stroke([ll, [w,h-r-18*(1-sin(theta))/cos(theta)]], width=strokewidth, endcaps=\"arrow2\");\n//     translate([w/1.6,0])text(\"radius\", size=1.4);\n//   }\n// Figure(2D,Med,NoAxes):  Parameters of a \"smooth\" roundover with the default of `k=0.5`.  Note the long, slow transition from flat to round.  \n//   h = 18;\n//   w = 12.6;\n//   strokewidth = .3;\n//   example = [[0,0],[w,h],[2*w,0]];\n//   stroke(example, width=strokewidth*1.5);\n//   textangle = 90-vector_angle(example)/2;\n//   color(\"green\"){ stroke([[w,h], [w,h-cos(vector_angle(example)/2) *3/8*h]], width=strokewidth, endcaps=\"arrow2\");\n//                   translate([w-1.75,h-5.5])scale(.1)rotate(textangle)text(\"cut\",size=14); }\n//   ll=lerp([w,h], [0,0],18/norm([w,h]-[0,0]) );\n//   color(\"blue\"){ stroke(_shift_segment([[w,h], ll], -.7), width=strokewidth,endcaps=\"arrow2\");\n//                  translate([w/2-1.3,h/2+.6])  scale(.1)rotate(textangle)text(\"joint\",size=14);}\n//   color(\"red\")stroke(\n//         select(round_corners(example, joint=18, method=\"smooth\",closed=false),1,-2),\n//         width=strokewidth);\n// Figure(2D,Med,NoAxes):  Parameters of a \"smooth\" roundover, with `k=0.75`.  The transition into the roundover is shorter, and faster.  The cut length is bigger for the same joint length.\n//   h = 18;\n//   w = 12.6;\n//   strokewidth = .3;\n//   example = [[0,0],[w,h],[2*w,0]];\n//   stroke(example, width=strokewidth*1.5);\n//   textangle = 90-vector_angle(example)/2;\n//   color(\"green\"){ stroke([[w,h], [w,h-cos(vector_angle(example)/2) *4/8*h]], width=strokewidth, endcaps=\"arrow2\");\n//                   translate([w-1.75,h-5.5])scale(.1)rotate(textangle)text(\"cut\",size=14); }\n//   ll=lerp([w,h], [0,0],18/norm([w,h]-[0,0]) );\n//   color(\"blue\"){ stroke(_shift_segment([[w,h], ll], -.7), width=strokewidth,endcaps=\"arrow2\");\n//                  translate([w/2-1.3,h/2+.6])  scale(.1)rotate(textangle)text(\"joint\",size=14);}\n//   color(\"red\")stroke(\n//         select(round_corners(example, joint=18, method=\"smooth\",closed=false,k=.75),1,-2),\n//         width=strokewidth);\n// Figure(2D,Med,NoAxes):  Parameters of a \"smooth\" roundover, with `k=0.15`.  The transition is so gradual that it appears that the roundover is much smaller than specified.  The cut length is much smaller for the same joint length.  \n//   h = 18;\n//   w = 12.6;\n//   strokewidth = .3;\n//   example = [[0,0],[w,h],[2*w,0]];\n//   stroke(example, width=strokewidth*1.5);\n//   textangle = 90-vector_angle(example)/2;\n//   color(\"green\"){ stroke([[w,h], [w,h-cos(vector_angle(example)/2) *1.6/8*h]], width=strokewidth, endcaps=\"arrow2\");\n//                   translate([w+.3,h])text(\"cut\",size=1.4); }\n//   ll=lerp([w,h], [0,0],18/norm([w,h]-[0,0]) );\n//   color(\"blue\"){ stroke(_shift_segment([[w,h], ll], -.7), width=strokewidth,endcaps=\"arrow2\");\n//                  translate([w/2-1.3,h/2+.6])  scale(.1)rotate(textangle)text(\"joint\",size=14);}\n//   color(\"red\")stroke(\n//         select(round_corners(example, joint=18, method=\"smooth\",closed=false,k=.15),1,-2),\n//         width=strokewidth);\n// Figure(2D,Med,NoAxes):  Parameters of a symmetric \"chamfer\".\n//   h = 18;\n//   w = 12.6;\n//   strokewidth = .3;\n//   example = [[0,0],[w,h],[2*w,0]];\n//   stroke(example, width=strokewidth*1.5);\n//   textangle = 90-vector_angle(example)/2;\n//   color(\"black\"){\n//        stroke(fwd(1,\n//         select(round_corners(example, joint=18, method=\"chamfer\",closed=false),1,-2)),\n//         width=strokewidth,endcaps=\"arrow2\");\n//        translate([w,.3])text(\"width\", size=1.4,halign=\"center\");\n//   }     \n//   color(\"green\"){ stroke([[w,h], [w,h-18*cos(vector_angle(example)/2)]], width=strokewidth, endcaps=\"arrow2\");\n//                   translate([w-1.75,h-5.5])scale(.1)rotate(textangle)text(\"cut\",size=14); }\n//   ll=lerp([w,h], [0,0],18/norm([w,h]-[0,0]) );\n//   color(\"blue\"){ stroke(_shift_segment([[w,h], ll], -.7), width=strokewidth,endcaps=\"arrow2\");\n//                  translate([w/2-1.3,h/2+.6]) rotate(textangle)text(\"joint\",size=1.4);}\n//   color(\"red\")stroke(\n//         select(round_corners(example, joint=18, method=\"chamfer\",closed=false),1,-2),\n//         width=strokewidth);\n\n\n// Section: Rounding Paths\n\n// Function: round_corners()\n// Synopsis: Round or chamfer the corners of a path (clipping them off).\n// SynTags: Path\n// Topics: Rounding, Paths\n// See Also: round_corners(), smooth_path(), path_join(), offset_stroke()\n// Usage:\n//   rounded_path = round_corners(path, [method], [radius=], [cut=], [joint=], [closed=], [verbose=]);\n// Description:\n//   Takes a 2D or 3D path as input and rounds each corner\n//   by a specified amount.  The rounding at each point can be different and some points can have zero\n//   rounding.  The `round_corners()` function supports three types of corner treatment: chamfers, circular rounding,\n//   and continuous curvature rounding using 4th order bezier curves.  See\n//   [Types of Roundover](rounding.scad#subsection-types-of-roundover) for details on rounding types.  \n//   .\n//   You select the type of rounding using the `method` parameter, which should be `\"smooth\"` to\n//   get continuous curvature rounding, `\"circle\"` to get circular rounding, or `\"chamfer\"` to get chamfers.  The default is circle\n//   rounding.  Each method accepts multiple options to specify the amount of rounding.  See\n//   [Types of Roundover](rounding.scad#subsection-types-of-roundover) for example diagrams.\n//   .\n//   * The `cut` parameter specifies the distance from the unrounded corner to the rounded tip, so how\n//   much of the corner to \"cut\" off.  \n//   * The `joint` parameter specifies the distance\n//   away from the corner along the path where the roundover or chamfer should start.  This makes it easy to ensure your roundover will fit,\n//   so use it if you want the largest possible roundover.  \n//   * For circular rounding you can use the `radius` or `r` parameter to set the rounding radius.\n//   * For chamfers you can use the `width` parameter, which sets the width of the chamfer edge.  \n//   .\n//   As explained in [Types of Roundover](rounding.scad#subsection-types-of-roundover), the continuous curvature \"smooth\"\n//   type of rounding also accepts the `k` parameter, between 0 and 1, which specifies how fast the curvature changes at\n//   the joint.  The default is `k=0.5`.  \n//   .\n//   If you select curves that are too large to fit the function will fail with an error.  You can set `verbose=true` to\n//   get a message showing a list of scale factors you can apply to your rounding parameters so that the\n//   roundovers will fit on the curve.  If the scale factors are larger than one\n//   then they indicate how much you can increase the curve sizes before collisions will occur.\n//   .\n//   The parameters `radius`, `cut`, `joint` and `k` can be numbers, which round every corner using the same parameters, or you\n//   can specify a list to round each corner with different parameters.  If the curve is not closed then the first and last points\n//   of the curve are not rounded.  In this case you can specify a full list of points anyway, and the endpoint values are ignored,\n//   or you can specify a list that has length len(path)-2, omitting the two dummy values.\n//   .\n//   If your input path includes collinear points you must use a cut or radius value of zero for those \"corners\".  You can\n//   choose a nonzero joint parameter when the collinear points form a 180 degree angle.  This will cause extra points to be inserted. \n//   If the collinear points form a spike (0 degree angle) then round_corners will fail. \n//   .\n//   Examples:\n//   * `method=\"circle\", radius=2`:\n//       Rounds every point with circular, radius 2 roundover\n//   * `method=\"smooth\", cut=2`:\n//       Rounds every point with continuous curvature rounding with a cut of 2, and a default 0.5 smoothing parameter\n//   * `method=\"smooth\", cut=2, k=0.3`:\n//       Rounds every point with continuous curvature rounding with a cut of 2, and a very gentle 0.3 smoothness setting\n//   .\n//   The number of segments used for roundovers is determined by `$fa`, `$fs` and `$fn` as usual for\n//   circular roundovers.  For continuous curvature roundovers `$fs` and `$fn` are used and `$fa` is\n//   ignored.  Note that $fn is interpreted as the number of points on the roundover curve, which is\n//   not equivalent to its meaning for rounding circles because roundovers are usually small fractions\n//   of a circular arc.  As usual, $fn overrides $fs.  When doing continuous curvature rounding be sure to use lots of segments or the effect\n//   will be hidden by the discretization.  Note that if you use $fn with \"smooth\" then $fn points are added at each corner.\n//   This guarantees a specific output length.  It also means that if\n//   you set `joint` nonzero on a flat \"corner\", with collinear points, you will get $fn points at that \"corner.\"\n//   If you have two roundovers that fully consume a segment then they share a point where they meet in the segment, which means the output\n//   point count will be decreased by one.  \n// Arguments:\n//   path = list of 2d or 3d points defining the path to be rounded.\n//   method = rounding method to use.  Set to \"chamfer\" for chamfers, \"circle\" for circular rounding and \"smooth\" for continuous curvature 4th order bezier rounding.  Default: \"circle\"\n//   ---\n//   radius/r = rounding radius, only compatible with `method=\"circle\"`. Can be a number or vector.\n//   cut = rounding cut distance, compatible with all methods.  Can be a number or vector.\n//   joint = rounding joint distance, compatible with `method=\"chamfer\"` and `method=\"smooth\"`.  Can be a number or vector.\n//   width = width of the flat edge created by chamfering, compatible with `method=\"chamfer\"`.  Can be a number or vector. \n//   k = continuous curvature smoothness parameter for `method=\"smooth\"`.  Can be a number or vector.  Default: 0.5\n//   closed = if true treat the path as a closed polygon, otherwise treat it as open.  Default: true.\n//   verbose = if true display rounding scale factors that show how close roundovers are to overlapping.  Default: false\n//\n// Example(2D,Med): Standard circular roundover with radius the same at every point. Compare results at the different corners.\n//   $fn=36;\n//   shape = [[0,0], [10,0], [15,12], [6,6], [6, 12], [-3,7]];\n//   polygon(round_corners(shape, radius=1));\n//   color(\"red\") down(.1) polygon(shape);\n// Example(2D,Med): Circular roundover using the \"cut\" specification, the same at every corner.\n//   $fn=36;\n//   shape = [[0,0], [10,0], [15,12], [6,6], [6, 12], [-3,7]];\n//   polygon(round_corners(shape, cut=1));\n//   color(\"red\") down(.1) polygon(shape);\n// Example(2D,Med): Continous curvature roundover using \"cut\", still the same at every corner.  The default smoothness parameter of 0.5 was too gradual for these roundovers to fit, but 0.7 works.\n//   $fn=36;\n//   shape = [[0,0], [10,0], [15,12], [6,6], [6, 12], [-3,7]];\n//   polygon(round_corners(shape, method=\"smooth\", cut=1, k=0.7));\n//   color(\"red\") down(.1) polygon(shape);\n// Example(2D,Med): Continuous curvature roundover using \"joint\", for the last time the same at every corner.  Notice how small the roundovers are.\n//   $fn=36;\n//   shape = [[0,0], [10,0], [15,12], [6,6], [6, 12], [-3,7]];\n//   polygon(round_corners(shape, method=\"smooth\", joint=1, k=0.7));\n//   color(\"red\") down(.1) polygon(shape);\n// Example(2D,Med): Circular rounding, different at every corner, some corners left unrounded\n//   shape = [[0,0], [10,0], [15,12], [6,6], [6, 12], [-3,7]];\n//   radii = [1.8, 0, 2, 0.3, 1.2, 0];\n//   polygon(round_corners(shape, radius = radii,$fn=64));\n//   color(\"red\") down(.1) polygon(shape);\n// Example(2D,Med): Continuous curvature rounding, different at every corner, with varying smoothness parameters as well, and `$fs` set very small.  Note that `$fa` is ignored here with method set to \"smooth\".\n//   shape = [[0,0], [10,0], [15,12], [6,6], [6, 12], [-3,7]];\n//   cuts = [1.5,0,2,0.3, 1.2, 0];\n//   k = [0.6, 0.5, 0.5, 0.7, 0.3, 0.5];\n//   polygon(round_corners(shape, method=\"smooth\", cut=cuts, k=k, $fs=0.1));\n//   color(\"red\") down(.1) polygon(shape);\n// Example(2D,Med): Chamfers\n//   $fn=36;\n//   shape = [[0,0], [10,0], [15,12], [6,6], [6, 12], [-3,7]];\n//   polygon(round_corners(shape, method=\"chamfer\", cut=1));\n//   color(\"red\") down(.1) polygon(shape);\n// Example(Med3D): 3D printing test pieces to display different curvature shapes.  You can see the discontinuity in the curvature on the \"C\" piece in the rendered image.\n//   ten = square(50);\n//   cut = 5;\n//   linear_extrude(height=14) {\n//     translate([25,25,0])text(\"C\",size=30, valign=\"center\", halign=\"center\");\n//     translate([85,25,0])text(\"5\",size=30, valign=\"center\", halign=\"center\");\n//     translate([85,85,0])text(\"3\",size=30, valign=\"center\", halign=\"center\");\n//     translate([25,85,0])text(\"7\",size=30, valign=\"center\", halign=\"center\");\n//   }\n//   linear_extrude(height=13) {\n//     polygon(round_corners(ten, cut=cut, $fn=96*4));\n//     translate([60,0,0])polygon(round_corners(ten,  method=\"smooth\", cut=cut, $fn=96));\n//     translate([60,60,0])polygon(round_corners(ten, method=\"smooth\", cut=cut, k=0.32, $fn=96));\n//     translate([0,60,0])polygon(round_corners(ten, method=\"smooth\", cut=cut, k=0.7, $fn=96));\n//   }\n// Example(2D,Med): Rounding a path that is not closed in a three different ways.\n//   $fs=.1;\n//   $fa=1;\n//   zigzagx = [-10, 0, 10, 20, 29, 38, 46, 52, 59, 66, 72, 78, 83, 88, 92, 96, 99, 102, 112];\n//   zigzagy = concat([0], flatten(repeat([-10,10],8)), [-10,0]);\n//   zig = hstack(zigzagx,zigzagy);\n//   stroke(zig,width=1);   // Original shape\n//   fwd(20)            // Smooth size corners with a cut of 4 and curvature parameter 0.6\n//     stroke(round_corners(zig,cut=4, k=0.6, method=\"smooth\", closed=false),width=1);\n//   fwd(40)            // Smooth size corners with circular arcs and a cut of 4\n//     stroke(round_corners(zig,cut=4,closed=false, method=\"circle\"),width=1);\n//                      // Smooth size corners with a circular arc and radius 1.5 (close to maximum possible)\n//   fwd(60)            // Note how the different points are cut back by different amounts\n//     stroke(round_corners(zig,radius=1.5,closed=false),width=1);\n// Example(FlatSpin,VPD=42,VPT=[7.75,6.69,5.22]): Rounding some random 3D paths\n//   $fn=36;\n//   list1= [\n//     [2.887360, 4.03497, 6.372090],\n//     [5.682210, 9.37103, 0.783548],\n//     [7.808460, 4.39414, 1.843770],\n//     [0.941085, 5.30548, 4.467530],\n//     [1.860540, 9.81574, 6.497530],\n//     [6.938180, 7.21163, 5.794530]\n//   ];\n//   list2= [\n//     [1.079070, 4.74091, 6.900390],\n//     [8.775850, 4.42248, 6.651850],\n//     [5.947140, 9.17137, 6.156420],\n//     [0.662660, 6.95630, 5.884230],\n//     [6.564540, 8.86334, 9.953110],\n//     [5.420150, 4.91874, 3.866960]\n//   ];\n//   path_sweep(regular_ngon(n=36,or=.1),round_corners(list1,closed=false, method=\"smooth\", cut = 0.65));\n//   right(6)\n//     path_sweep(regular_ngon(n=36,or=.1),round_corners(list2,closed=false, method=\"circle\", cut = 0.75));\n// Example(3D,Med):  Rounding a spiral with increased rounding along the length\n//   // Construct a square spiral path in 3D\n//   $fn=36;\n//   square = [[0,0],[1,0],[1,1],[0,1]];\n//   spiral = flatten(repeat(concat(square,reverse(square)),5));  // Squares repeat 10x, forward and backward\n//   squareind = [for(i=[0:9]) each [i,i,i,i]];                   // Index of the square for each point\n//   z = count(40)*.2+squareind;\n//   path3d = hstack(spiral,z);                                   // 3D spiral\n//   rounding = squareind/20;\n//       // Setting k=1 means curvature won't be continuous, but curves are as round as possible\n//       // Try changing the value to see the effect.\n//   rpath = round_corners(path3d, joint=rounding, k=1, method=\"smooth\", closed=false);\n//   path_sweep( regular_ngon(n=36, or=.1), rpath);\n// Example(2D): The rounding invocation that is commented out gives an error because the rounding parameters interfere with each other.  The error message gives a list of factors that can help you fix this: [0.852094, 0.852094, 1.85457, 10.1529]\n//   $fn=64;\n//   path = [[0, 0],[10, 0],[20, 20],[30, -10]];\n//   debug_polygon(path);\n//   //polygon(round_corners(path,cut = [1,3,1,1],\n//   //        method=\"circle\"));\n// Example(2D): The list of factors shows that the problem is in the first two rounding values, because the factors are smaller than one.  If we multiply the first two parameters by 0.85 then the roundings fit.  The verbose option gives us the same fit factors.  \n//   $fn=64;\n//   path = [[0, 0],[10, 0],[20, 20],[30, -10]];\n//   polygon(round_corners(path,cut = [0.85,3*0.85,1,1],\n//                         method=\"circle\", verbose=true));\n// Example(2D): From the fit factors we can see that rounding at vertices 2 and 3 could be increased a lot.  Applying those factors we get this more rounded shape.  The new fit factors show that we can still further increase the rounding parameters if we wish.  \n//   $fn=64;\n//   path = [[0, 0],[10, 0],[20, 20],[30, -10]];\n//   polygon(round_corners(path,cut = [0.85,3*0.85,2.13, 10.15],\n//                         method=\"circle\",verbose=true));\n// Example(2D): Using the `joint` parameter it's easier to understand whether your roundvers will fit.  We can guarantee a fairly large roundover on any path by picking each one to use up half the segment distance along the shorter of its two segments:\n//   $fn=64;\n//   path = [[0, 0],[10, 0],[20, 20],[30, -10]];\n//   path_len = path_segment_lengths(path,closed=true);\n//   halflen = [for(i=idx(path)) min(select(path_len,i-1,i))/2];\n//   polygon(round_corners(path,joint = halflen,\n//                         method=\"circle\",verbose=true));\n// Example(2D): Chamfering, specifying the chamfer width\n//   path = star(5, step=2, d=100);\n//   path2 = round_corners(path, method=\"chamfer\", width=5);\n//   polygon(path2);\n// Example(2D): Chamfering, specifying the cut\n//   path = star(5, step=2, d=100);\n//   path2 = round_corners(path, method=\"chamfer\", cut=5);\n//   polygon(path2);\n// Example(2D): Chamfering, specifying joint length\n//   path = star(5, step=2, d=100);\n//   path2 = round_corners(path, method=\"chamfer\", joint=5);\n//   polygon(path2);\n// Example(2D): Two passes to apply chamfers first, and then round the unchamfered corners.  Chamfers always add one point, so it's not hard to keep track of the vertices\n//   $fn=32;\n//   shape = square(10);\n//   chamfered = round_corners(shape, method=\"chamfer\",\n//                             cut=[2,0,2,0]);\n//   rounded = round_corners(chamfered, \n//              cut = [0, 0,  // 1st original vertex, chamfered\n//                     1.5,   // 2nd original vertex\n//                     0, 0,  // 3rd original vertex, chamfered\n//                     2.5]); // 4th original vertex\n//   polygon(rounded);\n// Example(2D): Another example of mixing chamfers and roundings with two passes\n//   path = star(5, step=2, d=100);\n//   chamfcut = [for (i=[0:4]) each [7,0]];\n//   radii = [for (i=[0:4]) each [0,0,10]];\n//   path2=round_corners(\n//           round_corners(path,\n//                         method=\"chamfer\",\n//                         cut=chamfcut),\n//           radius=radii);\n//   stroke(path2, closed=true);\n// Example(2D,Med,NoAxes): Specifying by corner index.  Use {{list_set()}} to construct the full chamfer cut list. \n//   path = star(47, ir=25, or=50);  // long path, lots of corners\n//   chamfind = [8, 28, 60];         // But only want 3 chamfers\n//   chamfcut = list_set([],chamfind,[10,13,15],minlen=len(path));\n//   rpath = round_corners(path, cut=chamfcut, method=\"chamfer\");   \n//   polygon(rpath);\n// Example(2D,Med,NoAxes): Two-pass to chamfer and round by index.  Use {{repeat_entries()}} to correct for first pass chamfers.\n//   $fn=32;\n//   path = star(47, ir=32, or=65);  // long path, lots of corners\n//   chamfind = [8, 28, 60];         // But only want 3 chamfers\n//   roundind = [7,9,27,29,59,61];   // And 6 roundovers\n//   chamfcut = list_set([],chamfind,[10,13,15],minlen=len(path));\n//   roundcut = list_set([],roundind,repeat(8,6),minlen=len(path));\n//   dups = list_set([], chamfind, repeat(2,len(chamfind)), dflt=1, minlen=len(path));\n//   rpath1 = round_corners(path, cut=chamfcut, method=\"chamfer\");\n//   rpath2 = round_corners(rpath1, cut=repeat_entries(roundcut,dups));\n//   polygon(rpath2);\nmodule round_corners(path, method=\"circle\", radius, r, cut, joint, width, k, closed=true, verbose=false) {no_module();}\nfunction round_corners(path, method=\"circle\", radius, r, cut, joint, width, k, closed=true, verbose=false) =\n    assert(in_list(method,[\"circle\", \"smooth\", \"chamfer\"]), \"method must be one of \\\"circle\\\", \\\"smooth\\\" or \\\"chamfer\\\"\")\n    let(\n        default_k = 0.5,\n        size=one_defined([radius, r, cut, joint, width], \"radius,r,cut,joint,width\"),\n        path = force_path(path), \n        size_ok = is_num(size) || len(size)==len(path) || (!closed && len(size)==len(path)-2),\n        k_ok = is_undef(k) || (method==\"smooth\" && (is_num(k) || len(k)==len(path) || (!closed && len(k)==len(path)-2))),\n        measure = is_def(radius) ? \"radius\"\n                : is_def(r) ? \"radius\"\n                : is_def(cut) ? \"cut\" \n                : is_def(joint) ? \"joint\"\n                : \"width\"\n    )\n    assert(is_path(path,[2,3]), \"input path must be a 2d or 3d path\")\n    assert(len(path)>2,str(\"Path has length \",len(path),\".  Length must be 3 or more.\"))\n    assert(size_ok,str(\"Input \",measure,\" must be a number or list with length \",len(path), closed?\"\":str(\" or \",len(path)-2)))\n    assert(k_ok,method==\"smooth\" ? str(\"Input k must be a number or list with length \",len(path), closed?\"\":str(\" or \",len(path)-2)) :\n                                   \"Input k is only allowed with method=\\\"smooth\\\"\")\n    assert(method==\"circle\" || measure!=\"radius\", \"radius parameter allowed only with method=\\\"circle\\\"\")\n    assert(method==\"chamfer\" || measure!=\"width\", \"width parameter  allowed only with method=\\\"chamfer\\\"\")\n    let(\n        parm = is_num(size) ? repeat(size, len(path)) :\n               len(size)<len(path) ? [0, each size, 0] :\n                                     size,\n        k = is_undef(k) ? repeat(default_k,len(path)) :\n            is_num(k) ? repeat(k, len(path)) :\n            len(k)<len(path) ? [0, each k, 0] :\n                               k,\n        badparm = [for(i=idx(parm)) if(parm[i]<0)i],\n        badk = [for(i=idx(k)) if(k[i]<0 || k[i]>1)i]\n     )\n     assert(is_vector(parm) && badparm==[], str(measure,\" must be nonnegative\"))\n     assert(is_vector(k) && badk==[], \"k parameter must be in the interval [0,1]\")\n     let(\n        // dk is a list of parameters, where distance is the joint length to move away from the corner\n        //     \"smooth\" method: [distance, curvature]\n        //     \"circle\" method: [distance, radius]\n        //     \"chamfer\" method: [distance]\n        dk = [\n              for(i=[0:1:len(path)-1])\n                  let(\n                      pathbit = select(path,i-1,i+1),\n                      // This is the half-angle at the corner\n                      angle = approx(pathbit[0],pathbit[1]) || approx(pathbit[1],pathbit[2]) ? undef\n                            : vector_angle(select(path,i-1,i+1))/2\n                  )\n                  (!closed && (i==0 || i==len(path)-1))  ? [0] :          // Force zeros at ends for non-closed\n                  parm[i]==0 ? [0]    : // If no rounding requested then don't try to compute parameters\n                  assert(is_def(angle), str(\"Repeated point in path at index \",i,\" with nonzero rounding\"))\n                  assert(!approx(angle,0), closed && i==0 ? \"Closing the path causes it to turn back on itself at the end\" :\n                                                            str(\"Path turns back on itself at index \",i,\" with nonzero rounding\"))\n                  (method==\"chamfer\" && measure==\"joint\")? [parm[i]] :\n                  (method==\"chamfer\" && measure==\"cut\")  ? [parm[i]/cos(angle)] :\n                  (method==\"chamfer\" && measure==\"width\") ? [parm[i]/sin(angle)/2] :\n                  (method==\"smooth\" && measure==\"joint\") ? [parm[i],k[i]] :\n                  (method==\"smooth\" && measure==\"cut\")   ? [8*parm[i]/cos(angle)/(1+4*k[i]),k[i]] :\n                  (method==\"circle\" && measure==\"radius\")? [parm[i]/tan(angle), parm[i]] :\n                  (method==\"circle\" && measure==\"joint\") ? [parm[i], parm[i]*tan(angle)] : \n                /*(method==\"circle\" && measure==\"cut\")*/   approx(angle,90) ? [INF] : \n                                                           let( circ_radius = parm[i] / (1/sin(angle) - 1))\n                                                           [circ_radius/tan(angle), circ_radius],\n        ],\n        lengths = [for(i=[0:1:len(path)]) norm(select(path,i)-select(path,i-1))],\n        scalefactors = [\n            for(i=[0:1:len(path)-1])\n                if (closed || (i!=0 && i!=len(path)-1))\n                 min(\n                    lengths[i]/(select(dk,i-1)[0]+dk[i][0]),\n                    lengths[i+1]/(dk[i][0]+select(dk,i+1)[0])\n                 )\n        ],\n        dummy = verbose ? echo(\"Roundover scale factors:\",scalefactors) : 0\n    )\n    assert(min(scalefactors)>=1,str(\"Roundovers are too big for the path.  If you multitply them by this vector they should fit: \",scalefactors))\n    // duplicates are introduced when roundings fully consume a segment, so remove them\n    deduplicate([\n        for(i=[0:1:len(path)-1]) each\n            (dk[i][0] == 0)? [path[i]] :\n            (method==\"smooth\")? _bezcorner(select(path,i-1,i+1), dk[i]) :\n            (method==\"chamfer\") ? _chamfcorner(select(path,i-1,i+1), dk[i]) :\n            _circlecorner(select(path,i-1,i+1), dk[i])\n    ]);\n\n// Computes the continuous curvature control points for a corner when given as\n// input three points in a list defining the corner.  The points must be\n// equidistant from each other to produce the continuous curvature result.\n// The output control points will include the 3 input points plus two\n// interpolated points.\n//\n// k is the curvature parameter, ranging from 0 for very slow transition\n// up to 1 for a sharp transition that doesn't have continuous curvature any more\nfunction _smooth_bez_fill(points,k) = [\n        points[0],\n        lerp(points[1],points[0],k),\n        points[1],\n        lerp(points[1],points[2],k),\n        points[2],\n];\n\n// Computes the points of a continuous curvature roundover given as input\n// the list of 3 points defining the corner and a parameter specification\n//\n// If parm is a scalar then it is treated as the curvature and the control\n// points are calculated using _smooth_bez_fill.  Otherwise, parm is assumed\n// to be a pair [d,k] where d is the length of the curve.  The length is\n// calculated from the input point list and the control point list will not\n// necessarily include points[0] or points[2] on its output.\n//\n// The number of points output is $fn if it is set.  Otherwise $fs is used\n// to calculate the point count.\n\nfunction _bezcorner(points, parm) =\n        let(\n                P = is_list(parm)?\n                        let(\n                                d = parm[0],\n                                k = parm[1],\n                                prev = unit(points[0]-points[1]),\n                                next = unit(points[2]-points[1])\n                        ) [\n                                points[1]+d*prev,\n                                points[1]+k*d*prev,\n                                points[1],\n                                points[1]+k*d*next,\n                                points[1]+d*next\n                        ] : _smooth_bez_fill(points,parm),\n                N = max(3,$fn>0 ?$fn : ceil(bezier_length(P)/$fs))\n        )\n        bezier_curve(P,N,endpoint=true);\n\nfunction _chamfcorner(points, parm) =\n        let(\n                d = parm[0],\n                prev = unit(points[0]-points[1]),\n                next = unit(points[2]-points[1])\n          )\n       [points[1]+prev*d, points[1]+next*d];\n\nfunction _circlecorner(points, parm) =\n        let(\n            angle = vector_angle(points)/2,\n            d = parm[0],\n            r = parm[1],\n            prev = unit(points[0]-points[1]),\n            next = unit(points[2]-points[1])\n        )\n        approx(angle,90) ? [points[1]+prev*d, points[1]+next*d] :\n        let(\n            center = r/sin(angle) * unit(prev+next)+points[1],\n                    start = points[1]+prev*d,\n                    end = points[1]+next*d\n        )     // 90-angle is half the angle of the circular arc\n        arc(max(3,ceil((90-angle)/180*segs(r))), cp=center, points=[start,end]);\n\n\n// Used by offset_sweep and convex_offset_extrude.\n// Produce edge profile curve from the edge specification\n// z_dir is the direction multiplier (1 to build up, -1 to build down)\nfunction _rounding_offsets(edgespec,z_dir=1) =\n        let(\n                edgetype = struct_val(edgespec, \"type\"),\n                extra = struct_val(edgespec,\"extra\"),\n                N = struct_val(edgespec, \"steps\"),\n                r = struct_val(edgespec,\"r\"),\n                cut = struct_val(edgespec,\"cut\"),\n                k = struct_val(edgespec,\"k\"),\n                radius = in_list(edgetype,[\"circle\",\"teardrop\"])\n                            ? (is_def(cut) ? cut/(sqrt(2)-1) : r)\n                         :edgetype==\"chamfer\"\n                            ? (is_def(cut) ? sqrt(2)*cut : r)\n                         : undef,\n                chamf_angle = struct_val(edgespec, \"angle\"),\n                cheight = struct_val(edgespec, \"chamfer_height\"),\n                cwidth = struct_val(edgespec, \"chamfer_width\"),\n                chamf_width = first_defined([!all_defined([cut,chamf_angle]) ? undef : cut/cos(chamf_angle),\n                                             cwidth,\n                                             !all_defined([cheight,chamf_angle]) ? undef : cheight*tan(chamf_angle)]),\n                chamf_height = first_defined([\n                                              !all_defined([cut,chamf_angle]) ? undef : cut/sin(chamf_angle),\n                                              cheight,\n                                              !all_defined([cwidth, chamf_angle]) ? undef : cwidth/tan(chamf_angle)]),\n                joint = first_defined([\n                        struct_val(edgespec,\"joint\"),\n                        all_defined([cut,k]) ? 16*cut/sqrt(2)/(1+4*k) : undef\n                ]),\n                points = struct_val(edgespec, \"points\"),\n                argsOK = in_list(edgetype,[\"circle\",\"teardrop\"])? is_def(radius) :\n                        edgetype == \"chamfer\"? chamf_angle>0 && chamf_angle<90 && num_defined([chamf_height,chamf_width])==2 :\n                        edgetype == \"smooth\"? num_defined([k,joint])==2 :\n                        edgetype == \"profile\"? points[0]==[0,0] :\n                        false\n        )\n        assert(argsOK,str(\"Invalid specification with type \",edgetype))\n        let(\n                offsets =\n                        edgetype == \"profile\"? scale([-1,z_dir], p=list_tail(points)) :\n                        edgetype == \"chamfer\"?  chamf_width==0 && chamf_height==0? [] : [[-chamf_width,z_dir*abs(chamf_height)]] :\n                        edgetype == \"teardrop\"? (\n                                radius==0? [] : concat(\n                                        [for(i=[1:N]) [radius*(cos(i*45/N)-1),z_dir*abs(radius)* sin(i*45/N)]],\n                                        [[-2*radius*(1-sqrt(2)/2), z_dir*abs(radius)]]\n                                )\n                        ) :\n                        edgetype == \"circle\"? radius==0? [] : [for(i=[1:N]) [radius*(cos(i*90/N)-1), z_dir*abs(radius)*sin(i*90/N)]] :\n                        /* smooth */ joint==0 ? [] :\n                        list_tail(\n                                _bezcorner([[0,0],[0,z_dir*abs(joint)],[-joint,z_dir*abs(joint)]], k, $fn=N+2)\n                        )\n        )\n        quant(extra > 0 && len(offsets)>0 ? concat(offsets, [last(offsets)+[0,z_dir*extra]]) : offsets, 1/1024);\n\n\n\n// Function: smooth_path()\n// Synopsis: Create smoothed path that passes through all the points of a given path.\n// SynTags: Path\n// Topics: Rounding, Paths\n// See Also: round_corners(), smooth_path(), path_join(), offset_stroke()\n// Usage:\n//   smoothed = smooth_path(path, [tangents], [size=|relsize=], [splinesteps=], [closed=], [uniform=]);\n// Description:\n//   Smooths the input path using a cubic spline.  Every segment of the path will be replaced by a cubic curve\n//   with `splinesteps` points.  The cubic interpolation will pass through every input point on the path\n//   and will match the tangents at every point.  If you do not specify tangents they will be computed using\n//   path_tangents with uniform=false by default.  Note that setting uniform to true with non-uniform\n//   sampling may be desirable in some cases but tends to produces curves that overshoot the point on the path.  \n//   .\n//   The size or relsize parameter determines how far the curve can bend away from\n//   the input path.  In the case where the curve has a single hump, the size specifies the exact distance\n//   between the specified path and the curve.  If you give relsize then it is relative to the segment\n//   length (e.g. 0.05 means 5% of the segment length).  In 2d when the spline may make an S-curve,\n//   in which case the size parameter specifies the sum of the deviations of the two peaks of the curve.  In 3-space\n//   the bezier curve may have three extrema: two maxima and one minimum.  In this case the size specifies\n//   the sum of the maxima minus the minimum.  At a given segment there is a maximum size: if your size\n//   value is too large it will be rounded down.  See also path_to_bezpath().\n// Arguments:\n//   path = path to smooth\n//   tangents = tangents constraining curve direction at each point.  Default: computed automatically\n//   ---\n//   relsize = relative size specification for the curve, a number or vector.  Default: 0.1\n//   size = absolute size specification for the curve, a number or vector\n//   uniform = set to true to compute tangents with uniform=true.  Default: false\n//   closed = true if the curve is closed.  Default: false. \n// Example(2D): Original path in green, smoothed path in yellow:\n//   color(\"green\")stroke(square(4), width=0.1);\n//   stroke(smooth_path(square(4),size=0.4), width=0.1);\n// Example(2D): Closing the path changes the end tangents\n//   polygon(smooth_path(square(4),size=0.4,closed=true));\n// Example(2D): Turning on uniform tangent calculation also changes the end derivatives:\n//   color(\"green\")stroke(square(4), width=0.1);\n//   stroke(smooth_path(square(4),size=0.4,uniform=true),\n//          width=0.1);\n// Example(2D): Here's a wide rectangle.  Using size means all edges bulge the same amount, regardless of their length. \n//   color(\"green\")\n//     stroke(square([10,4]), closed=true, width=0.1);\n//   stroke(smooth_path(square([10,4]),size=1,closed=true),\n//          width=0.1);\n// Example(2D): With relsize the bulge is proportional to the side length. \n//   color(\"green\")stroke(square([10,4]), closed=true, width=0.1);\n//   stroke(smooth_path(square([10,4]),relsize=0.1,closed=true),\n//          width=0.1);\n// Example(2D): Settting uniform to true biases the tangents to aline more with the line sides\n//   color(\"green\")\n//     stroke(square([10,4]), closed=true, width=0.1);\n//   stroke(smooth_path(square([10,4]),uniform=true,\n//                      relsize=0.1,closed=true),\n//          width=0.1);\n// Example(2D): A more interesting shape:\n//   path = [[0,0], [4,0], [7,14], [-3,12]];\n//   polygon(smooth_path(path,size=1,closed=true));\n// Example(2D): Here's the square again with less smoothing.\n//   polygon(smooth_path(square(4), size=.25,closed=true));\n// Example(2D): Here's the square with a size that's too big to achieve, so you get the maximum possible curve:\n//   color(\"green\")stroke(square(4), width=0.1,closed=true);\n//   stroke(smooth_path(square(4), size=4, closed=true),\n//          closed=true,width=.1);\n// Example(2D): You can alter the shape of the curve by specifying your own arbitrary tangent values\n//   polygon(smooth_path(square(4),\n//           tangents=1.25*[[-2,-1], [-4,1], [1,2], [6,-1]],\n//           size=0.4,closed=true));\n// Example(2D): Or you can give a different size for each segment\n//   polygon(smooth_path(square(4),size = [.4, .05, 1, .3],\n//                       closed=true));\n// Example(FlatSpin,VPD=35,VPT=[4.5,4.5,1]):  Works on 3d paths as well\n//   path = [[0,0,0],[3,3,2],[6,0,1],[9,9,0]];\n//   stroke(smooth_path(path,relsize=.1),width=.3);\n// Example(2D): This shows the type of overshoot that can occur with uniform=true.  You can produce overshoots like this if you supply a tangent that is difficult to connect to the adjacent points  \n//   pts = [[-3.3, 1.7], [-3.7, -2.2], [3.8, -4.8], [-0.9, -2.4]];\n//   stroke(smooth_path(pts, uniform=true, relsize=0.1),width=.1);\n//   color(\"red\")move_copies(pts)circle(r=.15,$fn=12);\n// Example(2D): With the default of uniform false no overshoot occurs.  Note that the shape of the curve is quite different.  \n//   pts = [[-3.3, 1.7], [-3.7, -2.2], [3.8, -4.8], [-0.9, -2.4]];\n//   stroke(smooth_path(pts, uniform=false, relsize=0.1),width=.1);\n//   color(\"red\")move_copies(pts)circle(r=.15,$fn=12);\nmodule smooth_path(path, tangents, size, relsize, splinesteps=10, uniform=false, closed=false) {no_module();}\nfunction smooth_path(path, tangents, size, relsize, splinesteps=10, uniform=false, closed) =\n  is_1region(path) ? smooth_path(path[0], tangents, size, relsize, splinesteps, uniform, default(closed,true)) :\n  let (\n     bez = path_to_bezpath(path, tangents=tangents, size=size, relsize=relsize, uniform=uniform, closed=default(closed,false)),\n     smoothed = bezpath_curve(bez,splinesteps=splinesteps)\n  )\n  closed ? list_unwrap(smoothed) : smoothed;\n\n\nfunction _scalar_to_vector(value,length,varname) = \n  is_vector(value)\n    ? assert(len(value)==length, str(varname,\" must be length \",length))\n      value\n    : assert(is_num(value), str(varname, \" must be a numerical value\"))\n      repeat(value, length);\n\n\n// Function: path_join()\n// Synopsis: Join paths end to end with optional rounding.\n// SynTags: Path\n// Topics: Rounding, Paths\n// See Also: round_corners(), smooth_path(), path_join(), offset_stroke()\n// Usage:\n//   joined_path = path_join(paths, [joint], [k=], [relocate=], [closed=]);\n// Description:\n//   Connect a sequence of paths together into a single path with optional continuous curvature rounding\n//   applied at the joints.  By default the first path is taken as specified and subsequent paths are\n//   translated into position so that each path starts where the previous path ended.\n//   If you set relocate to false then this relocation is skipped.\n//   You specify rounding using the `joint` parameter, which specifies the distance away from the corner\n//   where the roundover should start.  The path_join function may remove many path points to cut the path \n//   back by the joint length.  Rounding is using continous curvature 4th order bezier splines and\n//   the parameter `k` specifies how smooth the curvature match is.  This parameter ranges from 0 to 1 with\n//   a default of 0.5.  Use a larger k value to get a curve that is bigger for the same joint value.  When\n//   k=1 the curve may be similar to a circle if your curves are symmetric.  As the path is built up, the joint\n//   parameter applies to the growing path, so if you pick a large joint parameter it may interact with the\n//   previous path sections.  See [Types of Roundover](rounding.scad#subsection-types-of-roundover) for more details\n//   on continuous curvature rounding. \n//   .\n//   The rounding is created by extending the two clipped paths to define a corner point.  If the extensions of\n//   the paths do not intersect, the function issues an error.  When closed=true the final path should actually close\n//   the shape, repeating the starting point of the shape.  If it does not, then the rounding will fill the gap.\n//   .\n//   The number of segments in the roundovers is set based on $fn and $fs.  If you use $fn it specifies the number of\n//   segments in the roundover, regardless of its angular extent.\n// Arguments:\n//   paths = list of paths to join\n//   joint = joint distance, either a number, a pair (giving the previous and next joint distance) or a list of numbers and pairs.  Default: 0\n//   ---\n//   k = curvature parameter, either a number or vector.  Default: 0.5\n//   relocate = set to false to prevent paths from being arranged tail to head.  Default: true\n//   closed = set to true to round the junction between the last and first paths.  Default: false\n// Example(2D): Connection of 3 simple paths.  \n//   horiz = [[0,0],[10,0]];\n//   vert = [[0,0],[0,10]];\n//   stroke(path_join([horiz, vert, -horiz]));\n// Example(2D): Adding curvature with joint of 3\n//   horiz = [[0,0],[10,0]];\n//   vert = [[0,0],[0,10]];\n//   stroke(path_join([horiz, vert, -horiz],joint=3,$fn=16));\n// Example(2D): Setting k=1 increases the amount of curvature\n//   horiz = [[0,0],[10,0]];\n//   vert = [[0,0],[0,10]];\n//   stroke(path_join([horiz, vert, -horiz],joint=3,k=1,$fn=16));\n// Example(2D): Specifying pairs of joint values at a path joint creates an asymmetric curve\n//   horiz = [[0,0],[10,0]];\n//   vert = [[0,0],[0,10]];\n//   stroke(path_join([horiz, vert, -horiz],\n//                    joint=[[4,1],[1,4]],$fn=16),width=.3);\n// Example(2D): A closed square\n//   horiz = [[0,0],[10,0]];\n//   vert = [[0,0],[0,10]];\n//   stroke(path_join([horiz, vert, -horiz, -vert],\n//                    joint=3,k=1,closed=true,$fn=16),closed=true);\n// Example(2D): Different curve at each corner by changing the joint size\n//   horiz = [[0,0],[10,0]];\n//   vert = [[0,0],[0,10]];\n//   stroke(path_join([horiz, vert, -horiz, -vert],\n//                    joint=[3,0,1,2],k=1,closed=true,$fn=16),\n//          closed=true,width=0.4);\n// Example(2D): Different curve at each corner by changing the curvature parameter.  Note that k=0 still gives a small curve, unlike joint=0 which gives a sharp corner.\n//   horiz = [[0,0],[10,0]];\n//   vert = [[0,0],[0,10]];\n//   stroke(path_join([horiz, vert, -horiz, -vert],joint=3,\n//                    k=[1,.5,0,.7],closed=true,$fn=16),\n//          closed=true,width=0.4);\n// Example(2D): Joint value of 7 is larger than half the square so curves interfere with each other, which breaks symmetry because they are computed sequentially\n//   horiz = [[0,0],[10,0]];\n//   vert = [[0,0],[0,10]];\n//   stroke(path_join([horiz, vert, -horiz, -vert],joint=7,\n//                     k=.4,closed=true,$fn=16),\n//          closed=true);\n// Example(2D): Unlike round_corners, we can add curves onto curves.\n//   $fn=64;\n//   myarc = arc(width=20, thickness=5 );\n//   stroke(path_join(repeat(myarc,3), joint=4));\n// Example(2D): Here we make a closed shape from two arcs and round the sharp tips\n//   arc1 = arc(width=20, thickness=4,$fn=75);\n//   arc2 = reverse(arc(width=20, thickness=2,$fn=75));\n//   // Without rounding\n//   stroke(path_join([arc1,arc2]),width=.3);\n//   // With rounding\n//   color(\"red\")stroke(path_join([arc1,arc2], 3,k=1,closed=true),\n//                      width=.3,closed=true,$fn=12); \n// Example(2D): Combining arcs with segments\n//   arc1 = arc(width=20, thickness=4,$fn=75);\n//   arc2 = reverse(arc(width=20, thickness=2,$fn=75));\n//   vpath = [[0,0],[0,-5]];\n//   stroke(path_join([arc1,vpath,arc2,reverse(vpath)]),width=.2);\n//   color(\"red\")stroke(path_join([arc1,vpath,arc2,reverse(vpath)],\n//                                [1,2,2,1],k=1,closed=true),\n//                      width=.2,closed=true,$fn=12);\n// Example(2D): Here relocation is off.  We have three segments (in yellow) and add the curves to the segments.  Notice that joint zero still produces a curve because it refers to the endpoints of the supplied paths.  \n//   p1 = [[0,0],[2,0]];\n//   p2 = [[3,1],[1,3]];\n//   p3 = [[0,3],[-1,1]];\n//   color(\"red\")stroke(\n//     path_join([p1,p2,p3], joint=0, relocate=false,\n//               closed=true),\n//     width=.3,$fn=48);\n//   for(x=[p1,p2,p3]) stroke(x,width=.3);\n// Example(2D): If you specify closed=true when the last path doesn't meet the first one then it is similar to using relocate=false: the function tries to close the path using a curve.  In the example below, this results in a long curve to the left, when given the unclosed three segments as input.  Note that if the segments are parallel the function fails with an error.  The extension of the curves must intersect in a corner for the rounding to be well-defined.  To get a normal rounding of the closed shape, you must include a fourth path, the last segment that closes the shape.\n//   horiz = [[0,0],[10,0]];\n//   vert = [[0,0],[0,10]];\n//   h2 = [[0,-3],[10,0]];\n//   color(\"red\")stroke(\n//     path_join([horiz, vert, -h2],closed=true,\n//               joint=3,$fn=25),\n//     closed=true,width=.5);\n//   stroke(path_join([horiz, vert, -h2]),width=.3);\n// Example(2D): With a single path with closed=true the start and end junction is rounded.\n//   tri = regular_ngon(n=3, r=7);\n//   stroke(path_join([tri], joint=3,closed=true,$fn=12),\n//          closed=true,width=.5);\nmodule path_join(paths,joint=0,k=0.5,relocate=true,closed=false) { no_module();}\nfunction path_join(paths,joint=0,k=0.5,relocate=true,closed=false)=\n  assert(is_list(paths),\"Input paths must be a list of paths\")\n  let(\n      paths = [for(i=idx(paths)) force_path(paths[i],str(\"paths[\",i,\"]\"))],\n      badpath = [for(j=idx(paths)) if (!is_path(paths[j])) j]\n  )\n  assert(badpath==[], str(\"Entries in paths are not valid paths: \",badpath))\n  len(paths)==0 ? [] :\n  len(paths)==1 && !closed ? paths[0] :\n  let(\n      paths = !closed || len(paths)>1\n            ? paths\n            : [list_wrap(paths[0])],\n      N = len(paths) + (closed?0:-1),\n      k = _scalar_to_vector(k,N),\n      repjoint = is_num(joint) || (is_vector(joint,2) && len(paths)!=3),\n      joint = repjoint ? repeat(joint,N) : joint\n  )\n  assert(all_nonnegative(k), \"k must be nonnegative\")\n  assert(len(joint)==N,str(\"Input joint must be scalar or length \",N))\n  let(\n      bad_j = [for(j=idx(joint)) if (!is_num(joint[j]) && !is_vector(joint[j],2)) j]\n  )\n  assert(bad_j==[], str(\"Invalid joint values at indices \",bad_j))\n  let(result=_path_join(paths,joint,k, relocate=relocate, closed=closed))\n  closed ? list_unwrap(result) : result;\n\nfunction _path_join(paths,joint,k=0.5,i=0,result=[],relocate=true,closed=false) =\n  let( \n      result = result==[] ? paths[0] : result,\n      loop = i==len(paths)-1,\n      revresult = reverse(result),\n      nextpath = loop     ? result\n               : relocate ? move(revresult[0]-paths[i+1][0], p=paths[i+1])\n               : paths[i+1],\n      d_first = is_vector(joint[i]) ? joint[i][0] : joint[i],\n      d_next = is_vector(joint[i]) ? joint[i][1] : joint[i]\n  )\n  assert(d_first>=0 && d_next>=0, str(\"Joint value negative when adding path \",i+1))\n  \n  assert(d_first<path_length(revresult),str(\"Path \",i,\" is too short for specified cut distance \",d_first))\n  assert(d_next<path_length(nextpath), str(\"Path \",i+1,\" is too short for specified cut distance \",d_next))\n  let(\n      firstcut = path_cut_points(revresult, d_first, direction=true),\n      nextcut = path_cut_points(nextpath, d_next, direction=true)\n  )\n  assert(!loop || nextcut[1] < len(revresult)-1-firstcut[1], \"Path is too short to close the loop\")\n  let(\n     first_dir=firstcut[2],\n     next_dir=nextcut[2],\n     corner = approx(firstcut[0],nextcut[0]) ? firstcut[0]\n            : line_intersection([firstcut[0], firstcut[0]-first_dir], [nextcut[0], nextcut[0]-next_dir],RAY,RAY)\n  )\n  assert(is_def(corner), str(\"Curve directions at cut points don't intersect in a corner when \",\n                             loop?\"closing the path\":str(\"adding path \",i+1)))\n  let(\n      bezpts = _smooth_bez_fill([firstcut[0], corner, nextcut[0]],k[i]),\n      N = max(3,$fn>0 ?$fn : ceil(bezier_length(bezpts)/$fs)),\n      bezpath = approx(firstcut[0],corner) && approx(corner,nextcut[0])\n                  ? []\n                  : bezier_curve(bezpts,N),\n      new_result = [each select(result,loop?nextcut[1]:0,len(revresult)-1-firstcut[1]),\n                    each bezpath,\n                    nextcut[0],\n                    if (!loop) each list_tail(nextpath,nextcut[1])\n                   ]\n  )\n  i==len(paths)-(closed?1:2)\n     ? new_result\n     : _path_join(paths,joint,k,i+1,new_result, relocate,closed);\n\n\n\n// Function&Module: offset_stroke()\n// Synopsis: Draws a line along a path with options to specify angles and roundings at the ends.\n// SynTags: Path, Region\n// Topics: Rounding, Paths\n// See Also: round_corners(), smooth_path(), path_join(), offset_stroke()\n// Usage: as module\n//   offset_stroke(path, [width], [rounded=], [chamfer=], [start=], [end=], [check_valid=], [quality=], [closed=],...) [ATTACHMENTS];\n// Usage: as function\n//   path = offset_stroke(path, [width], closed=false, [rounded=], [chamfer=], [start=], [end=], [check_valid=], [quality=],...);\n//   region = offset_stroke(path, [width], closed=true, [rounded=], [chamfer=], [start=], [end=], [check_valid=], [quality=],...);\n// Description:\n//   Uses `offset()` to compute a stroke for the input path.  Unlike `stroke`, the result does not need to be\n//   centered on the input path.  The corners can be rounded, pointed, or chamfered, and you can make the ends\n//   rounded, flat or pointed with the `start` and `end` parameters.\n//   .\n//   The `check_valid` and `quality`  parameters are passed through to `offset()`\n//   .\n//   If `width` is a scalar then the output will be a centered stroke of the specified width.  If width\n//   is a list of two values then those two values will define the stroke side positions relative to the center line, where\n//   as with offset(), the shift is to the left for open paths and outward for closed paths.  For example,\n//   setting `width` to `[0,1]` will create a stroke of width 1 that extends entirely to the left of the input, and and [-4,-6]\n//   will create a stroke of width 2 offset 4 units to the right of the input path.\n//   .\n//   If closed==false then the function form will return a path.  If closed==true then it will return a region.  The `start` and\n//   `end` parameters are forbidden for closed paths.\n//   .\n//   Three simple end treatments are supported, \"flat\" (the default), \"round\" and \"pointed\".  The \"flat\" treatment\n//   cuts off the ends perpendicular to the path and the \"round\" treatment applies a semicircle to the end.  The\n//   \"pointed\" end treatment caps the stroke with a centered triangle that has 45 degree angles on each side.\n//   .\n//   More complex end treatments are available through parameter lists with helper functions to ease parameter passing.  The parameter list\n//   keywords are\n//      - \"for\" : must appear first in the list and have the value \"offset_stroke\"\n//      - \"type\": the type of end treatment, one of \"shifted_point\", \"roundover\", or \"flat\"\n//      - \"angle\": relative angle (relative to the path)\n//      - \"abs_angle\": absolute angle (angle relative to x-axis)\n//      - \"cut\": cut distance for roundovers, a single value to round both corners identically or a list of two values for the two corners.  Negative values round outward.\n//      - \"k\": curvature smoothness parameter for roundovers, default 0.75\n//   .\n//   Function helpers for defining ends, prefixed by \"os\" for offset_stroke, are:\n//      - os_flat(angle|absangle): specify a flat end either relative to the path or relative to the x-axis\n//      - os_pointed(dist, [loc]): specify a pointed tip where the point is distance `loc` from the centerline (positive is the left direction as for offset), and `dist` is the distance from the path end to the point tip.  The default value for `loc` is zero (the center).  You must specify `dist` when using this option.\n//      - os_round(cut, [angle|absangle], [k]).  Rounded ends with the specified cut distance, based on the specified angle or absolute angle.  The `k` parameter is the smoothness parameter for continuous curvature rounding.  See [Types of Roundover](rounding.scad#subsection-types-of-roundover) for more details on\n//        continuous curvature rounding.  \n//   .\n//   Note that `offset_stroke()` will attempt to apply roundovers and angles at the ends even when it means deleting segments of the stroke, unlike round_corners which only works on a segment adjacent to a corner.  If you specify an overly extreme angle it will fail to find an intersection with the stroke and display an error.  When you specify an angle the end segment is rotated around the center of the stroke and the last segment of the stroke one one side is extended to the corner.\n//   .\n//   The `$fn` and `$fs` variables are used in the usual way to determine the number of segments for roundings produced by the offset\n//   invocations and roundings produced by the semi-circular \"round\" end treatment.  The os_round() end treatment\n//   uses a bezier curve, and will produce segments of approximate length `$fs` or it will produce `$fn` segments.\n//   (This means that even a quarter circle will have `$fn` segments, unlike the usual case where it would have `$fn/4` segments.)\n// Arguments:\n//   path = 2d path that defines the stroke\n//   width = width of the stroke, a scalar or a vector of 2 values giving the offset from the path.  Default: 1\n//   ---\n//   rounded = set to true to use rounded offsets, false to use sharp (delta) offsets.  Default: true\n//   chamfer = set to true to use chamfers when `rounded=false`.  Default: false\n//   start = end treatment for the start of the stroke when closed=false.  See above for details.  Default: \"flat\"\n//   end = end treatment for the end of the stroke when closed=false.  See above for details.  Default: \"flat\"\n//   check_valid = passed to offset().  Default: true\n//   quality = passed to offset().  Default: 1\n//   closed = true if the curve is closed, false otherwise.  Default: false\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `\"origin\"`\n//   spin = Rotate this many degrees after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   cp = Centerpoint for determining intersection anchors or centering the shape.  Determintes the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 2D point.  Default: \"centroid\"\n//   atype = Set to \"hull\" or \"intersect\" to select anchor type.  Default: \"hull\"\n// Example(2D):  Basic examples illustrating flat, round, and pointed ends, on a finely sampled arc and a path made from 3 segments.\n//   arc = arc(points=[[1,1],[3,4],[6,3]],n=50);\n//   path = [[0,0],[6,2],[9,7],[8,10]];\n//   xdistribute(spacing=10){\n//     offset_stroke(path, width = 2);\n//     offset_stroke(path, start=\"round\", end=\"round\", width = 2);\n//     offset_stroke(path, start=\"pointed\", end=\"pointed\", width = 2);\n//   }\n//   fwd(10) xdistribute(spacing=10){\n//     offset_stroke(arc, width = 2);\n//     offset_stroke(arc, start=\"round\", end=\"round\", width = 2);\n//     offset_stroke(arc, start=\"pointed\", end=\"pointed\", width = 2);\n//   }\n// Example(2D):  The effect of the `rounded` and `chamfer` options is most evident at sharp corners.  This only affects the middle of the path, not the ends.\n//   sharppath = [[0,0], [1.5,5], [3,0]];\n//   xdistribute(spacing=5){\n//     offset_stroke(sharppath, $fn=16);\n//     offset_stroke(sharppath, rounded=false);\n//     offset_stroke(sharppath, rounded=false, chamfer=true);\n//   }\n// Example(2D):  When closed is enabled all the corners are affected by those options.\n//   sharppath = [[0,0], [1.5,5], [3,0]];\n//   xdistribute(spacing=5){\n//     offset_stroke(sharppath,closed=true, $fn=16);\n//     offset_stroke(sharppath, rounded=false, closed=true);\n//     offset_stroke(sharppath, rounded=false, chamfer=true,\n//                   closed=true);\n//   }\n// Example(2D):  The left stroke uses flat ends with a relative angle of zero.  The right hand one uses flat ends with an absolute angle of zero, so the ends are parallel to the x-axis.\n//   path = [[0,0],[6,2],[9,7],[8,10]];\n//   offset_stroke(path, start=os_flat(angle=0), end=os_flat(angle=0));\n//   right(5)\n//     offset_stroke(path, start=os_flat(abs_angle=0), end=os_flat(abs_angle=0));\n// Example(2D):  With continuous sampling the end treatment can remove segments or extend the last segment linearly, as shown here.  Again the left side uses relative angle flat ends and the right hand example uses absolute angle.\n//   arc = arc(points=[[4,0],[3,4],[6,3]],n=50);\n//   offset_stroke(arc, start=os_flat(angle=45), end=os_flat(angle=45));\n//   right(5)\n//     offset_stroke(arc, start=os_flat(abs_angle=45), end=os_flat(abs_angle=45));\n// Example(2D):  The os_pointed() end treatment allows adjustment of the point tip, as shown here.  The width is 2 so a location of 1 is at the edge.\n//   arc = arc(points=[[1,1],[3,4],[6,3]],n=50);\n//   offset_stroke(arc, width=2, start=os_pointed(loc=1,dist=3),end=os_pointed(loc=1,dist=3));\n//   right(10)\n//     offset_stroke(arc, width=2, start=os_pointed(dist=4),end=os_pointed(dist=-1));\n//   fwd(7)\n//     offset_stroke(arc, width=2, start=os_pointed(loc=2,dist=2),end=os_pointed(loc=.5,dist=-1));\n// Example(2D):  The os_round() end treatment adds roundovers to the end corners by specifying the `cut` parameter.  In the first example, the cut parameter is the same at each corner.  The bezier smoothness parameter `k` is given to allow a larger cut.  In the second example, each corner is given a different roundover, including zero for no rounding at all.  The red shows the same strokes without the roundover.\n//   $fn=36;\n//   arc = arc(points=[[1,1],[3,4],[6,3]],n=50);\n//   path = [[0,0],[6,2],[9,7],[8,10]];\n//   offset_stroke(path, width=2, rounded=false,start=os_round(angle=-20, cut=0.4,k=.9),\n//                                              end=os_round(angle=-35, cut=0.4,k=.9));\n//   color(\"red\")down(.1)offset_stroke(path, width=2, rounded=false,start=os_flat(-20),\n//                                                                  end=os_flat(-35));\n//   right(9){\n//     offset_stroke(arc, width=2, rounded=false, start=os_round(cut=[.3,.6],angle=-45),\n//                                                end=os_round(angle=20,cut=[.6,0]));\n//     color(\"red\")down(.1)offset_stroke(arc, width=2, rounded=false, start=os_flat(-45),\n//                                                                    end=os_flat(20));\n//   }\n// Example(2D):  Negative cut values produce a flaring end.  Note how the absolute angle aligns the ends of the first example withi the axes.  In the second example positive and negative cut values are combined.  Note also that very different cuts are needed at the start end to produce a similar looking flare.\n//   arc = arc(points=[[1,1],[3,4],[6,3]],n=50);\n//   path = [[0,0],[6,2],[9,7],[8,10]];\n//   offset_stroke(path, width=2, rounded=false,start=os_round(cut=-1, abs_angle=90),\n//                                              end=os_round(cut=-0.5, abs_angle=0),$fn=36);\n//   right(10)\n//      offset_stroke(arc, width=2, rounded=false, start=os_round(cut=[-.75,-.2], angle=-45),\n//                                                 end=os_round(cut=[-.2,.2], angle=20),$fn=36);\n// Example(2D):  Setting the width to a vector allows you to offset the stroke.  Here with successive increasing offsets we create a set of parallel strokes\n//   path = [[0,0],[4,4],[8,4],[2,9],[10,10]];\n//   for(i=[0:.25:2])\n//     offset_stroke(path, rounded=false,width = [i,i+.08]);\n// Example(2D):  Setting rounded=true in the above example makes a very big difference in the result.  \n//   path = [[0,0],[4,4],[8,4],[2,9],[10,10]];\n//   for(i=[0:.25:2])\n//     offset_stroke(path, rounded=true,width = [i,i+.08], $fn=36);\n// Example(2D):  In this example a spurious triangle appears.  This results from overly enthusiastic validity checking.  Turning validity checking off fixes it in this case.\n//   path = [[0,0],[4,4],[8,4],[2,9],[10,10]];\n//   offset_stroke(path, check_valid=true,rounded=false,\n//                 width = [1.4, 1.5]);\n//   right(2)\n//     offset_stroke(path, check_valid=false,rounded=false,\n//                   width = [1.4, 1.5]);\n// Example(2D):  But in this case, disabling the validity check produces an invalid result.\n//   path = [[0,0],[4,4],[8,4],[2,9],[10,10]];\n//   offset_stroke(path, check_valid=true,rounded=false,\n//                 width = [1.9, 2]);\n//   translate([1,-0.25])\n//     offset_stroke(path, check_valid=false,rounded=false,\n//                   width = [1.9, 2]);\n// Example(2D): Self-intersecting paths are handled differently than with the `stroke()` module.\n//   $fn=16;\n//   path = turtle([\"move\",10,\"left\",144], repeat=4);\n//   stroke(path, closed=true);\n//   right(12)\n//     offset_stroke(path, width=1, closed=true);\nfunction offset_stroke(path, width=1, rounded=true, start, end, check_valid=true, quality=1, chamfer=false, closed=false,\n                       atype=\"hull\", anchor, spin, cp=\"centroid\") =\n        let(path = force_path(path))\n        assert(is_path(path,2),\"path is not a 2d path\")\n        let(\n            closedok = !closed || (is_undef(start) && is_undef(end)),\n            start = default(start,\"flat\"),\n            end = default(end,\"flat\")\n        )\n        assert(closedok, \"Parameters `start` and `end` not allowed with closed path\")\n        let(\n            start = closed? [] : _parse_stroke_end(default(start,\"flat\"),\"start\"),\n            end = closed? [] : _parse_stroke_end(default(end,\"flat\"),\"end\"),\n            width = is_list(width)? reverse(sort(width)) : [1,-1]*width/2,\n            left_r = !rounded? undef : width[0],\n            left_delta = rounded? undef : width[0],\n            right_r = !rounded? undef : width[1],\n            right_delta = rounded? undef : width[1],\n            left_path = offset(\n                    path, delta=left_delta, r=left_r, closed=closed,\n                    check_valid=check_valid, quality=quality,\n                    chamfer=chamfer \n            ),\n            right_path = offset(\n                    path, delta=right_delta, r=right_r, closed=closed,\n                    check_valid=check_valid, quality=quality,\n                    chamfer=chamfer \n            )\n         )\n         closed? let(pts = [left_path, right_path])\n                 reorient(anchor=anchor, spin=spin, two_d=true, region=pts, extent=atype==\"hull\", cp=cp, p=pts)\n         :\n         let(\n             startpath = _stroke_end(width,left_path, right_path, start),\n             endpath = _stroke_end(reverse(width),reverse(right_path), reverse(left_path),end),\n             clipping_ok = startpath[1]+endpath[2]<=len(left_path) && startpath[2]+endpath[1]<=len(right_path)\n         )\n         assert(clipping_ok, \"End treatment removed the whole stroke\")\n         let(\n             pts = concat(\n                          slice(left_path,startpath[1],-1-endpath[2]),\n                          endpath[0],\n                          reverse(slice(right_path,startpath[2],-1-endpath[1])),\n                          startpath[0]\n                  )\n         )\n         reorient(anchor=anchor, spin=spin, two_d=true, path=pts, extent=atype==\"hull\", cp=cp, p=pts);\n\nfunction os_pointed(dist,loc=0) =\n        assert(is_def(dist), \"Must specify `dist`\")\n        [\n                \"for\", \"offset_stroke\",\n                \"type\", \"shifted_point\",\n                \"loc\",loc,\n                \"dist\",dist\n        ];\n\nfunction os_round(cut, angle, abs_angle, k, r) =\n        assert(is_undef(r), \"Radius not supported for os_round with offset_stroke.  (Did you mean os_circle for offset_sweep?)\")\n        let(\n                acount = num_defined([angle,abs_angle]),\n                use_angle = first_defined([angle,abs_angle,0])\n        )\n        assert(acount<2, \"You must define only one of `angle` and `abs_angle`\")\n        assert(is_def(cut), \"Parameter `cut` not defined.\")\n        [\n                \"for\", \"offset_stroke\",\n                \"type\", \"roundover\",\n                \"angle\", use_angle,\n                \"absolute\", is_def(abs_angle),\n                \"cut\", is_vector(cut)? point2d(cut) : [cut,cut],\n                \"k\", first_defined([k, 0.75])\n        ];\n\n\nfunction os_flat(angle, abs_angle) =\n        let(\n                acount = num_defined([angle,abs_angle]),\n                use_angle = first_defined([angle,abs_angle,0])\n        )\n        assert(acount<2, \"You must define only one of `angle` and `abs_angle`\")\n        [\n                \"for\", \"offset_stroke\",\n                \"type\", \"flat\",\n                \"angle\", use_angle,\n                \"absolute\", is_def(abs_angle)\n        ];\n\n\n\n// Return angle in (-90,90] required to map line1 onto line2 (lines specified as lists of two points)\nfunction angle_between_lines(line1,line2) =\n        let(angle = atan2(det2([line1,line2]),line1*line2))\n        angle > 90 ? angle-180 :\n        angle <= -90 ? angle+180 :\n        angle;\n\n\nfunction _parse_stroke_end(spec,name) =\n        is_string(spec)?\n            assert(\n                    in_list(spec,[\"flat\",\"round\",\"pointed\"]),\n                    str(\"Unknown \\\"\",name,\"\\\" string specification \\\"\", spec,\"\\\".  Must be \\\"flat\\\", \\\"round\\\", or \\\"pointed\\\"\")\n            )\n            [[\"type\", spec]]\n        : let(\n              dummy = _struct_valid(spec,\"offset_stroke\",name)\n          )\n          struct_set([], spec);\n\n\nfunction _stroke_end(width,left, right, spec) =\n        let(\n                type = struct_val(spec, \"type\"),\n                user_angle = default(struct_val(spec, \"angle\"), 0),\n                normal_seg = _normal_segment(right[0], left[0]),\n                normal_pt = normal_seg[1],\n                center = normal_seg[0],\n                parallel_dir = unit(left[0]-right[0]),\n                normal_dir = unit(normal_seg[1]-normal_seg[0]),\n                width_dir = sign(width[0]-width[1])\n        )\n        type == \"round\"? [arc(points=[right[0],normal_pt,left[0]],n=ceil(segs(width/2)/2)),1,1]  :\n        type == \"pointed\"? [[normal_pt],0,0] :\n        type == \"shifted_point\"? (\n                let(shiftedcenter = center + width_dir * parallel_dir * struct_val(spec, \"loc\"))\n                [[shiftedcenter+normal_dir*struct_val(spec, \"dist\")],0,0]\n        ) :\n        // Remaining types all support angled cutoff, so compute that\n        assert(abs(user_angle)<=90, \"End angle must be in [-90,90]\")\n        let(\n                angle = struct_val(spec,\"absolute\")?\n                        angle_between_lines(left[0]-right[0],[cos(user_angle),sin(user_angle)]) :\n                        user_angle,\n                endseg = [center, rot(p=[left[0]], angle, cp=center)[0]],\n                intright = angle>0,\n                pathclip = _path_line_intersection(intright? right : left, endseg),\n                pathextend = line_intersection(endseg, select(intright? left:right,0,1))\n        )\n        type == \"flat\"? (\n                intright?\n                        [[pathclip[0], pathextend], 1, pathclip[1]] :\n                        [[pathextend, pathclip[0]], pathclip[1],1]\n        ) :\n        type == \"roundover\"? (\n                let(\n                        bez_k = struct_val(spec,\"k\"),\n                        cut = struct_val(spec,\"cut\"),\n                        cutleft = cut[0],\n                        cutright = cut[1],\n                        // Create updated paths taking into account clipping for end rotation\n                        newright = intright?\n                                concat([pathclip[0]],list_tail(right,pathclip[1])) :\n                                concat([pathextend],list_tail(right)),\n                        newleft = !intright?\n                                concat([pathclip[0]],list_tail(left,pathclip[1])) :\n                                concat([pathextend],list_tail(left)),\n                        // calculate corner angles, which are different when the cut is negative (outside corner)\n                        leftangle = cutleft>=0?\n                                vector_angle([newleft[1],newleft[0],newright[0]])/2 :\n                                90-vector_angle([newleft[1],newleft[0],newright[0]])/2,\n                        rightangle = cutright>=0?\n                                vector_angle([newright[1],newright[0],newleft[0]])/2 :\n                                90-vector_angle([newright[1],newright[0],newleft[0]])/2,\n                        jointleft = 8*cutleft/cos(leftangle)/(1+4*bez_k),\n                        jointright = 8*cutright/cos(rightangle)/(1+4*bez_k),\n                        pathcutleft = path_cut_points(newleft,abs(jointleft)),\n                        pathcutright = path_cut_points(newright,abs(jointright)),\n                        leftdelete = intright? pathcutleft[1] : pathcutleft[1] + pathclip[1] -1,\n                        rightdelete = intright? pathcutright[1] + pathclip[1] -1 : pathcutright[1],\n                        leftcorner = line_intersection([pathcutleft[0], newleft[pathcutleft[1]]], [newright[0],newleft[0]]),\n                        rightcorner = line_intersection([pathcutright[0], newright[pathcutright[1]]], [newright[0],newleft[0]]),\n                        roundover_fits = is_def(rightcorner) && is_def(leftcorner) &&\n                                         jointleft+jointright < norm(rightcorner-leftcorner)\n                )\n                assert(roundover_fits,\"Roundover too large to fit\")\n                let(\n                        angled_dir = unit(newleft[0]-newright[0]),\n                        nPleft = [\n                                leftcorner - jointleft*angled_dir,\n                                leftcorner,\n                                pathcutleft[0]\n                        ],\n                        nPright = [\n                                pathcutright[0],\n                                rightcorner,\n                                rightcorner + jointright*angled_dir\n                        ],\n                        leftcurve = _bezcorner(nPleft, bez_k),\n                        rightcurve = _bezcorner(nPright, bez_k)\n                )\n                [concat(rightcurve, leftcurve), leftdelete, rightdelete]\n        ) : [[],0,0];  // This case shouldn't occur\n\n// returns [intersection_pt, index of first point in path after the intersection]\nfunction _path_line_intersection(path, line, ind=0) =\n        ind==len(path)-1 ? undef :\n        let(intersect=line_intersection(line, select(path,ind,ind+1),LINE,SEGMENT))\n        // If it intersects the segment excluding it's final point, then we're done\n        // The final point is treated as part of the next segment\n        is_def(intersect) && intersect != path[ind+1]?\n                [intersect, ind+1] :\n                _path_line_intersection(path, line, ind+1);\n\nmodule offset_stroke(path, width=1, rounded=true, start, end, check_valid=true, quality=1, chamfer=false, closed=false,\n                     atype=\"hull\", anchor, spin, cp=\"centroid\")\n{\n        result = offset_stroke(\n                path, width=width, rounded=rounded,\n                start=start, end=end,\n                check_valid=check_valid, quality=quality,\n                chamfer=chamfer,\n                closed=closed\n        );\n        region(result,atype=atype, anchor=anchor, spin=spin, cp=cp) children();\n}\n\n\n// Section: Three-Dimensional Rounding\n\n// Function&Module: offset_sweep()\n// Synopsis: Make a solid from a polygon with offset that changes along its length.\n// SynTags: Geom, VNF\n// Topics: Rounding, Offsets\n// See Also: convex_offset_extrude(), rounded_prism(), bent_cutout_mask(), join_prism(), linear_sweep()\n// Usage: most common module arguments.  See Arguments list below for more.\n//   offset_sweep(path, [height|length|h|l|], [bottom], [top], [offset=], [convexity=],...) [ATTACHMENTS];\n// Usage: most common function arguments.  See Arguments list below for more.\n//   vnf = offset_sweep(path, [height|h|l|length], [bottom], [top], [offset=], ...);\n// Description:\n//   Takes a 2d path as input and extrudes it upwards and/or downward.  Each layer in the extrusion is produced using `offset()` to expand or shrink the previous layer.  When invoked as a function returns a VNF; when invoked as a module produces geometry.  \n//   Using the `top` and/or `bottom` arguments you can specify a sequence of offsets values, or you can use several built-in offset profiles that\n//   provide end treatments such as roundovers.\n//   The height of the resulting object can be specified using the `height` argument, in which case `height` must be larger than the combined height\n//   of the end treatments.  If you omit `height` then the object height will be the height of just the top and bottom end treatments.  \n//   .\n//   The path is shifted by `offset()` multiple times in sequence\n//   to produce the final shape (not multiple shifts from one parent), so coarse definition of the input path will degrade\n//   from the successive shifts.  If the result seems rough or strange try increasing the number of points you use for\n//   your input.  If you get unexpected corners in your result you may have forgotten to set `$fn` or `$fa` and `$fs`.  \n//   Be aware that large numbers of points (especially when check_valid is true) can lead to lengthy run times.  If your\n//   shape doesn't develop new corners from the offsetting you may be able to save a lot of time by setting `check_valid=false`.  Be aware that\n//   disabling the validity check when it is needed can generate invalid polyhedra that will produce CGAL errors upon\n//   rendering.  Such validity errors will also occur if you specify a self-intersecting shape.\n//   The offset profile is quantized to 1/1024 steps to avoid failures in offset() that can occur with very tiny offsets.\n//   .\n//   The build-in profiles are: circular rounding, teardrop rounding, continuous curvature rounding, and chamfer.\n//   Also note that when a rounding radius is negative the rounding will flare outwards.  The easiest way to specify\n//   the profile is by using the profile helper functions.  These functions take profile parameters, as well as some\n//   general settings and translate them into a profile specification, with error checking on your input.  The description below\n//   describes the helper functions and the parameters specific to each function.  Below that is a description of the generic\n//   settings that you can optionally use with all of the helper functions.  For more details on the \"cut\" and \"joint\" rounding parameters, and\n//   on continuous curvature rounding, see [Types of Roundover](rounding.scad#subsection-types-of-roundover). \n//   .\n//   - profile: os_profile(points)\n//     Define the offset profile with a list of points.  The first point must be [0,0] and the roundover should rise in the positive y direction, with positive x values for inward motion (standard roundover) and negative x values for flaring outward.  If the y value ever decreases then you might create a self-intersecting polyhedron, which is invalid.  Such invalid polyhedra will create cryptic assertion errors when you render your model and it is your responsibility to avoid creating them.  Note that the starting point of the profile is the center of the extrusion.  If you use a profile as the top it will rise upwards.  If you use it as the bottom it will be inverted, and will go downward.\n//   - circle: os_circle(r|cut).  Define circular rounding either by specifying the radius or cut distance.\n//   - smooth: os_smooth(cut|joint, [k]).  Define continuous curvature rounding, with `cut` and `joint` as for round_corners. The k parameter controls how fast the curvature changes and should be between 0 and 1.  \n//   - teardrop: os_teardrop(r|cut).  Rounding using a 1/8 circle that then changes to a 45 degree chamfer.  The chamfer is at the end, and enables the object to be 3d printed without support.  The radius gives the radius of the circular part.\n//   - chamfer: os_chamfer([height], [width], [cut], [angle]).  Chamfer the edge at desired angle or with desired height and width.  You can specify height and width together and the angle will be ignored, or specify just one of height and width and the angle is used to determine the shape.  Alternatively, specify \"cut\" along with angle to specify the cut back distance of the chamfer.\n//   - mask: os_mask(mask, [out]).  Create a profile from one of the [2d masking shapes](shapes2d.scad#5-2d-masking-shapes).  The `out` parameter specifies that the mask should flare outward (like crown molding or baseboard).  This is set false by default.  \n//   .\n//   The general settings that you can use with all of the helper functions are mostly used to control how offset_sweep() calls the offset() function.\n//   - extra: Add an extra vertical step of the specified height, to be used for intersections or differences.  This extra step will extend the resulting object beyond the height you specify.  Default: 0\n//   - check_valid: passed to offset().  Default: true\n//   - quality: passed to offset().  Default: 1\n//   - steps: Number of vertical steps to use for the profile.  (Not used by os_profile).  Default: 16\n//   - offset: Select \"round\" (r=) or \"delta\" (delta=) offset types for offset. You can also choose \"chamfer\" but this leads to exponential growth in the number of vertices with the steps parameter.  Default: \"round\"\n//   .\n//   Many of the arguments are described as setting \"default\" values because they establish settings which may be overridden by\n//   the top and bottom profile specifications.\n//   .\n//   You will generally want to use the above helper functions to generate the profiles.\n//   The profile specification is a list of pairs of keywords and values, e.g. [\"for\",\"offset_sweep\",\"r\",12, type, \"circle\"]. The keywords are\n//   - \"for\" - must appear first in the list and have the value \"offset_sweep\"\n//   - \"type\" - type of rounding to apply, one of \"circle\", \"teardrop\", \"chamfer\", \"smooth\", or \"profile\" (Default: \"circle\")\n//   - \"r\" - the radius of the roundover, which may be zero for no roundover, or negative to round or flare outward.  Default: 0\n//   - \"cut\" - the cut distance for the roundover or chamfer, which may be negative for flares\n//   - \"chamfer_width\" - the width of a chamfer\n//   - \"chamfer_height\" - the height of a chamfer\n//   - \"angle\" - the chamfer angle, measured from the vertical (so zero is vertical, 90 is horizontal).  Default: 45\n//   - \"joint\" - the joint distance for a \"smooth\" roundover\n//   - \"k\" - the curvature smoothness parameter for \"smooth\" roundovers, a value in [0,1].  Default: 0.75\n//   - \"points\" - point list for use with the \"profile\" type\n//   - \"extra\" - extra height added for unions/differences.  This makes the shape taller than the requested height.  (Default: 0)\n//   - \"check_valid\" - passed to offset.  Default: true.\n//   - \"quality\" - passed to offset.  Default: 1.\n//   - \"steps\" - number of vertical steps to use for the roundover.  Default: 16.\n//   - \"offset\" - select \"round\" (r=), \"delta\" (delta=), or \"chamfer\" offset type for offset.  Default: \"round\"\n//   .\n//   Note that if you set the \"offset\" parameter to \"chamfer\" then every exterior corner turns from one vertex into two vertices with\n//   each offset operation.  Since the offsets are done one after another, each on the output of the previous one, this leads to\n//   exponential growth in the number of vertices.  This can lead to long run times or yield models that\n//   run out of recursion depth and give a cryptic error.  Furthermore, the generated vertices are distributed non-uniformly.  Generally you\n//   will get a similar or better looking model with fewer vertices using \"round\" instead of\n//   \"chamfer\".  Use the \"chamfer\" style offset only in cases where the number of steps is very small or just one (such as when using\n//   the `os_chamfer` profile type).\n//\n// Arguments:\n//   path = 2d path (list of points) to extrude\n//   height / l / h = total height (including rounded portions, but not extra sections) of the output.  Default: combined height of top and bottom end treatments.\n//   bottom = rounding spec for the bottom end\n//   top = rounding spec for the top end.\n//   ---\n//   offset = default offset, `\"round\"` or `\"delta\"`.  Default: `\"round\"`\n//   steps = default step count.  Default: 16\n//   quality = default quality.  Default: 1\n//   check_valid = default check_valid.  Default: true.\n//   extra = default extra height.  Default: 0\n//   cut = default cut value.\n//   chamfer_width = default width value for chamfers.\n//   chamfer_height = default height value for chamfers.\n//   angle = default angle for chamfers.  Default: 45\n//   joint = default joint value for smooth roundover.\n//   k = default curvature parameter value for \"smooth\" roundover\n//   convexity = convexity setting for use with polyhedron.  (module only) Default: 10\n//   anchor = Translate so anchor point is at the origin.  (module only) Default: \"origin\"\n//   spin = Rotate this many degrees around Z axis after anchor.  (module only) Default: 0\n//   orient = Vector to rotate top towards after spin  (module only)\n//   atype = Select \"hull\", \"intersect\", \"surf_hull\" or \"surf_intersect\" anchor types.  Default: \"hull\"\n//   cp = Centerpoint for determining \"intersect\" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 3D point.  Default: \"centroid\"\n// Anchor Types:\n//   hull = Anchors to the convex hull of the linear sweep of the path, ignoring any end roundings. \n//   intersect = Anchors to the surface of the linear sweep of the path, ignoring any end roundings.\n//   surf_hull = Anchors to the convex hull of the offset_sweep shape, including end treatments.\n//   surf_intersect = Anchors to the surface of the offset_sweep shape, including any end treatments.\n// Example: Rounding a star shaped prism with postive radius values\n//   star = star(5, r=22, ir=13);\n//   rounded_star = round_corners(star, cut=flatten(repeat([.5,0],5)), $fn=24);\n//   offset_sweep(rounded_star, height=20, bottom=os_circle(r=4), top=os_circle(r=1), steps=15);\n// Example: Rounding a star shaped prism with negative radius values.  The starting shape has no corners, so the value of `$fn` does not matter.\n//   star = star(5, r=22, ir=13); \n//   rounded_star = round_corners(star, cut=flatten(repeat([.5,0],5)), $fn=36);\n//   offset_sweep(rounded_star, height=20, bottom=os_circle(r=-4), top=os_circle(r=-1), steps=15);\n// Example: If the shape has sharp corners, make sure to set `$fn/$fs/$fa`.  The corners of this triangle are not round, even though `offset=\"round\"` (the default) because the number of segments is small.\n//   triangle = [[0,0],[10,0],[5,10]];\n//   offset_sweep(triangle, height=6, bottom = os_circle(r=-2),steps=4);\n// Example: Can improve the result by increasing `$fn`\n//   $fn=12;\n//   triangle = [[0,0],[10,0],[5,10]];\n//   offset_sweep(triangle, height=6, bottom = os_circle(r=-2),steps=4);\n// Example: Using `$fa` and `$fs` works too; it produces a different looking triangulation of the rounded corner\n//   $fa=1;$fs=0.3;\n//   triangle = [[0,0],[10,0],[5,10]];\n//   offset_sweep(triangle, height=6, bottom = os_circle(r=-2),steps=4);\n// Example: Here is the star chamfered at the top with a teardrop rounding at the bottom. Check out the rounded corners on the chamfer.  The large `$fn` value ensures a smooth curve on the concave corners of the chamfer.  It has no effect anywhere else on the model.  Observe how the rounded star points vanish at the bottom in the teardrop: the number of vertices does not remain constant from layer to layer.\n//    star = star(5, r=22, ir=13);\n//    rounded_star = round_corners(star, cut=flatten(repeat([.5,0],5)), $fn=24);\n//    offset_sweep(rounded_star, height=20, bottom=os_teardrop(r=4), top=os_chamfer(width=4),$fn=64);\n// Example: We round a cube using the continous curvature rounding profile.  But note that the corners are not smooth because the curved square collapses into a square with corners.    When a collapse like this occurs, we cannot turn `check_valid` off.  For a better result use `rounded_prism()` instead.\n//   square = square(1);\n//   rsquare = round_corners(square, method=\"smooth\", cut=0.1, k=0.7, $fn=36);\n//   end_spec = os_smooth(cut=0.1, k=0.7, steps=22);\n//   offset_sweep(rsquare, height=1, bottom=end_spec, top=end_spec);\n// Example(3D,Med): A nice rounded box, with a teardrop base and circular rounded interior and top\n//   box = square([255,50]);\n//   rbox = round_corners(box, method=\"smooth\", cut=4, $fn=12);\n//   thickness = 2;\n//   difference(){\n//     offset_sweep(rbox, height=50, check_valid=false, steps=22,\n//                  bottom=os_teardrop(r=2), top=os_circle(r=1));\n//     up(thickness)\n//       offset_sweep(offset(rbox, r=-thickness, closed=true,check_valid=false),\n//                    height=48, steps=22, check_valid=false,\n//                    bottom=os_circle(r=4), top=os_circle(r=-1,extra=1));\n//   }\n// Example: This box is much thicker, and cut in half to show the profiles.  Note also that we can turn `check_valid` off for the outside and for the top inside, but not for the bottom inside.  This example shows use of the direct keyword syntax without the helper functions.\n//   smallbox = square([75,50]);\n//   roundbox = round_corners(smallbox, method=\"smooth\", cut=4, $fn=12);\n//   thickness=4;\n//   height=50;\n//   back_half(y=25, s=200)\n//     difference(){\n//       offset_sweep(roundbox, height=height, bottom=[\"for\",\"offset_sweep\",\"r\",10,\"type\",\"teardrop\"],\n//                                             top=[\"for\",\"offset_sweep\",\"r\",2], steps = 22, check_valid=false);\n//       up(thickness)\n//         offset_sweep(offset(roundbox, r=-thickness, closed=true),\n//                       height=height-thickness, steps=22,\n//                       bottom=[\"for\",\"offset_sweep\",\"r\",6],\n//                       top=[\"for\",\"offset_sweep\",\"type\",\"chamfer\",\"angle\",30,\n//                            \"chamfer_height\",-3,\"extra\",1,\"check_valid\",false]);\n//   }\n// Example(3D,Med): A box with multiple sections and rounded dividers\n//   thickness = 2;\n//   box = square([255,50]);\n//   cutpoints = [0, 125, 190, 255];\n//   rbox = round_corners(box, method=\"smooth\", cut=4, $fn=12);\n//   back_half(y=25, s=700)\n//     difference(){\n//       offset_sweep(rbox, height=50, check_valid=false, steps=22,\n//                    bottom=os_teardrop(r=2), top=os_circle(r=1));\n//       up(thickness)\n//         for(i=[0:2]){\n//           ofs = i==1 ? 2 : 0;\n//           hole = round_corners([[cutpoints[i]-ofs,0], [cutpoints[i]-ofs,50],\n//                                 [cutpoints[i+1]+ofs, 50], [cutpoints[i+1]+ofs,0]],\n//                                method=\"smooth\", cut=4, $fn=36);\n//           offset_sweep(offset(hole, r=-thickness, closed=true,check_valid=false),\n//                         height=48, steps=22, check_valid=false,\n//                         bottom=os_circle(r=4), top=os_circle(r=-1,extra=1));\n//         }\n//     }\n// Example(3D,Med): Star shaped box\n//   star = star(5, r=22, ir=13);\n//   rounded_star = round_corners(star, cut=flatten(repeat([.5,0],5)), $fn=24);\n//   thickness = 2;\n//   ht=20;\n//   difference(){\n//     offset_sweep(rounded_star, height=ht, bottom=[\"for\",\"offset_sweep\",\"r\",4],\n//                                           top=[\"for\",\"offset_sweep\",\"r\",1], steps=15);\n//     up(thickness)\n//         offset_sweep(offset(rounded_star,r=-thickness,closed=true),\n//                       height=ht-thickness, check_valid=false,\n//                       bottom=os_circle(r=7), top=os_circle(r=-1, extra=1),$fn=40);\n//     }\n// Example: A profile defined by an arbitrary sequence of points.\n//   star = star(5, r=22, ir=13);\n//   rounded_star = round_corners(star, cut=flatten(repeat([.5,0],5)), $fn=24);\n//   profile = os_profile(points=[[0,0],[.3,.1],[.6,.3],[.9,.9], [1.2, 2.7],[.8,2.7],[.8,3]]);\n//   offset_sweep(reverse(rounded_star), height=20, top=profile, bottom=profile, $fn=32);\n// Example: Parabolic rounding\n//   star = star(5, r=22, ir=13);\n//   rounded_star = round_corners(star, cut=flatten(repeat([.5,0],5)), $fn=24);\n//   offset_sweep(rounded_star, height=20, top=os_profile(points=[for(r=[0:.1:2])[sqr(r),r]]),\n//                                          bottom=os_profile(points=[for(r=[0:.2:5])[-sqrt(r),r]]),$fn=32);\n// Example: This example uses a sine wave offset profile.  Note that we give no specification for the bottom, so it is straight.\n//   sq = [[0,0],[20,0],[20,20],[0,20]];\n//   sinwave = os_profile(points=[for(theta=[0:5:720]) [4*sin(theta), theta/700*15]]);\n//   offset_sweep(sq, height=20, top=sinwave, $fn=32);\n// Example: The same as the previous example but `offset=\"delta\"`\n//   sq = [[0,0],[20,0],[20,20],[0,20]];\n//   sinwave = os_profile(points=[for(theta=[0:5:720]) [4*sin(theta), theta/700*15]]);\n//   offset_sweep(sq, height=20, top=sinwave, offset=\"delta\");\n// Example: a box with a flared top.  A nice roundover on the top requires a profile edge, but we can use \"extra\" to create a small chamfer.\n//   rhex = round_corners(hexagon(side=10), method=\"smooth\", joint=2, $fs=0.2);\n//   back_half()\n//     difference(){\n//       offset_sweep(rhex, height=10, bottom=os_teardrop(r=2), top=os_teardrop(r=-4, extra=0.2));\n//       up(1)\n//         offset_sweep(offset(rhex,r=-1), height=9.5, bottom=os_circle(r=2), top=os_teardrop(r=-4));\n//     }\n// Example: Using os_mask to create ogee profiles:\n//   ogee = mask2d_ogee([\n//       \"xstep\",1,  \"ystep\",1,  // Starting shoulder.\n//       \"fillet\",5, \"round\",5,  // S-curve.\n//       \"ystep\",1,              // Ending shoulder.\n//   ]);\n//   star = star(5, r=220, ir=130);\n//   rounded_star = round_corners(star, cut=flatten(repeat([5,0],5)), $fn=24);\n//   offset_sweep(rounded_star, height=100, top=os_mask(ogee), bottom=os_mask(ogee,out=true));\n\n\n// This function does the actual work of repeatedly calling offset() and concatenating the resulting face and vertex lists to produce\n// the inputs for the polyhedron module.\nfunction _make_offset_polyhedron(path,offsets, offset_type, flip_faces, quality, check_valid, offsetind=0,\n                                 vertexcount=0, vertices=[], faces=[] )=\n        offsetind==len(offsets)? (\n                let(\n                        bottom = count(len(path),vertexcount),\n                        oriented_bottom = !flip_faces? bottom : reverse(bottom)\n                ) [vertices, concat(faces,[oriented_bottom])]\n        ) : (\n                let(\n                        this_offset = offsetind==0? offsets[0][0] : offsets[offsetind][0] - offsets[offsetind-1][0],\n                        delta = offset_type==\"delta\" || offset_type==\"chamfer\" ? this_offset : undef,\n                        r = offset_type==\"round\"? this_offset : undef,\n                        do_chamfer = offset_type == \"chamfer\"\n                )\n                let(\n                        vertices_faces = offset(\n                                path, r=r, delta=delta, chamfer = do_chamfer, closed=true,\n                                check_valid=check_valid, quality=quality,\n                                return_faces=true,\n                                firstface_index=vertexcount,\n                                flip_faces=flip_faces\n                        )\n                )\n                _make_offset_polyhedron(\n                        vertices_faces[0], offsets, offset_type,\n                        flip_faces, quality, check_valid, \n                        offsetind+1, vertexcount+len(path),\n                        vertices=concat(\n                                vertices,\n                                path3d(vertices_faces[0],offsets[offsetind][1])\n                        ),\n                        faces=concat(faces, vertices_faces[1])\n                )\n        );\n\n\nfunction _struct_valid(spec, func, name) =\n        spec==[] ? true :\n        assert(is_list(spec) && len(spec)>=2 && spec[0]==\"for\",str(\"Specification for \\\"\", name, \"\\\" is an invalid structure\"))\n        assert(spec[1]==func, str(\"Specification for \\\"\",name,\"\\\" is for a different function (\",func,\")\"));\n\nfunction offset_sweep(\n                       path, height, \n                       bottom=[], top=[], \n                       h, l, length, \n                       offset=\"round\", r=0, steps=16,\n                       quality=1, check_valid=true,\n                       extra=0,\n                       cut=undef, chamfer_width=undef, chamfer_height=undef,\n                       joint=undef, k=0.75, angle=45\n                      ) =\n    let(\n        argspec = [\n                   [\"for\",\"\"],\n                   [\"r\",r],\n                   [\"extra\",extra],\n                   [\"type\",\"circle\"],\n                   [\"check_valid\",check_valid],\n                   [\"quality\",quality],\n                   [\"steps\",steps],\n                   [\"offset\",offset],\n                   [\"chamfer_width\",chamfer_width],\n                   [\"chamfer_height\",chamfer_height],\n                   [\"angle\",angle],\n                   [\"cut\",cut],\n                   [\"joint\",joint],\n                   [\"k\", k],\n                   [\"points\", []],\n        ],\n        path = force_path(path)\n    )\n    assert(is_path(path,2), \"Input path must be a 2D path\")\n    let(\n        clockwise = is_polygon_clockwise(path),\n        dummy1 = _struct_valid(top,\"offset_sweep\",\"top\"),\n        dummy2 = _struct_valid(bottom,\"offset_sweep\",\"bottom\"),\n        top = struct_set(argspec, top, grow=false),\n        bottom = struct_set(argspec, bottom, grow=false),\n\n        //  This code does not work.  It hits the error in _make_offset_polyhedron from offset being wrong\n        //  before this code executes.  Had to move the test into _make_offset_polyhedron, which is ugly since it's in the loop\n        offsetsok = in_list(struct_val(top, \"offset\"),[\"round\",\"delta\",\"chamfer\"])\n                    && in_list(struct_val(bottom, \"offset\"),[\"round\",\"delta\",\"chamfer\"])\n    )\n    assert(offsetsok,\"Offsets must be one of \\\"round\\\", \\\"delta\\\", or \\\"chamfer\\\"\")\n    let(\n        offsets_bot = _rounding_offsets(bottom, -1),\n        offsets_top = _rounding_offsets(top, 1),\n        dummy = (struct_val(top,\"offset\")==\"chamfer\" && len(offsets_top)>5)\n                        || (struct_val(bottom,\"offset\")==\"chamfer\" && len(offsets_bot)>5)\n                ? echo(\"WARNING: You have selected offset=\\\"chamfer\\\", which leads to exponential growth in the vertex count and requested more than 5 layers.  This can be slow or run out of recursion depth.\")\n                : 0,\n\n        // \"Extra\" height enlarges the result beyond the requested height, so subtract it\n        bottom_height = len(offsets_bot)==0 ? 0 : abs(last(offsets_bot)[1]) - struct_val(bottom,\"extra\"),\n        top_height = len(offsets_top)==0 ? 0 : abs(last(offsets_top)[1]) - struct_val(top,\"extra\"),\n\n        height = one_defined([l,h,height,length], \"l,h,height,length\", dflt=u_add(bottom_height,top_height)),\n        middle = height-bottom_height-top_height\n    )\n    assert(height>0, \"Height must be positive\") \n    assert(middle>=0, str(\"Specified end treatments (bottom height = \",bottom_height,\n                          \" top_height = \",top_height,\") are too large for extrusion height (\",height,\")\"\n                         )\n    )\n    let(\n        initial_vertices_bot = path3d(path),\n\n        vertices_faces_bot = _make_offset_polyhedron(\n                path, offsets_bot, struct_val(bottom,\"offset\"), clockwise,\n                struct_val(bottom,\"quality\"),\n                struct_val(bottom,\"check_valid\"),\n                vertices=initial_vertices_bot\n        ),\n\n        top_start_ind = len(vertices_faces_bot[0]),\n        initial_vertices_top = path3d(path, middle),\n        vertices_faces_top = _make_offset_polyhedron(\n                path, move(p=offsets_top,[0,middle]),\n                struct_val(top,\"offset\"), !clockwise,\n                struct_val(top,\"quality\"),\n                struct_val(top,\"check_valid\"),\n                vertexcount=top_start_ind,\n                vertices=initial_vertices_top\n        ),\n        middle_faces = middle==0 ? [] : [\n                for(i=[0:len(path)-1]) let(\n                        oneface=[i, (i+1)%len(path), top_start_ind+(i+1)%len(path), top_start_ind+i]\n                ) !clockwise ? reverse(oneface) : oneface\n        ]\n    )\n    [up(bottom_height, concat(vertices_faces_bot[0],vertices_faces_top[0])),  // Vertices\n     concat(vertices_faces_bot[1], vertices_faces_top[1], middle_faces)];     // Faces\n\n\nmodule offset_sweep(path, height, \n                    bottom=[], top=[], \n                    h, l,\n                    offset=\"round\", r=0, steps=16,\n                    quality=1, check_valid=true,\n                    extra=0,\n                    cut=undef, chamfer_width=undef, chamfer_height=undef,\n                    joint=undef, k=0.75, angle=45,\n                    convexity=10,anchor=\"origin\",cp=\"centroid\",\n                    spin=0, orient=UP, atype=\"hull\")\n{\n    assert(in_list(atype, [\"intersect\",\"hull\",\"surf_hull\",\"surf_intersect\"]), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\");\n    vnf = offset_sweep(path=path, height=height, h=h, l=l, top=top, bottom=bottom, offset=offset, r=r, steps=steps,\n                       quality=quality, check_valid=check_valid, extra=extra, cut=cut, chamfer_width=chamfer_width,\n                       chamfer_height=chamfer_height, joint=joint, k=k, angle=angle);\n\n    if (in_list(atype,[\"hull\",\"intersect\"])){\n        h=first_defined([h,l,height]);\n        attachable(anchor,spin,orient,region=[path],h=h,extent=atype==\"hull\",cp=cp){\n            down(h/2)polyhedron(vnf[0],vnf[1],convexity=convexity);\n            children();\n        }\n    }\n    else\n        vnf_polyhedron(vnf,convexity=convexity,anchor=anchor, spin=spin, orient=orient, atype=atype==\"surf_hull\"?\"hull\":\"intersect\", cp=cp)\n            children();\n}   \n\n\n\nfunction os_circle(r,cut,extra,check_valid, quality,steps, offset) =\n        assert(num_defined([r,cut])==1, \"Must define exactly one of `r` and `cut`\")\n        _remove_undefined_vals([\n                \"for\", \"offset_sweep\",\n                \"type\", \"circle\",\n                \"r\",r,\n                \"cut\",cut,\n                \"extra\",extra,\n                \"check_valid\",check_valid,\n                \"quality\", quality,\n                \"steps\", steps,\n                \"offset\", offset\n        ]);\n\nfunction os_teardrop(r,cut,extra,check_valid, quality,steps, offset) =\n        assert(num_defined([r,cut])==1, \"Must define exactly one of `r` and `cut`\")\n        _remove_undefined_vals([\n                \"for\", \"offset_sweep\",\n                \"type\", \"teardrop\",\n                \"r\",r,\n                \"cut\",cut,\n                \"extra\",extra,\n                \"check_valid\",check_valid,\n                \"quality\", quality,\n                \"steps\", steps,\n                \"offset\", offset\n        ]);\n\nfunction os_chamfer(height, width, cut, angle, extra,check_valid, quality,steps, offset) =\n        let(ok = (is_def(cut) && num_defined([height,width])==0) || num_defined([height,width])>0)\n        assert(ok, \"Must define `cut`, or one or both of `width` and `height`\")\n        _remove_undefined_vals([\n                \"for\", \"offset_sweep\",\n                \"type\", \"chamfer\",\n                \"chamfer_width\",width,\n                \"chamfer_height\",height,\n                \"cut\",cut,\n                \"angle\",angle,\n                \"extra\",extra,\n                \"check_valid\",check_valid,\n                \"quality\", quality,\n                \"steps\", steps,\n                \"offset\", offset\n        ]);\n\nfunction os_smooth(cut, joint, k, extra,check_valid, quality,steps, offset) =\n        assert(num_defined([joint,cut])==1, \"Must define exactly one of `joint` and `cut`\")\n        _remove_undefined_vals([\n                \"for\", \"offset_sweep\",\n                \"type\", \"smooth\",\n                \"joint\",joint,\n                \"k\",k,\n                \"cut\",cut,\n                \"extra\",extra,\n                \"check_valid\",check_valid,\n                \"quality\", quality,\n                \"steps\", steps,\n                \"offset\", offset\n        ]);\n\nfunction os_profile(points, extra,check_valid, quality, offset) =\n        assert(is_path(points),\"Profile point list is not valid\")\n        _remove_undefined_vals([\n                \"for\", \"offset_sweep\",\n                \"type\", \"profile\",\n                \"points\", points,\n                \"extra\",extra,\n                \"check_valid\",check_valid,\n                \"quality\", quality,\n                \"offset\", offset\n        ]);\n\n\nfunction os_mask(mask, out=false, extra,check_valid, quality, offset) =\n  let(\n      origin_index = [for(i=idx(mask)) if (mask[i].x<0 && mask[i].y<0) i],\n      xfactor = out ? -1 : 1\n  )\n  assert(len(origin_index)==1,\"Cannot find origin in the mask\")\n  let(\n      points = ([for(pt=list_rotate(mask,origin_index[0])) [xfactor*max(pt.x,0),-max(pt.y,0)]])\n  )\n  os_profile(deduplicate(move(-points[1],p=list_tail(points))), extra,check_valid,quality,offset);\n\n\n// Module: convex_offset_extrude()\n// Synopsis: Make a solid from geometry where offset changes along the object's length.\n// SynTags: Geom\n// Topics: Rounding, Offsets\n// See Also: offset_sweep(), rounded_prism(), bent_cutout_mask(), join_prism(), linear_sweep()\n// Usage: Basic usage.  See below for full options\n//   convex_offset_extrude(height, [bottom], [top], ...) 2D-CHILDREN;\n// Description:\n//   Extrudes 2d children with layers formed from the convex hull of the offset of each child according to a sequence of offset values.\n//   Like `offset_sweep` this module can use built-in offset profiles to provide treatments such as roundovers or chamfers but unlike `offset_sweep()` it\n//   operates on 2d children rather than a point list.  Each offset is computed using\n//   the native `offset()` module from the input geometry.\n//   If your shape has corners that you want rounded by offset be sure to set `$fn` or `$fs` appropriately.\n//   If your geometry has internal holes or is too small for the specified offset then you may get\n//   unexpected results.\n//   .\n//   The build-in profiles are: circular rounding, teardrop rounding, continuous curvature rounding, and chamfer.\n//   Also note that when a rounding radius is negative the rounding will flare outwards.  The easiest way to specify\n//   the profile is by using the profile helper functions.  These functions take profile parameters, as well as some\n//   general settings and translate them into a profile specification, with error checking on your input.  The description below\n//   describes the helper functions and the parameters specific to each function.  Below that is a description of the generic\n//   settings that you can optionally use with all of the helper functions.\n//   For more details on the \"cut\" and \"joint\" rounding parameters, and\n//   on continuous curvature rounding, see [Types of Roundover](rounding.scad#subsection-types-of-roundover). \n//   .\n//   The final shape is created by combining convex hulls of small extrusions.  The thickness of these small extrusions may result\n//   your model being slightly too long (if the curvature at the end is flaring outward), so if the exact length is very important\n//   you may need to intersect with a bounding cube.  (Note that extra length can also be intentionally added with the `extra` argument.)\n//   .\n//   - profile: os_profile(points)\n//     Define the offset profile with a list of points.  The first point must be [0,0] and the roundover should rise in the positive y direction, with positive x values for inward motion (standard roundover) and negative x values for flaring outward.  If the y value ever decreases then you might create a self-intersecting polyhedron, which is invalid.  Such invalid polyhedra will create cryptic assertion errors when you render your model and it is your responsibility to avoid creating them.  Note that the starting point of the profile is the center of the extrusion.  If you use a profile as the top it will rise upwards.  If you use it as the bottom it will be inverted, and will go downward.\n//   - circle: os_circle(r|cut).  Define circular rounding either by specifying the radius or cut distance.\n//   - smooth: os_smooth(cut|joint, [k]).  Define continuous curvature rounding, with `cut` and `joint` as for round_corners.  The k parameter controls how fast the curvature changes and should be between 0 and 1.\n//   - teardrop: os_teardrop(r|cut).  Rounding using a 1/8 circle that then changes to a 45 degree chamfer.  The chamfer is at the end, and enables the object to be 3d printed without support.  The radius gives the radius of the circular part.\n//   - chamfer: os_chamfer([height], [width], [cut], [angle]).  Chamfer the edge at desired angle or with desired height and width.  You can specify height and width together and the angle will be ignored, or specify just one of height and width and the angle is used to determine the shape.  Alternatively, specify \"cut\" along with angle to specify the cut back distance of the chamfer.\n//   .\n//   The general settings that you can use with all of the helper functions are mostly used to control how offset_sweep() calls the offset() function.\n//   - extra: Add an extra vertical step of the specified height, to be used for intersections or differences.  This extra step will extend the resulting object beyond the height you specify.  Default: 0\n//   - steps: Number of vertical steps to use for the profile.  (Not used by os_profile).  Default: 16\n//   - offset: Select \"round\" (r=), \"delta\" (delta=), or \"chamfer\" offset types for offset.  Default: \"round\"\n//   .\n//   Many of the arguments are described as setting \"default\" values because they establish settings which may be overridden by\n//   the top and bottom profile specifications.\n//   .\n//   You will generally want to use the above helper functions to generate the profiles.\n//   The profile specification is a list of pairs of keywords and values, e.g. [\"r\",12, type, \"circle\"]. The keywords are\n//   - \"type\" - type of rounding to apply, one of \"circle\", \"teardrop\", \"chamfer\", \"smooth\", or \"profile\" (Default: \"circle\")\n//   - \"r\" - the radius of the roundover, which may be zero for no roundover, or negative to round or flare outward.  Default: 0\n//   - \"cut\" - the cut distance for the roundover or chamfer, which may be negative for flares\n//   - \"chamfer_width\" - the width of a chamfer\n//   - \"chamfer_height\" - the height of a chamfer\n//   - \"angle\" - the chamfer angle, measured from the vertical (so zero is vertical, 90 is horizontal).  Default: 45\n//   - \"joint\" - the joint distance for a \"smooth\" roundover\n//   - \"k\" - the curvature smoothness parameter for \"smooth\" roundovers, a value in [0,1].  Default: 0.75\n//   - \"points\" - point list for use with the \"profile\" type\n//   - \"extra\" - extra height added for unions/differences.  This makes the shape taller than the requested height.  (Default: 0)\n//   - \"steps\" - number of vertical steps to use for the roundover.  Default: 16.\n//   - \"offset\" - select \"round\" (r=) or \"delta\" (delta=) offset type for offset.  Default: \"round\"\n//   .\n//   Note that unlike `offset_sweep`, because the offset operation is always performed from the base shape, using chamfered offsets does not increase the\n//   number of vertices or lead to any special complications.\n//\n// Arguments:\n//   height / length / l / h = total height (including rounded portions, but not extra sections) of the output.  Default: combined height of top and bottom end treatments.\n//   bottom = rounding spec for the bottom end\n//   top = rounding spec for the top end.\n//   ---\n//   offset = default offset, `\"round\"`, `\"delta\"`, or `\"chamfer\"`.  Default: `\"round\"`\n//   steps = default step count.  Default: 16\n//   extra = default extra height.  Default: 0\n//   cut = default cut value.\n//   chamfer_width = default width value for chamfers.\n//   chamfer_height = default height value for chamfers.\n//   angle = default angle for chamfers.  Default: 45\n//   joint = default joint value for smooth roundover.\n//   k = default curvature parameter value for \"smooth\" roundover\n//   convexity = convexity setting for use with polyhedron.  Default: 10\n// Example: Chamfered elliptical prism.  If you stretch a chamfered cylinder the chamfer will be uneven.\n//   convex_offset_extrude(bottom = os_chamfer(height=-2),\n//                         top=os_chamfer(height=1), height=7)\n//     xscale(4)circle(r=6,$fn=64);\n// Example: Elliptical prism with circular roundovers.\n//   convex_offset_extrude(bottom=os_circle(r=-2),\n//                         top=os_circle(r=1), height=7,steps=10)\n//     xscale(4)circle(r=6,$fn=64);\n// Example: If you give a non-convex input you get a convex hull output\n//   right(50) linear_extrude(height=7) star(5,r=22,ir=13);\n//   convex_offset_extrude(bottom = os_chamfer(height=-2),\n//                         top=os_chamfer(height=1), height=7, $fn=32)\n//     star(5,r=22,ir=13);\nfunction convex_offset_extrude(\n        height, \n        bottom=[], top=[], \n        h, l, length,\n        offset=\"round\", r=0, steps=16,\n        extra=0,\n        cut=undef, chamfer_width=undef, chamfer_height=undef,\n        joint=undef, k=0.75, angle=45,\n        convexity=10, thickness = 1/1024\n) = no_function(\"convex_offset_extrude\");\nmodule convex_offset_extrude(\n        height,\n        bottom=[],\n        top=[], \n        h, l, length,\n        offset=\"round\", r=0, steps=16,\n        extra=0,\n        cut=undef, chamfer_width=undef, chamfer_height=undef,\n        joint=undef, k=0.75, angle=45,\n        convexity=10, thickness = 1/1024\n) {\n        req_children($children);  \n        argspec = [\n                [\"for\", \"\"],\n                [\"r\",r],\n                [\"extra\",extra],\n                [\"type\",\"circle\"],\n                [\"steps\",steps],\n                [\"offset\",offset],\n                [\"chamfer_width\",chamfer_width],\n                [\"chamfer_height\",chamfer_height],\n                [\"angle\",angle],\n                [\"cut\",cut],\n                [\"joint\",joint],\n                [\"k\", k],\n                [\"points\", []],\n        ];\n        top = struct_set(argspec, top, grow=false);\n        bottom = struct_set(argspec, bottom, grow=false);\n\n        offsets_bot = _rounding_offsets(bottom, -1);\n        offsets_top = _rounding_offsets(top, 1);\n\n        // \"Extra\" height enlarges the result beyond the requested height, so subtract it\n        bottom_height = len(offsets_bot)==0 ? 0 : abs(last(offsets_bot)[1]) - struct_val(bottom,\"extra\");\n        top_height = len(offsets_top)==0 ? 0 : abs(last(offsets_top)[1]) - struct_val(top,\"extra\");\n\n        height = one_defined([l,h,height,length], \"l,h,height,length\", dflt=u_add(bottom_height,top_height));\n        middle = height-bottom_height-top_height;\n        check =\n          assert(height>=0, \"Height must be nonnegative\")\n          assert(middle>=0, str(\n                                \"Specified end treatments (bottom height = \",bottom_height,\n                                \" top_height = \",top_height,\") are too large for extrusion height (\",height,\")\"\n                            )\n          );\n        // The entry r[i] is [radius,z] for a given layer\n        r = move([0,bottom_height],p=concat(\n                          reverse(offsets_bot), [[0,0], [0,middle]], move([0,middle], p=offsets_top)));\n        delta = [for(val=deltas(column(r,0))) sign(val)];\n        below=[-thickness,0];\n        above=[0,thickness];\n           // layers is a list of pairs of the relative positions for each layer, e.g. [0,thickness]\n           // puts the layer above the polygon, and [-thickness,0] puts it below.\n        layers = [for (i=[0:len(r)-1])\n          i==0 ? (delta[0]<0 ? below : above) :\n          i==len(r)-1 ? (delta[len(delta)-1] < 0 ? below : above) :\n          delta[i]==0 ? above :\n          delta[i+1]==0 ? below :\n          delta[i]==delta[i-1] ? [-thickness/2, thickness/2] :\n          delta[i] == 1 ? above :\n          /* delta[i] == -1 ? */ below];\n        dochamfer = offset==\"chamfer\";\n        attachable(){\n          for(i=[0:len(r)-2])\n            for(j=[0:$children-1])\n             hull(){\n               up(r[i][1]+layers[i][0])\n                 linear_extrude(convexity=convexity,height=layers[i][1]-layers[i][0])\n                   if (offset==\"round\")\n                     offset(r=r[i][0])\n                       children(j);\n                   else\n                     offset(delta=r[i][0],chamfer = dochamfer)\n                       children(j);\n               up(r[i+1][1]+layers[i+1][0])\n                 linear_extrude(convexity=convexity,height=layers[i+1][1]-layers[i+1][0])\n                   if (offset==\"round\")\n                     offset(r=r[i+1][0])\n                       children(j);\n                   else\n                     offset(delta=r[i+1][0],chamfer=dochamfer)\n                       children(j);\n             }\n          union();\n        }\n}\n\n\n\nfunction _remove_undefined_vals(list) =\n        let(ind=search([undef],list,0)[0])\n        list_remove(list, concat(ind, add_scalar(ind,-1)));\n\n\n\nfunction _rp_compute_patches(top, bot, rtop, rsides, ktop, ksides, concave) =\n   let(\n     N = len(top),\n     plane = plane3pt_indexed(top,0,1,2),\n     rtop_in = is_list(rtop) ? rtop[0] : rtop,\n     rtop_down = is_list(rtop) ? rtop[1] : abs(rtop)\n   )\n  [for(i=[0:N-1])\n           let(\n               rside_prev = is_list(rsides[i])? rsides[i][0] : rsides[i],\n               rside_next = is_list(rsides[i])? rsides[i][1] : rsides[i],\n               concave_sign = (concave[i] ? -1 : 1) * (rtop_in>=0 ? 1 : -1),  // Negative if normals need to go \"out\"\n               prev = select(top,i-1) - top[i],\n               next = select(top,i+1) - top[i],\n               prev_offset = top[i] + rside_prev * unit(prev) / sin(vector_angle(prev,bot[i]-top[i])),\n               next_offset = top[i] + rside_next * unit(next) / sin(vector_angle(next,bot[i]-top[i])),\n               down = rtop_down * unit(bot[i]-top[i]) / sin(abs(plane_line_angle(plane, [bot[i],top[i]]))),\n               row2 = [prev_offset,     top[i],     next_offset     ],\n               row4 = [prev_offset+down,top[i]+down,next_offset+down],\n               in_prev = concave_sign * unit(next-(next*prev)*prev/(prev*prev)),\n               in_next = concave_sign * unit(prev-(prev*next)*next/(next*next)),\n               far_corner = top[i]+ concave_sign*unit(unit(prev)+unit(next))* abs(rtop_in) / sin(vector_angle(prev,next)/2),\n               row0 =\n                 concave_sign<0 ?\n                    [prev_offset+abs(rtop_in)*in_prev, far_corner, next_offset+abs(rtop_in)*in_next]\n                 :\n                    let(\n                       prev_corner = prev_offset + abs(rtop_in)*in_prev,\n                       next_corner = next_offset + abs(rtop_in)*in_next,\n                       line = project_plane(plane, [\n                                                       [far_corner, far_corner+prev],\n                                                       [prev_offset, prev_offset+in_prev],\n                                                       [far_corner, far_corner+next],\n                                                       [next_offset, next_offset+in_next]\n                                                   ]),\n                       prev_degenerate = is_undef(line_intersection(line[0],line[1],RAY,RAY)),\n                       next_degenerate = is_undef(line_intersection(line[2],line[3],RAY,RAY))\n                    )\n                    [ prev_degenerate ? far_corner : prev_corner,\n                      far_corner,\n                      next_degenerate ? far_corner : next_corner]\n            ) _smooth_bez_fill(\n                      [for(row=[row0, row2, row4]) _smooth_bez_fill(row,ksides[i])],\n                      ktop)];\n\n\n// Function&Module: rounded_prism()\n// Synopsis: Make a rounded 3d object by connecting two polygons with the same vertex count.\n// SynTags: Geom, VNF\n// Topics: Rounding, Offsets\n// See Also: offset_sweep(), convex_offset_extrude(), rounded_prism(), bent_cutout_mask(), join_prism()\n// Usage: as a module\n//   rounded_prism(bottom, [top], [height=|h=|length=|l=], [joint_top=], [joint_bot=], [joint_sides=], [k=], [k_top=], [k_bot=], [k_sides=], [splinesteps=], [debug=], [convexity=],...) [ATTACHMENTS];\n// Usage: as a function\n//   vnf = rounded_prism(bottom, [top], [height=|h=|length=|l=], [joint_top=], [joint_bot=], [joint_sides=], [k=], [k_top=], [k_bot=], [k_sides=], [splinesteps=], [debug=]);\n// Description:\n//   Construct a generalized prism with continuous curvature rounding.  You supply the polygons for the top and bottom of the prism.  The only\n//   limitation is that joining the edges must produce a valid polyhedron with coplanar side faces.  You specify the rounding by giving\n//   the joint distance away from the corner for the rounding curve.  The k parameter ranges from 0 to 1 with a default of 0.5.  Larger\n//   values give a more abrupt transition and smaller ones a more gradual transition.  If you set the value much higher\n//   than 0.8 the curvature changes abruptly enough that though it is theoretically continuous, it may\n//   not be continuous in practice.  A value of 0.92 is a good approximation to a circle.  If you set it very small then the transition\n//   is so gradual that the roundover may be very small.  If you want a very smooth roundover, set the joint parameter as large as possible and\n//   then adjust the k value down as low as gives a sufficiently large roundover.  See\n//   [Types of Roundover](rounding.scad#subsection-types-of-roundover) for more information on continuous curvature rounding.  \n//   .\n//   You can specify the bottom and top polygons by giving two compatible 3d paths.  You can also give 2d paths and a height/length and the\n//   two shapes will be offset in the z direction from each other.  The final option is to specify just the bottom along with a height/length;\n//   in this case the top will be a copy of the bottom, offset in the z direction by the specified height.\n//   .\n//   You define rounding for all of the top edges, all of the bottom edges, and independently for each of the connecting side edges.\n//   You specify rounding the rounding by giving the joint distance for where the curved section should start.  If the joint distance is 1 then\n//   it means the curved section begins 1 unit away from the edge (in the perpendicular direction).  Typically each joint distance is a scalar\n//   value and the rounding is symmetric around each edge.  However, you can specify a 2-vector for the joint distance to produce asymmetric\n//   rounding which is different on the two sides of the edge.  This may be useful when one one edge in your polygon is much larger than another.\n//   For the top and bottom you can specify negative joint distances.  If you give a scalar negative value then the roundover will flare\n//   outward.  If you give a vector value then a negative value then if joint_top[0] is negative the shape will flare outward, but if\n//   joint_top[1] is negative the shape will flare upward.  At least one value must be non-negative.  The same rules apply for joint_bot.\n//   The joint_sides parameter must be entirely nonnegative.\n//   .\n//   If the roundings at two adjacent side edges exceed the width of the face then the polyhedron will have self-intersecting faces, so it will be invalid.\n//   Similarly, if the roundings on the top or bottom edges cross the top face and intersect with each other, the resulting polyhedron is invalid:\n//   the top face after the roundings are applied must be a valid, non-degenerate polyhedron.  There are two exceptions:  it is permissible to\n//   construct a top that is a single point or two points.  This means you can completely round a cube by setting the joint to half of\n//   the cube's width.  \n//   If you set `debug` to true the module version will display the polyhedron even when it is invalid and it will show the bezier patches at the corners.\n//   This can help troubleshoot problems with your parameters.  With the function form setting debug to true causes it to return [patches,vnf] where\n//   patches is a list of the bezier control points for the corner patches.\n//   .\n//   Note that rounded_prism() is not well suited to rounding shapes that have already been rounded, or that have many points.\n//   It works best when the top and bottom are polygons with well-defined corners.  When the polygons have been rounded already,\n//   further rounding generates tiny bezier patches patches that can more easily\n//   interfere, giving rise to an invalid polyhedron.  It's also slow because you get bezier patches for every corner in the model.  \n//   .\n// Arguments:\n//   bottom = 2d or 3d path describing bottom polygon\n//   top = 2d or 3d path describing top polygon (must be the same dimension as bottom)\n//   ---\n//   height/length/h/l = height of the shape when you give 2d bottom\n//   joint_top = rounding length for top (number or 2-vector).  Default: 0\n//   joint_bot = rounding length for bottom (number or 2-vector).  Default: 0\n//   joint_sides = rounding length for side edges, a number/2-vector or list of them.  Default: 0\n//   k = continuous curvature rounding parameter for all edges.  Default: 0.5\n//   k_top = continuous curvature rounding parameter for top\n//   k_bot = continuous curvature rounding parameter for bottom\n//   k_sides = continuous curvature rounding parameter side edges, a number or vector.  \n//   splinesteps = number of segments to use for curved patches.  Default: 16\n//   debug = turn on debug mode which displays illegal polyhedra and shows the bezier corner patches for troubleshooting purposes.  Default: False\n//   convexity = convexity parameter for polyhedron(), only for module version.  Default: 10\n//   anchor = Translate so anchor point is at the origin.  (module only) Default: \"origin\"\n//   spin = Rotate this many degrees around Z axis after anchor.  (module only) Default: 0\n//   orient = Vector to rotate top towards after spin  (module only)\n//   atype = Select \"hull\" or \"intersect\" anchor types.  (module only) Default: \"hull\"\n//   cp = Centerpoint for determining \"intersect\" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 3D point.  (module only) Default: \"centroid\"\n// Example: Uniformly rounded pentagonal prism\n//   rounded_prism(pentagon(3), height=3,\n//                 joint_top=0.5, joint_bot=0.5, joint_sides=0.5);\n// Example: Maximum possible rounding.\n//   rounded_prism(pentagon(3), height=3,\n//                 joint_top=1.5, joint_bot=1.5, joint_sides=1.5);\n// Example: Decreasing k from the default of 0.5 to 0.3 gives a smoother round over which takes up more space, so it appears less rounded.\n//   rounded_prism(pentagon(3), height=3, joint_top=1.5, joint_bot=1.5,\n//                 joint_sides=1.5, k=0.3, splinesteps=32);\n// Example: Increasing k from the default of 0.5 to 0.92 approximates a circular roundover, which does not have continuous curvature.  Notice the visible \"edges\" at the boundary of the corner and edge patches.  \n//   rounded_prism(pentagon(3), height=3, joint_top=0.5,\n//                 joint_bot=0.5, joint_sides=0.5, k=0.92);\n// Example: rounding just one edge\n//   rounded_prism(pentagon(side=3), height=3, joint_top=0.5, joint_bot=0.5,\n//                 joint_sides=[0,0,0.5,0,0], splinesteps=16);\n// Example: rounding all the edges differently\n//   rounded_prism(pentagon(side=3), height=3, joint_top=0.25, joint_bot=0.5,\n//                 joint_sides=[1.7,.5,.7,1.2,.4], splinesteps=32);\n// Example: different k values for top, bottom and sides\n//   rounded_prism(pentagon(side=3.0), height=3.0, joint_top=1.4, joint_bot=1.4,\n//                 joint_sides=0.7, k_top=0.7, k_bot=0.3, k_sides=0.5, splinesteps=48);\n// Example: flared bottom\n//   rounded_prism(pentagon(3), height=3, joint_top=1.0,\n//                 joint_bot=-0.5, joint_sides=0.5);\n// Example: truncated pyramid\n//   rounded_prism(pentagon(3), apply(scale(.7),pentagon(3)),\n//                 height=3, joint_top=0.5, joint_bot=0.5, joint_sides=0.5);\n// Example: top translated\n//   rounded_prism(pentagon(3), apply(right(2),pentagon(3)),\n//                 height=3, joint_top=0.5, joint_bot=0.5, joint_sides=0.5);\n// Example(NORENDER): top rotated: fails due to non-coplanar side faces\n//   rounded_prism(pentagon(3), apply(rot(45),pentagon(3)), height=3,\n//                 joint_top=0.5, joint_bot=0.5, joint_sides=0.5);\n// Example: skew top\n//   rounded_prism(path3d(pentagon(3)), apply(affine3d_skew_yz(0,-20),path3d(pentagon(3),3)),\n//                 joint_top=0.5, joint_bot=0.5, joint_sides=0.5);\n// Example: this rotation gives coplanar sides\n//   rounded_prism(path3d(square(4)), apply(yrot(-100)*right(2),path3d(square(4),3)),\n//                 joint_top=0.5, joint_bot=0.5, joint_sides=0.5);\n// Example: a shape with concave corners\n//   M = path3d(turtle([\"left\", 180, \"length\",3,\"move\", \"left\", \"move\", 3, \"right\",\n//                      \"move\", \"right\", \"move\", 4, \"right\", \"move\", 3, \"right\", \"move\", 2]));\n//   rounded_prism(M, apply(up(3),M), joint_top=0.75, joint_bot=0.2,\n//                 joint_sides=[.2,2.5,2,0.5,1.5,.5,2.5], splinesteps=32);\n// Example: using debug mode to see the corner patch sizes, which may help figure out problems with interfering corners or invalid polyhedra.  The corner patches must not intersect each other.\n//   M = path3d(turtle([\"left\", 180, \"length\",3,\"move\", \"left\", \"move\", 3, \"right\",\n//                      \"move\", \"right\", \"move\", 4, \"right\", \"move\", 3, \"right\", \"move\", 2]));\n//   rounded_prism(M, apply(up(3),M), joint_top=0.75, joint_bot=0.2,\n//                 joint_sides=[.2,2.5,2,0.5,1.5,.5,2.5], splinesteps=16,debug=true);\n// Example: applying transformation to the previous example\n//   M = path3d(turtle([\"left\", 180, \"length\",3,\"move\", \"left\", \"move\", 3, \"right\",\n//                      \"move\", \"right\", \"move\", 4, \"right\", \"move\", 3, \"right\", \"move\", 2]));\n//   rounded_prism(M, apply(right(1)*scale(.75)*up(3),M), joint_top=0.5, joint_bot=0.2,\n//                 joint_sides=[.2,1,1,0.5,1.5,.5,2], splinesteps=32);\n// Example: this example shows most of the different types of patches that rounded_prism creates.  Note that some of the patches are close to interfering with each other across the top of the polyhedron, which would create an invalid result.\n//   N = apply(rot(180)*yscale(.8),turtle([\"length\",3,\"left\", \"move\", 2, \"right\", 135,\"move\", sqrt(2), \n//                                         \"left\", \"move\", sqrt(2), \"right\", 135, \"move\", 2]));\n//   rounded_prism(N, height=3, joint_bot=0.5, joint_top=1.25, joint_sides=[[1,1.75],0,.5,.5,2], debug=true);\n// Example: This object has different scales on its different axies.  Here is the largest symmetric rounding that fits.  Note that the rounding is slightly smaller than the object dimensions because of roundoff error.\n//   rounded_prism(square([100.1,30.1]), height=8.1, joint_top=4, joint_bot=4,\n//                 joint_sides=15, k_sides=0.3, splinesteps=32);\n// Example: Using asymetric rounding enables a much more rounded form:\n//   rounded_prism(square([100.1,30.1]), height=8.1, joint_top=[15,4], joint_bot=[15,4],\n//                 joint_sides=[[15,50],[50,15],[15,50],[50,15]], k_sides=0.3, splinesteps=32);\n// Example: Flaring the top upward instead of outward.  The bottom has an asymmetric rounding with a small flare but a large rounding up the side.\n//   rounded_prism(pentagon(3), height=3, joint_top=[1,-1],\n//                 joint_bot=[-0.5,2], joint_sides=0.5);\n// Example: Sideways polygons:\n//   rounded_prism(apply(yrot(95),path3d(hexagon(3))), apply(yrot(95), path3d(hexagon(3),3)),\n//                 joint_top=2, joint_bot=1, joint_sides=1);\n// Example: Chamfer a polyhedron by setting splinesteps to 1\n//   N = apply(rot(180)*yscale(.8),turtle([\"length\",3,\"left\", \"move\", 2, \"right\", 135,\"move\", sqrt(2), \n//                                         \"left\", \"move\", sqrt(2), \"right\", 135, \"move\", 2]));\n//   rounded_prism(N, height=3, joint_bot=-0.3, joint_top=.4, joint_sides=[.75,0,.2,.2,.7], splinesteps=1);\n\n\nmodule rounded_prism(bottom, top, joint_bot=0, joint_top=0, joint_sides=0, k_bot, k_top, k_sides,\n                     k=0.5, splinesteps=16, h, length, l, height, convexity=10, debug=false,\n                     anchor=\"origin\",cp=\"centroid\",spin=0, orient=UP, atype=\"hull\")\n{\n  assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\");\n  result = rounded_prism(bottom=bottom, top=top, joint_bot=joint_bot, joint_top=joint_top, joint_sides=joint_sides,\n                         k_bot=k_bot, k_top=k_top, k_sides=k_sides, k=k, splinesteps=splinesteps, h=h, length=length, height=height, l=l,debug=debug);\n  vnf = debug ? result[1] : result;\n  attachable(anchor=anchor, spin=spin, orient=orient, vnf=vnf, extent=atype==\"hull\", cp=cp)\n  {\n    if (debug){\n        vnf_polyhedron(vnf, convexity=convexity);\n        debug_bezier_patches(result[0], showcps=true, splinesteps=splinesteps, $fn=16, showdots=false, showpatch=false);\n    }\n    else vnf_polyhedron(vnf,convexity=convexity);\n    children();\n  }\n}\n\n\nfunction rounded_prism(bottom, top, joint_bot=0, joint_top=0, joint_sides=0, k_bot, k_top, k_sides, k=0.5, splinesteps=16,\n                       h, length, l, height, debug=false) =\n   let(\n       bottom = force_path(bottom,\"bottom\"),\n       top = force_path(top,\"top\")\n   )\n   assert(is_path(bottom,[2,3]) && len(bottom)>=3, \"bottom must be a 2D or 3D path\")\n   assert(is_num(k) && k>=0 && k<=1, \"Curvature parameter k must be in interval [0,1]\")\n   let(\n     N=len(bottom),\n     k_top = default(k_top, k),\n     k_bot = default(k_bot, k),\n     k_sides = default(k_sides, k),\n     height = one_defined([h,l,height,length],\"height,length,l,h\", dflt=undef),\n     shapedimok = (len(bottom[0])==3 && is_path(top,3)) || (len(bottom[0])==2 && (is_undef(top) || is_path(top,2)))\n   )\n   assert(is_num(k_top) && k_top>=0 && k_top<=1, \"Curvature parameter k_top must be in interval [0,1]\")\n   assert(is_num(k_bot) && k_bot>=0 && k_bot<=1, \"Curvature parameter k_bot must be in interval [0,1]\")\n   assert(shapedimok,\"bottom and top must be 2d or 3d paths with the same dimension\")\n   assert(len(bottom[0])==3 || is_num(height),\"Must give height/length with 2d polygon input\")\n   let(\n     // Determine which points are concave by making bottom 2d if necessary\n     bot_proj = len(bottom[0])==2 ? bottom :  project_plane(select(bottom,0,2),bottom),\n     bottom_sign = is_polygon_clockwise(bot_proj) ? 1 : -1,\n     concave = [for(i=[0:N-1]) bottom_sign*sign(_point_left_of_line2d(select(bot_proj,i+1), select(bot_proj, i-1,i)))>0],\n     top = is_undef(top) ? path3d(bottom,height/2) :\n           len(top[0])==2 ? path3d(top,height/2) :\n           top,\n     bottom = len(bottom[0])==2 ? path3d(bottom,-height/2) : bottom,\n     jssingleok = (is_num(joint_sides) && joint_sides >= 0) || (is_vector(joint_sides,2) && joint_sides[0]>=0 && joint_sides[1]>=0),\n     jsvecok = is_list(joint_sides) && len(joint_sides)==N && []==[for(entry=joint_sides) if (!(is_num(entry) || is_vector(entry,2))) entry]\n   )\n   assert(is_num(joint_top) || is_vector(joint_top,2))\n   assert(is_num(joint_bot) || is_vector(joint_bot,2))\n   assert(is_num(joint_top) || (joint_top[0]>=0 ||joint_top[1]>=0), \"Both entries in joint_top cannot be negative\")\n   assert(is_num(joint_bot) || (joint_bot[0]>=0 ||joint_bot[1]>=0), \"Both entries in joint_bot cannot be negative\")\n   assert(jsvecok || jssingleok,\n          str(\"Argument joint_sides is invalid.  All entries must be nonnegative, and it must be a number, 2-vector, or a length \",N,\" list those.\"))\n   assert(is_num(k_sides) || is_vector(k_sides,N), str(\"Curvature parameter k_sides must be a number or length \",N,\" vector\"))\n   assert(is_coplanar(bottom))\n   assert(is_coplanar(top))\n   assert(!is_num(k_sides) || (k_sides>=0 && k_sides<=1), \"Curvature parameter k_sides must be in interval [0,1]\")\n   let(\n     non_coplanar=[for(i=[0:N-1]) if (!is_coplanar(concat(select(top,i,i+1), select(bottom,i,i+1)))) [i,(i+1)%N]],\n     k_sides_vec = is_num(k_sides) ? repeat(k_sides, N) : k_sides,\n     kbad = [for(i=[0:N-1]) if (k_sides_vec[i]<0 || k_sides_vec[i]>1) i],\n     joint_sides_vec = jssingleok ? repeat(joint_sides,N) : joint_sides,\n     top_collinear = [for(i=[0:N-1]) if (is_collinear(select(top,i-1,i+1))) i],\n     bot_collinear = [for(i=[0:N-1]) if (is_collinear(select(bottom,i-1,i+1))) i]\n   )\n   assert(non_coplanar==[], str(\"Side faces are non-coplanar at edges: \",non_coplanar))\n   assert(top_collinear==[], str(\"Top has collinear or duplicated points at indices: \",top_collinear))\n   assert(bot_collinear==[], str(\"Bottom has collinear or duplicated points at indices: \",bot_collinear))\n   assert(kbad==[], str(\"k_sides parameter outside interval [0,1] at indices: \",kbad))\n   let(\n     top_patch = _rp_compute_patches(top, bottom, joint_top, joint_sides_vec, k_top, k_sides_vec, concave),\n     bot_patch = _rp_compute_patches(bottom, top, joint_bot, joint_sides_vec, k_bot, k_sides_vec, concave),\n\n     vertbad = [for(i=[0:N-1])\n                   if (norm(top[i]-top_patch[i][4][2]) + norm(bottom[i]-bot_patch[i][4][2]) > EPSILON + norm(bottom[i]-top[i])) i],\n     // Check that the patch fits on the polygon edge\n     topbad = [for(i=[0:N-1])\n                   if (norm(top_patch[i][2][4]-top_patch[i][2][2]) + norm(select(top_patch,i+1)[2][0]-select(top_patch,i+1)[2][2])\n                  > EPSILON + norm(top_patch[i][2][2] - select(top_patch,i+1)[2][2]))   [i,(i+1)%N]],\n     botbad = [for(i=[0:N-1])\n                   if (norm(bot_patch[i][2][4]-bot_patch[i][2][2]) + norm(select(bot_patch,i+1)[2][0]-select(bot_patch,i+1)[2][2])\n                  > EPSILON + norm(bot_patch[i][2][2] - select(bot_patch,i+1)[2][2]))   [i,(i+1)%N]],\n     // If top/bot is L-shaped, check that arms of L from adjacent patches don't cross\n     topLbad = [for(i=[0:N-1])\n                   if (norm(top_patch[i][0][2]-top_patch[i][0][4]) + norm(select(top_patch,i+1)[0][0]-select(top_patch,i+1)[0][2])\n                          > EPSILON + norm(top_patch[i][0][2]-select(top_patch,i+1)[0][2])) [i,(i+1)%N]],\n     botLbad = [for(i=[0:N-1])\n                   if (norm(bot_patch[i][0][2]-bot_patch[i][0][4]) + norm(select(bot_patch,i+1)[0][0]-select(bot_patch,i+1)[0][2])\n                          > EPSILON + norm(bot_patch[i][0][2]-select(bot_patch,i+1)[0][2])) [i,(i+1)%N]],\n     // Check that the inner edges of the patch don't cross\n     topinbad = [for(i=[0:N-1]) \n                     let(\n                          line1 = project_plane(top,[top_patch[i][2][0],top_patch[i][0][0]]),\n                          line2 = project_plane(top,[select(top_patch,i+1)[2][4],select(top_patch,i+1)[0][4]])\n                     )\n                     if (!approx(line1[0],line1[1]) && !approx(line2[0],line2[1]) &&\n                         line_intersection(line1,line2, SEGMENT,SEGMENT))\n                          [i,(i+1)%N]],\n     botinbad = [for(i=[0:N-1])\n                     let(\n                          line1 = project_plane(bottom,[bot_patch[i][2][0],bot_patch[i][0][0]]),\n                          line2 = project_plane(bottom,[select(bot_patch,i+1)[2][4],select(bot_patch,i+1)[0][4]])\n                     )\n                     if (!approx(line1[0],line1[1]) && !approx(line2[0],line2[1]) &&\n                         line_intersection(line1,line2, SEGMENT,SEGMENT))\n                          [i,(i+1)%N]]\n   )\n   assert(debug || vertbad==[], str(\"Top and bottom joint lengths are too large; they interfere with each other at vertices: \",vertbad))\n   assert(debug || topbad==[], str(\"Joint lengths too large at top or side edges: \",topbad))\n   assert(debug || botbad==[], str(\"Joint lengths too large at bottom or side edges: \",botbad))\n   assert(debug || topLbad==[], str(\"Joint length too large on the top face or side at edges: \", topLbad))\n   assert(debug || botLbad==[], str(\"Joint length too large on the bottom face or side at edges: \", botLbad))\n   assert(debug || topinbad==[], str(\"Joint length too large on the top face at edges: \", topinbad))\n   assert(debug || botinbad==[], str(\"Joint length too large on the bottom face at edges: \", botinbad))\n   let(\n     // Entries in the next two lists have the form [edges, vnf] where\n     // edges is a list [leftedge, rightedge, topedge, botedge]\n     top_samples = [for(patch=top_patch) bezier_vnf_degenerate_patch(patch,splinesteps,reverse=false,return_edges=true) ],\n     bot_samples = [for(patch=bot_patch) bezier_vnf_degenerate_patch(patch,splinesteps,reverse=true,return_edges=true) ],\n     leftidx=0,\n     rightidx=1,\n     topidx=2,\n     botidx=3,\n     edge_points =\n       [for(i=[0:N-1])\n            let(\n               top_edge  = [ top_samples[i][1][rightidx], select(top_samples, i+1)[1][leftidx]],\n               bot_edge  = [ select(bot_samples, i+1)[1][leftidx], bot_samples[i][1][rightidx]],\n               vert_edge = [ bot_samples[i][1][botidx], top_samples[i][1][botidx]]\n               )\n               each [top_edge, bot_edge, vert_edge] ],\n     faces = [\n              [for(i=[0:N-1]) each top_samples[i][1][topidx]],\n              [for(i=[N-1:-1:0]) each reverse(bot_samples[i][1][topidx])],\n              for(i=[0:N-1]) [\n                                 bot_patch[i][4][4],\n                                 select(bot_patch,i+1)[4][0],\n                                 select(top_patch,i+1)[4][0],\n                                 top_patch[i][4][4]\n                             ]\n             ],\n     top_collinear = is_collinear(faces[0]),\n     bot_collinear = is_collinear(faces[1]),\n     top_degen_ok = top_collinear && len(deduplicate(faces[0]))<=2,\n     bot_degen_ok = bot_collinear && len(deduplicate(faces[1]))<=2,\n     top_simple = top_degen_ok || (!top_collinear && is_path_simple(project_plane(faces[0],faces[0]),closed=true)),\n     bot_simple = bot_degen_ok || (!bot_collinear && is_path_simple(project_plane(faces[1],faces[1]),closed=true)),                                   \n     // verify vertical edges\n     verify_vert =\n       [for(i=[0:N-1],j=[0:4])\n         let(\n               vline = concat(select(column(top_patch[i],j),2,4),\n                              select(column(bot_patch[i],j),2,4))\n             )\n         if (!is_collinear(vline)) [i,j]],\n     //verify horiz edges\n     verify_horiz=[for(i=[0:N-1], j=[0:4])\n         let(\n             hline_top = concat(select(top_patch[i][j],2,4), select(select(top_patch, i+1)[j],0,2)),\n             hline_bot = concat(select(bot_patch[i][j],2,4), select(select(bot_patch, i+1)[j],0,2))\n         )\n         if (!is_collinear(hline_top) || !is_collinear(hline_bot)) [i,j]]\n    )\n    assert(debug || top_simple,\n          \"Roundovers interfere with each other on top face: either input is self intersecting or top joint length is too large\")\n    assert(debug || bot_simple,\n          \"Roundovers interfere with each other on bottom face: either input is self intersecting or top joint length is too large\")\n    assert(debug || (verify_vert==[] && verify_horiz==[]), \"Curvature continuity failed\")\n    let( \n        vnf = vnf_join([ each column(top_samples,0),\n                          each column(bot_samples,0),\n                          for(pts=edge_points) vnf_vertex_array(pts),\n                          debug ? vnf_from_polygons(faces,fast=true) \n                                : vnf_triangulate(vnf_from_polygons(faces))\n                       ])\n    )\n    debug ? [concat(top_patch, bot_patch), vnf] : vnf;\n\n\n\n// Converts a 2d path to a path on a cylinder at radius r\nfunction _cyl_hole(r, path) =\n    [for(point=path) cylindrical_to_xyz(concat([r],xscale(360/(2*PI*r),p=point)))];\n\n// Mask profile of 180 deg of a circle to round an edge\nfunction _circle_mask(r) =\n   let(eps=0.1)\n\n   fwd(r+.01,p=\n   [\n    [r+eps,0],\n    each arc(r=r, angle=[0, 180]),\n    [-r-eps,0],\n    [-r-eps, r+3*eps],\n    [r+eps, r+3*eps]\n   ]);\n\n\n// Module: bent_cutout_mask()\n// Synopsis: Create a mask for making a round-edged cutout in a cylindrical shell.\n// SynTags: Geom\n// Topics: Rounding, Offsets\n// See Also: offset_sweep(), convex_offset_extrude(), rounded_prism(), bent_cutout_mask(), join_prism()\n// Usage:\n//   bent_cutout_mask(r|radius, thickness, path);\n// Description:\n//   Creates a mask for cutting a round-edged hole out of a vertical cylindrical shell.  The specified radius\n//   is the center radius of the cylindrical shell.  The path needs to be sampled finely enough\n//   so that it can follow the curve of the cylinder.  The thickness may need to be slighly oversized to\n//   handle the faceting of the cylinder.  The path is wrapped around a cylinder, keeping the\n//   same dimensions that is has on the plane, with y axis mapping to the z axis and the x axis bending\n//   around the curve of the cylinder.  The angular span of the path on the cylinder must be somewhat\n//   less than 180 degrees, and the path shouldn't have closely spaced points at concave points of high curvature because\n//   this will cause self-intersection in the mask polyhedron, resulting in CGAL failures.\n// Arguments:\n//   r / radius = center radius of the cylindrical shell to cut a hole in\n//   thickness = thickness of cylindrical shell (may need to be slighly oversized)\n//   path = 2d path that defines the hole to cut\n// Example: The mask as long pointed ends because this was the most efficient way to close off those ends.\n//   bent_cutout_mask(10, 1, apply(xscale(3),circle(r=3)),$fn=64);\n// Example: An elliptical hole.  Note the thickness is slightly increased to 1.05 compared to the actual thickness of 1.\n//   rot(-90) {\n//     $fn=128;\n//     difference(){\n//       cyl(r=10.5, h=10);\n//       cyl(r=9.5, h=11);\n//       bent_cutout_mask(10, 1.05, apply(xscale(3),circle(r=3)),\n//                        $fn=64);\n//     }\n//   }\n// Example: An elliptical hole in a thick cylinder\n//   rot(-90) {\n//     $fn=128;\n//     difference(){\n//       cyl(r=14.5, h=15);\n//       cyl(r=9.5, h=16);\n//       bent_cutout_mask(12, 5.1, apply(xscale(3),circle(r=3)));\n//     }\n//   }\n// Example: Complex shape example\n//   rot(-90) {\n//     $fn=128;\n//     difference(){\n//       cyl(r=10.5, h=10, $fn=128);\n//       cyl(r=9.5, h=11, $fn=128);\n//       bent_cutout_mask(10, 1.05,\n//         apply(scale(3),\n//           supershape(step=2,m1=5, n1=0.3,n2=1.7)),$fn=32);\n//     }\n//   }\n// Example: this shape is invalid due to self-intersections at the inner corners\n//   rot(-90) {\n//     $fn=128;\n//     difference(){\n//       cylinder(r=10.5, h=10,center=true);\n//       cylinder(r=9.5, h=11,center=true);\n//       bent_cutout_mask(10, 1.05,\n//         apply(scale(3),\n//           supershape(step=2,m1=5, n1=0.1,n2=1.7)),$fn=32);\n//     }\n//   }\n// Example: increasing the step gives a valid shape, but the shape looks terrible with so few points.\n//   rot(-90) {\n//     $fn=128;\n//     difference(){\n//       cylinder(r=10.5, h=10,center=true);\n//       cylinder(r=9.5, h=11,center=true);\n//       bent_cutout_mask(10, 1.05,\n//         apply(scale(3),\n//           supershape(step=12,m1=5, n1=0.1,n2=1.7)),$fn=32);\n//     }\n//   }\n// Example: uniform resampling produces a somewhat better result, but room remains for improvement.  The lesson is that concave corners in your cutout cause trouble.  To get a very good result we need to non-uniformly sample the supershape with more points at the star tips and few points at the inner corners.\n//   rot(-90) {\n//     $fn=128;\n//     difference(){\n//       cylinder(r=10.5, h=10,center=true);\n//       cylinder(r=9.5, h=11,center=true);\n//       bent_cutout_mask(10, 1.05,\n//         apply(scale(3), resample_path(\n//              supershape(step=1,m1=5, n1=0.10,n2=1.7),\n//              60,closed=true)),\n//         $fn=32);\n//     }\n//   }\n// Example: The cutout spans 177 degrees.  If you decrease the tube radius to 2.5 the cutout spans over 180 degrees and the model fails.\n//   r=2.6;     // Don't make this much smaller or it will fail\n//   rot(-90) {\n//     $fn=128;\n//     difference(){\n//       tube(or=r, wall=1, h=10, anchor=CENTER);\n//       bent_cutout_mask(r-0.5, 1.05,\n//         apply(scale(3),\n//           supershape(step=1,m1=5, n1=0.15,n2=1.7)),$fn=32);\n//     }\n//   }\n// Example: A square hole is not as simple as it seems.  The model valid, but wrong, because the square didn't have enough samples to follow the curvature of the cylinder.\n//   r=25;\n//   rot(-90) {\n//     $fn=128;\n//     difference(){\n//       tube(or=r, wall=2, h=35, anchor=BOT);\n//       bent_cutout_mask(r-1, 2.1, back(5,p=square([18,18])));\n//     }\n//   }\n// Example: Adding additional points fixed this problem\n//   r=25;\n//   rot(-90) {\n//     $fn=128;\n//     difference(){\n//       tube(or=r, wall=2, h=35, anchor=BOT);\n//       bent_cutout_mask(r-1, 2.1,\n//         subdivide_path(back(5,p=square([18,18])),64,closed=true));\n//     }\n//   }\n// Example: Rounding just the exterior corners of this star avoids the problems we had above with concave corners of the supershape, as long as we don't oversample the star.\n//   r=25;\n//   rot(-90) {\n//     $fn=128;\n//     difference(){\n//       tube(or=r, wall=2, h=35, anchor=BOT);\n//       bent_cutout_mask(r-1, 2.1,\n//         apply(back(15),\n//           subdivide_path(\n//             round_corners(star(n=7,ir=5,or=10),\n//                           cut=flatten(repeat([0.5,0],7)),$fn=32),\n//             14*15,closed=true)));\n//     }\n//   }\n// Example(2D): Cutting a slot in a cylinder is tricky if you want rounded corners at the top.  This slot profile has slightly angled top edges to blend into the top edge of the cylinder.\n//   function slot(slotwidth, slotheight, slotradius) = let(\n//       angle = 85,\n//       slot = round_corners(\n//           turtle([\n//               \"right\",\n//               \"move\", slotwidth,\n//               \"left\", angle,\n//               \"move\", 2*slotwidth,\n//               \"right\", angle,\n//               \"move\", slotheight,\n//               \"left\",\n//               \"move\", slotwidth,\n//               \"left\",\n//               \"move\", slotheight,\n//               \"right\", angle,\n//               \"move\", 2*slotwidth,\n//               \"left\", angle,\n//               \"move\", slotwidth\n//           ]),\n//           radius = [0,0,each repeat(slotradius,4),0,0], closed=false\n//       )\n//   ) apply(left(max(column(slot,0))/2)*fwd(min(column(slot,1))), slot);\n//   stroke(slot(15,29,7));\n// Example: A cylindrical container with rounded edges and a rounded finger slot.\n//   function slot(slotwidth, slotheight, slotradius) = let(\n//       angle = 85,\n//       slot = round_corners(\n//           turtle([\n//               \"right\",\n//               \"move\", slotwidth,\n//               \"left\", angle,\n//               \"move\", 2*slotwidth,\n//               \"right\", angle,\n//               \"move\", slotheight,\n//               \"left\",\n//               \"move\", slotwidth,\n//               \"left\",\n//               \"move\", slotheight,\n//               \"right\", angle,\n//               \"move\", 2*slotwidth,\n//               \"left\", angle,\n//               \"move\", slotwidth\n//           ]),\n//           radius = [0,0,each repeat(slotradius,4),0,0], closed=false\n//       )\n//   ) apply(left(max(column(slot,0))/2)*fwd(min(column(slot,1))), slot);\n//   diam = 80;\n//   wall = 4;\n//   height = 40;\n//   rot(-90) {\n//       $fn=128;\n//       difference(){\n//           cyl(d=diam, rounding=wall/2, h=height, anchor=BOTTOM);\n//           up(wall)cyl(d=diam-2*wall, rounding1=wall, rounding2=-wall/2, h=height-wall+.01, anchor=BOTTOM);\n//           bent_cutout_mask(diam/2-wall/2, wall+.1, subdivide_path(apply(back(10),slot(15, 29, 7)),250));\n//       }\n//   }\nfunction bent_cutout_mask(r, thickness, path, radius, convexity=10) = no_function(\"bent_cutout_mask\");\nmodule bent_cutout_mask(r, thickness, path, radius, convexity=10)\n{\n  no_children($children);\n  r = get_radius(r1=r, r2=radius);\n  dummy1=assert(is_def(r) && r>0,\"Radius of the cylinder to bend around must be positive\");\n  path2 = force_path(path);\n  dummy2=assert(is_path(path2,2),\"Input path must be a 2D path\")\n         assert(r-thickness>0, \"Thickness too large for radius\")\n         assert(thickness>0, \"Thickness must be positive\");\n  fixpath = clockwise_polygon(path2);\n  curvepoints = arc(d=thickness, angle = [-180,0]);\n  profiles = [for(pt=curvepoints) _cyl_hole(r+pt.x,apply(xscale((r+pt.x)/r), offset(fixpath,delta=thickness/2+pt.y,check_valid=false,closed=true)))];\n  pathx = column(fixpath,0);\n  minangle = (min(pathx)-thickness/2)*360/(2*PI*r);\n  maxangle = (max(pathx)+thickness/2)*360/(2*PI*r);\n  mindist = (r+thickness/2)/cos((maxangle-minangle)/2);\n  dummy3 = assert(maxangle-minangle<180,\"Cutout angle span is too large.  Must be smaller than 180.\");\n  zmean = mean(column(fixpath,1));\n  innerzero = repeat([0,0,zmean], len(fixpath));\n  outerpt = repeat( [1.5*mindist*cos((maxangle+minangle)/2),1.5*mindist*sin((maxangle+minangle)/2),zmean], len(fixpath));\n  default_tag(\"remove\")\n    vnf_polyhedron(vnf_vertex_array([innerzero, each profiles, outerpt],col_wrap=true),convexity=convexity);\n}\n\n\n\n/*\n\njoin_prism To Do List:\n\nspecial handling for planar joins?\n   offset method\n   cut, radius?\nAccess to the derivative smoothing parameter?   \n\n*/\n\n\n\n// Function&Module: join_prism()\n// Synopsis: Join an arbitrary prism to a plane, sphere, cylinder or another arbitrary prism with a fillet.\n// SynTags: Geom, VNF\n// Topics: Rounding, Offsets\n// See Also: offset_sweep(), convex_offset_extrude(), rounded_prism(), bent_cutout_mask(), join_prism()\n// Usage: The two main forms with most common options\n//   join_prism(polygon, base, length=|height=|l=|h=, fillet=, [base_T=], [scale=], [prism_end_T=], [short=], ...) [ATTACHMENTS];\n//   join_prism(polygon, base, aux=, fillet=, [base_T=], [aux_T=], [scale=], [prism_end_T=], [short=], ...) [ATTACHMENTS];\n// Usage: As function\n//   vnf = join_prism( ... );\n// Description:\n//   This function creates a smooth fillet between one or both ends of an arbitrary prism and various other shapes: a plane, a sphere, a cylinder,\n//   or another arbitrary prism.  The fillet is a continuous curvature rounding with a specified width/height.  This module is very general\n//   and hence has a complex interface.  The examples below form a tutorial on how to use `join_prism` that steps\n//   through the various options and how they affect the results.  Be sure to check the examples for help understanding how the various options work.\n//   .\n//   When joining between planes this function produces similar results to {{rounded_prism()}}.  This function works best when the prism\n//   cross section is a continuous shape with a high sampling rate and without sharp corners.  If you have sharp corners you should consider\n//   giving them a small rounding first.  When the prism cross section has concavities the fillet size will be limited by the curvature of those concavities.\n//   In contrast, {{rounded_prism()}} works best on a prism that has fewer points.  A high sampling rate can lead to problems, and rounding\n//   over sharp corners leads to poor results.  \n//   .\n//   You specify the prism by giving its cross section as a 2D path.  The cross section will always be the orthogonal cross\n//   section of the prism.  Depending on end conditions, the ends may not be perpendicular to the\n//   axis of the prism, but the cross section you give *is* always perpendicular to that cross section.\n// Figure(3D,Big,NoScales,VPR=[74.6, 0, 329.7], VPT=[28.5524, 35.3006, 22.522], VPD=325.228): The layout and terminology used by `join_prism`.  The \"base object\" is centered on the origin.  The \"auxiliary object\" (if present) is some distance away so there is room for the \"joiner prism\" to connect the two objects.  The blue line is the axis of the jointer prism.  It will be at the origin of the shape you supply for defining that prism.  The \"root\" point of the joiner prism is the point where the prism axis intersects the base.  The prism end point is where the prism axis intersects the auxiliary object.  If you don't give an auxiliary object then the prism end point is distance `length` along the axis from the root.  \n//   aT = right(-10)*back(0)*up(75)*xrot(-35)*zrot(75);\n//   br = 17;\n//   ar = 15;\n//   xcyl(r=br, l=50, circum=true, $fn=64);\n//   multmatrix(aT)right(15)xcyl(r=ar,circum=true,l=50,$fn=64);\n//   %join_prism(circle(r=10), base = \"cyl\", base_r=br, aux=\"cyl\", aux_r=ar, aux_T=aT,fillet=3);\n//   root = [-2.26667, 0, 17];\n//   rback = [15,0,25];\n//   endpt =  [-7.55915, 0, 56.6937];\n//   endback = [10,0,55];\n//   stroke([root,endpt],\n//          width=1,endcap_width=3,endcaps=\"dot\",endcap_color=\"red\",color=\"blue\",$fn=16);\n//   stroke(move(3*unit(rback-root), [rback,root]), endcap2=\"arrow2\",width=1/2,$fn=16,color=\"black\");\n//   down(0)right(4)color(\"black\")move(rback)rot($vpr)text(\"prism root point\",size=4);\n//   stroke(move(3*unit(endback-endpt), [endback,endpt]), endcap2=\"arrow2\", width=1/2, $fn=16, color=\"black\");\n//   down(2)right(4)color(\"black\")move(endback)rot($vpr)text(\"prism end point\",size=4);\n//   right(4)move(-20*[1,1])color(\"black\")rot($vpr)text(\"base\",size=8);\n//   up(83)right(-10)move(-20*[1,1])color(\"black\")rot($vpr)text(\"aux\",size=8);\n//   aend=[-13,13,30];\n//   ast=aend+10*[-1,1,0];\n//   stroke([ast,aend],endcap2=\"arrow2\", width=1/2, color=\"black\");\n//   left(2)move(ast)rot($vpr)color(\"black\")text(\"joiner prism\",size=5,anchor=RIGHT);\n// Continues:\n//   You must include a base (\"plane\", \"sphere\", \"cylinder\", \"cyl\"), or a polygon describing the cross section of a base prism.  If you specify a\n//   sphere or cylinder you must give `base_r` or `base_d` to specify the radius or diameter of the base object.  If you choose a cylinder or a polygonal\n//   prism then the base object appears aligned with the X axis.  In the case of the planar base, the\n//   joining prism will have one end of its axis at the origin.  As shown above, the point where the joining prism attaches to its base is the \"root\" of the prism.\n//   If you use some other base shape, the root will be adjusted so that it is on the boundary of your shape.  This happens by finding the intersection\n//   of the joiner prisms's axis and using that as the root.  By default the prism axis is parallel to the Z axis.  \n//   .\n//   You may give `base_T`, a rotation operator that will be applied to the base.  This is\n//   useful to tilt a planar or cylindrical base.  The `base_T` operator must be an origin-centered rotation like yrot(25).  \n//   .\n//   You may optionally specify an auxiliary shape.  When you do this, the joining prism connects the base to the auxiliary shape,\n//   which must be one of \"none\", \"plane\", \"sphere\", \"cyl\", or \"cylinder\".  You can also set it to a polygon to create an arbitrary\n//   prism for the auxiliary shape.  As is the case for the base, auxiliary cylinders and prisms appear oriented along the X axis.  \n//   For a cylinder or sphere you must use `aux_r` or `aux_d` to specify the radius or diameter.\n//   The auxiliary shape appears centered on the origin and will most likely be invalid as an end location unless you translate it to a position\n//   away from the base object.  The `aux_T` operator operates on the auxiliary object, and unlike `base_T` can be a rotation that includes translation\n//   operations (or is a non-centered rotation).\n//   .\n//   When you specify an auxiliary object, the joiner prism axis is initially the line connecting the origin (the base center point) to the auxiliary\n//   object center point.  The joiner prism end point is determined analogously to how the root is determined, by intersecting the joiner\n//   prism axis with the auxiliary object.  Note that this means that if `aux_T` is a rotation it will change the joiner prism root, because\n//   the rotated prism axis will intersect the base in a different location.  If you do not give an auxiliary object then you must give\n//   the length/height parameter to specify the prism length.  This gives the length of the prism measured from the root to the end point.\n//   Note that the joint with a curved base may significantly extend the length of the joiner prism: it's total length will often be larger than\n//   the length you request.  \n//   .\n//   For the cylinder and spherical objects you may with to joint a prism to the concave surface.  You can do this by setting a negative\n//   radius for the base or auxiliary object.  When `base_r` is negative, and the joiner prism axis is vertical, the prism root will be **below** the\n//   XY plane.  In this case it is actually possible to use the same object for base and aux and you can get a joiner prism that crosses a cylindrical\n//   or spherical hole.\n//   .\n//   When placing prisms inside a hole, an ambiguity can arise about how to identify the root and end of the joiner prism.  The prism axis will have\n//   two intersections with a cylinder and both are potentially valid roots.  When the auxiliary object is entirely inside the hole, or the auxiliary\n//   object is a sphere or cylinder with negative radius that intersections the base, both prism directions produce a valid\n//   joiner prism that meets the hole's concave surface, so two valid interpretations exist.  By default, the longer prism will be returned.\n//   You can select the shorter prism by setting `short=true`.  If you specify `short=true` when the base has a negative radius, but only one valid\n//   prism exists, you'll get an error, but it won't clearly identify that a bogus `short=true` was the real cause.  \n//   .\n//   You can also alter your prism by using the `prism_end_T` operator which applies to the end point of the prism.  It does not effect\n//   the root  of the prism.  The `prism_end_T` operator is applied in a coordinate system where the root of the\n//   prism is the origin, so if you set it to a rotation the prism base will stay rooted at the same location and the prism will rotate \n//   in the specified fashion.  After `prism_end_T` is applied, the prism axis will probably be different and the resulting new end point will\n//   probably not be on the auxiliary object, or it will have changed the length of the prism.  Therefore, the end point is recalculated\n//   to achieve the specified length (if aux is \"none\") or to contact the auxiliary object, if you have specified one.  This means, for example,\n//   that setting `prism_end_T` to a scale operation won't change the result because it doesn't alter the prism axis.  \n//   .\n//   The size of the fillets is determined by the fillet, `fillet_base`, and `fillet_aux` parameters.  The fillet parameter will control both\n//   ends of the prism, or you can set the ends independently.  The fillets must be nonnegative except when the prism joints a plane.\n//   In this case a negative fillet gives a roundover.  In the case of no auxiliary object you can use `round_end` to round over the planar\n//   far end of the joiner prism.  By default, the fillet is constructed using a method that produces a fillet with a uniform height along\n//   the joiner prism.  This can be limiting when connectijng to objects with high curvature, so you can turn it off using the `uniform` option.\n//   See the figures below for an explanation of the uniform and non-uniform filleting methods.  \n//   .\n//   The overlap is a potentially tricky parameter.  It specifies how much extra material to\n//   create underneath the filleted prism so it overlaps the object that it joins to, ensuring valid unions.\n//   For joins to convex objects you can choose a small value, but when joining to a concave object the overlap may need to be\n//   very large to ensure that the base of the joiner prism is well-behaved.  In such cases you may need to use an intersection\n//   remove excess base.\n// Figure(2D,Med,NoAxes): Uniform fillet method.  This image shows how the fillet we construct a uniform fillet.  The pictures shows the cross section that is perpendicular to the prism.  The blue curve represents the base object surface.  The vertical line is the side of the prism.  To construct a fillet we travel along the surface of the base, following the curve, until we have moved the fillet length, `a`.  This defines the point `u`.  We then construct a tangent line to the base and find its intersection, `v`, with the prism.  Note that if the base is steeply curved, this tangent may fail to intersect, and the algorithm will fail with an error because `v` does not exist.  Finally we locate `w` to be distance `a` above the point where the prism intersects the base object.  The fillet is defined by the `[u,v,w]` triple and is shown in red.  Note that with this method, the fillet is always height `a` above the base, so it makes a uniform curve parallel to the base object.  However, when the base curvature is more extreme, point `v` may end up above point `w`, resulting in an invalid configuration.  It also happens that point `v`, while below `w`, is very close to `w`, so the resulting fillet has an abrupt angle near `w` instead of a smooth transition.  \n//   R=60;\n//   base = R*[cos(70),sin(70)];\n//   end = R*[cos(45),sin(45)];\n//   tang = [-sin(45),cos(45)];\n//   isect = line_intersection([base,back(1,base)], [end,end+tang]);\n//   toppt = base+[0,2*PI*R*25/360];\n//   bez = _smooth_bez_fill([toppt, isect,end], 0.8);\n//   color(\"red\")\n//     stroke(bezier_curve(bez,30,endpoint=true), width=.5);\n//   color(\"blue\"){\n//      stroke(arc(n=50,angle=[35,80], r=R), width=1);\n//      stroke([base, back(40,base)]);\n//      move(R*[cos(35),sin(35)])text(\"Base\", size=5,anchor=BACK);\n//      back(1)move(base+[0,40]) text(\"Prism\", size=5, anchor=FWD);\n//   }\n//   color([.3,1,.3]){\n//     right(2)move(toppt)text(\"w\",size=5);\n//     right(2)move(end)text(\"u\",size=5);\n//     stroke([isect+[1,1/4], isect+[16,4]], width=.5, endcap1=\"arrow2\");\n//     move([16.5,3])move(isect)text(\"v\",size=5);\n//     stroke([end,isect],dots=true);\n//     stroke([isect,toppt], dots=true);\n//   }\n//   color(\"black\")  {\n//      stroke(arc(n=50, angle=[45,70], r=R-3), color=\"black\", width=.6, endcaps=\"arrow2\");\n//       move( (R-10)*[cos(57.5),sin(57.5)]) text(\"a\",size=5);\n//      left(3)move( base+[0,PI*R*25/360]) text(\"a\", size=5,anchor=RIGHT);\n//      left(2)stroke( [base, toppt],endcaps=\"arrow2\",width=.6);\n//   }\n// Figure(2D,Med,NoAxes): Non-Uniform fillet method.  This method differs because point `w` is found by moving the fillet distance `a` starting at the intersection point `v` instead of at the base surface.  This means that the `[u,v,w]` triple is always in the correct order to produce a valid fillet.  However, the height of the fillet above the surface will vary.  When the base concave, point `v` is below the surface of the base, which in more extreme cases can produce a fillet that goes below the base surface.  The uniform method is less likely to produce this kind of result.  When the base surface is a plane, the uniform and non-uniform methods are identical.\n//   R=60;\n//   base = R*[cos(70),sin(70)];\n//   end = R*[cos(45),sin(45)];\n//   tang = [-sin(45),cos(45)];\n//   isect = line_intersection([base,back(1,base)], [end,end+tang]);\n//   toppt = isect+[0,2*PI*R*25/360];\n//   bez = _smooth_bez_fill([toppt, isect,end], 0.8);\n//   color(\"red\")stroke(bezier_curve(bez,30,endpoint=true), width=.5);\n//   color(\"blue\"){\n//      stroke(arc(n=50,angle=[35,80], r=R), width=1);\n//      stroke([base, back(40,base)]);\n//      move(R*[cos(35),sin(35)])text(\"Base\", size=5,anchor=BACK);\n//      back(1)move(base+[0,40]) text(\"Prism\", size=5, anchor=FWD);\n//   }\n//   color([.3,1,.3]){\n//     right(2)move(toppt)text(\"w\",size=5);\n//     right(2)move(end)text(\"u\",size=5);\n//     stroke([isect+[1,1/4], isect+[16,4]], width=.5, endcap1=\"arrow2\");\n//     move([16.5,3])move(isect)text(\"v\",size=5);\n//     stroke([end,isect],dots=true);\n//     stroke([isect,toppt], dots=true);\n//   }\n//   color(\"black\")  {\n//      stroke(arc(n=50, angle=[45,70], r=R-3), width=.6, endcaps=\"arrow2\");\n//      move( (R-10)*[cos(57.5),sin(57.5)]) text(\"a\",size=5);\n//      left(3)move( (isect+toppt)/2) text(\"a\", size=5,anchor=RIGHT);\n//      left(2)stroke( [isect, toppt],endcaps=\"arrow2\",width=.6);\n//   }\n// Arguments:\n//   polygon = polygon giving prism cross section\n//   base = string specifying base object to join to (\"plane\",\"cyl\",\"cylinder\", \"sphere\") or a point list to use an arbitrary prism as the base.\n//   ---\n//   length / height / l / h = length/height of prism if aux==\"none\"\n//   scale = scale factor for prism far end.  Default: 1\n//   prism_end_T = root-centered arbitrary transform to apply to the prism's far point.  Default: IDENT\n//   short = flip prism direction for concave sphere or cylinder base, when there are two valid prisms.  Default: false\n//   base_T = origin-centered rotation operator to apply to the base\n//   base_r / base_d = base radius or diameter if you picked sphere or cylinder\n//   aux = string specifying auxilary object to connect to (\"none\", \"plane\", \"cyl\", \"cylinder\", or \"sphere\") or a point list to use an arbitrary prism.  Default: \"none\"\n//   aux_T = rotation operator that may include translation when aux is not \"none\" to apply to aux\n//   aux_r / aux_d = radius or diameter of auxiliary object if you picked sphere or cylinder\n//   n = number of segments in the fillet at both ends.  Default: 15\n//   base_n = number of segments to use in fillet at the base\n//   aux_n = number of segments to use in fillet at the aux object\n//   end_n = number of segments to use in roundover at the end of prism with no aux object\n//   fillet = fillet for both ends of the prism (if applicable)  Must be nonnegative except for joiner prisms with planar ends\n//   base_fillet = fillet for base end of prism \n//   aux_fillet = fillet for joint with aux object\n//   end_round = roundover of end of prism with no aux object \n//   overlap = amount of overlap of prism fillet into objects at both ends.  Default: 1 for normal fillets, 0 for negative fillets and roundovers\n//   base_overlap = amount of overlap of prism fillet into the base object\n//   aux_overlap = amount of overlap of the prism fillet into aux object\n//   k = fillet curvature parameter for both ends of prism\n//   base_k = fillet curvature parameter for base end of prism\n//   end_k / aux_k = fillet curvature parameter for end of prism where the aux object is\n//   uniform = set to false to get non-uniform filleting at both ends (see Figures 2-3).  Default: true\n//   base_uniform = set to false to get non-uniform filleting at the base\n//   aux_uniform = set to false to get non-uniform filleting at the auxiliary object\n//   debug = set to true to allow return of various cases where self-intersection was detected\n//   anchor = Translate so anchor point is at the origin.  (module only) Default: \"origin\"\n//   spin = Rotate this many degrees around Z axis after anchor.  (module only) Default: 0\n//   orient = Vector to rotate top towards after spin  (module only)\n//   atype = Select \"hull\" or \"intersect\" anchor types.  (module only) Default: \"hull\"\n//   cp = Centerpoint for determining \"intersect\" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 3D point.  (module only) Default: \"centroid\"\n// Extra Anchors:\n//   \"root\" = Root point of the joiner prism, pointing out in the direction of the prism axis\n//   \"end\" = End point of the joiner prism, pointing out in the direction of the prism axis\n// Example(3D,NoScales): Here is the simplest case, a circular prism with a specified length standing vertically on a plane.  \n//   join_prism(circle(r=15,$fn=60),base=\"plane\",\n//              length=18, fillet=3, n=12);\n//   cube([50,50,5],anchor=TOP);\n// Example(3D,NoScales): Here we substitute an abitrary prism. \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"plane\",length=18, fillet=3, n=12);\n//   cube([50,50,5],anchor=TOP);\n// Example(3D,NoScales): Here we apply a rotation of the prism, using prism_end_T, which rotates around the prism root.  Note that aux_T will rotate around the origin, which is the same when the prism is joined to a plane.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"plane\",length=18, fillet=3,\n//              n=12, prism_end_T=yrot(25));\n//   cube([50,50,5],anchor=TOP);\n// Example(3D,NoScales): We can use `end_round` to get a roundover\n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"plane\",length=18, fillet=3,\n//              n=12, prism_end_T=yrot(25), end_round=4);\n//   cube([50,50,5],anchor=TOP);\n// Example(3D,NoScales): We can tilt the base plane by applying a base rotation.  Note that because we did not tilt the prism, it still points upwards.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"plane\",length=18, fillet=3,\n//              n=12, base_T=yrot(25));\n//   yrot(25)cube([50,50,5],anchor=TOP);\n// Example(3D,NoScales): Next consider attaching the prism to a sphere.  You must use a circumscribed sphere to avoid a lip or gap between the sphere and prism.  Note that the prism is attached to the sphere's boundary above the origin and projects by the specified length away from the attachment point.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"sphere\",base_r=30, length=18,\n//              fillet=3, n=12);\n//   spheroid(r=30,circum=true,$fn=64);\n// Example(3D,NoScales): Rotating using the prism_end_T option rotates around the attachment point.  Note that if you rotate too far, some points of the prism will miss the sphere, which is an error.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"sphere\",base_r=30, length=18,\n//              fillet=3, n=12, prism_end_T=yrot(-15));\n//   spheroid(r=30,circum=true,$fn=64);\n// Example(3D,NoScales): Rotating using the aux_T option rotates around the origin.  You could get the same result in this case by rotating the whole model.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"sphere\",base_r=30, length=18,\n//              fillet=3, n=12, aux_T=yrot(-45));\n//   spheroid(r=30,circum=true,$fn=64);\n// Example(3D,NoScales): The origin in the prism cross section always aligns with the origin of the object you attach to.  If you want to attach off center, then shift your prism cross section.  If you shift too far so that parts of the prism miss the base object then you will get an error.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(right(10,flower),base=\"sphere\",base_r=30,\n//              length=18, fillet=3, n=12);\n//   spheroid(r=30,circum=true,$fn=64);\n// Example(3D,NoScales): The third available base shape is the cylinder.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"cylinder\",base_r=30,\n//              length=18, fillet=4, n=12); \n//   xcyl(r=30,l=75,circum=true,$fn=64);\n// Example(3D,NoScales): You can rotate the cylinder the same way we rotated the plane.\n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"cylinder\",base_r=30, length=18,\n//              fillet=4, n=12, base_T=zrot(33)); \n//   zrot(33)xcyl(r=30,l=75,circum=true,$fn=64);\n// Example(3D,NoScales): And you can rotate the prism around its attachment point with prism_end_T\n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"cylinder\",base_r=30, length=18,\n//              fillet=4, n=12, prism_end_T=yrot(22));\n//   xcyl(r=30,l=75,circum=true,$fn=64);\n// Example(3D,NoScales): Or you can rotate the prism around the origin with aux_T\n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"cylinder\",base_r=30, length=18,\n//              fillet=4, n=12, aux_T=xrot(22));\n//   xcyl(r=30,l=75,circum=true,$fn=64);\n// Example(3D,NoScales): Here's a prism where the scale changes\n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"cylinder\",base_r=30, length=18,\n//              fillet=4, n=12,scale=.5);\n//   xcyl(r=30,l=75,circum=true,$fn=64);\n// Example(3D,NoScales,VPD=190,VPR=[61.3,0,69.1],VPT=[41.8956,-9.49649,4.896]): Giving a negative radius attaches to the inside of a sphere or cylinder.  Note you want the inscribed cylinder for the inner wall.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"cylinder\",base_r=-30, length=18,\n//              fillet=4, n=12);\n//   bottom_half(z=-10)\n//     tube(ir=30,wall=3,l=74,$fn=64,orient=RIGHT,anchor=CENTER);\n// Example(3D,NoScales,VPD=140,VPR=[72.5,0,73.3],VPT=[40.961,-19.8319,-3.03302]): A hidden problem lurks with concave attachments.  The bottom of the prism does not follow the curvature of the base.  Here you can see a gap.  In some cases you can create a self-intersection in the prism.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   left_half(){\n//     join_prism(flower,base=\"cylinder\",base_r=-30, length=18,\n//                fillet=4, n=12);\n//     bottom_half(z=-10)\n//       tube(ir=30,wall=3,l=74,$fn=64,orient=RIGHT,anchor=CENTER);\n//   }\n// Example(3D,NoScales,VPD=140,VPR=[72.5,0,73.3],VPT=[40.961,-19.8319,-3.03302]): The solution to both problems is to increase the overlap parameter, but you may then have excess base that must be differenced or intersected away.  In this case, an overlap of 2 is sufficient to eliminate the hole.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   left_half(){\n//     join_prism(flower,base=\"cylinder\",base_r=-30, length=18,\n//                fillet=4, n=12, overlap=2);     \n//     bottom_half(z=-10)\n//       tube(ir=30,wall=3,l=74,$fn=64,orient=RIGHT,anchor=CENTER);\n//   }\n// Example(3D,NoScales,VPD=126,VPR=[76.7,0,111.1],VPT=[6.99093,2.52831,-14.8461]): Here is an example with a spherical base.  This overlap is near the minimum required to eliminate the gap, but it creates a large excess structure around the base of the prism.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   left_half(){\n//     join_prism(flower,base=\"sphere\",base_r=-30, length=18,\n//                fillet=4, n=12, overlap=7);\n//     bottom_half(z=-10) difference(){\n//       sphere(r=33,$fn=16);\n//       sphere(r=30,$fn=64);\n//     }\n//   }\n// Example(3D,NoScales,VPD=126,VPR=[55,0,25],VPT=[1.23541,-1.80334,-16.9789]): Here is an example with a spherical base.  This overlap is near the minimum required to eliminate the gap, but it creates a large excess structure around the base of the prism.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   intersection(){\n//     union(){\n//       join_prism(flower,base=\"sphere\",base_r=-30, length=18, \n//                  fillet=4, n=12, overlap=7);\n//       difference(){\n//         down(18)cuboid([68,68,30],anchor=TOP);\n//         sphere(r=30,$fn=64);\n//       }\n//     }\n//     sphere(r=33,$fn=16);\n//   }\n// Example(3D,NoScales,VPD=126,VPR=[55,0,25],VPT=[1.23541,-1.80334,-16.9789]): As before, rotating with aux_T rotates around the origin. \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   intersection(){\n//     union(){\n//       join_prism(flower,base=\"sphere\",base_r=-30, length=18,\n//                  fillet=4, n=12, overlap=7, aux_T=yrot(13));\n//       difference(){\n//         down(18)cuboid([68,68,30],anchor=TOP);\n//         sphere(r=30,$fn=64);\n//       }\n//     }\n//     sphere(r=33,$fn=16);\n//   }\n// Example(3D,NoScales,VPD=102.06,VPR=[55,0,25],VPT=[3.96744,-2.80884,-19.9293]): Rotating with prism_end_T rotates around the attachment point.  We shrank the prism to allow a significant rotation.\n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   intersection(){\n//     union(){\n//       join_prism(scale(.5,flower),base=\"sphere\",base_r=-30,\n//                  length=18, fillet=2, n=12, overlap=7,\n//                  prism_end_T=yrot(25));\n//       difference(){\n//         down(23)cuboid([68,68,30],anchor=TOP);\n//         sphere(r=30,$fn=64);\n//       }\n//     }\n//     sphere(r=33,$fn=16);\n//   }\n// Example(3D,NoScales,VPR=[65.5,0,105.3],VPT=[8.36329,13.0211,9.98397],VPD=237.091): You can create a prism that crosses the inside of a cylinder or sphere by giving the same negative radius twice and leaving both objects with the same center, as shown here.  \n//   left_half(x=7){\n//     join_prism(circle(r=15),base=\"cylinder\",base_r=-30, n=12,\n//                aux=\"cylinder\", aux_r=-30, fillet=8, overlap=3);\n//     tube(ir=30,wall=5,l=74,$fn=64,orient=RIGHT,anchor=CENTER);     \n//   }\n// Example(3D,NoScales,VPR=[65.5,0,105.3],VPT=[8.36329,13.0211,9.98397],VPD=237.091): Here's a similar example with a plane for the auxiliary object.  Note that we observe the 1 unit overlap on the top surface.  \n//   left_half(x=7){\n//     join_prism(circle(r=15),base=\"cylinder\",base_r=-30,\n//                aux=\"plane\", fillet=8, n=12, overlap=3);\n//     tube(ir=30,wall=5,l=74,$fn=64,orient=RIGHT,anchor=CENTER);     \n//   }\n// Example(3D,NoScales,VPR=[65.5,0,105.3],VPT=[8.36329,13.0211,9.98397],VPD=237.091): We have tweaked the previous example just slightly by lowering the height of the plane.  The result is a bit of a surprise:  the prism flips upside down!  This happens because there is an ambiguity in creating a prism between a plane and the inside of the cylinder.  By default, this ambiguity is resolved by choosing the longer prism.  \n//   left_half(x=7){\n//     join_prism(circle(r=15),base=\"cylinder\",base_r=-30, n=12,\n//                aux=\"plane\", aux_T=down(5), fillet=8, overlap=3);\n//     tube(ir=30,wall=5,l=74,$fn=64,orient=RIGHT,anchor=CENTER);     \n//   }\n// Example(3D,NoScales,VPR=[65.5,0,105.3],VPT=[8.36329,13.0211,9.98397],VPD=237.091): Adding `short=true` resolves the ambiguity of which prism to construct in the other way, by choosing the shorter option.  \n//   left_half(x=7){\n//     join_prism(circle(r=15),base=\"cylinder\",base_r=-30,\n//                aux=\"plane\", aux_T=down(5), fillet=8,\n//                n=12, overlap=3, short=true);\n//     tube(ir=30,wall=5,l=74,$fn=64,orient=RIGHT,anchor=CENTER);\n//   }\n// Example(3D,NoScales,VPR=[85.1,0,107.4],VPT=[8.36329,13.0211,9.98397],VPD=237.091): The problem does not arise in this case because the auxiliary object only allows one possible way to make the connection. \n//   left_half(x=7){\n//     join_prism(circle(r=15),base=\"cylinder\",base_r=-30,\n//                aux=\"cylinder\", aux_r=30, aux_T=up(20),\n//                fillet=8, n=12, overlap=3);\n//     tube(ir=30,wall=5,l=74,$fn=64,orient=RIGHT,anchor=CENTER);\n//     up(20)xcyl(r=30,l=74,$fn=64);\n//   }\n// Example(3D,NoScales,VPT=[-1.23129,-3.61202,-0.249883],VPR=[87.9,0,295.7],VPD=213.382): When the aux cylinder is inside the base cylinder we can select the two options, shown here as red for the default and blue for the `short=true` case. \n//   color(\"red\")\n//     join_prism(circle(r=5),base=\"cylinder\",base_r=-30, \n//                aux=\"cyl\",aux_r=10, aux_T=up(12), fillet=4,\n//                 n=12, overlap=3, short=false);\n//   color(\"blue\")\n//     join_prism(circle(r=5),base=\"cylinder\",base_r=-30, \n//                aux=\"cyl\",aux_r=10, aux_T=up(12), fillet=4,\n//                n=12, overlap=3, short=true);\n//   tube(ir=30,wall=5,$fn=64,l=18,orient=RIGHT,anchor=CENTER);\n//   up(12)xcyl(r=10, circum=true, l=18);\n// Example(3D,NoScales,VPR=[94.9,0,106.7],VPT=[4.34503,1.48579,-2.32228],VPD=237.091): The same thing is true when you use a negative radius for the aux cylinder. This is the default long case.  \n//   join_prism(circle(r=5,$fn=64),base=\"cylinder\",base_r=-30, \n//              aux=\"cyl\",aux_r=-10, aux_T=up(12), fillet=4,\n//              n=12, overlap=3, short=false);\n//   tube(ir=30,wall=5,l=24,$fn=64,orient=RIGHT,anchor=CENTER);\n//   up(12) top_half()\n//      tube(ir=10,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);\n// Example(3D,NoScales,VPR=[94.9,0,106.7],VPT=[4.34503,1.48579,-2.32228],VPD=237.091): And here is the short case:\n//   join_prism(circle(r=5,$fn=64),base=\"cylinder\",base_r=-30, \n//              aux=\"cyl\",aux_r=-10, aux_T=up(12), fillet=4,\n//              n=12, overlap=3, short=true);\n//   tube(ir=30,l=24,wall=5,$fn=64,orient=RIGHT,anchor=CENTER);\n//   up(12) bottom_half()\n//     tube(ir=10,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);\n// Example(3D,NoScales,VPR=[94.9,0,106.7],VPT=[0.138465,6.78002,24.2731],VPD=325.228): Another example where the cylinders overlap, with the long case here:\n//   auxT=up(40);\n//   join_prism(circle(r=5,$fn=64),base=\"cylinder\",base_r=-30, \n//              aux=\"cyl\",aux_r=-40, aux_T=auxT, fillet=4,\n//              n=12, overlap=3, short=false);\n//   tube(ir=30,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);\n//   multmatrix(auxT)\n//     tube(ir=40,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);\n// Example(3D,NoScales,VPR=[94.9,0,106.7],VPT=[0.138465,6.78002,24.2731],VPD=325.228): And the short case:\n//   auxT=up(40);\n//   join_prism(circle(r=5,$fn=64),base=\"cylinder\",base_r=-30, \n//              aux=\"cyl\",aux_r=-40, aux_T=auxT, fillet=4,\n//              n=12, overlap=3, short=true);\n//   tube(ir=30,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);\n//   multmatrix(auxT)\n//     tube(ir=40,wall=4,l=24,$fn=64,orient=RIGHT,anchor=CENTER);\n// Example(3D,NoScales): Many of the preceeding examples feature a prism with a concave shape cross section.  Concave regions can limit the amount of rounding that is possible.  This occurs because the algorithm is not able to handle a fillet that intersects itself.  Fillets on a convex prism always grow larger as they move away from the prism, so they cannot self intersect.  This means that you can make the fillet as big as will fit on the base shape.  The fillet will fail to fit if the tangent plane to the base at the fillet distance from the prism fails to intersect the prism.  Here is an extreme example, almost the largest possible fillet to the convex elliptical convex prism.  \n//   ellipse = ellipse([17,10],$fn=164);  \n//   join_prism(ellipse,base=\"sphere\",base_r=30, length=18,\n//              fillet=18, n=25, overlap=1);\n//   spheroid(r=30,circum=true, $fn=96);\n// Example(3D,NoScales): This example shows a failed rounding attempt where the result is self-intersecting.  Using the `debug=true` option makes it possible to view the result to understand what went wrong.  Note that the concave corners have a crease where the fillet crosses itself.  The error message will advise you to decrease the size of the fillet.  You can also fix the problem by making your concave curves shallower.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+2.5*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"cylinder\",base_r=30, length=18,\n//              fillet=6, n=12, debug=true); \n// Example(3D,NoScales): Your prism needs to be finely sampled enough to follow the contour of the base you are attaching it to.  If it is not, you get a result like this.  The fillet joints the prism smoothly, but makes a poor transition to the sphere. \n//   sq = rect(15);\n//   join_prism(sq, base=\"sphere\", base_r=25,\n//              length=18, fillet=4, n=12);\n//   spheroid(r=25, circum=true, $fn=96);\n// Example(3D,NoScales): To fix the problem, you must subdivide the polygon that defines the prism.  But note that the join_prism method works poorly at sharp corners.\n//   sq = subdivide_path(rect(15),n=64);\n//   join_prism(sq, base=\"sphere\", base_r=25,\n//              length=18, fillet=4, n=12);\n//   spheroid(r=25, circum=true,$fn=96);\n// Example(3D,NoScales): In the previous example, a small rounding of the prism corners produces a nicer result.\n//   sq = subdivide_path(\n//          round_corners(rect(15),cut=.5,$fn=32),\n//          n=128);\n//   join_prism(sq, base=\"sphere\", base_r=25,\n//              length=18, fillet=4, n=12);\n//   spheroid(r=25, circum=true,$fn=96);\n// Example(3D,NoScales): The final option for specifying the base is to use an arbitrary prism, specified by a polygon.  Note that the base prism is oriented to the RIGHT, so the attached prism remains Z oriented.  \n//   ellipse = ellipse([17,10],$fn=164);  \n//   join_prism(zrot(90,ellipse), base=2*ellipse, length=19,\n//              fillet=4, n=12);\n//   linear_sweep(2*ellipse,height=60, center=true, orient=RIGHT);\n// Example(3D,NoScales): As usual, you can rotate around the attachment point using prism_end_T. \n//   ellipse = ellipse([17,10],$fn=164);  \n//   join_prism(zrot(90,ellipse), base=2*ellipse, length=19,\n//              fillet=4, n=12, prism_end_T=yrot(22));\n//   linear_sweep(2*ellipse,height=60, center=true, orient=RIGHT);\n// Example(3D,NoScales): And you can rotate around the origin with aux_T.\n//   ellipse = ellipse([17,10],$fn=164);  \n//   join_prism(zrot(90,ellipse), base=2*ellipse, length=19,\n//              fillet=4, n=12, aux_T=yrot(22));\n//   linear_sweep(2*ellipse,height=60, center=true, orient=RIGHT);\n// Example(3D,NoScales): The base prism can be a more complicated shape.\n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=1.4*flower, fillet=3,\n//              n=15, length=20);\n//   linear_sweep(1.4*flower,height=60,center=true,\n//                convexity=10,orient=RIGHT);\n// Example(3D,NoScales): Here's an example with both prism_end_T and aux_T \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=1.4*flower, length=20,\n//              prism_end_T=yrot(20),aux_T=xrot(10),\n//              fillet=3, n=25);\n//   linear_sweep(1.4*flower,height=60,center=true,\n//                convexity=10,orient=RIGHT);\n// Example(3D,NoScales,VPR=[78,0,42],VPT=[12.45,-12.45,10.4],VPD=130): Instead of terminating your prism in a flat face perpendicular to its axis you can attach it to a second object.  The simplest case is to connect to planar attachments.  When connecting to a second object you must position and orient the second object using aux_T, which is now allowed to be a rotation and translation operator.  The `length` parameter is no longer allowed.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"plane\", fillet=4, n=12,\n//              aux=\"plane\", aux_T=up(12));\n//   %up(12)cuboid([40,40,4],anchor=BOT); \n//   cuboid([40,40,4],anchor=TOP);\n// Example(3D,NoScales,VPR=[78,0,42],VPT=[12.45,-12.45,10.4],VPD=130): Here's an example where the second object is rotated.  Note that the prism will go from the origin to the origin point of the object.  In this case because the rotation is applied first, the prism is vertical.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   aux_T = up(12)*xrot(-22);\n//   join_prism(flower,base=\"plane\",fillet=4, n=12,\n//              aux=\"plane\", aux_T=aux_T); \n//   multmatrix(aux_T)cuboid([42,42,4],anchor=BOT);\n//   cuboid([40,40,4],anchor=TOP);\n// Example(3D,NoScales,VPR=[78,0,42],VPT=[12.45,-12.45,10.4],VPD=130): In this example, the aux_T transform moves the centerpoint (origin) of the aux object, and the resulting prism connects centerpoints, so it is no longer vertical. \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   aux_T = xrot(-22)*up(12);\n//   join_prism(flower,base=\"plane\",fillet=4, n=12,\n//              aux=\"plane\", aux_T=aux_T);\n//   multmatrix(aux_T)cuboid([42,42,4],anchor=BOT);\n//   cuboid([43,43,4],anchor=TOP);\n// Example(3D,NoScales,VPR=[78,0,42],VPT=[9.95,-9.98,13.0],VPD=142]): You can combine with base_T\n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   aux_T = xrot(-22)*up(22);\n//   base_T = xrot(5)*yrot(-12);\n//   join_prism(flower,base=\"plane\",base_T=base_T, \n//              aux=\"plane\",aux_T=aux_T, fillet=4, n=12);\n//   multmatrix(aux_T)cuboid([42,42,4],anchor=BOT);\n//   multmatrix(base_T)cuboid([45,45,4],anchor=TOP);\n// Example(3D,NoScales,VPR=[76.6,0,29.4],VPT=[11.4009,-8.43978,16.1934],VPD=157.778): Using prism_end_T shifts the prism's end without tilting the plane, so the prism ends are not perpendicular to the prism axis.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   join_prism(flower,base=\"plane\", prism_end_T=right(14),\n//              aux=\"plane\",aux_T=up(24), fillet=4, n=12);\n//   right(7){\n//     %up(24)cuboid([65,42,4],anchor=BOT);\n//     cuboid([65,42,4],anchor=TOP);\n//   }\n// Example(3D,NoAxes,NoScales,VPR=[101.9, 0, 205.6], VPT=[5.62846, -5.13283, 12.0751], VPD=102.06): Negative fillets give roundovers and are pemitted only for joints to planes.  Note that overlap defaults to zero for negative fillets.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   aux_T = xrot(-22)*up(22);\n//   base_T = xrot(5)*yrot(-12);\n//   join_prism(flower,base=\"plane\",base_T=base_T,\n//              aux=\"plane\", aux_T=aux_T, fillet=-4,n=12);\n// Example(3D,NoScales,VPR=[84,0,21],VPT=[13.6,-1,46.8],VPD=446): It works the same way with the other shapes, but make sure you move the shapes far enough apart that there is room for a prism.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   aux_T = up(85);\n//   base_T = xrot(5)*yrot(-12);\n//   join_prism(flower,base=\"cylinder\",base_r=25, fillet=4, n=12,\n//              aux=\"sphere\",aux_r=35,base_T=base_T, aux_T=aux_T);\n//   multmatrix(aux_T)spheroid(35,circum=true);\n//   multmatrix(base_T)xcyl(l=75,r=25,circum=true);\n// Example(3D,NoScales,VPR=[84,0,21],VPT=[13.6,-1,46.8],VPD=446): Here we translate the sphere to the right and the prism goes with it\n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   aux_T = right(40)*up(85);\n//   join_prism(flower,base=\"cylinder\",base_r=25, n=12,\n//              aux=\"sphere\",aux_r=35, aux_T=aux_T, fillet=4);\n//   multmatrix(aux_T)spheroid(35,circum=true);\n//   xcyl(l=75,r=25,circum=true);\n// Example(3D,NoScales,VPR=[84,0,21],VPT=[13.6,-1,46.8],VPD=446): This is the previous example with the prism_end_T transformation used to shift the far end of the prism away from the sphere center.  Note that prism_end_T can be any transformation, but it just acts on the location of the prism endpoint to shift the direction the prism points.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   aux_T = right(40)*up(85);\n//   join_prism(flower,base=\"cylinder\",base_r=25,\n//              prism_end_T=left(4), fillet=3, n=12, \n//              aux=\"sphere\",aux_r=35, aux_T=aux_T); \n//   multmatrix(aux_T)spheroid(35,circum=true);\n//   xcyl(l=75,r=25,circum=true);\n// Example(3D,NoScales,VPR=[96.9,0,157.5],VPT=[-7.77616,-2.272,37.9424],VPD=366.527): Here the base is a cylinder but the auxilary object is a generic prism, and the joiner prism has a scale factor.  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   aux_T = up(85)*zrot(-75);\n//   ellipse = ellipse([17,10],$fn=164);  \n//   join_prism(flower,base=\"cylinder\",base_r=25,\n//              fillet=4, n=12,\n//              aux=ellipse, aux_T=aux_T,scale=.5);\n//   multmatrix(aux_T)\n//     linear_sweep(ellipse,orient=RIGHT,height=75,center=true);\n//   xcyl(l=75,r=25,circum=true,$fn=100);\n// Example(3D,NoAxes,VPT=[10.0389,1.71153,26.4635],VPR=[89.3,0,39],VPD=237.091): Base and aux are both a general prism in this case.\n//   ellipse = ellipse([10,17]/2,$fn=96);  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   aux_T=up(50);   \n//   join_prism(ellipse,base=flower,aux_T=aux_T,aux=flower,\n//              fillet=3, n=12, prism_end_T=right(9));\n//   multmatrix(aux_T)\n//     linear_sweep(flower,height=60,center=true,orient=RIGHT);\n//   linear_sweep(flower,height=60,center=true,orient=RIGHT);\n// Example(3D,NoAxes,VPT=[8.57543,0.531762,26.8046],VPR=[89.3,0,39],VPD=172.84): Shifting the joiner prism forward brings it close to a steeply curved edge of the auxiliary prism at the top.  Note that a funny looking bump with a sharp corner has appeared in the fillet.  This bump/corner is a result of the uniform filleting method running out of space.  If we move the joiner prism farther forward, the algorithm fails completely.  \n//   ellipse = ellipse([10,17]/2,$fn=96);  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   aux_T=up(50);   \n//   join_prism(ellipse,base=flower,aux_T=aux_T,aux=flower,\n//              fillet=3, n=12, prism_end_T=fwd(1.6));\n//   multmatrix(aux_T)\n//     linear_sweep(flower,height=60,center=true,orient=RIGHT);\n//   linear_sweep(flower,height=60,center=true,orient=RIGHT);\n// Example(3D,NoAxes,VPT=[8.57543,0.531762,26.8046],VPR=[89.3,0,39],VPD=172.84): This is the same example as above but with uniform turned off.  Note how the line the fillet makes on the joiner prism is not uniform, but the overall curved shape is more pleasing than the previous result, and we can bring the joiner prism a little farther forward and still construct a model. \n//   ellipse = ellipse([10,17]/2,$fn=96);  \n//   flower = [for(theta=lerpn(0,360,180,endpoint=false))\n//             (15+1.3*sin(6*theta))*[cos(theta),sin(theta)]];\n//   aux_T=up(50);   \n//   join_prism(ellipse,base=flower,aux_T=aux_T,aux=flower,\n//              fillet=3, n=12, prism_end_T=fwd(1.7),\n//              uniform=false);\n//   multmatrix(aux_T)\n//     linear_sweep(flower,height=60,center=true,orient=RIGHT);\n//   linear_sweep(flower,height=60,center=true,orient=RIGHT);\n// Example(3D): Positioning a joiner prism as an attachment\n//   cuboid([20,30,40])\n//     attach(RIGHT,\"root\")\n//       join_prism(circle(r=8,$fn=32),\n//                  l=10, base=\"plane\", fillet=4);\nmodule join_prism(polygon, base, base_r, base_d, base_T=IDENT,\n                    scale=1, prism_end_T=IDENT, short=false, \n                    length, l, height, h,\n                    aux=\"none\", aux_T=IDENT, aux_r, aux_d,\n                    overlap, base_overlap,aux_overlap,\n                    n=15, base_n, end_n, aux_n,\n                    fillet, base_fillet,aux_fillet,end_round,\n                    k=0.7, base_k,aux_k,end_k,\n                    uniform=true, base_uniform, aux_uniform, \n                    debug=false, anchor=\"origin\", extent=true, cp=\"centroid\", atype=\"hull\", orient=UP, spin=0,\n                    convexity=10)\n{\n    assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\");\n    vnf_start_end = join_prism(polygon,base, base_r=base_r, base_d=base_d, base_T=base_T,\n                   scale=scale, prism_end_T=prism_end_T, short=short,\n                   length=length, l=l, height=height, h=h,\n                   aux=aux, aux_T=aux_T, aux_r=aux_r, aux_d=aux_d,\n                   overlap=overlap, base_overlap=base_overlap, aux_overlap=aux_overlap,\n                   n=n,base_n=base_n, end_n=end_n, aux_n=aux_n,\n                   fillet=fillet, base_fillet=base_fillet, aux_fillet=aux_fillet, end_round=end_round,\n                   k=k, base_k=base_k, aux_k=aux_k, end_k=end_k,\n                   uniform=uniform, base_uniform=base_uniform, aux_uniform=aux_uniform, \n                   debug=debug,\n                   return_axis=true\n    );\n    axis = vnf_start_end[2] - vnf_start_end[1];\n    anchors = [\n               named_anchor(\"root\",vnf_start_end[1], -axis),\n               named_anchor(\"end\",vnf_start_end[2], axis)\n              ];\n    attachable(anchor,spin,orient,vnf=vnf_start_end[0], extent=atype==\"hull\", cp=cp, anchors=anchors) {\n      vnf_polyhedron(vnf_start_end[0],convexity=convexity);\n      children();\n    }\n}\n\n\n\nfunction join_prism(polygon, base, base_r, base_d, base_T=IDENT,\n                    scale=1, prism_end_T=IDENT, short=false, \n                    length, l, height, h,\n                    aux=\"none\", aux_T=IDENT, aux_r, aux_d,\n                    overlap, base_overlap,aux_overlap,\n                    n=15, base_n, aux_n, end_n, \n                    fillet, base_fillet,aux_fillet,end_round,\n                    k=0.7, base_k,aux_k,end_k,\n                    uniform=true, base_uniform, aux_uniform, \n                    debug=false, return_axis=false) =\n  let(\n      objects=[\"cyl\",\"cylinder\",\"plane\",\"sphere\"],\n      length = one_defined([h,height,l,length], \"h,height,l,length\", dflt=undef)\n  )\n  assert(is_path(polygon,2),\"Prism polygon must be a 2d path\")\n  assert(is_rotation(base_T,3,centered=true),\"Base transformation must be a rotation around the origin\")\n  assert(is_rotation(aux_T,3),\"Aux transformation must be a rotation\")\n  assert(aux!=\"none\" || is_rotation(aux_T,centered=true), \"With no aux, aux_T must be a rotation centered on the origin\")\n  assert(is_matrix(prism_end_T,4), \"Prism endpoint transformation is invalid\")\n  assert(aux!=\"none\" || (is_num(length) && length>0),\"With no aux must give positive length\")\n  assert(aux==\"none\" || is_undef(length), \"length parameter allowed only when aux is \\\"none\\\"\")\n  assert(aux==\"none\" || is_path(aux,2) || in_list(aux,objects), \"Unknown aux type\")\n  assert(is_path(base,2) || in_list(base,objects), \"Unknown base type\")\n  assert(is_undef(length) || (is_num(length) && length>0), \"Prism length must be positive\")\n  assert(is_num(scale) && scale>=0, \"Prism scale must be non-negative\")\n  assert(num_defined([end_k,aux_k])<2, \"Cannot define both end_k and aux_k\")\n  assert(num_defined([end_n,aux_n])<2, \"Cannot define both end_n and aux_n\")\n  let(\n      base_r = get_radius(r=base_r,d=base_d),\n      aux_r = get_radius(r=aux_r,d=aux_d),\n      base_k= first_defined([base_k,k]),\n      aux_k = first_defined([end_k,aux_k,k]),\n      aux_n = first_defined([end_n,aux_n,n]),\n      base_n = first_defined([base_n,n]),\n      base_fillet = one_defined([fillet,base_fillet],\"fillet,base_fillet\"),\n      aux_fillet = aux==\"none\" ? one_defined([aux_fillet,u_mul(-1,end_round)],\"aux_fillet,end_round\",0)\n              : one_defined([fillet,aux_fillet],\"fillet,aux_fillet\"),\n      base_overlap = one_defined([base_overlap,overlap],\"base_overlap,overlap\",base_fillet>0?1:0),\n      aux_overlap = one_defined([aux_overlap,overlap],\"aux_overlap,overlap\",aux_fillet>0?1:0),\n      base_uniform = first_defined([base_uniform, uniform]),\n      aux_uniform = first_defined([aux_uniform, uniform])\n  )\n  assert(is_num(base_fillet),\"Must give a numeric fillet or base_fillet value\")\n  assert(base==\"plane\" || base_fillet>=0, \"Fillet for non-planar base object must be nonnegative\")\n  assert(is_num(aux_fillet), \"Must give numeric fillet or aux_fillet\")\n  assert(in_list(aux,[\"none\",\"plane\"]) || aux_fillet>=0, \"Fillet for aux object must be nonnegative\")\n  assert(!in_list(base,[\"sphere\",\"cyl\",\"cylinder\"]) || (is_num(base_r) && !approx(base_r,0)), str(\"Must give nonzero base_r with base \",base))\n  assert(!in_list(aux,[\"sphere\",\"cyl\",\"cylinder\"]) || (is_num(aux_r) && !approx(aux_r,0)), str(\"Must give nonzero aux_r with base \",base))\n  assert(!short || (in_list(base,[\"sphere\",\"cyl\",\"cylinder\"]) && base_r<0), \"You can only set short to true if the base is a sphere or cylinder with radius<0\")\n  let(\n      base_r=default(base_r,0),\n      polygon=clockwise_polygon(polygon),\n      start_center = CENTER,\n      dir = aux==\"none\" ? apply(aux_T,UP)\n          : apply(aux_T,CENTER) == CENTER ? apply(aux_T,UP)\n          : apply(aux_T,CENTER),\n      flip = short ? -1 : 1,\n      start = base==\"sphere\" ?\n                let( answer = _sphere_line_isect_best(abs(base_r),[CENTER,flip*dir], sign(base_r)*flip*dir))\n                assert(answer,\"Prism center doesn't intersect sphere (base)\")\n                answer\n            : base==\"cyl\" || base==\"cylinder\" ?\n                let(\n                     mapped = apply(yrot(90),[CENTER,flip*dir]),\n                     answer = _cyl_line_intersection(abs(base_r),mapped,sign(base_r)*mapped[1])\n                 )\n                 assert(answer,\"Prism center doesn't intersect cylinder (base)\")\n                 apply(yrot(-90),answer)\n            : is_path(base) ?\n                let( \n                     mapped = apply(yrot(90),[CENTER,flip*dir]),\n                     answer = _prism_line_isect(pair(base,wrap=true),mapped,mapped[1])[0]\n                 )\n                 assert(answer,\"Prism center doesn't intersect prism (base)\")\n                 apply(yrot(-90),answer)\n            : start_center,\n      aux_T = aux==\"none\" ? move(start)*prism_end_T*move(-start)*move(length*dir)*move(start)\n              : aux_T,\n      prism_end_T = aux==\"none\" ? IDENT : prism_end_T,\n      aux = aux==\"none\" && aux_fillet!=0 ? \"plane\" : aux, \n      end_center = apply(aux_T,CENTER), \n      ndir = base_r<0 ? unit(start_center-start) : unit(end_center-start_center,UP),\n      end_prelim = apply(move(start)*prism_end_T*move(-start),\n            aux==\"sphere\" ?\n                let( answer = _sphere_line_isect_best(abs(aux_r), [start,start+ndir], -sign(aux_r)*ndir))\n                assert(answer,\"Prism center doesn't intersect sphere (aux)\")\n                apply(aux_T,answer)\n          : aux==\"cyl\" || aux==\"cylinder\" ? \n                let(\n                     mapped = apply(yrot(90)*rot_inverse(aux_T),[start,start+ndir]),\n                     answer = _cyl_line_intersection(abs(aux_r),mapped, -sign(aux_r)*(mapped[1]-mapped[0]))\n                 )\n                 assert(answer,\"Prism center doesn't intersect cylinder (aux)\")\n                 apply(aux_T*yrot(-90),answer)\n          : is_path(aux) ?\n                let( \n                     mapped = apply(yrot(90),[start,start+ndir]),\n                     answer = _prism_line_isect(pair(aux,wrap=true),mapped,mapped[0]-mapped[1])[0]\n                 )\n                 assert(answer,\"Prism center doesn't intersect prism (aux)\")\n                 apply(aux_T*yrot(-90),answer)\n          : end_center\n      ),\n      end = prism_end_T == IDENT ? end_prelim\n          : aux==\"sphere\" ?\n                let( answer = _sphere_line_isect_best(abs(aux_r), move(-end_center,[start,end_prelim]), -sign(aux_r)*(end_prelim-start)))\n                assert(answer,\"Prism center doesn't intersect sphere (aux)\")\n                answer+end_center\n          : aux==\"cyl\" || aux==\"cylinder\" ? \n                let(\n                     mapped = apply(yrot(90)*move(-end_center),[start,end_prelim]),\n                     answer = _cyl_line_intersection(abs(aux_r),mapped, -sign(aux_r)*(mapped[1]-mapped[0]))\n                 )\n                 assert(answer,\"Prism center doesn't intersect cylinder (aux)\")\n                 apply(move(end_center)*yrot(-90),answer)\n          : is_path(aux) ?\n                let( \n                     mapped = apply(yrot(90)*move(-end_center),[start,end_prelim]),\n                     answer = _prism_line_isect(pair(aux,wrap=true),mapped,mapped[0]-mapped[1])[0]\n                 )\n                 assert(answer,\"Prism center doesn't intersect prism (aux)\")\n                 apply(move(end_center)*yrot(-90),answer)\n          : plane_line_intersection( plane_from_normal(apply(aux_T,UP), end_prelim),[start,end_prelim]),\n      pangle = rot(from=UP, to=end-start),\n      truetop = apply(move(start)*pangle,path3d(scale(scale,polygon),norm(start-end))),      \n      truebot = apply(move(start)*pangle,path3d(polygon)),\n      base_trans = rot_inverse(base_T),\n      base_top = apply(base_trans, truetop),\n      base_bot = apply(base_trans, truebot),\n      botmesh = apply(base_T,_prism_fillet(\"base\", base, base_r, base_bot, base_top, base_fillet, base_k, n, base_overlap,base_uniform,debug)),\n      aux_trans = rot_inverse(aux_T),\n      aux_top = apply(aux_trans, reverse_polygon(truetop)),\n      aux_bot = apply(aux_trans, reverse_polygon(truebot)),\n      topmesh_reversed = _prism_fillet(\"aux\",aux, aux_r, aux_top, aux_bot, aux_fillet, aux_k, n, aux_overlap,aux_uniform,debug),\n      topmesh = apply(aux_T,[for(i=[len(topmesh_reversed)-1:-1:0]) reverse_polygon(topmesh_reversed[i])]),\n      round_dir = select(topmesh,-1)-botmesh[0],\n      roundings_cross = [for(i=idx(topmesh)) if (round_dir[i]*(truetop[i]-truebot[i])<0) i],\n      vnf = vnf_vertex_array(concat(topmesh,botmesh),col_wrap=true, caps=true, reverse=true)\n  )\n  assert(debug || roundings_cross==[],\"Roundings from the two ends cross on the prism: decrease size of roundings\")\n  return_axis ? [vnf,start,end] : vnf;\n\nfunction _fix_angle_list(list,ind=0, result=[]) =\n    ind==0 ? _fix_angle_list(list,1,[list[0]])\n  : ind==len(list) ? result \n  : list[ind]-result[ind-1]>90 ? _fix_angle_list(list,ind+1,concat(result,[list[ind]-360]))\n  : list[ind]-result[ind-1]<-90 ? _fix_angle_list(list,ind+1,concat(result,[list[ind]+360]))\n  : _fix_angle_list(list,ind+1,concat(result,[list[ind]]));\n                 \n\n\n// intersection with cylinder of radius R oriented on Z axis, with infinite extent\n// if ref is given, return point with larger inner product with ref.  \nfunction _cyl_line_intersection(R, line, ref) =\n   let(\n       line2d = path2d(line),\n       cisect = circle_line_intersection(r=R, cp=[0,0], line=line2d)\n   )\n   len(cisect)<2 ? [] :\n   let(\n       linevec = line2d[1]-line2d[0],\n       dz = line[1].z-line[0].z,\n       pts = [for(pt=cisect)\n          let(t = (pt-line2d[0])*linevec/(linevec*linevec))  // position parameter for line\n          [pt.x,pt.y,dz * t + line[0].z]]\n   )\n   is_undef(ref) ? pts :\n   let(   \n      dist = [for(pt=pts) ref*pt]\n   )\n   dist[0]>dist[1] ? pts[0] : pts[1];\n\n\nfunction _sphere_line_isect_best(R, line, ref) =\n   let(\n        pts = sphere_line_intersection(abs(R), [0,0,0], line=line)\n   )\n   len(pts)<2 ? [] :\n   let(  \n        dist = [for(pt=pts) ref*pt]\n   )\n   dist[0]>dist[1] ? pts[0] : pts[1];\n\n// First input is all the pairs of the polygon, e.g. pair(poly,wrap=true)\n// Unlike the others this returns [point, ind, u], where point is the actual intersection\n// point, ind ind and u are the segment index and u value.  Prism is z-aligned.  \nfunction _prism_line_isect(poly_pairs, line, ref) =\n   let(\n       line2d = path2d(line),\n       ref=point2d(ref),\n       ilist = [for(j=idx(poly_pairs)) \n                 let(segisect = _general_line_intersection(poly_pairs[j],line2d))\n                 if (segisect && segisect[1]>=-EPSILON && segisect[1]<=1+EPSILON)\n                    [segisect[0],j,segisect[1],segisect[0]*ref]]\n   )\n   len(ilist)==0 ? [] :\n   let (\n       ind = max_index(column(ilist,3)),\n       isect2d = ilist[ind][0],\n       isect_ind = ilist[ind][1],\n       isect_u = ilist[ind][2],\n       slope = (line[1].z-line[0].z)/norm(line[1]-line[0]),\n       z = slope * norm(line2d[0]-isect2d) + line[0].z\n   )\n   [point3d(isect2d,z),isect_ind, isect_u];\n\n  \nfunction _prism_fillet(name, base, R, bot, top, d, k, N, overlap,uniform,debug) =\n    base==\"none\" ? [bot] \n  : base==\"plane\" ? _prism_fillet_plane(name,bot, top, d, k, N, overlap,debug)\n  : base==\"cyl\" || base==\"cylinder\" ? _prism_fillet_cyl(name, R, bot, top, d, k, N, overlap,uniform,debug)\n  : base==\"sphere\" ? _prism_fillet_sphere(name, R, bot, top, d, k, N, overlap,uniform,debug)\n  : is_path(base,2) ? _prism_fillet_prism(name, base, bot, top, d, k, N, overlap,uniform,debug)\n  : assert(false,\"Unknown base type\");\n\nfunction _prism_fillet_plane(name, bot, top, d, k, N, overlap,debug) = \n    let(\n        dir = sign(top[0].z-bot[0].z),\n        isect = [for (i=idx(top)) plane_line_intersection([0,0,1,0], [top[i],bot[i]])],\n        base_normal = -path3d(path_normals(path2d(isect), closed=true)),\n        mesh = transpose([for(i=idx(top))\n          let(\n              \n              base_angle = vector_angle(top[i],isect[i],isect[i]+sign(d)*base_normal[i]),\n              // joint length\n              // d = r,\n              r=abs(d)*tan(base_angle/2),\n              // radius\n              //d = r/tan(base_angle/2),\n              // cut\n              //r = r / (1/sin(base_angle/2) - 1),\n              //d = r/tan(base_angle/2),\n              prev = unit(top[i]-isect[i]),\n              next = sign(d)*dir*base_normal[i],\n              center = r/sin(base_angle/2) * unit(prev+next) + isect[i]\n          )\n          [\n            each arc(N, cp=center, points = [isect[i]+prev*abs(d), isect[i]+next*d]),\n            isect[i]+next*d+[0,0,-overlap*dir]\n          ]\n        ])\n    )\n    assert(debug || is_path_simple(path2d(select(mesh,-2)),closed=true),\"Fillet doesn't fit: it intersects itself\")\n    mesh;\n\nfunction _prism_fillet_plane(name, bot, top, d, k, N, overlap,debug) = \n    let(\n        dir = sign(top[0].z-bot[0].z),    // Negative if we are upside down, with \"top\" below \"bot\"\n        isect = [for (i=idx(top)) plane_line_intersection([0,0,1,0], [top[i],bot[i]])]\n    )\n    d==0 ? [isect, if (overlap!=0) isect + overlap*dir*DOWN] :\n    let(\n        base_normal = -path3d(path_normals(path2d(isect), closed=true)),\n        mesh = transpose([for(i=idx(top))\n          assert(norm(top[i]-isect[i])>=d,\"Prism is too short for fillet to fit\")\n          let(\n              d_step = isect[i]+abs(d)*unit(top[i]-isect[i]),\n              edgepoint = isect[i]+d*dir*base_normal[i],\n              bez = _smooth_bez_fill([d_step, isect[i], edgepoint],k)\n          )\n          [\n            each bezier_curve(bez,N,endpoint=true),\n            if (overlap!=0) edgepoint + overlap*dir*DOWN\n          ]\n        ])\n    )\n    assert(debug || is_path_simple(path2d(select(mesh,-2)),closed=true),\"Fillet doesn't fit: it intersects itself\")\n    mesh;\n\n\n// This function was written for a z-aligned cylinder but the actual\n// upstream assumption is an x-aligned cylinder, so input is rotated and\n// output is un-rotated.  \nfunction _prism_fillet_cyl(name, R, bot, top, d, k, N, overlap, uniform, debug) =\n    let(\n        top = yrot(-90,top),\n        bot = yrot(-90,bot),\n        isect = [for (i=idx(top))\n                   let (cisect = _cyl_line_intersection(abs(R), [top[i],bot[i]], sign(R)*(top[i]-bot[i])))\n                   assert(cisect, str(\"Prism doesn't fully intersect cylinder (\",name,\")\"))\n                   cisect\n                ]\n    )\n    d==0 ? [ \n             isect,\n             if (overlap!=0) [for(p=isect) point3d(unit(point2d(p))*(norm(point2d(p))-sign(R)*overlap),p.z)]\n           ] :\n    let(\n        tangent = path_tangents(isect,closed=true),\n        mesh = transpose([for(i=idx(top))\n           assert(norm(top[i]-isect[i])>=d,str(\"Prism is too short for fillet to fit (\",name,\")\"))\n           let(\n               dir = sign(R)*unit(cross([isect[i].x,isect[i].y,0],tangent[i])),\n               zpart = d*dir.z,\n               curvepart = d*norm(point2d(dir)),\n               curveang = sign(cross(point2d(isect[i]),point2d(dir))) * curvepart * 180 / PI / abs(R), \n               edgepoint = apply(up(zpart)*zrot(curveang), isect[i]),\n               corner = plane_line_intersection(plane_from_normal([edgepoint.x,edgepoint.y,0], edgepoint),\n                                                [isect[i],top[i]],\n                                                bounded=false/*[R>0,true]*/),\n               d_step = abs(d)*unit(top[i]-isect[i])+(uniform?isect[i]:corner)\n           )\n           assert(is_vector(corner,3),str(\"Fillet does not fit.  Decrease size of fillet (\",name,\").\"))\n           assert(debug || R<0 || (d_step-corner)*(corner-isect[i])>=0,\n                 str(\"Unable to fit fillet, probably due to steep curvature of the cylinder (\",name,\").\"))\n           let(\n                bez = _smooth_bez_fill([d_step,corner,edgepoint], k)\n           )\n           [ \n             each bezier_curve(bez, N, endpoint=true),\n             if (overlap!=0) point3d(unit(point2d(edgepoint))*(norm(point2d(edgepoint))-sign(R)*overlap),edgepoint.z)\n           ]\n        ]),\n        angle_list = _fix_angle_list([for(pt=select(mesh,-2)) atan2(pt.y,pt.x)]),\n        z_list = [for(pt=select(mesh,-2)) pt.z],\n        is_simple = debug || is_path_simple(hstack([angle_list,z_list]), closed=true)\n    )\n    assert(is_simple, str(\"Fillet doesn't fit: its edge is self-intersecting.  Decrease size of roundover. (\",name,\")\"))\n    yrot(90,mesh);\n\n\n\nfunction _prism_fillet_sphere(name, R,bot, top, d, k, N, overlap, uniform, debug) = \n    let(\n        isect = [for (i=idx(top))\n                    let( isect_pt = _sphere_line_isect_best(abs(R), [top[i],bot[i]],sign(R)*(top[i]-bot[i])))\n                    assert(isect_pt, str(\"Prism doesn't fully intersect sphere (\",name,\")\"))\n                    isect_pt\n                ]\n    )\n    d==0 ? [isect,\n            if (overlap!=0) [for(p=isect) p - overlap*sign(R)*unit(p)]\n           ] :\n    let(          \n        tangent = path_tangents(isect,closed=true),\n        mesh = transpose([for(i=idx(top))\n           assert(norm(top[i]-isect[i])>=d,str(\"Prism is too short for fillet to fit (\",name,\")\"))\n           let(   \n               dir = sign(R)*unit(cross(isect[i],tangent[i])),\n               curveang = d * 180 / PI / R,\n               edgepoint = rot(-curveang,v=tangent[i],p=isect[i]),\n               corner = plane_line_intersection(plane_from_normal(edgepoint, edgepoint),\n                                                [isect[i],top[i]],\n                                                bounded=[R>0,true]),\n               d_step = d*unit(top[i]-isect[i])+(uniform?isect[i]:corner)\n           ) \n           assert(is_vector(corner,3),str(\"Fillet does not fit (\",name,\")\"))\n           assert(debug || R<0 || (d_step-corner)*(corner-isect[i])>0, \n                  str(\"Unable to fit fillet, probably due to steep curvature of the sphere (\",name,\").\"))\n           let(\n               bez = _smooth_bez_fill([d_step,corner,edgepoint], k)         \n           ) \n           [ \n             each bezier_curve(bez, N, endpoint=true),\n             if (overlap!=0) edgepoint - overlap*sign(R)*unit(edgepoint)\n           ]\n        ])\n      )\n      // this test will fail if the prism isn't \"vertical\".  Project along prism direction?  \n      assert(debug || is_path_simple(path2d(select(mesh,-2)),closed=true),str(\"Fillet doesn't fit: it intersects itself (\",name,\")\"))\n      mesh;\n\n\n\n// Return an interpolated normal to the polygon at segment i, fraction u along the segment.\n\nfunction _getnormal(polygon,index,u,) =\n  let(\n      //flat=1/3,\n      flat=1/8,\n//     flat=0,\n      edge = (1-flat)/2,\n      L=len(polygon),\n      next_ind = posmod(index+1,L),\n      prev_ind = posmod(index-1,L),\n      this_normal = line_normal(select(polygon,index,index+1))\n  )\n    u > 1-edge ? lerp(this_normal,line_normal(select(polygon,index+1,index+2)), (u-edge-flat)/edge/2)\n  : u < edge ? lerp(line_normal(select(polygon,index-1,index)),this_normal, 0.5+u/edge/2)\n  : this_normal;\n\n\n// Start at segment ind, position u on the polygon and find a point length units\n// from that starting point.  If dir<0 goes backwards through polygon segments\n// and if dir>0 goes forwards through polygon segments.\n// Returns [ point, ind, u] where point is the actual point desired.  \nfunction _polygon_step(poly, ind, u, dir, length) =\n    let(ind = posmod(ind,len(poly)))\n    u==0 && dir<0 ? _polygon_step(poly, ind-1, 1, dir, length)\n  : u==1 && dir>0 ? _polygon_step(poly, ind+1, 0, dir, length)\n  : let(\n        seg = select(poly,ind,ind+1),\n        seglen = norm(seg[1]-seg[0]),\n        frac_needed = length / seglen\n    )\n    dir>0 ?\n            ( (1-u) < frac_needed ? _polygon_step(poly,ind+1,0,dir,length-(1-u)*seglen)\n                                 : [lerp(seg[0],seg[1],u+frac_needed),ind,u+frac_needed]\n            )\n          :\n            ( u < frac_needed ? _polygon_step(poly,ind-1,1,dir,length-u*seglen)\n                                 : [lerp(seg[0],seg[1],u-frac_needed),ind,u-frac_needed]\n            );\n\n\n// This function needs more error checking?\n// Needs check for zero overlap case and zero joint case\nfunction _prism_fillet_prism(name, basepoly, bot, top, d, k, N, overlap, uniform, debug)=\n    let(\n         top = yrot(-90,top),\n         bot = yrot(-90,bot),\n         basepoly = clockwise_polygon(basepoly),\n         segpairs = pair(basepoly,wrap=true),\n         isect_ind = [for (i=idx(top))\n                         let(isect = _prism_line_isect(segpairs, [top[i], bot[i]], top[i]))\n                         assert(isect, str(\"Prism doesn't fully intersect prism (\",name,\")\"))\n                         isect\n                     ],\n         isect=column(isect_ind,0),\n         index = column(isect_ind,1),\n         uval = column(isect_ind,2),\n         tangent = path_tangents(isect,closed=true),\n         mesh = transpose([for(i=idx(top))\n           let(\n               normal = point3d(_getnormal(basepoly,index[i],uval[i])),\n               dir = unit(cross(normal,tangent[i])),\n               zpart = d*dir.z,\n               length_needed = d*norm(point2d(dir)),\n               edgept2d = _polygon_step(basepoly, index[i], uval[i], sign(cross(point2d(dir),point2d(normal))), length_needed),\n               edgepoint = point3d(edgept2d[0],isect[i].z+zpart),\n               corner = plane_line_intersection(plane_from_normal(point3d(_getnormal(basepoly, edgept2d[1],edgept2d[2])),edgepoint),\n                                                [top[i],isect[i]],\n                                                bounded=false), // should be true!!!  But fails to intersect if given true.\n               d_step = abs(d)*unit(top[i]-isect[i])+(uniform?isect[i]:corner)\n           )\n           assert(is_vector(corner,3),str(\"Fillet does not fit.  Decrease size of fillet (\",name,\").\"))\n           assert(debug  || (top[i]-d_step)*(d_step-corner)>=0,\n                   str(\"Unable to fit fillet, probably due to steep curvature of the prism (\",name,\").\",\n                     d_step,\" \",corner,\" \", edgepoint,\" \", isect[i]\n                     ))\n           let(\n                bez = _smooth_bez_fill([d_step,corner,edgepoint], k)\n           )\n           [ \n             each bezier_curve(bez, N, endpoint=true),\n             if (overlap!=0) edgepoint-point3d(normal)*overlap\n           ]\n          ])\n         )\n        yrot(90,mesh);\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-34", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: screw_drive.scad\n//   Masks for Phillips, Torx and square (Robertson) driver holes.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/screw_drive.scad>\n// FileGroup: Threaded Parts\n// FileSummary: Masks for Phillips, Torx and square (Robertson) driver holes.\n//////////////////////////////////////////////////////////////////////\n\n\ninclude <structs.scad>\n\n// Section: Phillips Drive\n\n// Module: phillips_mask()\n// Synopsis: Creates a mask for a Philips screw drive.\n// SynTags: Geom\n// Topics: Screws, Masks\n// See Also: hex_drive_mask(), phillips_depth(), phillips_diam(), torx_mask(), robertson_mask()\n// Usage:\n//   phillips_mask(size) [ATTACHMENTS];\n// Description:\n//   Creates a mask for creating a Phillips drive recess given the Phillips size.  Each mask can\n//   be lowered to different depths to create different sizes of recess.  \n// Arguments:\n//   size = The size of the bit as an integer or string.  \"#0\", \"#1\", \"#2\", \"#3\", or \"#4\"\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   xdistribute(10) {\n//      phillips_mask(size=\"#1\");\n//      phillips_mask(size=\"#2\");\n//      phillips_mask(size=3);\n//      phillips_mask(size=4);\n//   }\n\n// Specs for phillips recess here:\n//   https://www.fasteners.eu/tech-info/ISO/4757/\n\nfunction _phillips_shaft(x) = [3,4.5,6,8,10][x];\nfunction _ph_bot_angle() = 28.0;\nfunction _ph_side_angle() = 26.5;\n\nmodule phillips_mask(size=\"#2\", $fn=36, anchor=BOTTOM, spin=0, orient=UP) {\n    dummy = assert(in_list(size,[\"#0\",\"#1\",\"#2\",\"#3\",\"#4\",0,1,2,3,4]));\n    num = is_num(size) ? size : ord(size[1]) - ord(\"0\");\n    shaft = _phillips_shaft(num);\n    b =     [0.61, 0.97, 1.47, 2.41, 3.48][num];\n    e =     [0.31, 0.435, 0.815, 2.005, 2.415][num];\n    g =     [0.81, 1.27, 2.29, 3.81, 5.08][num];\n    alpha = [ 136,  138,  140,  146,  153][num];\n    beta  = [7.00, 7.00, 5.75, 5.75, 7.00][num];\n    gamma = 92.0;\n    h1 = adj_ang_to_opp(g/2, _ph_bot_angle());   // height of the small conical tip\n    h2 = adj_ang_to_opp((shaft-g)/2, 90-_ph_side_angle());   // height of larger cone\n    l = h1+h2;\n    h3 = adj_ang_to_opp(b/2, _ph_bot_angle());   // height where cutout starts\n    p0 = [0,0];\n    p1 = [adj_ang_to_opp(e/2, 90-alpha/2), -e/2];\n    p2 = p1 + [adj_ang_to_opp((shaft-e)/2, 90-gamma/2),-(shaft-e)/2];\n    attachable(anchor,spin,orient, d=shaft, l=l) {\n        down(l/2) {\n            difference() {\n                rotate_extrude()\n                    polygon([[0,0],[g/2,h1],[shaft/2,l],[0,l]]);\n                zrot(45)\n                zrot_copies(n=4, r=b/2) {                   \n                    up(h3) {\n                        yrot(beta) {\n                            down(1)\n                            linear_extrude(height=l+2, convexity=4, center=false) {\n                                path = [p0, p1, p2, [p2.x,-p2.y], [p1.x,-p1.y]];\n                                polygon(path);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n\n// Function: phillips_depth()\n// Synopsis: Returns the depth a phillips recess needs to be for a given diameter.\n// Topics: Screws, Masks\n// See Also: phillips_mask(), hex_drive_mask(), phillips_depth(), phillips_diam(), torx_mask()\n// Usage:\n//   depth = phillips_depth(size, d);\n// Description:\n//   Returns the depth of the Phillips recess required to produce the specified diameter, or\n//   undef if not possible.\n// Arguments:\n//   size = size as a number or text string like \"#2\"\n//   d = desired diameter\nfunction phillips_depth(size, d) =\n    assert(in_list(size,[\"#0\",\"#1\",\"#2\",\"#3\",\"#4\",0,1,2,3,4]))\n    let(\n        num = is_num(size) ? size : ord(size[1]) - ord(\"0\"),\n        shaft = [3,4.5,6,8,10][num],\n        g =     [0.81, 1.27, 2.29, 3.81, 5.08][num],\n        h1 = adj_ang_to_opp(g/2, _ph_bot_angle()),   // height of the small conical tip\n        h2 = adj_ang_to_opp((shaft-g)/2, 90-_ph_side_angle())   // height of larger cone\n    )\n    d>=shaft || d<g ? undef :\n    (d-g) / 2 / tan(_ph_side_angle()) + h1;\n\n\n// Function: phillips_diam()\n// Synopsis: Returns the diameter of a phillips recess of a given depth.\n// Topics: Screws, Masks\n// See Also: phillips_mask(), hex_drive_mask(), phillips_depth(), phillips_diam(), torx_mask()\n// Usage:\n//   diam = phillips_diam(size, depth);\n// Description:\n//   Returns the diameter at the top of the Phillips recess when constructed at the specified depth,\n//   or undef if that depth is not valid.  \n// Arguments:\n//   size = size as number or text string like \"#2\"\n//   depth = depth of recess to find the diameter of\nfunction phillips_diam(size, depth) =\n    assert(in_list(size,[\"#0\",\"#1\",\"#2\",\"#3\",\"#4\",0,1,2,3,4]))\n    let(\n        num = is_num(size) ? size : ord(size[1]) - ord(\"0\"),\n        shaft = _phillips_shaft(num),\n        g =     [0.81, 1.27, 2.29, 3.81, 5.08][num],\n        h1 = adj_ang_to_opp(g/2, _ph_bot_angle()),   // height of the small conical tip\n        h2 = adj_ang_to_opp((shaft-g)/2, 90-_ph_side_angle())   // height of larger cone\n    )\n    depth<h1 || depth>= h1+h2 ? undef :\n    2 * tan(_ph_side_angle())*(depth-h1) + g;\n\n\n// Section: Hex drive\n\n// Module: hex_drive_mask()\n// Synopsis: Creates a mask for a hex drive recess.\n// SynTags: Geom\n// Topics: Screws, Masks\n// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), robertson_mask()\n// Usage:\n//   hex_drive_mask(size, length, [anchor], [spin], [orient], [$slop]) [ATTACHMENTS];\n// Description:\n//   Creates a mask for hex drive.  Note that the hex recess specs requires\n//   a slightly oversized recess.  You can use $slop to increase the size by \n//   `2 * $slop` if necessary.  \n// \nmodule hex_drive_mask(size,length,l,h,height,anchor,spin,orient)\n{\n   length = one_defined([length,height,l,h],\"length,height,l,h\");\n   realsize = 1.0072*size + 0.0341 + 2 * get_slop();  // Formula emperically determined from ISO standard\n   linear_sweep(height=length,hexagon(id=realsize),anchor=anchor,spin=spin,orient=orient) children();\n}\nfunction hex_drive_mask(size,length,l,h,height,anchor,spin,orient) = no_function(\"hex_drive_mask\");\n\n\n// Section: Torx Drive\n\n// Module: torx_mask()\n// Synopsis: Creates a mask for a torx drive recess.\n// SynTags: Geom\n// Topics: Screws, Masks\n// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), robertson_mask()\n// Usage:\n//   torx_mask(size, l, [center]) [ATTACHMENTS];\n// Description: Creates a torx bit tip.  The anchors are located on the circumscribing cylinder.  See {{torx_info()}} for allowed sizes.\n// Arguments:\n//   size = Torx size.\n//   l = Length of bit.\n//   center = If true, centers mask vertically.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   torx_mask(size=30, l=10, $fa=1, $fs=1);\nmodule torx_mask(size, l=5, center, anchor, spin=0, orient=UP) {\n    od = torx_diam(size);\n    anchor = get_anchor(anchor, center, BOT, BOT);\n    attachable(anchor,spin,orient, d=od, l=l) {\n        linear_extrude(height=l, convexity=4, center=true) {\n            torx_mask2d(size);\n        }\n        children();\n    }\n}\n\n\n// Module: torx_mask2d()\n// Synopsis: Creates the 2D cross section for a torx drive recess.\n// SynTags: Geom\n// Topics: Screws, Masks\n// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), torx_info(), robertson_mask()\n// Usage:\n//   torx_mask2d(size);\n// Description: Creates a torx bit 2D profile.  The anchors are located on the circumscribing circle.   See {{torx_info()}} for allowed sizes.\n// Arguments:\n//   size = Torx size.\n// Example(2D):\n//   torx_mask2d(size=30, $fa=1, $fs=1);\nmodule torx_mask2d(size,anchor=CENTER,spin) {\n    info = torx_info(size);\n    od = info[0];\n    id = info[1];\n    tip = info[3];\n    rounding = info[4];\n    base = od - 2*tip;\n    $fn = quantup(segs(od/2),12);\n    attachable(anchor,spin,two_d=true,d=od){\n        difference() {\n            union() {\n                circle(d=base);\n                zrot_copies(n=2) {\n                    hull() {\n                        zrot_copies(n=3) {\n                            translate([base/2,0,0]) {\n                                circle(r=tip, $fn=$fn/2);\n                            }\n                        }\n                    }\n                }\n            }\n            zrot_copies(n=6) {\n                zrot(180/6) {\n                    translate([id/2+rounding,0,0]) {\n                        circle(r=rounding);\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Function: torx_info()\n// Synopsis: Returns the dimensions of a torx drive.\n// Topics: Screws, Masks\n// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), torx_info()\n// Usage:\n//   info = torx_info(size);\n// Description:\n//   Get the typical dimensional info for a given Torx size.\n//   Returns a list containing, in order:\n//   - Outer Diameter\n//   - Inner Diameter\n//   - Drive Hole Depth\n//   - External Tip Rounding Radius\n//   - Inner Rounding Radius\n// .\n//   The allowed torx sizes are:\n//   1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 27, 30, 40, 45, 50, 55,\n//   60, 70, 80, 90, 100.\n// Arguments:\n//   size = Torx size.\nfunction torx_info(size) =\n    let( \n        info_arr = [      // Depth is from metric socket head screws, ISO 14583\n            //T#     OD     ID     H        Re     Ri\n            [  1, [  0.90,  0.65,  0.40,  0.059, 0.201]],  // depth interpolated\n            [  2, [  1.00,  0.73,  0.44,  0.069, 0.224]],  // depth interpolated\n            [  3, [  1.20,  0.87,  0.53,  0.081, 0.266]],  // depth interpolated\n            [  4, [  1.35,  0.98,  0.59,  0.090, 0.308]],  // depth interpolated\n            [  5, [  1.48,  1.08,  0.65,  0.109, 0.330]],  // depth interpolated\n            [  6, [  1.75,  1.27,  0.775, 0.132, 0.383]],\n            [  7, [  2.08,  1.50,  0.886, 0.161, 0.446]],  // depth interpolated\n            [  8, [  2.40,  1.75,  1.0,   0.190, 0.510]],\n            [  9, [  2.58,  1.87,  1.078, 0.207, 0.554]],  // depth interpolated\n            [ 10, [  2.80,  2.05,  1.142, 0.229, 0.598]],\n            [ 15, [  3.35,  2.40,  1.2,   0.267, 0.716]],  // depth interpolated\n            [ 20, [  3.95,  2.85,  1.4,   0.305, 0.859]],  // depth interpolated\n            [ 25, [  4.50,  3.25,  1.61,  0.375, 0.920]],  \n            [ 27, [  5.07,  3.65,  1.84,  0.390, 1.108]],\n            [ 30, [  5.60,  4.05,  2.22,  0.451, 1.194]],\n            [ 40, [  6.75,  4.85,  2.63,  0.546, 1.428]],\n            [ 45, [  7.93,  5.64,  3.115, 0.574, 1.796]],\n            [ 50, [  8.95,  6.45,  3.82,  0.775, 1.816]],\n            [ 55, [ 11.35,  8.05,  5.015, 0.867, 2.667]],\n            [ 60, [ 13.45,  9.60,  5.805, 1.067, 2.883]],\n            [ 70, [ 15.70, 11.20,  6.815, 1.194, 3.477]],\n            [ 80, [ 17.75, 12.80,  7.75,  1.526, 3.627]],\n            [ 90, [ 20.20, 14.40,  8.945, 1.530, 4.468]],\n            [100, [ 22.40, 16.00, 10.79,  1.720, 4.925]],\n        ],\n        found = struct_val(info_arr,size)\n    )\n    assert(found, str(\"Unsupported Torx size, \",size))\n    found;\n\n\n// Function: torx_diam()\n// Synopsis: Returns the diameter of a torx drive.\n// Topics: Screws, Masks\n// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), torx_info()\n// Usage:\n//   diam = torx_diam(size);\n// Description: Get the typical outer diameter of Torx profile.\n// Arguments:\n//   size = Torx size.\nfunction torx_diam(size) = torx_info(size)[0];\n\n\n// Function: torx_depth()\n// Synopsis: Returns the typical depth of a torx drive recess.\n// Topics: Screws, Masks\n// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), torx_info()\n// Usage:\n//   depth = torx_depth(size);\n// Description: Gets typical drive hole depth.\n// Arguments:\n//   size = Torx size.\nfunction torx_depth(size) = torx_info(size)[2];\n\n\n\n// Section: Robertson/Square Drives\n\n// Module: robertson_mask()\n// Synopsis: Creates a mask for a Robertson/Square drive recess.\n// SynTags: Geom\n// Topics: Screws, Masks\n// See Also: phillips_mask(), hex_drive_mask(), torx_mask(),  phillips_depth(), phillips_diam(), torx_info(), robertson_mask()\n// Usage:\n//   robertson_mask(size, [extra], [ang], [$slop=]);\n// Description:\n//   Creates a mask for creating a Robertson/Square drive recess given the drive size as an integer.\n//   The width of the recess will be oversized by `2 * $slop`.  Note that this model is based\n//   on an incomplete spec.   https://www.aspenfasteners.com/content/pdf/square_drive_specification.pdf\n//   We determined the angle by doing print tests on a Prusa MK3S with $slop set to 0.05.\n// Arguments:\n//   size = The size of the square drive, as an integer from 0 to 4.\n//   extra = Extra length of drive mask to create.\n//   ang = taper angle of each face.  Default: 2.5\n//   ---\n//   $slop = enlarge recess by this twice amount.  Default: 0\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: TOP\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   Sets tag to \"remove\" if no tag is set.  \n// Example:\n//   robertson_mask(size=2);\n// Example:\n//   difference() {\n//       cyl(d1=2, d2=8, h=4, anchor=TOP);\n//       robertson_mask(size=2);\n//   }\nmodule robertson_mask(size, extra=1, ang=2.5,anchor=TOP,spin,orient) {\n    dummy=assert(is_int(size) && size>=0 && size<=4);\n    Mmin = [0.0696, 0.0900, 0.1110, 0.1315, 0.1895][size];\n    Mmax = [0.0710, 0.0910, 0.1126, 0.1330, 0.1910][size];\n    M = (Mmin + Mmax) / 2 * INCH;\n    Tmin = [0.063, 0.105, 0.119, 0.155, 0.191][size];\n    Tmax = [0.073, 0.113, 0.140, 0.165, 0.201][size];\n    T = (Tmin + Tmax) / 2 * INCH;\n    Fmin = [0.032, 0.057, 0.065, 0.085, 0.090][size];\n    Fmax = [0.038, 0.065, 0.075, 0.095, 0.100][size];\n    F = (Fmin + Fmax) / 2 * INCH;\n    h = T + extra;\n    Mslop=M+2*get_slop();\n    Mtop = Mslop + 2*adj_ang_to_opp(F+extra,ang);\n    Mbot = Mslop - 2*adj_ang_to_opp(T-F,ang);\n    anchors = [named_anchor(\"standard\",[0,0,T-h/2], UP, 0)];\n    default_tag(\"remove\")\n      attachable(anchor,spin,orient,size=[Mbot,Mbot,T],size2=[Mtop,Mtop],anchors=anchors){\n        down(T/2)\n            intersection(){\n                prismoid([Mbot,Mbot],[Mtop,Mtop],h=h,anchor=BOT);\n                cyl(d1=0, d2=Mslop/(T-F)*sqrt(2)*h, h=h, anchor=BOT);\n            }\n        children();\n      }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-35", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: screws.scad\n//   Functions and modules for creating metric (ISO) and English (UTS) standard screws and nuts.\n//   Included is a function for calculating the standard dimensions of screws including the\n//   tolerance values that are required to make screws mate properly when they are formed\n//   precisely.  If you can fabricate objects accurately then the modeled screws will mate\n//   with standard hardware without the need to introduce extra gaps for clearance.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/screws.scad>\n// FileGroup: Threaded Parts\n// FileSummary: ISO (metric) and UTS screws and nuts.\n//////////////////////////////////////////////////////////////////////\n\ninclude <structs.scad>\ninclude <threading.scad>\ninclude <screw_drive.scad>\n\n// Section: Screw and Nut Parameters\n//    This modules in this file create standard ISO (metric) and UTS (English) threaded screws.\n//    The {{screw()}} and {{nut()}} modules produce\n//    screws and nuts that comply with the relevant ISO and ASME standards,\n//    including tolerances for screw fit.  You can also create screws with\n//    various head types and drive types that should match standard hardware.\n// Subsection: Screw Naming\n//    You can specify screws using a string that specifies the screw.\n//    Metric or ISO screws are specified by a diameter in millimeters and a thread pitch in millimeters.  For example,\n//    an M8x2 screw has a nominal diameter of 8 mm and a thread pitch of 2 mm.  \n//    The screw specification for these screws has the form: \"M`<size>`x`<pitch>`,`<length>`,\n//    so \"M6x1,10\" specifies a 6mm diameter screw with a thread pitch of 1mm and length of 10mm.\n//    You can omit the pitch or length, e.g. \"M6x1\", or \"M6,10\", or just \"M6\".  If you omit the\n//    length then you must provide the `length` parameter.  If you omit the pitch, the library\n//    provides a standard pitch for the specified diameter.\n//    .\n//    Imperial or UTS screws are specified by a diameter and the number of threads per inch.\n//    For large screws, the diameter is simply the nominal diameter in inches, so a 5/16-18 screw\n//    has a nominal diameter of 5/16 inches and 18 threads per inch.  For diameters smaller than\n//    1/4 inch, the screw diameter is given using a screw gauge, which can be from 0 up to 12.\n//    A common smaller size is #8-32, an 8 gauge screw with 32 threads per inch.  \n//    For UTS screws the specification has the form `<size>`-`<threadcount>`,`<length>`, e.g. \n//    \"#8-32,1/2\", or \"1/4-20,1\".  The units are in inches, including the length.  Size can be a\n//    gauge number from 0 to 12 with or without a leading # to specify a screw gauge size, or any other\n//    value to specify a diameter in inches, either as a float or a fraction, so \"0.5-13\" and\n//    \"1/2-13\" are equivalent.  To force interpretation of the value as inches add '' (two\n//    single-quotes) to the end, e.g. \"1''-4\" is a one inch screw and \"1-80\" is a very small\n//    1-gauge screw.  The pitch is specified using a thread count, the number of threads per inch.\n//    As with the ISO screws, you can omit the pitch or length and specify \"#6-32\", \"#6,3/4\", or simply #6.\n//    As in the metric case, if you omit the length then you must provide the `length` parameter.  If you omit the pitch, the\n//    library provides a standard pitch for the specified diameter.\n// Subsection: Standard Screw Pitch\n//    If you omit the pitch when specifying a screw or nut then the library supplies a standard screw pitch based\n//    on the screw diameter as listed in ISO 724 or ASME B1.1.  For many diameters, multiple standard pitches exist.\n//    The available thread pitch types are different for ISO and UTS:\n//    .\n//    | ISO      |    UTS   |\n//    | -------- | -------- |\n//    | \"coarse\" |  \"coarse\" or \"UNC\" |\n//    | \"fine\"   |   \"fine\" or \"UNF\"  |\n//    | \"extrafine\" or \"extra fine\" | \"extrafine\", \"extra fine\", or \"UNEF\"  |\n//    | \"superfine\" or \"super fine\" |   |\n//    | \"none\"   |  \"none\"  |\n//    .\n//    The default pitch selection is \"coarse\".  Note that this selection is case insensitive.\n//    To set the pitch using these pitch strings you use the `thread=` argument to the modules.\n//    You cannot incorporate a named pitch into the thread name.  The finer pitch categories\n//    are defined only for larger screw diameters.  You can also use the `thread=` argument to\n//    directly specify a pitch, so `thread=2` produces a thread pitch of 2mm.  Setting the\n//    pitch to zero produces an unthreaded screws, the same as setting it to \"none\".  Specifying\n//    a numeric value this way overrides a value given in the specification.  You can also set\n//    `thread=true` or `thread=false` to turn threading on and off, with the same default coarse\n//    threading when you set it to true.  \n// Subsection: Screw Heads\n//    By default screws do not have heads.  \n//    You can request a screw head using `head=` parameter to specify the desired head type.  If you want the\n//    head to have a recess for driving the screw you must also specify a drive type using `drive=`.  \n//    The table below lists the head options.  Only some combinations of head and drive\n//    type are supported.  Different sized flat heads exist for the same screw type.\n//    Sometimes this depends on the type of recess.  If you specify \"flat\" then the size will be chosen\n//    appropriately for the recess you specify.\n//    .\n//    The `drive=` argument can be set to \"none\", \"hex\", \"slot\", \n//    \"phillips\", \"ph0\" to \"ph4\" (for phillips of the specified size), \"torx\" or\n//    \"t<size>\" (for Torx at a specified size, e.g. \"t20\").  If you have no head but still\n//    give a drive type you will get a set screw.  The table below lists all of the head types and\n//    shows which drive type is compatible with each head types.  Different head types work in ISO and UTS,\n//    as marked in the first column.  \n//    .\n//    |ISO|UTS|Head            | Drive  |\n//    |---|---|--------------- | ----------------------------|\n//    |X|X|\"none\"          | hex, torx, slot |\n//    |X|X|\"hex\"           | *none*|\n//    |X|X|\"socket\"        | hex, torx|\n//    |X|X|\"button\"        | hex, torx|\n//    |X|X|\"flat\"          | slot, phillips, hex, torx|\n//    |X|X|\"flat sharp\"    | slot, phillips, hex, torx|\n//    | |X|\"flat small\"    | slot, phillips|\n//    | |X|\"flat large\"    | hex, torx |\n//    | |X|\"flat undercut\" | slot, phillips |\n//    | |X|\"flat 82\"       | slot, phillips |\n//    | |X|\"flat 100\"      | slot, phillips |\n//    | |X|\"round\"         | slot, phillips |\n//    | |X|\"fillister\"     | slot, phillips |\n//    |X|X|\"pan\"           | slot, phillips, torx (ISO only) |\n//    |X| |\"cheese\"        | slot, phillips, torx |\n//    .\n//    The drive size is specified appropriately for the drive type: drive number for phillips or torx,\n//    and recess width in mm or inches (as appropriate) for hex.  Drive size is determined automatically\n//    from the screw size, but by passing the `drive_size=` argument you can override the default, or\n//    in cases where no default exists you can specify it.  Flat head screws have variations such as 100 degree\n//    angle for UTS, or undercut heads.  You can also request a \"sharp\" screw which will set the screw diameter \n//    the theoretical maximum and produce sharp corners instead of a flat edge on the head.  For a flat head screw\n//    the drive specification must start with \"flat\", but the flat head options\n//    can be mixed in any order, for example, \"flat sharp undercut\" or \"flat undercut sharp\".\n// Subsection: Nuts\n//    Nuts come in standard sizes and BOSL2 has tables to produce sizes for both Imperial and metric nuts.\n//    A nut for a given thread size is defined by its shape, width and thickness.  The shape is either \"hex\"\n//    for hexagonal nuts or \"square\" for square nuts.  For hexagonal Imperial nuts, you can choose from thickness values\n//    of \"thin\", \"normal\" or \"thick\", but the thin and thick nuts are defined only for thread sizes of 1/4 inch and above.\n//    .\n//    Metric nut standards are more complicated because ISO has a series of standards and DIN has a series of conflicting\n//    standards.  Nuts from McMaster-Carr in the USA comply with DIN rather than ISO.  Furthermore, ISO does not appear\n//    to specify dimensions for square nuts.  For metric nuts you can specify \"thin\", \"normal\" and \"thick\" and the\n//    nut will be constructed to ISO standards (ISO 4035, ISO 4032, and ISO 4033 respectively).  The DIN standard for thin\n//    nuts matches ISO, but the DIN normal thickness nuts are thinner than ISO nuts.  You can request DIN nuts\n//    by specifying a thickness of \"DIN\" or \"undersized\".  If you request a square nut it necessariliy derives from DIN\n//    instead of ISO.  For most nut sizes, the nut widths match between ISO and DIN, but they do differ for M10, M12, M14 and M22.\n//    .\n//    You can of course specify nuts by giving an explicit numerical width and thickness in millimeters. \n// Subsection: Tolerance\n//    Without tolerance requirements, screws would not fit together.  The screw standards specify a\n//    nominal size, but the tolerance determines a range of allowed sizes based on that nominal size.\n//    So for example, an M10 screw with the default tolerance has an outside (major) diameter between 9.74 mm and 9.97 mm.\n//    The library will use the center point in the allowed range and create a screw with a diameter of 9.86 mm.\n//    A M10 nut at the default tolerance has a major diameter (which is the inside diameter) between 10 mm and 10.4 mm.\n//    Shrinking the major diameter of a screw makes the screw loose.  Shrinking the major diameter of a nut, on the other hand,\n//    makes the hole smaller and hence makes the nut tighter.  For this reason, we need a difference tolerance\n//    for a screw than for a nut.  Screw tolerances shrink the diameter to make the screw looser whereas nut tolerances\n//    increase the diameter to make the nut looser.  Screws modeled using this library will have dimensions consistent with the\n//    standards they are based on, so that they will interface properly if fabricated by an accurate method.  The ISO and UTS\n//    systems use different tolerance designations.\n//    .\n//    For UTS screw threads the tolerance is one of \"1A\", \"2A\" or \"3A\", in\n//    order of increasing tightness.  The default tolerance is \"2A\", which\n//    is the general standard for manufactured bolts.\n//    .\n//    For UTS nut threads, the tolerance is one of \"1B\", \"2B\" or \"3B\", in\n//    order of increasing tightness.  The default tolerance is \"2B\", which\n//    is the general standard for manufactured nuts.\n//    .\n//    The ISO tolerances are more complicated.  For both screws and nuts the ISO tolerance has the form of a number\n//    and letter.  The letter specifies the \"fundamental deviation\", also called the \"tolerance position\", the gap\n//    from the nominal size.  The number specifies the allowed range (variability) of the thread heights.  For\n//    screws, the letter must be \"e\", \"f\", \"g\", or \"h\", where \"e\" is the loosest and \"h\" means no gap.  The number\n//    for a screw tolerance must be a value from 3-9 for crest diameter and one of 4, 6, or 8 for pitch diameter.\n//    A tolerance \"6g\" specifies both pitch and crest diameter to be the same, but they can be different, with a\n//    tolerance like \"5g6g\" specifies a pitch diameter tolerance of \"5g\" and a crest diameter tolerance of \"6g\".\n//    Smaller numbers give a tighter tolerance.  The default ISO screw tolerance is \"6g\".\n//    .\n//    For ISO nuts the letters specifying the fundamental deviation are upper case and must be \"G\" or \"H\" where \"G\"\n//    is loose and \"H\" means no gap. The number specifying the variability must range from 4-8.  An allowed (loose)\n//    nut tolerance is \"7G\".  The default ISO tolerance is \"6H\".\n//    .\n//    Clearance holes have a different tolerance system, described in {{screw_hole()}}.\n//    .\n//    If you wish to create screws at the nominal size you can set the tolerance to 0 or \"none\".  \n// Subsection: screw_info and nut_info structures\n//    When you make a screw or nut, information about the object such as the thread characteristics \n//    head and drive size, or nut thickness are placed into a data structure.  The screw and nut \n//    modules can accept screw names, as described above, or they can accept screw structures. \n//    When you use a screw structure as a specification, computed values like head type and size and\n//    driver characteristics are fixed and cannot be changed, but values that are not computed\n//    like length can still be altered.  If you want to create an unusual part you can hand\n//    generate the structure with your desired parameters to fill in values that would normally\n//    be produced automatically from the standard tables.  So if your hardware is missing from the\n//    tables, or is sized differently, you can still create the part.  For details on the\n//    screw_info and nut_info structures, see {{screw_info()}} and {{nut_info()}}.  \n//    .\n//    All of the screw related modules set the variable `$screw_spec` to contain the specification\n//    for their screw.  This means that child modules can make use of this variable to create\n//    mating (or identical) parts.  Note that the `shaft_oversize` and `head_oversize` screw\n//    info fields are only inherited into modules that are the same as the parent module.\n//    This means that if you create an oversized screw hole and then make a screw as s child, the\n//    child screw will **not** inherit the oversize parameters.  But a screw_hole will inherit \n//    oversize parameters from a parent screw_hole.  \n\n/*\nhttp://mdmetric.com/thddata.htm#idx\n\nSeems to show JIS has same nominal thread as others\nhttps://www.nbk1560.com/~/media/Images/en/Product%20Site/en_technical/11_ISO%20General%20Purpose%20Metric%20Screw%20Threads.ashx?la=en\n\nVarious ISO standards here:  https://www.fasteners.eu/standards/ISO/4026/\n\nTorx values:  https://www.stanleyengineeredfastening.com/-/media/web/sef/resources/docs/other/socket_screw_tech_manual_1.ashx\n\n*/\n\n\n// Section: Making Screws\n\n// Module: screw()\n// Synopsis: Creates a standard screw with optional tolerances.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: screw_hole(), shoulder_screw()\n// Usage:\n//   screw([spec], [head], [drive], [thread=], [drive_size=], [length=|l=], [thread_len=], [undersize=], [shaft_undersize=], [head_undersize=], [tolerance=], [blunt_start=], [details=], [anchor=], [atype=], [orient=], [spin=]) [ATTACHMENTS];\n// Description:\n//   Create a screw.  See [screw and nut parameters](#section-screw-and-nut-parameters) for details on\n//   the parameters that define a screw.  The tolerance determines the dimensions of the screw based\n//   on ISO and ASME standards.  Screws fabricated at those dimensions will mate properly with\n//   standard hardware.  Note that the $slop argument does not affect the size of screws: it only\n//   adjusts screw holes.  This will work fine if you are printing both parts, but if you need to mate\n//   printed screws to metal parts you may need to adjust the size of the screws, which you can do\n//   with the undersize arguments.\n//   .\n//   You can generate a screw specification from {{screw_info()}}, possibly create a modified version\n//   using {{struct_set()}}, and pass that in rather than giving the parameters.\n//   .\n//   Various anchor types refer to different parts of the screw, some of which are labeled below.  The\n//   \"screw\" anchor type (the default) is simply the entire screw, so TOP and BOTTOM refer to the head\n//   end and tip respectively, and CENTER is the midpoint of the whole screw, including the head.  The\n//   \"head\" anchor refers to the head alone.  Both of these anchor types refer to the bounding\n//   cylinder for the specified screw part, except for hex heads, which anchor to a hexagonal prism.\n// Figure(2D,Med,VPD = 140, VPT = [18.4209, 14.9821, -3.59741], VPR = [0, 0, 0],NoAxes):\n//   rpos=33;\n//   fsize=2.5;\n//   projection(cut=true) xrot(-90)screw(\"M8\", head=\"socket\", length=25, thread_len=10,anchor=BOT);\n//   right(rpos)projection(cut=true) xrot(-90)screw(\"M8\", head=\"flat\", length=25, thread_len=10,anchor=BOT);\n//   color(\"black\"){\n//      stroke([[5,0],[5,10]],endcaps=\"arrow2\",width=.3);\n//      back(5)right(6)text(\"threads\",size=fsize,anchor=LEFT);\n//      stroke([[5,10],[5,25]],endcaps=\"arrow2\",width=.3);\n//      back(10+15/2)right(6)text(\"shank\",size=fsize,anchor=LEFT);\n//      stroke([[-5,0],[-5,25]],endcaps=\"arrow2\",width=.3);\n//      back(25/2)right(-6)text(\"shaft\",size=fsize,anchor=RIGHT);\n//   }\n//   sh=10.2841;\n//   right(rpos)\n//   color(\"black\"){\n//      stroke([[5,0],[5,10]],endcaps=\"arrow2\",width=.3);\n//      back(5)right(6)text(\"threads\",size=fsize,anchor=LEFT);\n//      stroke([[5,10],[5,10+sh]],endcaps=\"arrow2\",width=.3);\n//      back(10+sh/2)right(6)text(\"shank\",size=fsize,anchor=LEFT);\n//      stroke([[-5,0],[-5,10+sh]],endcaps=\"arrow2\",width=.3);\n//      back((10+sh)/2)right(-6)text(\"shaft\",size=fsize,anchor=RIGHT);\n//   }\n// Arguments:\n//   spec = screw specification, e.g. \"M5x1\" or \"#8-32\".  See [screw naming](#subsection-screw-naming).  This can also be a screw specification structure of the form produced by {{screw_info()}}.  \n//   head = head type.  See [screw heads](#subsection-screw-heads)  Default: none\n//   drive = drive type.  See [screw heads](#subsection-screw-heads) Default: none\n//   ---\n//   length / l = length of screw (in mm)\n//   thread = thread type or specification. See [screw pitch](#subsection-standard-screw-pitch). Default: \"coarse\"\n//   drive_size = size of drive recess to override computed value\n//   thread_len = length of threaded portion of screw (in mm), for making partly threaded screws.  Default: fully threaded\n//   details = toggle some details in rendering.  Default: true\n//   tolerance = screw tolerance.  Determines actual screw thread geometry based on nominal sizing.  See [tolerance](#subsection-tolerance). Default is \"2A\" for UTS and \"6g\" for ISO.  \n//   undersize = amount to decrease screw diameter, a scalar to apply to all parts, or a 2-vector to control shaft and head.  Replaces rather than adding to the head_oversize value in a screw specification.  \n//   shaft_undersize = amount to decrease diameter of the shaft of screw; replaces rather than adding to the shaft_oversize value in a screw specification. \n//   head_undersize = amount to decrease the head diameter of the screw; replaces rather than adding to the head_oversize value in a screw specification. \n//   bevel1 = bevel bottom end of screw.  Default: true\n//   bevel2 = bevel top end of threaded section.  Default: true for fully threaded or unthreaded headless, false otherwise\n//   bevel = bevel both ends of the threaded section.\n//   blunt_start = if true and hole is threaded, create blunt start threads.  Default: true\n//   blunt_start1 = if true and hole is threaded, create blunt start threads at bottom end.\n//   blunt_start2 = if true and hole is threaded, create blunt start threads top end.\n//   atype = anchor type, one of \"screw\", \"head\", \"shaft\", \"threads\", \"shank\"\n//   anchor = Translate so anchor point on the shaft is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   `$screw_spec` is set to the spec specification structure. \n// Anchor Types:\n//   screw = the entire screw (default)\n//   head = screw head (invalid for headless screws)\n//   shaft = screw shaft\n//   shank = unthreaded section of shaft (invalid if screw is fully threaded)\n//   threads = threaded section of screw     \n// Extra Anchors:\n//   top = top of screw\n//   bot = bottom of screw\n//   center = center of screw\n//   head_top = top of head (same as top for headless screws)\n//   head_bot = bottom of head (same as top for headless screws)\n//   head_center = center of head (same as top for headless screws)\n//   shaft_top = top of shaft\n//   shaft_bot = bottom of shaft\n//   shaft_center = center of shaft\n//   shank_top = top of shank (invalid if screw is fully threaded)\n//   shank_bot = bottom of shank (invalid if screw is fully threaded)\n//   shank_center = center of shank (invalid if screw is fully threaded)\n//   threads_top = top of threaded portion of screw (invalid if thread_len=0)\n//   threads_bot = bottom of threaded portion of screw (invalid if thread_len=0)\n//   threads_center = center of threaded portion of screw (invalid if thread_len=0)\n// Example(Med): Selected UTS (English) screws\n//   $fn=32;\n//   xdistribute(spacing=8){\n//     screw(\"#6\", length=12);\n//     screw(\"#6-32\", head=\"button\", drive=\"torx\",length=12);\n//     screw(\"#6-32,3/4\", head=\"hex\");\n//     screw(\"#6\", thread=\"fine\", head=\"fillister\",length=12, drive=\"phillips\");\n//     screw(\"#6\", head=\"flat small\",length=12,drive=\"slot\");\n//     screw(\"#6-32\", head=\"flat large\", length=12, drive=\"torx\");\n//     screw(\"#6-32\", head=\"flat undercut\",length=12);\n//     screw(\"#6-24\", head=\"socket\",length=12);          // Non-standard threading\n//     screw(\"#6-32\", drive=\"hex\", drive_size=1.5, length=12);\n//   }\n// Example(Med): A few examples of ISO (metric) screws\n//   $fn=32;\n//   xdistribute(spacing=8){\n//     screw(\"M3\", head=\"flat small\",length=12);\n//     screw(\"M3\", head=\"button\",drive=\"torx\",length=12);\n//     screw(\"M3\", head=\"pan\", drive=\"phillips\",length=12);\n//     screw(\"M3x1\", head=\"pan\", drive=\"slot\",length=12);   // Non-standard threading!\n//     screw(\"M3\", head=\"flat large\",length=12);\n//     screw(\"M3\", thread=\"none\", head=\"flat\", drive=\"hex\",length=12);  // No threads\n//     screw(\"M3\", head=\"socket\",length=12);\n//     screw(\"M5,18\", head=\"hex\");\n//   }\n// Example(Med): Demonstration of all head types for UTS screws (using pitch zero for fast preview)\n//   xdistribute(spacing=15){\n//     ydistribute(spacing=15){\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"none\", drive=\"hex\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"none\", drive=\"torx\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"none\", drive=\"slot\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"none\");\n//     }\n//     screw(\"1/4\", thread=0, length=8, anchor=TOP, head=\"hex\");\n//     ydistribute(spacing=15){\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"socket\", drive=\"hex\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"socket\", drive=\"torx\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"socket\");\n//     }\n//     ydistribute(spacing=15){\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"socket ribbed\", drive=\"hex\",$fn=32);\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"socket ribbed\", drive=\"torx\",$fn=32);\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"socket ribbed\",$fn=24);\n//     }\n//     ydistribute(spacing=15){\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"button\", drive=\"hex\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"button\", drive=\"torx\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"button\");\n//     }\n//     ydistribute(spacing=15){\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"round\", drive=\"slot\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"round\", drive=\"phillips\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"round\");\n//     }     \n//     ydistribute(spacing=15){\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"pan\", drive=\"slot\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"pan\", drive=\"phillips\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"pan\");\n//     }\n//     ydistribute(spacing=15){\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"fillister\", drive=\"slot\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"fillister\", drive=\"phillips\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"fillister\");\n//     }\n//     ydistribute(spacing=15){\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat\", drive=\"slot\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat\", drive=\"phillips\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat\", drive=\"hex\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat\", drive=\"torx\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat large\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat small\");\n//     }\n//     ydistribute(spacing=15){\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat undercut\", drive=\"slot\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat undercut\", drive=\"phillips\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat undercut\");\n//     }\n//     ydistribute(spacing=15){\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat 100\", drive=\"slot\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat 100\", drive=\"phillips\");\n//        screw(\"1/4\", thread=0,length=8, anchor=TOP, head=\"flat 100\");\n//     }\n//   }\n// Example(Med): Demonstration of all head types for metric screws without threading.\n//   xdistribute(spacing=15){\n//     ydistribute(spacing=15){\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"none\", drive=\"hex\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"none\", drive=\"torx\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"none\", drive=\"slot\");\n//       screw(\"M6x0\", length=8, anchor=TOP);\n//     }\n//     screw(\"M6x0\", length=8, anchor=TOP,  head=\"hex\");\n//     ydistribute(spacing=15){\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"socket\", drive=\"hex\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"socket\", drive=\"torx\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"socket\");\n//     }\n//     ydistribute(spacing=15){\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"socket ribbed\", drive=\"hex\", $fn=32);\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"socket ribbed\", drive=\"torx\", $fn=32);\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"socket ribbed\", $fn=32);\n//     }\n//     ydistribute(spacing=15){\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"pan\", drive=\"slot\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"pan\", drive=\"phillips\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"pan\", drive=\"torx\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"pan\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"pan flat\");\n//     }\n//     ydistribute(spacing=15){\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"button\", drive=\"hex\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"button\", drive=\"torx\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"button\");\n//     }\n//     ydistribute(spacing=15){\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"cheese\", drive=\"slot\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"cheese\", drive=\"phillips\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"cheese\", drive=\"torx\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"cheese\");\n//     }\n//     ydistribute(spacing=15){\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"flat\", drive=\"phillips\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"flat\", drive=\"slot\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"flat\", drive=\"hex\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"flat\", drive=\"torx\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"flat small\");\n//       screw(\"M6x0\", length=8, anchor=TOP,  head=\"flat large\");\n//     }\n//   }\n// Example: The three different English (UTS) screw tolerances (labeled on their heads)\n//   module label(val)\n//   {\n//     difference(){\n//        children();\n//        yflip()linear_extrude(height=.35) text(val,valign=\"center\",halign=\"center\",size=8);\n//     }\n//   }\n//   $fn=64;\n//   xdistribute(spacing=15){\n//     label(\"1\") screw(\"1/4-20,5/8\", head=\"hex\",orient=DOWN,atype=\"head\", anchor=TOP,tolerance=\"1A\");  // Loose\n//     label(\"2\") screw(\"1/4-20,5/8\", head=\"hex\",orient=DOWN,atype=\"head\", anchor=TOP,tolerance=\"2A\");  // Standard\n//     label(\"3\") screw(\"1/4-20,5/8\", head=\"hex\",orient=DOWN,atype=\"head\", anchor=TOP,tolerance=\"3A\");  // Tight\n//   }\n// Example(2D,NoAxes): This example shows the gap between nut and bolt at the loosest tolerance for UTS.  This gap is what enables the parts to mesh without binding and is part of the definition for standard metal hardware.  Note that this gap is part of the standard definition for the metal hardware, not the 3D printing adjustment provided by the $slop parameter.  \n//   $fn=32;\n//   projection(cut=true)xrot(-90){\n//       screw(\"1/4-20,3/8\", head=\"hex\",orient=UP,anchor=BOTTOM,tolerance=\"1A\");\n//       down(INCH*1/20*1.5) nut(\"1/4-20\", thickness=8, nutwidth=0.5*INCH, tolerance=\"1B\");\n//   }\n// Example: Here is a screw with nonstandard threading and a weird head size, which we create by modifying the screw structure:\n//   spec = screw_info(\"M6x2,12\",head=\"socket\");\n//   newspec = struct_set(spec,[\"head_size\",20,\"head_height\",3]);\n//   screw(newspec);\n// Example: A bizarre custom screw with nothing standard about it.  If your screw is very strange, consider setting tolerance to zero so you get exactly the screw you defined.  You'll need to create your own clearance between mating threads in this case.  \n//   spec = [[\"system\",\"ISO\"],\n//           [\"type\",\"screw_info\"],\n//           [\"pitch\", 2.3],\n//           [\"head\", \"flat\"],\n//           [\"head_size\", 20],\n//           [\"head_size_sharp\", 22],\n//           [\"head_angle\", 60],\n//           [\"diameter\",12],\n//           [\"length\",22]];\n//   screw(spec,tolerance=0);\n\nfunction _get_spec(spec, needtype, origin, thread,   // common parameters\n                   head, drive, drive_size,          // screw parameters\n                   shape, thickness                  // nut parameters\n                  ) =\n    assert(needtype==\"screw_info\" || needtype==\"nut_info\")\n    assert(is_undef(thickness) || (is_num(thickness) && thickness>0) ||\n           in_list(_downcase_if_str(thickness),[\"thin\",\"normal\",\"thick\",\"undersized\",\"din\"]),\n          \"thickness must be a positive number of one of \\\"thin\\\", \\\"thick\\\", \\\"normal\\\", \\\"undersized\\\", or \\\"DIN\\\"\")\n    assert(!(is_undef(spec) && is_undef($screw_spec)), \"No screw spec given and no parent spec available to inherit\")\n    let(\n        spec=is_undef(spec) ? $screw_spec : spec,\n        spec_origin = is_struct(spec) ? struct_val(spec,\"origin\") : undef\n    )\n    assert(is_string(spec) || is_struct(spec), \"Screw/nut specification must be a string or struct\")\n    let(\n        specname = is_struct(spec) ? struct_val(spec,\"name\") : undef,\n        name = is_string(spec) ? spec\n             : struct_val(spec,\"type\") != needtype ?       // if we switch between screw and nut we need a name \n                   let(specname=struct_val(spec,\"name\"))\n                   assert(is_string(specname), \n                        \"Parent screw_info or nut_info structure doesn't have a valid name, but a name is needed when child is of a different type\")\n               specname\n             : undef,\n        p = is_struct(spec) ? struct_val(spec,\"pitch\") : undef,\n        thread = is_def(name) ? thread\n                 // If the origin of the struct is a hole with pitch zero and we are making a screw, try to find a nonzero pitch\n               : spec_origin==\"screw_hole\" && origin!=\"screw_hole\" && p==0 && is_string(specname) ?\n                    let(temp_info = screw_info(specname,thread))\n                    struct_val(temp_info,\"pitch\")\n//               : spec_origin==\"screw_hole\" && origin==\"screw_hole\" && all_positive([p]) ? p\n//               : origin==\"screw_hole\" && is_undef(thread) ? 0\n               : thread\n    )\n    is_def(name) ? (needtype==\"screw_info\" ? screw_info(name,_origin=origin, thread= origin==\"screw_hole\" ? default(thread,true) : thread,\n                                                        head=head, drive=drive, drive_size=drive_size)\n                                           : nut_info(name,_origin=origin, thread=thread, shape=shape, thickness=thickness))\n  : \n    assert(in_list(struct_val(spec,\"type\"), [\"nut_info\",\"screw_info\"]), \"Screw/nut spec is invalid struct type\")\n    assert(is_undef(thread) || thread==\"none\" || thread==false || thread==true || is_num(thread),\n           str(\"Thread type applied to struct specification must be numeric, \\\"none\\\" or false but got \",thread))\n    assert(is_undef(thickness) || is_num(thickness), str(\"thickness applied to struct specification must be numeric but is \",thickness))\n    assert(is_undef(head) || head==\"none\", str(\"The only head type allowed with struct specifications is \\\"none\\\" but got \",head))\n    assert(num_defined([drive,drive_size])==0, \"You cannot change drive or drive_size when using a struct specification\")\n    assert(is_undef(shape), \"You cannot change nut shape when using a struct specification\")\n    let(\n        spec = _struct_reset(spec,\n                                   [ \n                                     [\"origin\", origin],\n                                     if (origin==\"screw\") [\"counterbore\",0],\n                                     if (head==\"none\") [\"head\",\"none\"],\n                                     if (head==\"none\") [\"drive\",\"none\"],\n                                     if (thread==false || thread==\"none\") [\"pitch\",0]\n                                     else if (thread!=true) [\"pitch\",thread],\n                                     [\"thickness\", thickness],\n                                   ], grow=true),\n        inherit = is_undef(spec_origin) || spec_origin==origin \n    )\n    inherit ? spec\n  : struct_remove(spec, [\"shaft_oversize\",\"head_oversize\"]);\n\n\nfunction _struct_reset(s, keyval, grow=true) =\n  let(\n      good = [for(kv=keyval) (grow || is_def(struct_val(s,kv[0]))) && is_def(kv[1])]\n  )\n  struct_set(s,flatten(bselect(keyval,good)));\n\n\nfunction _nominal_diam(spec) = struct_val(spec,\"diameter\")+default(struct_val(spec,\"shaft_oversize\"),0);\n                                                    \nfunction screw(spec, head, drive, thread, drive_size, \n             length, l, thread_len, tolerance, details=true, \n             undersize, shaft_undersize, head_undersize,\n             atype=\"screw\",anchor, spin=0, orient=UP,\n             _shoulder_diam=0, _shoulder_len=0,\n             bevel,bevel1,bevel2,bevelsize,\n             blunt_start,blunt_start1, blunt_start2,\n             _internal=false, _counterbore, _teardrop=false)\n   = no_function(\"screw\");\nmodule screw(spec, head, drive, thread, drive_size, \n             length, l, thread_len, tolerance, details=true, \n             undersize, shaft_undersize, head_undersize,\n             atype=\"screw\",anchor, spin=0, orient=UP,\n             _shoulder_diam=0, _shoulder_len=0,\n             bevel,bevel1,bevel2,bevelsize,\n             blunt_start,blunt_start1, blunt_start2,\n             _internal=false, _counterbore, _teardrop=false)\n{\n   tempspec = _get_spec(spec, \"screw_info\", _internal ? \"screw_hole\" : \"screw\",\n                        thread=thread, head=head, drive=drive, drive_size=drive_size);\n   undersize = is_num(undersize) ? [undersize,undersize]\n             : undersize;\n   dummyA=assert(is_undef(undersize) || is_vector(undersize,2), \"Undersize must be a scalar or 2-vector\")\n          assert(is_undef(undersize) || num_defined([shaft_undersize, head_undersize])==0,\n                 \"Cannot combine \\\"undersize\\\" with other more specific undersize parameters\")\n          assert(is_bool(_teardrop) ||_teardrop==\"max\" || all_nonnegative([_teardrop]), str(\"Invalid teardrop parameter\",_teardrop));\n   _teardrop = _teardrop==true ? .05 : _teardrop;   // set teardrop default\n   shaft_undersize = first_defined([shaft_undersize, undersize[0]]);\n   head_undersize = first_defined([head_undersize, undersize[1]]);\n   dummyB=assert(is_undef(shaft_undersize) || is_finite(shaft_undersize), \"shaft_undersize must be a number\")\n          assert(is_undef(head_undersize) || is_finite(head_undersize), \"head_undersize must be a number\")\n          assert(is_undef(_counterbore) || is_bool(_counterbore) || (is_finite(_counterbore) && _counterbore>=0),\n                 \"Counterbore must be a nonnegative number of boolean\");\n   l = one_defined([l,length],\"l,length\",dflt=undef);\n   _counterbore = _counterbore==true ? struct_val(tempspec,\"head_height\") \n                : _counterbore==false ? undef\n                : _counterbore;\n   head = struct_val(tempspec,\"head\");\n   headless = head==\"none\";\n   flathead = is_def(head) && starts_with(head,\"flat\");\n   reset_headsize = _internal && flathead ? struct_val(tempspec,\"head_size_sharp\") : undef;\n   spec=_struct_reset(tempspec,[\n                                [\"length\", l],\n                                [\"shaft_oversize\", u_mul(-1,shaft_undersize)],\n                                [\"head_oversize\", u_mul(-1,head_undersize)],\n                                [\"counterbore\", _counterbore],\n                                [\"thread_len\", thread_len],\n                                [\"head_size\", reset_headsize],\n                               ]);\n   dummy = _validate_screw_spec(spec);\n   $screw_spec = spec;\n   pitch =  struct_val(spec, \"pitch\") ;\n   threadspec = pitch==0 ? undef : thread_specification(spec, internal=_internal, tolerance=tolerance);\n   nominal_diam = _nominal_diam(spec);\n   d_major = pitch==0 ? nominal_diam : mean(struct_val(threadspec, \"d_major\"));\n   length = struct_val(spec,\"length\");\n   counterbore = default(struct_val(spec,\"counterbore\"),0);\n   user_thread_len = struct_val(spec,\"thread_len\");\n   dummyC = assert(in_list(atype,[\"shaft\",\"head\",\"shank\",\"threads\",\"screw\",\"shoulder\"]),str(\"Unknown anchor type: \\\"\",atype,\"\\\"\"))\n            assert(is_finite(length) && length>0, \"Must specify positive screw length\")\n            assert(is_finite(_shoulder_len) && _shoulder_len>=0, \"Must specify a nonegative shoulder length\")\n            assert(is_finite(_shoulder_diam) && _shoulder_diam>=0, \"Must specify nonnegative shoulder diameter\")\n            assert(is_undef(user_thread_len) || (is_finite(user_thread_len) && user_thread_len>=0), \"Must specify nonnegative thread length\");\n   sides = max(pitch==0 ? 3 : 12, segs(nominal_diam/2));\n   head_height = headless || flathead ? 0 \n               : counterbore==true || is_undef(counterbore) || counterbore==0 ? struct_val(spec, \"head_height\")\n               : counterbore;\n   head_diam = struct_val(spec, \"head_size\",0) + struct_val(spec, \"head_oversize\",0);\n   flat_height = !flathead ? 0 \n               : let( given_height = struct_val(spec, \"head_height\"))\n                 all_positive(given_height) ? given_height\n               : (struct_val(spec,\"head_size_sharp\")+struct_val(spec,\"head_oversize\",0)-d_major)/2/tan(struct_val(spec,\"head_angle\")/2);\n   flat_cbore_height = flathead && is_num(counterbore) ? counterbore : 0;\n\n   blunt_start1 = first_defined([blunt_start1,blunt_start,true]);\n   blunt_start2 = first_defined([blunt_start2,blunt_start,true]);\n\n   shoulder_adj = _shoulder_len>0 ? flat_height:0;  // Adjustment because flathead height doesn't count toward shoulder length\n   shoulder_full = _shoulder_len==0 ? 0 : _shoulder_len + flat_height;\n   shank_len = is_def(user_thread_len) ? length - user_thread_len - (_shoulder_len==0?flat_height:0) : 0;\n   thread_len = is_def(user_thread_len) ? user_thread_len\n              : length - (_shoulder_len==0?flat_height:0);\n   dummyD = assert(!(atype==\"shank\" && shank_len==0), \"Specified atype of \\\"shank\\\" but screw has no shank (thread_len not given or it equals shaft length)\")\n            assert(!(atype==\"shoulder\" && _shoulder_len==0), \"Specified atype of \\\"shoulder\\\" but screw has no shoulder\")\n            assert(!(atype==\"threads\" && thread_len==0), \"Specified atype of \\\"threads\\\" but screw has no threaded part (thread_len=0)\")\n            assert(!(atype==\"head\" && headless), \"You cannot anchor headless screws with atype=\\\"head\\\"\");\n   eps_gen = 0.01;\n   eps_shoulder = headless && !_internal ? 0 : eps_gen;\n   eps_shank = headless && !_internal && _shoulder_len==0 ? 0 : eps_gen;\n   eps_thread = headless && !_internal && shank_len==0 && _shoulder_len==0 ? 0 : eps_gen;\n   dummyL = assert(_shoulder_len>0 || is_undef(flat_height) || flat_height < length,\n                   str(\"Length of screw (\",length,\") is shorter than the flat head height (\",flat_height,\")\"));\n   offset = atype==\"head\" ? (-head_height+flat_height-flat_cbore_height)/2\n          : atype==\"shoulder\" ? _shoulder_len/2 + flat_height\n          : atype==\"shaft\" ? _shoulder_len + (length+flat_height+shoulder_adj)/2\n          : atype==\"shank\" ? _shoulder_len + (length-thread_len+flat_height+shoulder_adj)/2\n          : atype==\"threads\" ? _shoulder_len + shoulder_adj + length-thread_len + thread_len/2\n          : atype==\"screw\" ? (length-head_height+_shoulder_len+shoulder_adj-flat_cbore_height)/2\n          : assert(false,\"Unknown atype\");\n   dummyM = //assert(!headless || !in_list(anchor,[\"head_top\",\"head_bot\",\"head_center\"]), str(\"Anchor \\\"\",anchor,\"\\\" not allowed for headless screw\"))\n            assert(shank_len>0 || !in_list(anchor,[\"shank_top\",\"shank_bot\",\"shank_center\"]),\n                   str(\"Screw has no unthreaded shank so anchor \\\"\",anchor,\"\\\" is not allowed\"));\n   anchor_list = [\n          named_anchor(\"top\", [0,0,offset+head_height+flat_cbore_height]),\n          named_anchor(\"bot\", [0,0,-length-shoulder_full+offset]),\n          named_anchor(\"center\", [0,0, -length/2 - shoulder_full/2 + head_height/2 + offset]),\n          named_anchor(\"head_top\", [0,0,head_height+offset]),\n          named_anchor(\"head_bot\", [0,0,-flat_height+offset]),\n          named_anchor(\"head_center\", [0,0,(head_height-flat_height)/2+offset]),\n          if (_shoulder_len>0) named_anchor(\"shoulder_top\", [0,0,offset-flat_height]),\n          if (_shoulder_len>0) named_anchor(\"shoulder_bot\", [0,0,offset-shoulder_full]),\n          if (_shoulder_len>0) named_anchor(\"shoulder_center\", [0,0,offset-flat_height-_shoulder_len/2]),\n          named_anchor(\"shaft_top\", [0,0,-_shoulder_len-flat_height+offset]),\n          named_anchor(\"shaft_bot\", [0,0,-length-shoulder_full+offset]),\n          named_anchor(\"shaft_center\", [0,0,(-_shoulder_len-flat_height-length-shoulder_full)/2+offset]),\n          if (shank_len>0) named_anchor(\"shank_top\", [0,0,-_shoulder_len-flat_height+offset]),\n          if (shank_len>0) named_anchor(\"shank_bot\", [0,0,-shank_len-_shoulder_len-flat_height+offset]),\n          if (shank_len>0) named_anchor(\"shank_center\", [0,0,-shank_len/2-_shoulder_len-flat_height+offset]),\n          named_anchor(\"threads_top\", [0,0,-shank_len-_shoulder_len-flat_height+offset]),\n          named_anchor(\"threads_bot\", [0,0,-length-shoulder_full+offset]),\n          named_anchor(\"threads_center\", [0,0,(-shank_len-length-_shoulder_len-shoulder_full-flat_height)/2+offset])\n   ];\n   rad_scale = _internal? (1/cos(180/sides)) : 1;\n   islop = _internal ? 4*get_slop() : 0;\n   vnf = head==\"hex\" && atype==\"head\" && counterbore==0 ? linear_sweep(hexagon(id=head_diam*rad_scale),height=head_height,center=true) : undef;\n   head_diam_full = head==\"hex\" ? 2*head_diam/sqrt(3) : head_diam;\n   attach_d = in_list(atype,[\"threads\",\"shank\",\"shaft\"]) ? d_major \n            : atype==\"screw\" ? max(d_major,_shoulder_diam,default(head_diam_full,0))\n            : atype==\"shoulder\" ? _shoulder_diam\n            : is_def(vnf) ? undef\n            : head_diam_full;\n   attach_l = atype==\"shaft\" ? length-(_shoulder_len>0?0:flat_height)\n            : atype==\"shoulder\" ? _shoulder_len\n            : atype==\"shank\" ? shank_len\n            : atype==\"threads\" ? thread_len\n            : atype==\"screw\" ? length+head_height+shoulder_full + flat_cbore_height\n            : is_def(vnf) ? undef\n            : head_height+flat_height+flat_cbore_height;\n   bevelsize = default(bevelsize, d_major/12);\n   bevel1 = first_defined([bevel1,bevel,true]);\n   bevel2 = first_defined([bevel2,bevel,headless && _shoulder_len==0 && shank_len==0]);\n   attachable(\n              vnf = vnf, \n              d = u_add(u_mul(attach_d, rad_scale), islop),\n              l = attach_l,\n              orient = orient,\n              anchor = anchor,\n              spin = spin,\n              anchors=anchor_list)\n   {\n     up(offset)\n       difference(){\n         union(){\n           screw_head(spec,details,counterbore=counterbore,flat_height=flat_height,\n                      slop=islop,teardrop=_teardrop);\n           if (_shoulder_len>0)\n             up(eps_shoulder-flat_height){\n               if (_teardrop!=false) //////\n                 teardrop(d=_shoulder_diam*rad_scale+islop,cap_h=is_num(_teardrop) ? (_shoulder_diam*rad_scale+islop)/2*(1+_teardrop):undef,\n                          h=_shoulder_len+eps_shoulder, anchor=FRONT, orient=BACK, $fn=sides);\n               else\n                 cyl(d=_shoulder_diam*rad_scale+islop, h=_shoulder_len+eps_shoulder, anchor=TOP, $fn=sides, chamfer1=details ? _shoulder_diam/30:0);\n             }\n           if (shank_len>0 || pitch==0){\n             L = pitch==0 ? length - (_shoulder_len==0?flat_height:0) : shank_len;\n             bevsize = (_internal ? -1 : 1)*bevelsize;\n             bev1 = pitch!=0 ? 0\n                  : bevel1==true ? bevsize\n                  : bevel1==false ? 0\n                  : bevel1==\"reverse\" ? -bevsize\n                  : bevel1;\n             bev2 = pitch!=0 ? 0\n                  : bevel2==true ? bevsize\n                  : bevel2==false ? 0\n                  : bevel2==\"reverse\" ? -bevsize\n                  : bevel2;\n             down(_shoulder_len+flat_height-eps_shank)\n               if (_teardrop!=false)  ///////\n                 teardrop(d=d_major*rad_scale+islop, cap_h=is_num(_teardrop) ? (d_major*rad_scale+islop)/2*(1+_teardrop) : undef,\n                          h=L+eps_shank, anchor=FRONT, orient=BACK, $fn=sides, chamfer1=bev1, chamfer2=bev2);\n               else\n                 cyl(d=d_major*rad_scale+islop, h=L+eps_shank, anchor=TOP, $fn=sides, chamfer1=bev1, chamfer2=bev2);\n           }\n           if (thread_len>0 && pitch>0){\n             down(_shoulder_len+flat_height+shank_len-eps_thread)\n                   threaded_rod([mean(struct_val(threadspec, \"d_minor\")),\n                                 mean(struct_val(threadspec, \"d_pitch\")),\n                                 d_major], \n                      pitch = struct_val(threadspec, \"pitch\"),\n                      l=thread_len+eps_thread, left_handed=false, internal=_internal, \n                      bevel1=bevel1,\n                      bevel2=bevel2,teardrop=_teardrop,\n                      blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2, \n                      $fn=sides, anchor=TOP);\n            }\n             \n         }\n         if (!_internal) _driver(spec);\n       }\n     children();\n   }  \n}\n\n\n\n// Module: screw_hole()\n// Synopsis: Creates a screw hole.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: screw()\n// Usage:\n//   screw_hole([spec], [head], [thread=], [length=|l=], [oversize=], [hole_oversize=], [teardrop=], [head_oversize], [tolerance=], [$slop=], [blunt_start=], [anchor=], [atype=], [orient=], [spin=]) [ATTACHMENTS];\n// Description:\n//   Create a screw hole mask.  See [screw and nut parameters](#section-screw-and-nut-parameters) for details on the parameters that define a screw.\n//   The screw hole can be threaded to receive a screw or it can be an unthreaded clearance hole.  \n//   The tolerance determines the dimensions of the screw\n//   based on ISO and ASME standards.  Screws fabricated at those dimensions will mate properly with standard hardware.\n//   The $slop argument makes the hole larger by 4*$slop to account for printing overextrusion.  It defaults to 0.\n//   .\n//   You can generate a screw specification from {{screw_info()}}, possibly create a modified version, and pass that in rather than giving the parameters.\n//   .\n//   The tolerance should be a nut tolerance for a threaded hole or a clearance hole tolerance for clearance holes.\n//   For clearance holes, the UTS tolerances are \"normal\", \"loose\" and \"close\".  ASME also specifies the same naming for metric clearance holes.\n//   However, ISO gives \"fine\", \"medium\" and \"coarse\" instead.  This function accepts all of these in either system.  It also takes \"tight\" to be equivalent to \"close\",\n//   even though no standard suggests it, because it's a natural opposite of \"loose\".  The official tolerance designations for ISO are \"H12\" for \"fine\", \"H13\" for \"medium\"\n//   and \"H14\" for \"coarse\".  These designations will also work, but only for metric holes.  You can also set tolerance to 0 or \"none\" to produce holes at the nominal size.\n//   .\n//   If you want to produce holes for tapping you can use a tolerance of \"tap\".  This produces a hole of the nominal screw diameter reduced by the thread pitch.  You may still\n//   need to adjust $slop for best results.  Some people screw machine screws directly into plastic without tapping.  This works better with a somewhat larger hole, so\n//   a tolerance of \"self tap\" produces such a hole.  Note that this tolerance also makes the default bevel2=true to bevel the top, which makes it much easier\n//   to start the screw.  The \"self tap\" tolerance subtracts `0.72 * pitch` when pitch is below 1mm, `0.6 * pitch` when the pitch is over 1.5mm, and it interpolates between.\n//   It was tested in PLA with a Prusa MK3S and $slop=0.05 and worked on UTS screws from #2 up to 1/2 inch.  \n//   .\n//   The counterbore parameter adds a cylindrical clearance hole above the screw shaft.  For flat heads it extends above the flathead and for other screw types it \n//   replaces the head with a cylinder large enough in diameter for the head to fit.  For a flat head you must specify the length of the counterbore.  For other heads you can\n//   set counterbore to true and it will be sized to match the head height.  The counterbore will extend 0.01 above the TOP of the hole mask to ensure no\n//   problems with differences.  Note that the counterbore defaults to true for non-flathead screws.  If you want the actual head shape to appear, set counterbore to zero.\n//   .\n//   For 3d printing circular holes can be problematic.  One solution is to use octagonal holes, setting $fn=8.  Another option is to use a teardrop hole, which\n//   can be accomplished by setting `teardrop=true`.  The point of the teardrop will point in the Y direction (BACK) so you will need to ensure that you orient it\n//   correctly in your final model.  \n//   .\n//   Anchoring for screw_hole() is the same as anchoring for {{screw()}}, with all the same anchor types and named anchors.  If you specify a counterbore it is treated as\n//   the \"head\", or in the case of flat heads, it becomes part of the head.  If you make a teardrop hole the point is ignored for purposes of anchoring.\n// Arguments:\n//   spec = screw specification, e.g. \"M5x1\" or \"#8-32\".  See [screw naming](#subsection-screw-naming).  This can also be a screw specification structure of the form produced by {{screw_info()}}.  \n//   head = head type.  See [screw heads](#subsection-screw-heads)  Default: none\n//   ---\n//   thread = thread type or specification for threaded masks, true to make a threaded mask with the standard threads, or false to make an unthreaded mask.  See [screw pitch](#subsection-standard-screw-pitch). Default: false\n//   teardrop = If true, adds a teardrop profile to the hole for 3d printability of horizontal holes. If numeric, specifies the proportional extra distance of the teardrop flat top from the screw center, or set to \"max\" for a pointed teardrop. Default: false\n//   oversize = amount to increase diameter of the screw hole (hole and countersink).  A scalar or length 2 vector.  Default: use computed tolerance\n//   hole_oversize = amount to increase diameter of the hole.  Overrides the use of tolerance and replaces any settings given in the screw specification. \n//   head_oversize = amount to increase diameter of head.  Overrides the user of tolerance and replaces any settings given in the screw specification.  \n//   length / l= length of screw (in mm)\n//   counterbore = set to length of counterbore, or true to make a counterbore equal to head height.  Default: false for flat heads and headless, true otherwise\n//   tolerance = threading or clearance hole tolerance.  For internal threads, detrmines actual thread geometry based on nominal sizing.  See [tolerance](#subsection-tolerance). Default is \"2B\" for UTS and 6H for ISO.  For clearance holes, determines how much clearance to add.  Default is \"normal\".  \n//   bevel = if true create bevel at both ends of hole.  Default: see below\n//   bevel1 = if true create bevel at bottom end of hole.  Default: false\n//   bevel2 = if true create bevel at top end of hole.     Default: true when tolerance=\"self tap\", false otherwise\n//   blunt_start = if true and hole is threaded, create blunt start threads.  Default: true\n//   blunt_start1 = if true and hole is threaded, create blunt start threads at bottom end.\n//   blunt_start2 = if true and hole is threaded, create blunt start threads top end.\n//   $slop = add extra gap to account for printer overextrusion.  Default: 0\n//   atype = anchor type, one of \"screw\", \"head\", \"shaft\", \"threads\", \"shank\"\n//   anchor = Translate so anchor point on the shaft is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   `$screw_spec` is set to the spec specification structure. \n// Anchor Types:\n//   screw = the entire screw (default)\n//   head = screw head (invalid for headless screws)\n//   shaft = screw shaft\n//   shank = unthreaded section of shaft (invalid if screw is fully threaded)\n//   threads = threaded section of screw     \n// Extra Anchors:\n//   top = top of screw\n//   bot = bottom of screw\n//   center = center of screw\n//   head_top = top of head (invalid for headless screws)\n//   head_bot = bottom of head (invalid for headless screws)\n//   head_center = center of head (invalid for headless screws)\n//   shaft_top = top of shaft\n//   shaft_bot = bottom of shaft\n//   shaft_center = center of shaft\n//   shank_top = top of shank (invalid if screw is fully threaded)\n//   shank_bot = bottom of shank (invalid if screw is fully threaded)\n//   shank_center = center of shank (invalid if screw is fully threaded)\n//   threads_top = top of threaded portion of screw (invalid if thread_len=0)\n//   threads_bot = bottom of threaded portion of screw (invalid if thread_len=0)\n//   threads_center = center of threaded portion of screw (invalid if thread_len=0)\n// Example: Counterbored clearance hole\n//   diff()\n//     cuboid(20)\n//       attach(TOP)\n//         screw_hole(\"1/4-20,.5\",head=\"socket\",counterbore=5,anchor=TOP);\n// Example: Clearance hole for flathead \n//   diff()\n//     cuboid(20)\n//       attach(TOP)\n//          screw_hole(\"1/4-20,.5\",head=\"flat\",counterbore=0,anchor=TOP);\n// Example: Threaded hole, with inward bevel at the base\n//   bottom_half()\n//     diff()\n//       cuboid(20)\n//         attach(FRONT)\n//           screw_hole(\"M16,15\",anchor=TOP,thread=true,bevel1=\"reverse\");\nfunction screw_hole(spec, head, thread, oversize, hole_oversize, head_oversize, \n             length, l, thread_len, tolerance=undef, counterbore, teardrop=false,\n             bevel, bevel1, bevel2, blunt_start, blunt_start1, blunt_start2, \n             atype=\"screw\",anchor=CENTER,spin=0, orient=UP)\n    = no_function(\"screw_hole\");\nmodule screw_hole(spec, head, thread, oversize, hole_oversize, head_oversize, \n             length, l, thread_len, tolerance=undef, counterbore, teardrop=false,\n             bevel, bevel1, bevel2, blunt_start, blunt_start1, blunt_start2, \n             atype=\"screw\",anchor=CENTER,spin=0, orient=UP)\n{\n   screwspec = _get_spec(spec, \"screw_info\", \"screw_hole\", \n                        thread=thread, head=head);\n   bevel1 = first_defined([bevel1,bevel,false]);\n   bevel2 = first_defined([bevel2,bevel,tolerance==\"self tap\"]);\n   thread = default(thread,false);\n   checkhead = struct_val(screwspec,\"head\");\n   default_counterbore = checkhead==\"none\" || starts_with(checkhead,\"flat\") ? 0 : true;\n   counterbore = default(counterbore, default_counterbore);\n   dummy = _validate_screw_spec(screwspec);\n   threaded = thread==true || (is_finite(thread) && thread>0) || (is_undef(thread) && struct_val(screwspec,\"pitch\")>0);\n   oversize = force_list(oversize,2);\n   hole_oversize = first_defined([hole_oversize, oversize[0],struct_val(screwspec,\"shaft_oversize\")]);\n   head_oversize = first_defined([head_oversize, oversize[1],struct_val(screwspec,\"head_oversize\")]);\n   if (threaded || is_def(hole_oversize) || tolerance==0 || tolerance==\"none\") {\n     default_tag(\"remove\")\n       screw(spec,head=head,thread=thread,shaft_undersize=u_mul(-1,hole_oversize), head_undersize=u_mul(-1,head_oversize),\n             blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2, \n             length=length,l=l,thread_len=thread_len, tolerance=tolerance, _counterbore=counterbore,\n             bevel1=bevel1, bevel2=bevel2, \n             atype=atype, anchor=anchor, spin=spin, orient=orient, _internal=true, _teardrop=teardrop)\n         children();\n   }\n   else {\n     tolerance = default(tolerance, \"normal\");\n     pitch = struct_val(screwspec,\"pitch\");\n     dummy3 = assert((downcase(tolerance) != \"tap\" && downcase(tolerance)!=\"self tap\") || pitch!=0,\n                     \"\\\"tap\\\" clearance requires a pitch size, but pitch is set to zero\");\n     // UTS clearances from ASME B18.2.8\n     UTS_clearance = [\n       [ // Close fit\n         [0.1120 * INCH,0.008*INCH],\n         [0.1250 * INCH, 1/64*INCH],\n         [7/16   * INCH, 1/64*INCH],\n         [1/2    * INCH, 1/32*INCH],\n         [1.25   * INCH, 1/32*INCH],\n         [1.375  * INCH, 1/16*INCH]\n       ],\n       [ // Normal fit\n         [0.1120 * INCH, 1/64*INCH],\n         [0.1250 * INCH, 1/32*INCH],\n         [7/16   * INCH, 1/32*INCH],\n         [1/2    * INCH, 1/16*INCH],\n         [7/8    * INCH, 1/16*INCH],\n         [1      * INCH, 3/32*INCH],\n         [1.25   * INCH, 3/32*INCH],\n         [1.375  * INCH,  1/8*INCH],\n       ],\n       [ // Loose fit\n         [0.1120 * INCH, 1/32*INCH],\n         [0.1250 * INCH, 3/64*INCH],\n         [7/16   * INCH, 3/64*INCH],\n         [1/2    * INCH, 7/64*INCH],\n         [5/8    * INCH, 7/64*INCH],\n         [3/4    * INCH, 5/32*INCH],\n         [1      * INCH, 5/32*INCH],\n         [1.125  * INCH, 3/16*INCH],\n         [1.25   * INCH, 3/16*INCH],\n         [1.375  * INCH,15/64*INCH]\n       ]\n     ];\n     // ISO clearances appear in ASME B18.2.8 and ISO 273\n     ISO_clearance = [\n       [ // Close, Fine, H12 \n         [2.5, 0.1],\n         [3.5, 0.2],\n         [4,   0.3],\n         [5,   0.3],\n         [6,   0.4],\n         [8,   0.4],\n         [10,  0.5],\n         [12,  1],\n         [42,  1],\n         [48,  2],\n         [80,  2],\n         [90,  3],\n         [100, 4],\n       ],\n       [  // Normal, Medium, H13\n         [1.6, 0.2],\n         [2,   0.4],\n         [3.5, 0.4],\n         [4,   0.5],\n         [5,   0.5],\n         [6,   0.6],\n         [8,   1],\n         [10,  1],\n         [12,  1.5],\n         [16,  1.5],\n         [20,  2],\n         [24,  2],\n         [30,  3],\n         [42,  3],\n         [48,  4],\n         [56,  6],\n         [90,  6],\n         [100, 7],\n       ],\n       [  // Loose, Coarse, H14\n         [1.6, 0.25],\n         [2,   0.3],\n         [3,   0.6],\n         [3.5, 0.7],\n         [4,   0.8],\n         [5,   0.8],\n         [6,   1],\n         [8,   2],\n         [10,  2],\n         [12,  2.5],\n         [16,  2.5],\n         [20,  4],\n         [24,  4],\n         [30,  5],\n         [36,  6],\n         [42,  6],\n         [48,  8],\n         [56, 10],\n         [72, 10],\n         [80, 11],\n         [90, 11],\n         [100,12],\n       ]\n     ];\n     tol_ind = in_list(downcase(tolerance), [\"close\", \"fine\", \"tight\"]) ? 0\n             : in_list(downcase(tolerance), [\"normal\", \"medium\", \"tap\", \"self tap\"]) ? 1\n             : in_list(downcase(tolerance), [\"loose\", \"coarse\"]) ? 2\n             : in_list(tolerance, [\"H12\",\"H13\",\"H14\"]) ?\n                   assert(struct_val(screwspec,\"system\")==\"ISO\", str(\"Hole tolerance \", tolerance, \" only allowed with ISO screws\"))\n                   parse_int(substr(tolerance,1))\n             : assert(false,str(\"Unknown tolerance \",tolerance, \" for clearance hole\"));\n     tol_table = struct_val(screwspec,\"system\")==\"UTS\" ? UTS_clearance[tol_ind] : ISO_clearance[tol_ind];\n     tol_gap = lookup(_nominal_diam(screwspec), tol_table);\n     // If we got here, hole_oversize is undefined and oversize is undefined\n     hole_oversize = downcase(tolerance)==\"tap\" ? -pitch\n                   : downcase(tolerance)==\"self tap\" ? -pitch*lookup(pitch,[[1,0.72],[1.5,.6]])\n                   : tol_gap;\n     head_oversize = default(head_oversize, tol_gap);\n     default_tag(\"remove\")     \n       screw(spec,head=head,thread=0,shaft_undersize=-hole_oversize, head_undersize=-head_oversize, \n             length=length,l=l,thread_len=thread_len, _counterbore=counterbore,\n             bevel1=bevel1, bevel2=bevel2, bevelsize=pitch>0?pitch:undef,\n             atype=atype, anchor=anchor, spin=spin, orient=orient, _internal=true, _teardrop=teardrop)\n         children();\n   }\n} \n\n// Module: shoulder_screw()\n// Synopsis: Creates a shoulder screw.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: screw(), screw_hole()\n// Usage:\n//   shoulder_screw(s, d, length, [head=], [thread_len=], [tolerance=], [head_size=], [drive=], [drive_size=], [thread=], [undersize=], [shaft_undersize=], [head_undersize=], [shoulder_undersize=],[atype=],[anchor=],[orient=],[spin=]) [ATTACHMENTS];\n// Description:\n//   Create a shoulder screw.  See [screw and nut parameters](#section-screw-and-nut-parameters) for details on the parameters that define a screw.\n//   The tolerance determines the dimensions of the screw\n//   based on ISO and ASME standards.  Screws fabricated at those dimensions will mate properly with standard hardware.\n//   Note that the $slop argument does not affect the size of screws: it only adjusts screw holes.  This will work fine\n//   if you are printing both parts, but if you need to mate printed screws to metal parts you may need to adjust the size\n//   of the screws, which you can do with the undersize arguments.\n//   .\n//   Unlike a regular screw, a shoulder screw is based on its shoulder dimensions: diameter and length.  The ISO and ASME standards\n//   specify for a given shoulder diameter the thread size and even the length of the threads.  Note that these standards specify only\n//   a small range of sizes.  You can specify a shoulder screw by giving the system, either \"ISO\" or \"UTS\" and the shoulder diameter\n//   and length, and shoulder_screw() will supply the other parameters.\n//   .\n//   Hardware sources like McMaster sell many screws that don't comply with the standards.  If you want to make such a screw then\n//   you can specify parameters like thread_len, the length of the threaded portion below the shoulder, and you can choose a different head\n//   type.  You will need to specify the size of the head, since it cannot be looked up in tables.  You can also \n//   generate a screw specification from {{screw_info()}}, possibly create a modified version using {{struct_set()}}, and pass that in rather than giving the parameters.\n//   .\n//   The anchors and anchor types are the same as for {{screw()}} except that there is an anchor type for the shoulder and an additional set of named anchors\n//   refering to parts of the shoulder.  \n// Arguments:\n//   s = screw system to use, case insensitive, either \"ISO\", \"UTS\", \"english\" or \"metric\", or a screw name or specification.  See [screw naming](#subsection-screw-naming).\n//   d = nominal shoulder diameter in mm for ISO or inches for UTS\n//   length = length of the shoulder (in mm)\n//   ---\n//   thread_len = length of threads\n//   tolerance = screw tolerance.  Determines actual screw thread geometry based on nominal sizing.  See [tolerance](#subsection-tolerance). Default is \"2A\" for UTS and \"6g\" for ISO.\n//   drive = drive type.  See [screw heads](#subsection-screw-heads) set to \"none\" for no drive.  Default: \"hex\"\n//   drive_size = size of the drive recess\n//   thread = thread type or specification. See [screw pitch](#subsection-standard-screw-pitch). Default: \"coarse\"\n//   spec = screw specification to define the thread size \n//   head_size = scalar or vector to give width or [width, height].  If you only give width, height is computed using a formula for socket heads.  For flat head screws the second value in the vector is the sharp size; if you don't give it then the sharp size will be 12% more than the given size\n// Side Effects:\n//   `$screw_spec` is set to the spec specification structure. \n// Anchor Types:\n//   screw = the entire screw (default)\n//   head = screw head (invalid for headless screws)\n//   shoulder = the shoulder\n//   shaft = screw shaft\n//   threads = threaded section of screw     \n// Extra Anchors:\n//   top = top of screw\n//   bot = bottom of screw\n//   center = center of screw\n//   head_top = top of head (invalid for headless screws)\n//   head_bot = bottom of head (invalid for headless screws)\n//   head_center = center of head (invalid for headless screws)\n//   shoulder_top = top of shoulder\n//   shoulder_bot = bottom of shoulder\n//   shoulder_center = center of shoulder\n//   shaft_top = top of shaft\n//   shaft_bot = bottom of shaft\n//   shaft_center = center of shaft\n//   threads_top = top of threaded portion of screw (invalid if thread_len=0)\n//   threads_bot = bottom of threaded portion of screw (invalid if thread_len=0)\n//   threads_center = center of threaded portion of screw (invalid if thread_len=0)\n// Example: ISO shoulder screw\n//   shoulder_screw(\"iso\",10,length=20);\n// Example: English shoulder screw\n//   shoulder_screw(\"english\",1/2,length=20);\n// Example: Custom example.  You must specify thread_len and head_size when creating custom configurations.  \n//   shoulder_screw(\"M6\", 9.3, length=17, thread_len=8, head_size=14);\n// Example: Another custom example:\n//   shoulder_screw(\"M6\", 9.3, length=17, thread_len=8, head_size=14, head=\"button\", drive=\"torx\");\n// Example: Threadless \n//   shoulder_screw(\"iso\",10,length=15,thread=0);\n// Example: No drive recess\n//   shoulder_screw(\"iso\",10,length=15,drive=\"none\");\n// Example: Headless\n//   shoulder_screw(\"iso\", 16, length=20, head=\"none\");\n// Example: Changing head height\n//   shoulder_screw(\"iso\", 16, length=20, head_size=[24,5]);\nfunction shoulder_screw(s,d,length,head, thread_len, tolerance, head_size, drive, drive_size, thread,\n                      undersize, shaft_undersize, head_undersize, shoulder_undersize=0,\n                      blunt_start, blunt_start1, blunt_start2, \n                      atype=\"screw\", anchor=BOT, orient,spin) = no_function(\"shoulder_screw\");\nmodule shoulder_screw(s,d,length,head, thread_len, tolerance, head_size, drive, drive_size, thread,\n                      undersize, shaft_undersize, head_undersize, shoulder_undersize=0,\n                      blunt_start, blunt_start1, blunt_start2, \n                      atype=\"screw\", anchor=BOT, orient,spin)\n{\n  d1= assert(is_num(d) && d>0, \"Must specify shoulder diameter\")\n      assert (is_num(length) && length>0, \"Must specify shoulder length\");\n  systemOK=is_string(s) && in_list(downcase(s),[\"iso\",\"metric\",\"uts\",\"english\"]);\n  info_temp = systemOK ? undef\n            : is_struct(s) ? s\n            : screw_info(s);\n  infoOK = systemOK ? false\n         : _nominal_diam(info_temp) && struct_val(info_temp,\"pitch\") && struct_val(info_temp,\"system\");\n  d2=assert(systemOK || infoOK, \"System must be \\\"ISO\\\", \\\"UTS\\\", \\\"English\\\" or \\\"metric\\\" or a valid screw specification string\")\n     assert(!is_struct(s) || num_defined([drive, drive_size, thread, head])==0,\n            \"With screw struct, \\\"head\\\", \\\"drive\\\", \\\"drive_size\\\" and \\\"thread\\\" are not allowed\");\n  drive = drive==\"none\" ? undef : default(drive,\"hex\");\n  thread = default(thread,\"coarse\");\n  head = default(head, \"socket\");                                    \n  usersize = systemOK ? undef : s;\n  system = systemOK ? s : struct_val(info_temp,\"system\");\n  undersize = is_undef(undersize) ? undersize\n            : is_num(undersize) ? [undersize,undersize]\n            : undersize;\n  shaft_undersize = first_defined([shaft_undersize, undersize[0], 0]);\n  head_undersize = first_defined([head_undersize, undersize[1], 0]);\n  \n  iso = in_list(downcase(system), [\"iso\",\"metric\"]);\n\n  factor = iso ? 1 : INCH;\n\n  table = iso ?   //  iso shoulder screws, hex drive socket head  ISO 7379\n                  //  Mcmaster has variations like 12mm shoulder for m10, 6mm shoulder for M5\n                  // shld   screw  thread  head  hex  hex     head  \n                  // diam   size   length  diam      depth     ht \n                  [                                                 \n                     [6.5,  [\"M5\",   9.5,   10,   3,  2.4,     4.5]],\n                     [8  ,  [\"M6\",   11 ,   13,   4,  3.3,     5.5]],\n                     [10 ,  [\"M8\",   13 ,   16,   5,  4.2,     7  ]],\n                     [13 ,  [\"M10\",  16 ,   18,   6,  4.9,     9  ]],\n                     [16 ,  [\"M12\",  18 ,   24,   8,  6.6,    11  ]],\n                     [20 ,  [\"M16\",  22 ,   30,  10,  8.8,    14  ]],\n                     [25 ,  [\"M20\",  27 ,   36,  12,  10 ,    16  ]]\n                   ]\n        :\n                   // UTS shoulder screws, b18.3 (table 13)\n                   // sh diam  screw   thread len, head diam   hex size  hex depth\n                   [\n                      [1/8  ,  [\"#4\",     5/32 ,    1/4      ,  5/64   ,  0.067]],\n                      [5/32 ,  [\"#6\",     3/16 ,    9/32     ,  3/32   ,  0.067]],\n                      [3/16 ,  [\"#8\",     3/16 ,    5/16     ,  3/32   ,  0.079]],\n                      [1/4  ,  [\"#10\",    3/8  ,    3/8      ,  1/8    ,  0.094]],\n                      [5/16 ,  [\"1/4\",    7/16 ,    7/16     ,  5/32   ,  0.117]],\n                      [3/8  ,  [\"5/16\",   1/2  ,    9/16     ,  3/16   ,  0.141]],\n                      [1/2  ,  [\"3/8\",    5/8  ,    3/4      ,  1/4    ,  0.188]],\n                      [5/8  ,  [\"1/2\",    3/4  ,    7/8      ,  5/16   ,  0.234]],\n                      [3/4  ,  [\"5/8\",    7/8  ,    1        ,  3/8    ,  0.281]],\n                      [1    ,  [\"3/4\",    1    ,    1+5/16   ,  1/2    ,  0.375]],\n                      [1+1/4,  [\"7/8\",    1+1/8,    1+3/4    ,  5/8    ,  0.469]],\n                      [1+1/2,  [\"1.125\",  1+1/2,    2+1/8    ,  7/8    ,  0.656]],\n                      [1+3/4,  [\"1.25\",   1+3/4,    2+3/8    ,  1      ,  0.750]],\n                      [2    ,  [\"1.5\",    2    ,    2+3/4    ,  1+1/4  ,  0.937]]\n                   ];           \n  entry = struct_val(table, d);\n  shoulder_diam = d * factor - shoulder_undersize;\n  spec = first_defined([usersize, entry[0]]);\n  dummy2=assert(is_def(spec),\"No shoulder screw found with specified diameter\");\n  thread_len = first_defined([thread_len, u_mul(entry[1],factor)]);\n  head_size = first_defined([head_size, u_mul(entry[2],factor)]);\n  drive_size = first_defined([drive_size, u_mul(entry[3],factor)]);\n  drive_depth = u_mul(entry[4],factor);\n  head_height_table = iso? first_defined([entry[5],d/2+1.5])\n                    : d<3/4 ? (d/2 + 1/16)*INCH\n                    : (d/2 + 1/8)*INCH;\n  shoulder_tol = tolerance==0 || tolerance==\"none\" ? 0\n               : iso ? lookup(d, [[10,0.03],[13,0.037],[16,0.037],[20,0.046]])\n               : 1; //0.003 * INCH;\n  info = is_struct(s) ? s\n       : screw_info(spec, head, drive, drive_size=drive_size, thread=thread);\n\n  final_headsize = is_num(head_size) ? head_size\n                 : head_size[0];\n  d5=assert(is_num(final_headsize), \"Head size invalid or missing\");\n  final_sharpsize =  head!=\"flat\" ? undef : is_vector(head_size)? head_size[1] : final_headsize*1.12;\n  head_height_flat = head!=\"flat\" ? undef : (final_sharpsize-(shoulder_diam-shoulder_tol))/2/tan(struct_val(info,\"head_angle\")/2);\n  headfields = concat(\n                      [\"head_size\", final_headsize],\n                      head==\"flat\" ? [\"head_size_sharp\", final_sharpsize, \"head_height\", head_height_flat]\n                                   : [\"head_height\",   is_vector(head_size) ? head_size[1]\n                                                     : is_num(head_height_table)? head_height_table\n                                                     : final_headsize/2 + 1.5],\n                      is_def(drive_depth) ? [\"drive_depth\", drive_depth] :[]\n                     );\n  dummy3=assert(is_num(length) && length>0, \"Must give a positive shoulder length\");\n  screw(struct_set(info, headfields),\n        _shoulder_len = length, _shoulder_diam = shoulder_diam-shoulder_tol,\n        length=thread_len, tolerance=tolerance, shaft_undersize=shaft_undersize, head_undersize=head_undersize,\n        blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,                 \n        atype=atype, anchor=anchor, orient=orient, spin=spin)\n    children();\n}        \n                     \n\n\nmodule _driver(spec)\n{\n  drive = struct_val(spec,\"drive\");\n  if (is_def(drive) && drive!=\"none\") {\n    head = struct_val(spec,\"head\");\n    diameter = _nominal_diam(spec);\n    drive_size = struct_val(spec,\"drive_size\");\n    drive_diameter = struct_val(spec, \"drive_diameter\");\n    drive_depth = first_defined([struct_val(spec, \"drive_depth\"), .7*diameter]); // Note hack for unspecified depth\n    head_top = starts_with(head,\"flat\") || head==\"none\" ? 0 :\n               struct_val(spec,\"head_height\");\n    up(head_top-drive_depth){\n      // recess should be positioned with its bottom center at (0,0) and the correct recess depth given above\n      if (drive==\"phillips\") phillips_mask(drive_size,anchor=BOTTOM);\n      if (drive==\"torx\") torx_mask(size=drive_size, l=drive_depth+1, center=false);\n      if (drive==\"hex\") hex_drive_mask(drive_size,drive_depth+1,anchor=BOT);\n      if (drive==\"slot\") {\n          head_width = first_defined([u_add(struct_val(spec, \"head_size\"),struct_val(spec,\"head_oversize\",0)), diameter]);\n          cuboid([2*head_width, drive_size, drive_depth+1],anchor=BOTTOM);\n      }\n    }\n  }\n}\n\n\nfunction _ISO_thread_tolerance(diameter, pitch, internal=false, tolerance=undef) =\n  let(\n    P = pitch,\n    H = P*sqrt(3)/2,\n    tolerance = first_defined([tolerance, internal?\"6H\":\"6g\"]),\n\n    pdiam = diameter - 2*3/8*H,          // nominal pitch diameter\n    mindiam = diameter - 2*5/8*H,        // nominal minimum diameter\n\n    EI = [   // Fundamental deviations for nut thread\n          [\"G\", 15+11*P],\n          [\"H\", 0],            // Standard practice\n         ],\n\n    es = [    // Fundamental deviations for bolt thread\n          [\"e\", -(50+11*P)],   // Exceptions if P<=0.45mm\n          [\"f\", -(30+11*P)],\n          [\"g\", -(15+11*P)],   // Standard practice\n          [\"h\", 0]             // Standard practice for tight fit\n         ],\n\n    T_d6 = 180*pow(P,2/3)-3.15/sqrt(P),\n    T_d = [  // Crest diameter tolerance for major diameter of bolt thread\n           [4, 0.63*T_d6],\n           [6, T_d6],\n           [8, 1.6*T_d6]\n          ],\n\n    T_D1_6 = 0.2 <= P && P <= 0.8 ? 433*P - 190*pow(P,1.22) :\n             P > .8 ? 230 * pow(P,0.7) : undef,\n    T_D1 = [ // Crest diameter tolerance for minor diameter of nut thread\n             [4, 0.63*T_D1_6],\n             [5, 0.8*T_D1_6],\n             [6, T_D1_6],\n             [7, 1.25*T_D1_6],\n             [8, 1.6*T_D1_6]\n           ],\n\n    rangepts = [0.99, 1.4, 2.8, 5.6, 11.2, 22.4, 45, 90, 180, 300],\n    d_ind = floor(lookup(diameter,hstack(rangepts,count(len(rangepts))))),\n    avgd = sqrt(rangepts[d_ind]* rangepts[d_ind+1]),\n\n    T_d2_6 = 90*pow(P, 0.4)*pow(avgd,0.1),\n    T_d2 = [ // Pitch diameter tolerance for bolt thread\n             [3, 0.5*T_d2_6],\n             [4, 0.63*T_d2_6],\n             [5, 0.8*T_d2_6],\n             [6, T_d2_6],\n             [7, 1.25*T_d2_6],\n             [8, 1.6*T_d2_6],\n             [9, 2*T_d2_6],\n           ],\n\n    T_D2 = [  // Tolerance for pitch diameter of nut thread\n              [4, 0.85*T_d2_6],\n              [5, 1.06*T_d2_6],\n              [6, 1.32*T_d2_6],\n              [7, 1.7*T_d2_6],\n              [8, 2.12*T_d2_6]\n           ],\n\n    internal = is_def(internal) ? internal : tolerance[1] != downcase(tolerance[1]),\n    internalok = !internal || (\n                               len(tolerance)==2 && str_find(\"GH\",tolerance[1])!=undef && str_find(\"45678\",tolerance[0])!=undef),\n    tol_str = str(tolerance,tolerance),\n    externalok = internal || (\n                              (len(tolerance)==2 || len(tolerance)==4)\n                                                          && str_find(\"efgh\", tol_str[1])!=undef\n                                                          && str_find(\"efgh\", tol_str[3])!=undef\n                                                          && str_find(\"3456789\", tol_str[0]) != undef\n                                                          && str_find(\"468\", tol_str[2]) !=undef)\n  )\n  assert(internalok,str(\"Invalid internal thread tolerance, \",tolerance,\".  Must have form <digit><letter>\"))\n  assert(externalok,str(\"invalid external thread tolerance, \",tolerance,\".  Must have form <digit><letter> or <digit><letter><digit><letter>\"))\n  let(\n    tol_num_pitch = parse_num(tol_str[0]),\n    tol_num_crest = parse_num(tol_str[2]),\n    tol_letter = tol_str[1]\n  )\n  assert(tol_letter==tol_str[3],str(\"Invalid tolerance, \",tolerance,\".  Cannot mix different letters\"))\n  internal ?\n    let(  // Nut case\n      fdev = struct_val(EI,tol_letter)/1000,\n      Tdval = struct_val(T_D1, tol_num_crest)/1000,\n      Td2val = struct_val(T_D2, tol_num_pitch)/1000,\n      bot=[diameter+fdev, diameter+fdev+Td2val+H/6],\n      xdiam = [mindiam+fdev,mindiam+fdev+Tdval],\n      pitchdiam = [pdiam + fdev, pdiam+fdev+Td2val]\n    )\n    [[\"pitch\",P],[\"d_minor\",xdiam], [\"d_pitch\",pitchdiam], [\"d_major\",bot],[\"basic\",[mindiam,pdiam,diameter]]]\n  :\n    let( // Bolt case\n      fdev = struct_val(es,tol_letter)/1000,\n      Tdval = struct_val(T_d, tol_num_crest)/1000,\n      Td2val = struct_val(T_d2, tol_num_pitch)/1000,\n      mintrunc = P/8,\n      d1 = diameter-5*H/4,\n      maxtrunc = H/4 - mintrunc * (1-cos(60-acos(1-Td2val/4/mintrunc)))+Td2val/2,\n      bot = [diameter-2*H+2*mintrunc+fdev, diameter-2*H+2*maxtrunc+fdev],\n      xdiam = [diameter+fdev,diameter+fdev-Tdval],\n      pitchdiam = [pdiam + fdev, pdiam+fdev-Td2val]\n    )\n    [[\"pitch\",P],[\"d_major\",xdiam], [\"d_pitch\",pitchdiam], [\"d_minor\",bot],[\"basic\",[mindiam,pdiam,diameter]]];\n\nfunction _UTS_thread_tolerance(diam, pitch, internal=false, tolerance=undef) =\n  let(\n    d = diam/INCH,   // diameter in inches\n    P = pitch/INCH,  // pitch in inches\n    H = P*sqrt(3)/2,\n    tolerance = first_defined([tolerance, internal?\"2B\":\"2A\"]),\n    tolOK = in_list(tolerance, [\"1A\",\"1B\",\"2A\",\"2B\",\"3A\",\"3B\"]),\n    internal = tolerance[1]==\"B\"\n  )\n  assert(tolOK,str(\"Tolerance was \",tolerance,\". Must be one of 1A, 2A, 3A, 1B, 2B, 3B\"))\n  let(\n    LE = 9*P,   // length of engagement.  Is this right?\n    pitchtol_2A = 0.0015*pow(d,1/3) + 0.0015*sqrt(LE) + 0.015*pow(P,2/3),\n    pitchtol_table = [\n                 [\"1A\", 1.500*pitchtol_2A],\n                 [\"2A\",       pitchtol_2A],\n                 [\"3A\", 0.750*pitchtol_2A],\n                 [\"1B\", 1.950*pitchtol_2A],\n                 [\"2B\", 1.300*pitchtol_2A],\n                 [\"3B\", 0.975*pitchtol_2A]\n               ],\n     pitchtol = struct_val(pitchtol_table, tolerance),\n     allowance = tolerance==\"1A\" || tolerance==\"2A\" ? 0.3 * pitchtol_2A : 0,\n     majortol = tolerance == \"1A\" ? 0.090*pow(P,2/3) :\n                tolerance == \"2A\" || tolerance == \"3A\" ? 0.060*pow(P,2/3) :\n                pitchtol+pitch/4/sqrt(3),    // Internal case\n     minortol = tolerance==\"1B\" || tolerance==\"2B\" ?\n                    (\n                      d < 0.25 ? constrain(0.05*pow(P,2/3)+0.03*P/d - 0.002, 0.25*P-0.4*P*P, 0.394*P)\n                               : (P > 0.25 ? 0.15*P : 0.25*P-0.4*P*P)\n                    ) :\n                tolerance==\"3B\" ? constrain(0.05*pow(P,2/3)+0.03*P/d - 0.002, P<1/13 ? 0.12*P : 0.23*P-1.5*P*P, 0.394*P)\n                     :0, // not used for external threads\n     basic_minordiam = d - 5/4*H,\n     basic_pitchdiam = d - 3/4*H,\n     majordiam = internal ? [d,d] :          // A little confused here, paragraph 8.3.2\n                          [d-allowance-majortol, d-allowance],\n     pitchdiam = internal ? [basic_pitchdiam, basic_pitchdiam + pitchtol]\n                          : [majordiam[1] - 3/4*H-pitchtol, majordiam[1]-3/4*H],\n     minordiam = internal ? [basic_minordiam, basic_minordiam + minortol]\n                          : [pitchdiam[0] - 3/4*H, basic_minordiam - allowance - H/8]   // the -H/8 is for the UNR case, 0 for UN case\n    )\n    [[\"pitch\",P*INCH],[\"d_major\",majordiam*INCH], [\"d_pitch\", pitchdiam*INCH], [\"d_minor\",minordiam*INCH],\n     [\"basic\", INCH*[basic_minordiam, basic_pitchdiam, d]]];\n\nfunction _exact_thread_tolerance(d,P) =\n   let(\n       H = P*sqrt(3)/2,\n       basic_minordiam = d - 5/4*H,\n       basic_pitchdiam = d - 3/4*H\n      )\n    [[\"pitch\", P], [\"d_major\", [d,d]], [\"d_pitch\", [basic_pitchdiam,basic_pitchdiam]], [\"d_minor\", [basic_minordiam,basic_minordiam]],\n     [\"basic\", [basic_minordiam, basic_pitchdiam, d]]];\n\n\n// Takes a screw name as input and returns a list of the form\n// [system, diameter, thread, length]\n// where system is either \"english\" or \"metric\".  \n\nfunction _parse_screw_name(name) =\n    let( commasplit = str_split(name,\",\"),\n         length = parse_num(commasplit[1]),\n         xdash = str_split(commasplit[0], \"-x\"),\n         type = xdash[0],\n         thread = parse_float(xdash[1])\n    )\n    assert(len(commasplit)<=2, str(\"More than one comma found in screw name, \\\"\",name,\"\\\"\"))\n    assert(len(xdash)<=2, str(\"Screw name has too many '-' or 'x' characters, \\\"\",name,\"\\\"\"))\n    assert(len(commasplit)==1 || is_num(length), str(\"Invalid length \\\"\", commasplit[1],\"\\\" in screw name, \\\"\",name,\"\\\"\"))\n    assert(len(xdash)==1 || all_nonnegative(thread),str(\"Thread pitch not a valid number in screw name, \\\"\",name,\"\\\"\"))\n    type[0] == \"M\" || type[0] == \"m\" ? \n        let(diam = parse_float(substr(type,1)))\n        assert(is_num(diam), str(\"Screw size must be a number in screw name, \\\"\",name,\"\\\"\"))\n        [\"metric\", parse_float(substr(type,1)), thread, length] \n    :\n    let(\n        diam = type[0] == \"#\" ? type :\n               suffix(type,2)==\"''\" ? parse_float(substr(type,0,len(type)-2)) :\n               let(val=parse_num(type))\n               assert(all_positive(val), str(\"Screw size must be a number in screw name, \\\"\",name,\"\\\"\"))\n               val == floor(val) && val>=0 && val<=12 ? str(\"#\",type) : val\n    )\n    assert(is_str(diam) || is_num(diam), str(\"Invalid screw diameter in screw name, \\\"\",name,\"\\\"\"))\n    [\"english\", diam, thread, u_mul(25.4,length)];\n\n\n// drive can be \"hex\", \"phillips\", \"slot\", \"torx\", or \"none\"\n// or you can specify \"ph0\" up to \"ph4\" for phillips and \"t20\" for torx 20\nfunction _parse_drive(drive=undef, drive_size=undef) =\n    is_undef(drive) ? [\"none\",undef] \n  : assert(is_string(drive))\n    let(drive = downcase(drive))\n    in_list(drive,[\"hex\",\"phillips\", \"slot\", \"torx\", \"phillips\", \"none\"]) ? [drive, drive_size] \n  : drive[0]==\"t\" ? let(size = parse_int(substr(drive,1))) [\"torx\",size,torx_depth(size) ] \n  : starts_with(drive,\"ph\") && search(drive[2], \"01234\")!=[] ? [\"phillips\", ord(drive[2])-ord(\"0\")] \n  : assert(false,str(\"Unknown screw drive type \",drive));\n\n\n// Module: screw_head()\n// Synopsis: Creates a screw head.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: screw(), screw_hole()\n// Usage:\n//    screw_head(screw_info, [details],[counterbore],[flat_height],[teardrop],[internal])\n// Description:\n//    Draws the screw head described by the data structure `screw_info`, which\n//    should have the fields produced by {{screw_info()}}.  See that function for\n//    details on the fields.  Standard orientation is with the head centered at (0,0)\n//    and oriented in the +z direction.  Flat heads appear below the xy plane.\n//    Other heads appear sitting on the xy plane.  \n// Arguments:\n//    screw_info = structure produced by {{screw_info()}}\n//    ---\n//    details = true for more detailed model.  Default: false\n//    counterbore = counterbore height.  Default: no counterbore\n//    flat_height = height of flat head\n//    teardrop = if true make flathead and counterbores teardrop shaped with the flat 5% away from the edge of the screw.  If numeric, specify the fraction of extra to add.  Set to \"max\" for a pointed teardrop.  Default: false\n//    slop = enlarge diameter by this extra amount (beyond that specified in the screw specification).  Default: 0\nfunction screw_head(screw_info,details=false, counterbore=0,flat_height,teardrop=false,slop=0) = no_function(\"screw_head\");\nmodule screw_head(screw_info,details=false, counterbore=0,flat_height,teardrop=false,slop=0) {\n   no_children($children);\n   head_oversize = struct_val(screw_info, \"head_oversize\",0) + slop;\n   head = struct_val(screw_info, \"head\");\n   head_size = struct_val(screw_info, \"head_size\",0) + head_oversize;\n   head_height = struct_val(screw_info, \"head_height\");\n   dum0=assert(is_def(head_height) || in_list(head,[\"flat\",\"none\"]), \"Undefined head height only allowed with flat head or headless screws\")\n        assert(is_bool(teardrop) || teardrop==\"max\" || all_nonnegative([teardrop]),\"Teardrop parameter invalid\");\n   teardrop = teardrop==true ? .05 : teardrop;\n   heightok = (is_undef(head_height) && in_list(head,[\"flat\",\"none\"])) || all_positive(head_height);\n   dum1=assert(heightok, \"Head hight must be a postive number\");\n   dum2=assert(counterbore==0 || counterbore==false || head!=\"none\", \"Cannot counterbore a headless screw\");\n   counterbore_temp = counterbore==false? 0 \n                    : head!=\"flat\" && counterbore==true ? head_height \n                    : counterbore;\n   dum3=assert(is_finite(counterbore_temp) && counterbore_temp>=0, str(counterbore==true? \"Must specify numerical counterbore height with flat head screw\"\n                                                             : \"Counterbore must be a nonnegative number\"));\n\n   counterbore = counterbore_temp==0 && head!=\"flat\" ? counterbore_temp : counterbore_temp + 0.01;\n   adj_diam = struct_val(screw_info, \"diameter\") + head_oversize;   // Used for determining chamfers and ribbing\n   attachable(){\n     union(){\n         if (head!=\"flat\" && counterbore>0){\n           d = head==\"hex\"? 2*head_size/sqrt(3) : head_size;\n           if (teardrop!=false)\n             teardrop(d=d, l=counterbore, cap_h=is_num(teardrop) ? d/2*(1+teardrop):undef, orient=BACK, anchor=BACK);\n           else                    \n             cyl(d=d, l=counterbore, anchor=BOTTOM);\n         }  \n         if (head==\"flat\") {   // For flat head, counterbore is integrated\n           angle = struct_val(screw_info, \"head_angle\")/2;\n           sharpsize = struct_val(screw_info, \"head_size_sharp\")+head_oversize;\n           sidewall_height = (sharpsize - head_size)/2 / tan(angle);\n           cylheight = counterbore + sidewall_height;\n           slopeheight = flat_height - sidewall_height;\n           r1 = head_size/2;\n           r2 = r1 - tan(angle)*slopeheight;\n           n = segs(r1);\n           prof1 = teardrop!=false ? teardrop2d(r=r1,cap_h=is_num(teardrop)?r1*(1+teardrop):undef,$fn=n) : circle(r=r1, $fn=n);\n           prof2 = teardrop!=false ? teardrop2d(r=r2,cap_h=is_num(teardrop)?r2*(1+teardrop):undef,$fn=n) : circle(r=r2, $fn=n);\n           skin([prof2,prof1,prof1], z=[-flat_height, -flat_height+slopeheight, counterbore],slices=0);\n         }\n         if (head!=\"flat\" && counterbore==0) {\n           if (in_list(head,[\"round\",\"pan round\",\"button\",\"fillister\",\"cheese\"])) {\n             base = head==\"fillister\" ? 0.75*head_height :\n                    head==\"pan round\" ? .6 * head_height :\n                    head==\"cheese\" ? .7 * head_height :\n                    0.1 * head_height;   // round and button\n             head_size2 = head==\"cheese\" ?  head_size-2*tan(5)*head_height : head_size; // 5 deg slope on cheese head\n             segs = segs(head_size);\n             cyl(l=base, d1=head_size, d2=head_size2,anchor=BOTTOM, $fn=segs)\n               attach(TOP)\n                 zrot(180) // Needed to align facets when $fn is odd\n                 rotate_extrude($fn=segs)  // ensure same number of segments for cap as for head body\n                   intersection(){\n                     arc(points=[[-head_size2/2,0], [0,-base+head_height * (head==\"button\"?4/3:1)], [head_size2/2,0]]);\n                     square([head_size2, head_height-base]);\n                   }\n           }\n           if (head==\"pan flat\")\n             cyl(l=head_height, d=head_size, rounding2=0.2*head_size, anchor=BOTTOM);\n           if (head==\"socket\")\n             cyl(l=head_height, d=head_size, anchor=BOTTOM, chamfer2=details? adj_diam/10:undef);\n           if (head==\"socket ribbed\"){\n             // These numbers are based on ISO specifications that dictate how much oversizsed a ribbed socket head can be\n             // We are making our ribbed heads the same size as unribbed (by cutting the ribbing away), but these numbers are presumably a good guide\n             rib_size = [[2, .09],\n                         [3, .09],\n                         [6, .11],\n                         [12, .135],\n                         [20, .165]];\n             intersection() {\n               cyl(h=head_height/4, d=head_size, anchor=BOT)\n                  attach(TOP) cyl(l=head_height*3/4, d=head_size, anchor=BOT, texture=\"trunc_ribs\", tex_reps=[31,1],\n                                  tex_inset=true, tex_depth=-lookup(adj_diam,rib_size));\n               cyl(h=head_height,d=head_size, chamfer2=adj_diam/10, anchor=BOT);\n             }\n           }\n           if (head==\"hex\")\n             up(head_height/2)_nutshape(head_size,head_height,\"hex\",false,true);\n         }\n     }    \n     union(){};\n   }\n}\n\n\n// Section: Nuts and nut traps\n\n\n// Module: nut()\n// Synopsis: Creates a standard nut.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: screw(), screw_hole()\n// Usage:\n//   nut([spec], [shape], [thickness], [nutwidth], [thread=], [tolerance=], [hole_oversize=], [bevel=], [$slop=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n// Description:\n//   Generates a hexagonal or square nut.  See [screw and nut parameters](#section-screw-and-nut-parameters) for details on the parameters that define a nut.\n//   As with screws, you can give the specification in `spec` and then omit the name.  The diameter is the flat-to-flat\n//   size of the nut produced.  The thickness can be \"thin\", \"normal\" or \"thick\" to choose standard nut dimensions.  For metric\n//   nuts you can also use thickness values of \"DIN\" or \"undersized\".  The nut's shape is hexagonal by default; set shape to \"square\" for\n//   a square nut.\n//   .\n//   By default all nuts have the internal holes beveled and hex nuts have their corners beveled.  Square nuts get no outside bevel by default.\n//   ASME specifies that small square nuts should not be beveled, and many square nuts are beveled only on one side.   The bevel angle, specified with bevang,\n//   gives the angle for the bevel.  The default of 15 is shallow and may not be printable.  Internal hole are beveled at 45 deg by the depth of one thread.  \n//   .\n//   The tolerance determines the actual thread sizing based on the nominal size in accordance with standards.  \n//   The $slop parameter determines extra gaps left to account for printing overextrusion.  It defaults to 0.\n// Arguments:\n//   spec = nut specification, e.g. \"M5x1\" or \"#8-32\".  See [screw naming](#subsection-screw-naming).  This can also be a nut or screw specification structure of the form produced by {{nut_info()}} or {{screw_info()}}.  \n//   shape = \"hex\" or \"square\" to specify nut shape.  Default: \"hex\"\n//   thickness = \"thin\", \"normal\", \"thick\", or a thickness in mm.  See [nuts](#subsection-nuts).  Default: \"normal\"\n//   ---\n//   nutwidth = width of nut (overrides table values)\n//   thread = thread type or specification. See [screw pitch](#subsection-standard-screw-pitch). Default: \"coarse\"\n//   hole_oversize = amount to increase hole diameter.  Default: 0\n//   bevel = if true, bevel the outside of the nut.  Default: true for hex nuts, false for square nuts\n//   bevel1 = if true, bevel the outside of the nut bottom.\n//   bevel2 = if true, bevel the outside of the nut top. \n//   bevang = set the angle for the outside nut bevel.  Default: 15\n//   ibevel = if true, bevel the inside (the hole).   Default: true\n//   ibevel1 = if true bevel the inside, bottom end.\n//   ibevel2 = if true bevel the inside, top end.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   tolerance = nut tolerance.  Determines actual nut thread geometry based on nominal sizing.  See [tolerance](#subsection-tolerance). Default is \"2B\" for UTS and \"6H\" for ISO.\n//   $slop = extra space left to account for printing over-extrusion.  Default: 0\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   `$screw_spec` is set to the spec specification structure. \n// Example: All the UTS nuts at one size.  Note that square nuts come in only one thickness.  \n//   xdistribute(spacing=0.75*INCH){\n//       nut(\"3/8\",thickness=\"thin\");\n//       nut(\"3/8\",thickness=\"normal\");\n//       nut(\"3/8\",thickness=\"thick\");\n//       nut(\"3/8\",shape=\"square\");\n//   }\n// Example: All the ISO (and DIN) nuts at one size.  Note that M10 is one of the four cases where the DIN nut width is larger.  \n//   ydistribute(spacing=30){\n//      xdistribute(spacing=22){\n//         nut(\"M10\", thickness=\"thin\");\n//         nut(\"M10\",thickness=\"undersized\");\n//         nut(\"M10\",thickness=\"normal\");\n//         nut(\"M10\",thickness=\"thick\");\n//      }\n//      xdistribute(spacing=25){\n//         nut(\"M10\", shape=\"square\", thickness=\"thin\");\n//         nut(\"M10\", shape=\"square\", thickness=\"normal\");      \n//      }\n//   }\n// Example: The three different UTS nut tolerances (thickner than normal nuts)\n//   module mark(number)\n//   {\n//     difference(){\n//        children();\n//        ycopies(n=number, spacing=1.5)right(.25*INCH-2)up(8-.35)cyl(d=1, h=1);\n//     }\n//   }\n//   $fn=64;\n//   xdistribute(spacing=17){\n//     mark(1) nut(\"1/4-20\", thickness=8, nutwidth=0.5*INCH,tolerance=\"1B\");\n//     mark(2) nut(\"1/4-20\", thickness=8, nutwidth=0.5*INCH,tolerance=\"2B\");\n//     mark(3) nut(\"1/4-20\", thickness=8, nutwidth=0.5*INCH,tolerance=\"3B\");\n//   }\n// Example: Threadless nut\n//   nut(\"#8\", thread=\"none\");\n\nfunction nut(spec, shape, thickness, nutwidth, thread, tolerance, hole_oversize, \n           bevel,bevel1,bevel2,bevang=15,ibevel,ibevel1,ibevel2,blunt_start, blunt_start1, blunt_start2, anchor=BOTTOM, spin=0, orient=UP, oversize=0)\n           = no_function(\"nut\");\nmodule nut(spec, shape, thickness, nutwidth, thread, tolerance, hole_oversize, \n           bevel,bevel1,bevel2,bevang=15,ibevel,ibevel1,ibevel2,blunt_start, blunt_start1, blunt_start2, anchor=BOTTOM, spin=0, orient=UP, oversize=0)\n{\n   dummyA = assert(is_undef(nutwidth) || (is_num(nutwidth) && nutwidth>0));\n   \n   tempspec = _get_spec(spec, \"nut_info\", \"nut\", \n                        thread=thread, shape=shape, thickness=thickness);\n   spec=_struct_reset(tempspec,[\n                                [\"width\", nutwidth],\n                                [\"shaft_oversize\", hole_oversize],\n                               ]);\n   dummy=_validate_nut_spec(spec);\n   $screw_spec = spec;\n   shape = struct_val(spec, \"shape\");\n   pitch =  struct_val(spec, \"pitch\") ;\n   threadspec = pitch==0 ? undef : thread_specification(spec, internal=true, tolerance=tolerance);\n   nutwidth = struct_val(spec, \"width\");\n   thickness = struct_val(spec, \"thickness\");\n   threaded_nut(\n        nutwidth=nutwidth,\n        id=pitch==0 ? _nominal_diam(spec)\n          : [mean(struct_val(threadspec, \"d_minor\")),\n             mean(struct_val(threadspec, \"d_pitch\")),\n             mean(struct_val(threadspec, \"d_major\"))],\n        pitch = pitch, \n        h=thickness,\n        shape=shape, \n        bevel=bevel,bevel1=bevel1,bevel2=bevel2,bevang=bevang,\n        ibevel=ibevel,ibevel1=ibevel1,ibevel2=ibevel2,\n        blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,         \n        anchor=anchor,spin=spin,orient=orient) children();\n}\n\n\n\n\n\n\n// Module: nut_trap_side()\n// Synopsis: Creates a side nut trap mask.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: screw(), screw_hole()\n// Usage:\n//   nut_trap_side(trap_width, [spec], [shape], [thickness], [nutwidth=], [poke_len=], [poke_diam=], [$slop=], [anchor=], [orient=], [spin=]) [ATTACHMENTS];\n// Description:\n//   Create a nut trap that extends sideways, so the nut slides in perpendicular to the screw axis.\n//   The CENTER anchor is the center of the screw hole location in the trap.  The trap width is\n//   measured from the screw hole center point.  You can optionally create a poke hole to use for\n//   removing the nut by specifying a poke_len value that determines the length of the poke hole, measured\n//   from the screw center.  The diameter of the poke hole defaults to the thickness of the nut.  The nut dimensions\n//   will be increased by `2*$slop` to allow adjusting the fit of the trap for your printer.  \n//   The trap will have a default tag of \"remove\" if no other tag is in force.  \n// Arguments:\n//   trap_width = width of nut trap, measured from screw center, must be larger than half the nut width  (If spec is omitted this argument must be given by name.)\n//   spec = nut specification, e.g. \"M5\" or \"#8\".  See [screw naming](#subsection-screw-naming).  This can also be a screw or nut specification structure of the form produced by {{nut_info()}} or {{screw_info()}}.  \n//   shape = \"hex\" or \"square\" to specify the shape of the nut.   Default: \"hex\"\n//   thickness = \"thin\", \"normal\", or \"thick\".  \"DIN\" or \"undersized\" for metric nuts.  See [nuts](#subsection-nuts). Default: \"normal\"\n//   ---\n//   nutwidth = width of the nut.  Default: determined from tables\n//   poke_len = length of poke hole.  Default: no poke hole\n//   poke_diam = diameter of poke hole.  Default: nut thickness\n//   $slop = extra space left to account for printing over-extrusion.  Default: 0\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `BOTTOM`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   `$screw_spec` is set to the spec specification structure. \n// Example: Basic trap.  Note that screw center is at the origin and the width is measured from the origin.  \n//   nut_trap_side(10, \"#8\");\n// Example: Trap with poke hole for removing nut.  The poke hole length is also measured from the screw center at the origin\n//   $fn=16;\n//   nut_trap_side(10, \"#8\", poke_len=10);\n// Example: Trap for square nut\n//   $fn=16;\n//   nut_trap_side(10, \"#8\", shape=\"square\", poke_len=10);\n// Example: Trap with looser fit\n//   nut_trap_side(10, \"#8\", $slop=0.1);\n// Example: Trap placed at the bottom of a screw hole\n//   $fn=24;\n//   screw_hole(\"#8,1\") \n//     position(BOT) nut_trap_side(10,poke_len=8);\n// Example: Trap placed at the bottom of a screw hole 2mm extra screw hole below the trap\n//   $fn=24;\n//   screw_hole(\"#8,1\") \n//     up(2) position(BOT) nut_trap_side(trap_width=10,poke_len=8);\n// Example: Hole-trap assembly removed from an object\n//   $fn=24;\n//   back_half()\n//   diff()\n//   cuboid(30)\n//      position(TOP)screw_hole(\"#8,1\",anchor=TOP) \n//        position(BOT) nut_trap_side(trap_width=16);\n// Example: Hole-trap assembly where we position the trap relative to a feature on the model and then position the screw hole through the trap as a child to the trap.  \n//  diff()\n//   cuboid([30,30,20])\n//     position(RIGHT)cuboid([4,20,3],anchor=LEFT)\n//       right(1)position(TOP+LEFT)nut_trap_side(15, \"#8\",anchor=BOT+RIGHT)\n//         screw_hole(length=20,anchor=BOT);\nmodule nut_trap_side(trap_width, spec, shape, thickness, nutwidth, anchor=BOT, orient, spin, poke_len=0, poke_diam) {\n  dummy9=assert(is_num(trap_width), \"trap_width is missing or the wrong type\");\n  tempspec = _get_spec(spec, \"nut_info\", \"nut_trap\", shape=shape, thickness=thickness);\n  nutdata = _struct_reset(tempspec, [[\"width\", nutwidth]]);\n  $screw_spec = is_def(spec) ? nutdata : $screw_spec;\n  dummy8 = _validate_nut_spec(nutdata);\n  nutwidth = struct_val(nutdata,\"width\")+2*get_slop();\n  dummy = assert(is_num(poke_len) && poke_len>=0, \"poke_len must be a nonnegative number\")\n          assert(is_undef(poke_diam) || (is_num(poke_diam) && poke_diam>0), \"poke_diam must be a positive number\")\n          assert(is_num(trap_width) && trap_width>=nutwidth/2, str(\"trap_width is smaller than nut width: \",nutwidth));\n  nutthickness = struct_val(nutdata, \"thickness\")+2*get_slop();\n  cubesize = [trap_width, nutwidth,nutthickness];\n  halfwidth = shape==\"square\" ? nutwidth/2 : nutwidth/sqrt(3);\n  shift = cubesize[0]/2 - halfwidth/2;\n  default_tag(\"remove\")\n    attachable(size=cubesize+[halfwidth,0,0], offset=[shift,0,0],anchor=anchor,orient=orient,spin=spin)\n    {\n       union(){\n         if (shape==\"square\") left(nutwidth/2) cuboid(cubesize+[halfwidth,0,0],anchor=LEFT);\n         else {\n            cuboid(cubesize,anchor=LEFT);\n            linear_extrude(height=nutthickness,center=true)hexagon(id=nutwidth);\n         }\n         if (poke_len>0)\n           xcyl(l=poke_len, d=default(poke_diam, nutthickness), anchor=RIGHT);\n       }\n       children();\n    }     \n}\n\n// Module: nut_trap_inline()\n// Synopsis: Creates an inline nut trap mask.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: screw(), screw_hole()\n// Usage:\n//   nut_trap_inline(length|l|heigth|h, [spec], [shape], [$slop=], [anchor=], [orient=], [spin=]) [ATTACHMENTS];\n// Description:\n//   Create a nut trap that extends along the axis of the screw.  The nut width\n//   will be increased by `2*$slop` to allow adjusting the fit of the trap for your printer.\n//   If no tag is present the trap will be tagged with \"remove\".  Note that you can omit the specification\n//   and it will be inherited from a parent screw_hole to provide the screw size.  It's also possible to \n//   do this backwards, to declare a trap at a screw size and make a child screw hole, which will inherit\n//   the screw dimensions.  \n// Arguments:\n//   length/l/height/h = length/height of nut trap\n//   spec = nut specification, e.g. \"M5\" or \"#8\".  See [screw naming](#subsection-screw-naming).  This can also be a screw or nut specification structure of the form produced by {{nut_info()}} or {{screw_info()}}.  \n//   shape = \"hex\" or \"square to determine type of nut.  Default: \"hex\"\n//   ---\n//   $slop = extra space left to account for printing over-extrusion.  Default: 0\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `TOP`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Side Effects:\n//   `$screw_spec` is set to the spec specification structure. \n// Example: Basic trap\n//   nut_trap_inline(10, \"#8\");\n// Example: Basic trap with allowance for a looser fit\n//   nut_trap_inline(10, \"#8\", $slop=.1);\n// Example: Square trap (just a cube, but hopefully just the right size)\n//   nut_trap_inline(10, \"#8\", shape=\"square\");\n// Example: Attached to a screw hole\n//   screw_hole(\"#8,1\",head=\"socket\",counterbore=true, $fn=32) \n//     position(BOT) nut_trap_inline(10);\n// Example: Nut trap with child screw hole\n//   nut_trap_inline(10, \"#8\")\n//     position(TOP)screw_hole(length=10,anchor=BOT,head=\"flat\",$fn=32);\n// Example(Med,NoAxes): a pipe clamp\n//   $fa=5;$fs=0.5;\n//   bardiam = 32;\n//   bandwidth = 10;\n//   thickness = 3;\n//   back_half()\n//   diff()\n//     tube(id=bardiam, wall = thickness, h=bandwidth, orient=BACK)\n//       left(thickness/2) position(RIGHT) cube([bandwidth, bandwidth, 14], anchor = LEFT, orient=FWD)\n//       {\n//          screw_hole(\"#4\",length=12, head=\"socket\",counterbore=6,anchor=CENTER)\n//             position(BOT) nut_trap_inline(l=6,anchor=BOT);\n//          tag(\"remove\")right(1)position(RIGHT)cube([11+thickness, 11, 2], anchor = RIGHT);\n//       }\nmodule nut_trap_inline(length, spec, shape, l, height, h, nutwidth, anchor, orient, spin) {\n  tempspec = _get_spec(spec, \"nut_info\", \"nut_trap\", shape=shape, thickness=undef);\n  nutdata = _struct_reset(tempspec, [[\"width\", nutwidth]]);\n  $screw_spec = is_def(spec) ? nutdata : $screw_spec;\n  dummy = _validate_nut_spec(nutdata);\n  length = one_defined([l,length,h,height],\"l,length,h,height\");\n  assert(is_num(length) && length>0, \"length must be a positive number\");\n  nutwidth = struct_val(nutdata,\"width\")+2*get_slop();\n  default_tag(\"remove\"){\n    if (shape==\"square\")\n      cuboid([nutwidth,nutwidth,length], anchor=anchor, orient=orient, spin=spin) children();\n    else\n      linear_sweep(hexagon(id=nutwidth),height=length, anchor=anchor,orient=orient, spin=spin) children();\n  }\n}\n\n\n\n// Section: Screw and Nut Information\n\n\n// Function: screw_info()\n// Synopsis: Returns the dimensions and other info for the given screw.\n// Topics: Threading, Screws\n// See Also: screw(), screw_hole()\n// Usage:\n//   info = screw_info(name, [head], [drive], [thread=], [drive_size=], [oversize=], [head_oversize=])\n// Description:\n//   Look up screw characteristics for the specified screw type.\n//   See [screw and nut parameters](#section-screw-and-nut-parameters) for details on the parameters that define a screw.\n//   .\n//   The `oversize=` parameter adds the specified amount to the screw and head diameter to make an\n//   oversized screw.  Does not affect length, thread pitch or head height.\n//   .\n//   Note that flat head screws are defined by two different diameters, the theoretical maximum diameter, \"head_size_sharp\"\n//   and the actual diameter, \"head_size\".  The screw form is defined using the theoretical maximum, which gives\n//   sharp circular edge at the top of the screw.  Real screws have a flat chamfer around the edge.  \n// Figure(2D,Med,NoAxes,VPD=39,VPT=[0,-4,0],VPR=[0,0,0]):  Flat head screw geometry\n//   polysharp = [[0, -5.07407], [4.92593, -5.07407], [10, 0], [10, 0.01], [0, 0.01]];\n//   color(\"blue\"){\n//       xflip_copy()polygon(polysharp);\n//       back(1/2)stroke([[-10,0],[10,0]],endcaps=\"arrow2\",width=.15);    \n//       back(1.7)text(\"\\\"head_size_sharp\\\"\", size=.75,anchor=BACK);\n//   }\n//   poly= [[0, -5.07407], [4.92593, -5.07407], [9.02, -0.98], [9.02, 0.01], [0, 0.01]];\n//   xflip_copy()polygon(poly);\n//   rect([10,10],anchor=TOP);\n//   color(\"black\"){\n//     fwd(1/2)stroke([[-9.02,0],[9.02,0]],endcaps=\"arrow2\",width=.15);\n//     fwd(1)text(\"\\\"head_size\\\"\", size=.75,anchor=BACK);\n//   }  \n// Continues:\n//   The output is a [struct](structs.scad) with the following fields:\n//   . \n//   Field              | What it is\n//   ------------------ | ---------------\n//   \"type\"           | Always set to \"screw_info\"\n//   \"system\"         | Either `\"UTS\"` or `\"ISO\"` (used for correct tolerance computation).\n//   \"origin\"         | Module that generated the structure\n//   \"name\"           | Screw name used to make the structure\n//   \"diameter\"       | The nominal diameter of the screw shaft in mm.\n//   \"pitch\"          | The thread pitch in mm.  (0 for no threads)\n//   \"head\"           | The type of head (a string)\n//   \"head_size\"      | Size of the head (usually diameter) in mm.\n//   \"head_size_sharp\"| Theoretical head diameter for a flat head screw if it is made with sharp edges (or for countersinks)\n//   \"head_angle\"     | Countersink angle for flat heads.\n//   \"head_height\"    | Height of the head beyond the screw's nominal length.  The screw's total length is \"length\" + \"head_height\".  For flat heads \"head_height\" is zero, because they do not extend the screw.  \n//   \"drive\"          | The drive type (`\"phillips\"`, `\"torx\"`, `\"slot\"`, `\"hex\"`, `\"none\"`)\n//   \"drive_size\"     | The drive size, either a drive number (phillips, torx) or a dimension in mm (hex, slot).\n//   \"drive_depth\"    | Depth of the drive recess.\n//   \"length\"         | Length of the screw in mm measured in the customary fashion.  For flat head screws the total length and for other screws, the length from the bottom of the head to the screw tip.\n//   \"thread_len\"     | Length of threaded portion of screw in mm\n//   \"shaft_oversize\"| Amount to oversize the threads\n//   \"head_oversize\"   | Amount to oversize the head\n//   .\n//   If you want to define a custom drive for a screw you will need to provide the drive size and drive depth.  \n//\n// Arguments:\n//   name = screw specification, e.g. \"M5x1\" or \"#8-32\".  See [screw naming](#subsection-screw-naming).\n//   head = head type.  See [screw heads](#subsection-screw-heads)  Default: none\n//   drive = drive type.  See [screw heads](#subsection-screw-heads) Default: none\n//   ---\n//   thread = thread type or specification. See [screw pitch](#subsection-standard-screw-pitch). Default: \"coarse\"\n//   drive_size = size of drive recess to override computed value\n//   shaft_oversize = amount to increase screw diameter for clearance holes.  Default: 0\n//   head_oversize = amount to increase head diameter for countersink holes.  Default: 0 \n\nfunction screw_info(name, head, drive, thread, drive_size, shaft_oversize, head_oversize, _origin) =\n  assert(is_string(name), \"Screw specification must be a string\")\n  let(\n      thread = is_undef(thread) || thread==true ? \"coarse\"\n             : thread==false || thread==\"none\" ? 0\n             : thread,\n      head = default(head,\"none\"),\n      type=_parse_screw_name(name),\n      drive_info = _parse_drive(drive, drive_size),\n      drive=drive_info[0],\n      screwdata =   type[0] == \"english\" ? _screw_info_english(type[1],type[2], head, thread, drive) \n                  : type[0] == \"metric\" ? _screw_info_metric(type[1], type[2], head, thread, drive) \n                  : []\n    )\n    assert(is_def(struct_val(screwdata,\"head\")),str(\"Screw head \\\"\",head,\"\\\" unknown or unsupported for specified screw\"))\n    _struct_reset(screwdata,\n         [\n          [\"drive_depth\", drive_info[2]],\n          [\"length\", type[3]],\n          [\"drive_size\", drive_info[1]],\n          [\"name\", name],\n          [\"shaft_oversize\", shaft_oversize],\n          [\"head_oversize\", head_oversize],\n          [\"origin\",_origin]\n         ]);\n      \n\n// Function: nut_info()\n// Synopsis: Returns the dimensions and other info for the given nut.\n// Topics: Threading, Screws\n// See Also: screw(), screw_hole()\n// Usage:\n//   nut_spec = nut_info(name, [shape], [thickness=], [thread=], [width=], [hole_oversize=]);\n// Description:\n//   Produces a nut specification structure that describes a nut.  You can specify the width\n//   and thickness numerically, or you can let the width be calculated automatically from\n//   the thread specification.  The thickness can be \"normal\" (the default) or \"thin\" or \"thick\".\n//   Note that square nuts are only available in \"normal\" thickness, and \"thin\" and \"thick\" nuts\n//   are only available for 1/4 inch and above.  \n//   .\n//   The output is a [struct](structs.scad) with the following fields:\n//   . \n//   Field              | What it is\n//   ------------------ | ---------------\n//   \"type\"           | Always set to \"nut_info\"\n//   \"system\"         | Either `\"UTS\"` or `\"ISO\"` (used for correct tolerance computation).\n//   \"origin\"         | Module that created the structure\n//   \"name\"           | Name used to specify threading, such as \"M6\" or \"#8\"\n//   \"diameter\"       | The nominal diameter of the screw hole in mm.\n//   \"pitch\"          | The thread pitch in mm.  (0 for no threads)\n//   \"shape\"          | Shape of the nut, either \"hex\" or \"square\"\n//   \"width\"          | Flat to flat width of the nut\n//   \"thickness\"      | Thickness of the nut\n//   \"shaft_oversize\" | amount to oversize the threads (not including $slop)\n// Arguments:\n//   name = screw name, e.g. \"M5x1\" or \"#8-32\".  See [screw naming](#subsection-screw-naming).\n//   shape = shape of the nut, either \"hex\" or \"square\".  Default: \"hex\"\n//   ---\n//   thread = thread type or specification. See [screw pitch](#subsection-standard-screw-pitch). Default: \"coarse\"\n//   thickness = thickness of the nut (in mm) or one of \"thin\", \"normal\", or \"thick\".  Default: \"normal\"\n//   width = width of nut in mm.  Default: computed from thread specification\n//   hole_oversize = amount ot increase diameter of hole in nut.  Default: 0\n\nfunction nut_info(name, shape, thickness, thread, hole_oversize=0, width, _origin) =\n  assert(is_undef(thickness) || (is_num(thickness) && thickness>0) ||\n           in_list(_downcase_if_str(thickness),[\"thin\",\"normal\",\"thick\",\"undersized\",\"din\"]),\n          \"thickness must be a positive number of one of \\\"thin\\\", \\\"thick\\\", \\\"normal\\\", \\\"undersized\\\", or \\\"DIN\\\"\")\n  let(\n      shape = _downcase_if_str(default(shape,\"hex\")),\n      thickness = _downcase_if_str(default(thickness, \"normal\"))\n  )\n  assert(is_string(name), str(\"Nut nameification must be a string \",name))\n  assert(in_list(shape, [\"hex\",\"square\"]), \"Nut shape must be \\\"hex\\\" or \\\"square\\\"\")\n  assert(is_undef(width) || (is_num(width) && width>0), \"Specified width must be a positive number\")\n  let(\n      type = _parse_screw_name(name),\n      thread = is_undef(thread) || thread==true ? \"coarse\"\n             : thread==false || thread==\"none\" ? 0\n             : thread,\n      nutdata = type[0]==\"english\" ? _nut_info_english(type[1],type[2], thread, shape, thickness, width)\n              : type[0]==\"metric\" ?  _nut_info_metric(type[1],type[2], thread, shape, thickness, width)\n              : []\n  )\n  _struct_reset(nutdata, [[\"name\", name],\n                          [\"shaft_oversize\",hole_oversize],\n                          [\"width\", width],\n                          [\"origin\",_origin]\n                         ]);\n\n\n// Nut data is from ASME B18.2.2, mostly Table A-1\nfunction _nut_info_english(diam, threadcount, thread, shape, thickness, width) =\n  assert(!is_string(thickness) || in_list(thickness,[\"normal\",\"thin\",\"thick\"]),\n         \"You cannot use thickness \\\"DIN\\\" or \\\"undersized\\\" with English nuts\")\n  let(\n       screwspec=_screw_info_english(diam, threadcount, head=\"none\", thread=thread),\n       diameter = struct_val(screwspec,\"diameter\")/INCH,\n       //         thickness  width\n       normal = [\n            [\"#0\", [ 3/64 , 5/32  ]],\n            [\"#1\", [ 3/64 , 5/32  ]],\n            [\"#2\", [ 1/16 , 3/16  ]],\n            [\"#3\", [ 1/16 , 3/16  ]],\n            [\"#4\", [ 3/32 ,  1/4  ]],\n            [\"#5\", [ 7/64 , 5/16  ]],\n            [\"#6\", [ 7/64 , 5/16  ]],\n            [\"#8\", [  1/8 ,11/32  ]],\n            [\"#10\",[  1/8 ,  3/8  ]],\n            [\"#12\",[ 5/32 , 7/16  ]],\n            [1/4,  [ 7/32 , 7/16  ]],\n       ],\n       thin = [  // thickness\n            [1/4,  [ 5/32]],\n            [5/16, [ 3/16]],\n            [3/8,  [ 7/32]],\n            [7/16, [  1/4]],\n            [1/2,  [ 5/16]],\n            [9/16, [ 5/16]],\n            [5/8,  [  3/8]]\n       ],\n       thick = [\n            [1/4,  [9/32 ]],\n            [5/16, [21/64]],\n            [3/8,  [13/32]],\n            [7/16, [29/64]],\n            [1/2,  [9/16]],\n            [9/16, [39/64]],\n            [5/8,  [23/32]],\n            [3/4,  [13/16]],\n            [7/8,  [29/32]],\n            [1,    [1]],\n            [1+1/8,[1+5/32]],\n            [1+1/4,[1+1/4]],\n            [1+3/8,[1+3/8]],\n            [1+1/2,[1+1/2]]\n       ]\n  )\n  assert(is_num(thickness) || thickness==\"normal\" || diameter >=1/4,\n         str(\"No \", thickness, \" nut available at requested thread size\"))\n  assert(diameter <= 1.5, \"No thickness available for nut diameter over 1.5 inches\")\n  assert(shape==\"hex\" || thickness==\"normal\" || is_num(thickness),\"Square nuts only come in normal thickness\")\n  let(\n      table = thickness==\"normal\" ? normal\n            : thickness==\"thick\" ? thick\n            : thickness==\"thin\"  ? thin\n            : [],\n      entry = struct_val(table, diam),\n      thickness = is_num(thickness) ? thickness/INCH\n                : is_def(entry) ? entry[0]\n                : shape==\"square\" ? ( approx(diameter,1.125) ? 1\n                                                             : quantdn(7/8 * diameter,1/64))\n                : thickness==\"thin\" ? (diameter < 1+3/16 ? quantdn(0.5*diameter + 3/64,1/64)\n                                                         : 0.5*diameter + 3/32)\n                  // remaining case is \"normal\" thickness\n                : diameter < 11/16 ? quantdn(7/8*diameter,1/64)\n                : diameter < 1+3/16 ? 7/8*diameter - 1/64\n                : 7/8 * diameter - 1/32, \n      width = is_num(width) ? width/INCH\n            : is_def(entry[1]) ? entry[1]\n            : shape==\"square\" ? (diameter<5/8 ? quantup(1.5*diameter,1/16)+1/16 : 1.5*diameter)\n            : quantup(1.5*diameter,1/16)\n  )\n  [[\"type\",\"nut_info\"],\n   [\"system\", \"UTS\"],\n   [\"diameter\", struct_val(screwspec, \"diameter\")],\n   [\"pitch\", struct_val(screwspec,\"pitch\")],\n   [\"width\", width*INCH],\n   [\"thickness\", thickness*INCH],\n   [\"shape\", shape]];\n\n\nfunction _downcase_if_str(s) = is_string(s) ? downcase(s) : s;\n\nfunction _nut_info_metric(diam, pitch, thread, shape, thickness, width) =\n  let(\n       screwspec=_screw_info_metric(diam, pitch, head=\"none\", thread=thread),\n       diameter = struct_val(screwspec,\"diameter\"),\n\n       ISO_table =      //     - ASME B18.4.1M -    DIN 439\n          //                   --- ISO 4032 ----   ISO 4035   ISO 4033 \n          //                   normal     normal     thin       thick\n          // diam    width     midpt      max        (max)      (max)\n          // Preferred threads\n          [\n             [1.6,   [3.2 ,     1.2,       1.3,       1.0   ]],\n             [2,     [4   ,     1.5,       1.6,       1.2   ]],\n             [2.5,   [5   ,     1.875,     2,         1.6   ]],\n             [3,     [5.5 ,     2.25,      2.4,       1.8   ]],\n             [4,     [7   ,     3,         3.2,       2.2   ]],\n             [5,     [8   ,     4.5 ,      4.7,       2.7,      5.1]],\n             [6,     [10  ,     5,         5.2,       3.2,      5.7]],\n             [8,     [13  ,     6.675,     6.8,      undef,      7.5]],\n             [10,    [16  ,     8.25,      8.4,      undef,      9.3]],\n             [12,    [18  ,     10.5,     10.8,      undef,     12  ]],\n             [16,    [24  ,     14.5,     14.8,      undef,     16.4]],\n             [20,    [30  ,     17.5,     18,        undef,     20.3]],\n             [24,    [36  ,     21,       21.5,      undef,     23.9]],\n             [30,    [46  ,     25,       25.6,      undef,     28.6]],\n             [36,    [55  ,     30,       31,        undef,     34.7]],\n             [42,    [65  ,     33,       34,        undef      ]],\n             [48,    [75  ,     37,       38,        undef      ]],\n             [56,    [85  ,     44,       45,        undef      ]],\n             [64,    [95  ,     50,       51,        undef      ]],\n          // Non-preferred threads\n             [3.5,   [ 6,       2.675,     2.8,      2          ]],\n             [14,    [21,      12.5,      12.8,      undef,     14.1]],\n             [18,    [27,      15.5,      15.8,      undef,     17.6]],\n             [22,    [34,      19,        19.4,      undef,     21.8]],\n             [27,    [41,      23,        23.8,      undef,     26.7]],\n             [33,    [50,      28,        28.7,      undef,     32.5]],\n             [39,    [60,      33,        33.4,      undef      ]],\n             [45,    [70,      35,        36,        undef      ]],\n             [52,    [80,      41,        42,        undef      ]],\n             [60,    [90,      47,        48,        undef      ]]\n          ],\n       DIN_table =\n          [\n             //                  DIN 934   DIN 936  DIN 562     DIN 557\n             //diam      width   normal    thin    thin square   square\n             [   1,    [   2.5,    0.8,   undef]],\n             [   1.2,  [   3,      1  ,   undef]],\n             [   1.4,  [   3,      1.2,   undef]],\n             [   1.6,  [   3.2,    1.3,   undef,      1.0]],\n             [   2,    [   4,      1.6,   undef,      1.2]],\n             [   2.5,  [   5,      2  ,   undef,      1.6]],\n             [   3,    [   5.5,    2.4,   undef,      1.8]],\n             [   3.5,  [   6,      2.8,   undef,      2.0]],\n             [   4,    [   7,      3.2,     2.8,      2.2]],\n             [   5,    [   8,      4,       3.5,      2.7]],\n             [   6,    [  10,      5,       4  ,      3.2]],\n             [   7,    [  11,      5.5,     4  ]],\n             [   8,    [  13,      6.5,     5        ]],\n             [  10,    [  17,      8,       6        ]],     //\n             [  12,    [  19,     10,       7  ]],  //\n             [  14,    [  22,     11,       8  ]],  //\n             [  16,    [  24,     13,       8  ]],\n             [  18,    [  27,     15,       9  ]],\n             [  20,    [  30,     16,       9  ]],\n             [  22,    [  32,     18,      10  ]],  //\n             [  24,    [  36,     19,      10  ]],\n             [  27,    [  41,     22,      12  ]],\n             [  30,    [  46,     24,      12  ]],\n             [  33,    [  50,     26,      14  ]],\n             [  36,    [  55,     29,      14  ]],\n             [  39,    [  60,     31,      16  ]],\n             [  42,    [  65,     34,      16  ]],\n             [  45,    [  70,     36,      18  ]],\n             [  48,    [  75,     38,      18  ]],\n             [  52,    [  80,     42,      20  ]],\n             [  56,    [  85,     45]],\n             [  60,    [  90,     48]],\n             [  64,    [  95,     51]],\n             [  68,    [ 100,     54]],\n             [  72,    [ 105,     58]],\n             [  76,    [ 110,     61]],\n             [  80,    [ 115,     64]],\n             [  85,    [ 120,     68]],\n             [  90,    [ 130,     72]],\n             [ 100,    [ 145,     80]],\n             [ 110,    [ 155,     88]],\n             [ 125,    [ 180,    100]],\n             [ 140,    [ 200,    112]],\n             [ 160,    [ 230,    128]]\n          ],\n          useDIN = thickness==\"din\" || thickness==\"undersized\" || shape==\"square\", \n          entry = struct_val(useDIN ? DIN_table : ISO_table, diameter),\n          width = is_def(width) ? width\n                : entry[0],\n          thickind = useDIN && thickness==\"thin\" ? 3\n                   : useDIN ? 1 \n                   : thickness==\"normal\" ? 2\n                   : thickness==\"thin\" ? 3\n                   : thickness==\"thick\" ? 4\n                   : undef,\n          thickness = is_num(thickness) ? thickness\n                    : is_def(entry[thickind]) ? entry[thickind]\n                    : thickness==\"thin\" && diameter > 8 ? diam/2\n                    : undef\n  )\n  assert(is_def(thickness) && is_def(width), \"Unknown thickness, size and shape combination for nut\")\n  [[\"type\",\"nut_info\"],\n   [\"system\", \"ISO\"],\n   [\"diameter\", struct_val(screwspec, \"diameter\")],\n   [\"pitch\", struct_val(screwspec,\"pitch\")],\n   [\"width\", width],\n   [\"thickness\", thickness],\n   [\"shape\", shape]];\n          \n\nfunction _screw_info_english(diam, threadcount, head, thread, drive) =\n let(\n   diameter = is_string(diam) ? parse_int(substr(diam,1))*0.013 +0.06 \n                              : diam,\n   diamgroup = diameter<7/16 ? 0\n             : diameter==7/16 ? 1\n             : 2,\n   pitch =\n     is_num(thread) ? thread :\n     is_def(threadcount) ? INCH/threadcount :\n     let(\n        tind=struct_val([[\"coarse\",0],[\"unc\",0],\n                         [\"fine\",1],[\"unf\",1],\n                         [\"extra fine\",2],[\"extrafine\",2],[\"unef\",2]],\n                         downcase(thread)),\n        dummy = assert(is_def(tind), str(\"Unknown thread type, \\\"\",thread,\"\\\"\")),\n                 // coarse  fine  xfine\n                 // UNC     UNF   UNEF\n        UTS_thread = [\n            [\"#0\", [undef,    80, undef]],\n            [\"#1\", [   64,    72, undef]],\n            [\"#2\", [   56,    64, undef]],\n            [\"#3\", [   48,    56, undef]],\n            [\"#4\", [   40,    48, undef]],\n            [\"#5\", [   40,    44, undef]],\n            [\"#6\", [   32,    40, undef]],\n            [\"#8\", [   32,    36, undef]],\n            [\"#10\",[   24,    32, undef]],\n            [\"#12\",[   24,    28,    32]],\n            [1/4,  [   20,    28,    32]],\n            [5/16, [   18,    24,    32]],\n            [3/8,  [   16,    24,    32]],\n            [7/16, [   14,    20,    28]],\n            [1/2,  [   13,    20,    28]],\n            [9/16, [   12,    18,    24]],\n            [5/8,  [   11,    18,    24]],\n            [3/4,  [   10,    16,    20]],\n            [7/8,  [    9,    14,    20]],\n            [1,    [    8,    12,    20]],\n            [1.125,[    7,    12,    18]],\n            [1.25, [    7,    12,    18]],\n            [1.375,[    6,    12,    18]],\n            [1.5,  [    6,    12,    18]],\n            [1.75, [    5, undef, undef]],\n            [2,    [  4.5, undef, undef]],\n         ],\n       tentry = struct_val(UTS_thread, diam)\n     )\n     assert(is_def(tentry), str(\"Unknown screw size, \\\"\",diam,\"\\\"\"))\n     assert(is_def(tentry[tind]), str(\"No \",thread,\" pitch known for screw size, \\\"\",diam,\"\\\"\"))\n     INCH / tentry[tind],\n   head_data =\n       head==\"none\" ? let (\n          UTS_setscrew = [\n               // hex width, hex depth torx,  torx depth    slot width   slot depth \n            [\"#0\", [0.028,   0.050,   undef,     undef,       0.012,       0.018]],\n            [\"#1\", [0.035,   0.060,   undef,     undef,       0.014,       0.018]],\n            [\"#2\", [0.035,   0.060,   undef,     undef,       0.016,       0.022]],\n            [\"#3\", [0.05 ,   0.070,   undef,     undef,       0.018,       0.025]],\n            [\"#4\", [0.05 ,   0.045,      6,      0.027,       0.021,       0.028]],\n            [\"#5\", [1/16 ,   0.080,      7,      0.036,       0.023,       0.031]],\n            [\"#6\", [1/16 ,   0.080,      7,      0.036,       0.025,       0.035]],\n            [\"#8\", [5/64 ,   0.090,      8,      0.041,       0.029,       0.041]],\n            [\"#10\",[3/32 ,   0.100,      10,     0.049,       0.032,       0.048]],\n            [\"#12\",[undef,   undef,   undef,    undef,        0.038,       0.056]],\n            [1/4,  [1/8  ,   0.125,      15,     0.068,       0.045,       0.063]],\n            [5/16, [5/32 ,   0.156,      25,     0.088,       0.051,       0.078]],\n            [3/8,  [3/16 ,   0.188,      30,     0.097,       0.064,       0.094]],\n            [7/16, [7/32 ,   0.219,      40,     0.117,       0.072,       0.109]],\n            [1/2,  [1/4  ,   0.250,      45,     0.137,       0.081,       0.125]],\n            [9/16, [undef,   undef,   undef,    undef,        0.091,       0.141]],\n            [5/8,  [5/16 ,   0.312,      55,     0.202,       0.102,       0.156]],\n            [3/4,  [3/8  ,   0.375,      60,     0.202,       0.129,       0.188]],\n            [7/8,  [1/2  ,   0.500,      70,     0.291]],     \n            [1,    [9/16 ,   0.562,      70,     0.291]],     \n            [1.125,[9/16 ,   0.562]],\n            [1.25, [5/8  ,   0.625]],\n            [1.375,[5/8  ,   0.625]],\n            [1.5,  [3/4  ,   0.750]],\n            [1.75, [1    ,   1.000]],\n            [2,    [1    ,   1.000]],\n            ],\n          entry = struct_val(UTS_setscrew, diam),\n          dummy=assert(is_def(entry), str(\"Screw size \",diam,\" unsupported for headless screws\")),\n          drive_dims = drive == \"hex\" ? [[\"drive_size\", INCH*entry[0]], [\"drive_depth\", INCH*entry[1]]]\n                     : drive == \"torx\" ? [[\"drive_size\", entry[2]], [\"drive_depth\", INCH*entry[3]]] \n                     : drive == \"slot\" ? [[\"drive_size\", INCH*entry[4]], [\"drive_depth\", INCH*entry[5]]]\n                     : []\n         ) concat([[\"head\",\"none\"]], drive_dims) \n     : head==\"hex\" ? let( \n            UTS_hex = [\n               // flat to flat width, height\n               [\"#2\", [    1/8,   1/16]],\n               [\"#4\", [   3/16,   1/16]],\n               [\"#6\", [    1/4,   3/32]],\n               [\"#8\", [    1/4,   7/64]],\n               [\"#10\",[   5/16,    1/8]],\n               [\"#12\",[   5/16,   5/32]],\n               [1/4,  [   7/16,   5/32]],\n               [5/16, [    1/2,  13/64]],\n               [3/8,  [   9/16,    1/4]],\n               [7/16, [    5/8,  19/64]],\n               [1/2,  [    3/4,  11/32]],\n               [9/16, [  13/16,  23/64]],\n               [5/8,  [  15/16,  27/64]],\n               [3/4,  [  1.125,    1/2]],\n               [7/8,  [ 1+5/16,  37/64]],\n               [1,    [    1.5,  43/64]],\n               [1.125,[1+11/16,  11/16]],\n               [1.25, [  1+7/8,  27/32]],\n               [1.5,  [   2.25,  15/16]],\n               [1.75, [  2+5/8, 1+3/32]],\n               [2,    [      3, 1+7/32]],\n            ],\n            entry = struct_val(UTS_hex, diam)\n           )\n           assert(is_def(entry), str(\"Screw size \",diam,\" unsupported for head type \\\"\",head,\"\\\"\"))\n           [[\"head\", \"hex\"], [\"head_size\", INCH*entry[0]], [\"head_height\", INCH*entry[1]]] \n     : in_list(head,[\"socket\",\"socket ribbed\"]) ? let(\n            UTS_socket = [    // height = screw diameter\n                       //diam,   hex, torx size, hex depth, torx depth\n               [\"#0\", [  0.096,  0.05, 6,         0.025,      0.027]],\n               [\"#1\", [  0.118,  1/16, 7,         0.031,      0.036]],\n               [\"#2\", [   9/64,  5/64, 8,         0.038,      0.037]],\n               [\"#3\", [  0.161,  5/64, 8,         0.044,      0.041]],   // For larger sizes, hex recess depth is\n               [\"#4\", [  0.183,  3/32, 10,        0.051,      0.049]],   // half the screw diameter\n               [\"#5\", [  0.205,  3/32, 10,        0.057,      0.049]],\n               [\"#6\", [  0.226,  7/64, 15,        0.064,      0.058]],\n               [\"#8\", [  0.270,  9/64, 25,        0.077,      0.078]],\n               [\"#10\",[   5/16,  5/32, 27,        undef,      0.088]],\n               [\"#12\",[  0.324,  5/32, 27,        undef,      0.088]],\n               [1/4,  [    3/8,  3/16, 30,        undef,      0.097]],\n               [5/16, [  15/32,   1/4, 45,        undef,      0.137]],\n               [3/8,  [   9/16,  5/16, 50,        undef,      0.155]],\n               [7/16, [  21/32,   3/8, 55,        undef,      0.202]],\n               [1/2,  [    3/4,   3/8, 55,        undef,      0.202]],\n               [9/16, [  27/32,  7/16, 60,        undef,      0.240]],\n               [5/8,  [  15/16,   1/2, 70,        undef,      0.291]],\n               [3/4,  [  1.125,   5/8, 80,        undef,      0.332]],\n               [7/8,  [ 1+5/16,   3/4, 100,       undef,      0.425]],\n               [1,    [    1.5,   3/4, 100,       undef,      0.425]],\n               [1.125,[1+11/16,   7/8, undef,     undef,      undef]],\n               [1.25, [  1+7/8,   7/8, undef,     undef,      undef]],\n               [1.375,[ 2+1/16,     1, undef,     undef,      undef]],\n               [1.5,  [   2.25,     1, undef,     undef,      undef]],\n               [1.75, [  2+5/8,  1.25, undef,     undef,      undef]],\n               [2,    [      3,   1.5, undef,     undef,      undef]],\n            ],\n            entry = struct_val(UTS_socket, diam),\n            dummy=assert(is_def(entry), str(\"Screw size \",diam,\" unsupported for head type \\\"\",head,\"\\\"\")),\n            hexdepth = is_def(entry[3]) ? entry[3]\n                     : is_def(diameter) ? diameter/2\n                     : undef,\n            drive_size =  drive==\"hex\" ? [[\"drive_size\",INCH*entry[1]], [\"drive_depth\",INCH*hexdepth]] :\n                          drive==\"torx\" ? [[\"drive_size\",entry[2]],[\"drive_depth\",INCH*entry[4]]] : []\n            )\n            concat([[\"head\",head],[\"head_size\",INCH*entry[0]], [\"head_height\", INCH*diameter]],drive_size) \n     : head==\"pan\" ? let (\n           UTS_pan = [  // pan head for phillips or slotted\n                 //              head height \n                 //    diam,   slotted  phillips  phillips drive, phillips diam, phillips width, phillips depth, slot width, slot depth  torx size\n               [\"#0\", [0.116,   0.039,   0.044,        0,          0.067,          0.013,           0.039,       0.023,         0.022]],\n               [\"#1\", [0.142,   0.046,   0.053,        0,          0.085,          0.015,           0.049,       0.027,         0.027]],\n               [\"#2\", [0.167,   0.053,   0.063,        1,          0.104,          0.017,           0.059,       0.031,         0.031,      8]],\n               [\"#3\", [0.193,   0.060,   0.071,        1,          0.112,          0.019,           0.068,       0.035,         0.036]],\n               [\"#4\", [0.219,   0.068,   0.080,        1,          0.122,          0.019,           0.078,       0.039,         0.040,     10]],\n               [\"#5\", [0.245,   0.075,   0.089,        2,          0.158,          0.028,           0.083,       0.043,         0.045]],\n               [\"#6\", [0.270,   0.082,   0.097,        2,          0.166,          0.028,           0.091,       0.048,         0.050,     15]],\n               [\"#8\", [0.322,   0.096,   0.115,        2,          0.182,          0.030,           0.108,       0.054,         0.058,     20]],\n               [\"#10\",[0.373,   0.110,   0.133,        2,          0.199,          0.031,           0.124,       0.060,         0.068,     25]],\n               [\"#12\",[0.425,   0.125,   0.151,        3,          0.259,          0.034,           0.141,       0.067,         0.077]],\n               [1/4,  [0.492,   0.144,   0.175,        3,          0.281,          0.036,           0.161,       0.075,         0.087,     30]],\n               [5/16, [0.615,   0.178,   0.218,        4,          0.350,          0.059,           0.193,       0.084,         0.106]],\n               [3/8,  [0.740,   0.212,   0.261,        4,          0.389,          0.065,           0.233,       0.094,         0.124]],\n            ],\n            htind = drive==\"slot\" ? 1 : 2,\n            entry = struct_val(UTS_pan, diam),\n            dummy=assert(is_def(entry), str(\"Screw size \",diam,\" unsupported for head type \\\"\",head,\"\\\"\")),\n            drive_size = drive==\"phillips\" ? [[\"drive_size\", entry[3]],\n                                             // [\"drive_diameter\",INCH*entry[4]],\n                                             // [\"drive_width\",INCH*entry[5]],\n                                              [\"drive_depth\",INCH*entry[6]]]\n                                           : [[\"drive_size\", INCH*entry[7]],\n                                              [\"drive_depth\",INCH*entry[8]]])\n           concat([[\"head\",\"pan round\"], [\"head_size\", INCH*entry[0]], [\"head_height\", INCH*entry[htind]]], drive_size) \n     : head==\"button\" || head==\"round\" ? let(\n            UTS_button = [    // button, hex or torx drive\n                 //   head diam, height, phillips, hex,   torx, hex depth\n               [\"#0\", [0.114,    0.032,   undef,   0.035,  5    , 0.020, 0.015]],\n               [\"#1\", [0.139,    0.039,   undef,   3/64,   5    , 0.028, 0.022]],\n               [\"#2\", [0.164,    0.046,   undef,   3/64,   6    , 0.028, 0.023]],\n               [\"#3\", [0.188,    0.052,   undef,   1/16,   undef, 0.035, undef]],\n               [\"#4\", [0.213,    0.059,   undef,   1/16,   8    , 0.035, 0.032]],\n               [\"#5\", [0.238,    0.066,   undef,   5/64,   10   , 0.044, 0.038]],\n               [\"#6\", [0.262,    0.073,   undef,   5/64,   10   , 0.044, 0.038]],\n               [\"#8\", [0.312,    0.087,   undef,   3/32,   15   , 0.052, 0.045]],\n               [\"#10\",[0.361,    0.101,   undef,   1/8,    25   , 0.070, 0.052]],\n               [\"#12\",[0.413,    0.114,   undef,   1/8,    undef, 0.070, undef]],   // also 0.410, .115, 9/64, hex depth guessed\n               [1/4,  [0.437,    0.132,   undef,   5/32,   27   , 0.087, 0.068]],\n               [5/16, [0.547,    0.166,   undef,   3/16,   40   , 0.105, 0.090]],\n               [3/8,  [0.656,    0.199,   undef,   7/32,   45   , 0.122, 0.106]],\n               [7/16, [0.750,    0.220,   undef,   1/4,    undef, 0.193, undef]],  // hex depth interpolated\n               [1/2,  [0.875,    0.265,   undef,   5/16,   55   , 0.175, 0.158]],\n               [5/8,  [1.000,    0.331,   undef,   3/8,    60   , 0.210, 0.192]],\n               [3/4,  [1.1,      0.375,   undef,   7/16,   undef, 0.241]],  // hex depth extrapolated\n             ],\n             UTS_round = [   // slotted, phillips\n                  // head diam, head height, phillips drive, hex, torx, ph diam, ph width, ph depth, slot width, slot depth\n               [\"#0\", [0.113, 0.053, 0, undef, undef]],\n               [\"#1\", [0.138, 0.061, 0, undef, undef]],\n               [\"#2\", [0.162, 0.069, 1, undef, undef, 0.100, 0.017, 0.053, 0.031, 0.048]],\n               [\"#3\", [0.187, 0.078, 1, undef, undef, 0.109, 0.018, 0.062, 0.035, 0.053]],\n               [\"#4\", [0.211, 0.086, 1, undef, undef, 0.118, 0.019, 0.072, 0.039, 0.058]],\n               [\"#5\", [0.236, 0.095, 2, undef, undef, 0.154, 0.027, 0.074, 0.043, 0.063]],\n               [\"#6\", [0.260, 0.103, 2, undef, undef, 0.162, 0.027, 0.084, 0.048, 0.068]],\n               [\"#8\", [0.309, 0.120, 2, undef, undef, 0.178, 0.030, 0.101, 0.054, 0.077]],\n               [\"#10\",[0.359, 0.137, 2, undef, undef, 0.195, 0.031, 0.119, 0.060, 0.087]],\n               [\"#12\",[0.408, 0.153, 3, undef, undef, 0.249, 0.032, 0.125, 0.067, 0.096]],\n               [1/4,  [0.472, 0.175, 3, undef, undef, 0.268, 0.034, 0.147, 0.075, 0.109]],\n               [5/16, [0.590, 0.216, 3, undef, undef, 0.308, 0.040, 0.187, 0.084, 0.132]],\n               [3/8,  [0.708, 0.256, 4, undef, undef, 0.387, 0.064, 0.228, 0.094, 0.155]],\n               [1/2,  [0.813, 0.355, 4, undef, undef, 0.416, 0.068, 0.256, 0.106, 0.211]]\n             ],\n             entry = struct_val(head==\"button\" ? UTS_button : UTS_round, diam),\n             dummy=assert(is_def(entry), str(\"Screw size \",diam,\" unsupported for head type \\\"\",head,\"\\\"\")),\n             drive_index = drive==\"phillips\" ? 2 :\n                           drive==\"hex\" ? 3 :\n                           drive==\"torx\" ? 4 : undef,\n             drive_size = drive==\"phillips\" && head==\"round\" ? [[\"drive_size\", entry[2]],\n                                                               // [\"drive_diameter\",u_mul(INCH,entry[5])],\n                                                               // [\"drive_width\",INCH*entry[6]],\n                                                                [\"drive_depth\",INCH*entry[7]]]\n                        : drive==\"slot\" && head==\"round\" ?  [[\"drive_size\", INCH*entry[8]],\n                                                             [\"drive_depth\",u_mul(INCH,entry[9])]]\n                        : drive==\"hex\" && head==\"button\" ? [[\"drive_size\", INCH*entry[drive_index]],\n                                                            [\"drive_depth\", u_mul(INCH,entry[5])]]\n                        : drive==\"torx\" && head==\"button\" ? [[\"drive_size\", entry[drive_index]],\n                                                             [\"drive_depth\", u_mul(INCH,entry[6])]]\n                        : is_def(drive_index) && head==\"button\" ? [[\"drive_size\", entry[drive_index]]] : []\n             )\n             concat([[\"head\",head],[\"head_size\",INCH*entry[0]], [\"head_height\", INCH*entry[1]]],drive_size) \n     : head==\"fillister\" ? let(\n             UTS_fillister = [ // head diam, head height, slot width, slot depth, phillips diam, phillips depth, phillips width, phillips #\n                   [\"#0\", [0.096, 0.055, 0.023, 0.025, 0.067, 0.039, 0.013, 0]],\n                   [\"#1\", [0.118, 0.069, 0.027, 0.031, 0.085, 0.049, 0.015,  ]],\n                   [\"#2\", [0.140, 0.083, 0.031, 0.037, 0.104, 0.059, 0.017,  ]],\n                   [\"#3\", [0.161, 0.095, 0.035, 0.043, 0.112, 0.068, 0.019, 1]],\n                   [\"#4\", [0.183, 0.107, 0.039, 0.048, 0.122, 0.078, 0.019, 1]],\n                   [\"#5\", [0.205, 0.120, 0.043, 0.054, 0.143, 0.067, 0.027, 2]],\n                   [\"#6\", [0.226, 0.132, 0.048, 0.060, 0.166, 0.091, 0.028, 2]],\n                   [\"#8\", [0.270, 0.156, 0.054, 0.071, 0.182, 0.108, 0.030, 2]],\n                   [\"#10\",[0.313, 0.180, 0.060, 0.083, 0.199, 0.124, 0.031, 2]],\n                   [\"#12\",[0.357, 0.205, 0.067, 0.094, 0.259, 0.141, 0.034, 3]],\n                   [1/4,  [0.414, 0.237, 0.075, 0.109, 0.281, 0.161, 0.036, 3]],\n                   [5/16, [0.518, 0.295, 0.084, 0.137, 0.322, 0.203, 0.042, 3]],\n                   [3/8,  [0.622, 0.355, 0.094, 0.164, 0.389, 0.233, 0.065, 4]],\n             ],\n             entry = struct_val(UTS_fillister, diam),\n             dummy=assert(is_def(entry), str(\"Screw size \",diam,\" unsupported for head type \\\"\",head,\"\\\"\")),\n             drive_size = drive==\"phillips\" ? [[\"drive_size\", entry[7]],\n                                            //   [\"drive_diameter\",INCH*entry[4]],\n                                            //   [\"drive_width\",INCH*entry[6]],\n                                               [\"drive_depth\",INCH*entry[5]]] \n                        : drive==\"slot\"?  [[\"drive_size\", INCH*entry[2]],\n                                           [\"drive_depth\",INCH*entry[3]]] : []\n             )\n             concat([[\"head\", \"fillister\"], [\"head_size\", INCH*entry[0]], [\"head_height\", INCH*entry[1]]], drive_size) \n     : starts_with(head,\"flat \") || head==\"flat\" ? \n         let(\n             headparts = str_split(head,\" \",keep_nulls=false),\n             partsok = [for (part=headparts) if (!in_list(part, [\"flat\",\"undercut\",\"100\",\"82\",\"small\",\"large\",\"sharp\"])) part], \n             dummy1=assert(partsok==[], str(\"Unknown flat head parameter(s) \",partsok)),\n             dummy2=assert(!(in_list(\"small\",headparts) && in_list(\"large\",headparts)), \"Cannot specify large and small flat head at the same time\"),\n             undercut = in_list(\"undercut\", headparts),\n             small = in_list(\"small\",headparts) || (!in_list(\"large\",headparts) && drive!=\"hex\" && drive!=\"torx\"),\n             angle = in_list(\"100\", headparts) ? 100 : 82,\n             dummy3=assert(!undercut || angle==82, \"Cannot make undercut 100 degree screw\"),\n             dummy4=assert(small || angle==82, \"Only 82 deg large screws are supported\"),\n             dummy5=assert(small || !undercut, \"Undercut only supported for small flatheads\"),\n             UTS_flat_small = [  // for phillips drive, slotted, and torx   ASME B18.6.3\n                    //                     ----- Phillips ----              undercut phillips\n                    //    ph drive, torx , diam,  depth, width, slotwidth,  diam, depth, width\n                    //       0       1       2      3      4        5           6        7  \n                   [\"#0\", [  0,     undef, 0.062, 0.035, 0.014,   0.023,   0.062, 0.035, 0.014]],\n                   [\"#1\", [  0,     undef, 0.070, 0.043, 0.015,   0.026,   0.070, 0.043, 0.015]],\n                   [\"#2\", [  1,     6    , 0.096, 0.055, 0.017,   0.031,   0.088, 0.048, 0.017]],\n                   [\"#3\", [  1,     undef, 0.100, 0.060, 0.018,   0.035,   0.099, 0.059, 0.018]],\n                   [\"#4\", [  1,     8    , 0.122, 0.081, 0.018,   0.039,   0.110, 0.070, 0.018]],\n                   [\"#5\", [  2,     undef, 0.148, 0.074, 0.027,   0.043,   0.122, 0.081, 0.018]], //ph#1 for undercut\n                   [\"#6\", [  2,     10   , 0.168, 0.094, 0.029,   0.048,   0.140, 0.066, 0.025]],\n                   [\"#8\", [  2,     15   , 0.182, 0.110, 0.030,   0.054,   0.168, 0.094, 0.029]],\n                   [\"#10\",[  2,     20   , 0.198, 0.124, 0.032,   0.060,   0.182, 0.110, 0.030]],\n                   [\"#12\",[  3,     undef, 0.262, 0.144, 0.035,   0.067,   0.226, 0.110, 0.030]],\n                   [1/4,  [  3,     27   , 0.276, 0.160, 0.036,   0.075,   0.244, 0.124, 0.032]],\n                   [5/16, [  4,     40   , 0.358, 0.205, 0.061,   0.084,   0.310, 0.157, 0.053]],\n                   [3/8,  [  4,     40   , 0.386, 0.234, 0.065,   0.094,   0.358, 0.205, 0.061]],\n                   [1/2,  [  4,     undef, 0.418, 0.265, 0.069,   0.106,   0.402, 0.252, 0.068]]\n             ],\n             UTS_flat_small_100 = [  // for phillips drive, slotted, 100 deg angle  ASME B18.6.3\n                    //                     ----- Phillips ----            \n                    //    ph drive, torx , diam,  depth, width, slotwidth\n                    //       0       1       2      3      4        5    \n                   [\"#0\", [  0,     undef, 0.054, 0.027, 0.013,   0.023]],\n                   [\"#1\", [  0,     undef, 0.062, 0.035, 0.014,   0.026]],\n                   [\"#2\", [  1,     6    , 0.088, 0.048, 0.012,   0.031]],\n                   [\"#3\", [  1,     undef, 0.096, 0.055, 0.014,   0.035]],\n                   [\"#4\", [  1,     8    , 0.110, 0.070, 0.018,   0.039]],\n                   [\"#6\", [  2,     10   , 0.148, 0.074, 0.027,   0.048]],\n                   [\"#8\", [  2,     15   , 0.162, 0.090, 0.028,   0.054]],\n                   [\"#10\",[  2,     20   , 0.178, 0.104, 0.030,   0.060]],\n                   [1/4,  [  3,     27   , 0.240, 0.124, 0.033,   0.075]],\n                   [5/16, [  4,     40   , 0.310, 0.157, 0.053,   0.084]],\n                   [3/8,  [  4,     40   , 0.336, 0.182, 0.056,   0.094]],\n             ],\n             UTS_flat_large = [   // for hex drive, torx     ASME B18.3\n                       // minimum\n                       // head diam, hex drive size, torx size, hex depth, torx depth\n                   [\"#0\", [ 0.117,   1/32,            3    ,     0.025,    0.016]],\n                   [\"#1\", [ 0.143,   3/64,            6    ,     0.031,    0.036]],\n                   [\"#2\", [ 0.168,   3/64,            6    ,     0.038,    0.036]],\n                   [\"#3\", [ 0.193,   1/16,            8    ,     0.044,    0.041]],\n                   [\"#4\", [ 0.218,   1/16,            10   ,     0.055,    0.038]],\n                   [\"#5\", [ 0.240,   5/64,            10   ,     0.061,    0.038]],\n                   [\"#6\", [ 0.263,   5/64,            15   ,     0.066,    0.045]],\n                   [\"#8\", [ 0.311,   3/32,            20   ,     0.076,    0.053]],\n                   [\"#10\",[ 0.359,    1/8,            25   ,     0.087,    0.061]],\n                   [1/4,  [ 0.480,   5/32,            30   ,     0.111,    0.075]],\n                   [5/16, [ 0.600,   3/16,            40   ,     0.135,    0.090]],\n                   [3/8,  [ 0.720,   7/32,            45   ,     0.159,    0.106]],\n                   [7/16, [ 0.781,    1/4,            50   ,     0.172,    0.120]],\n                   [1/2,  [ 0.872,   5/16,            50   ,     0.220,    0.120]],\n                   [5/8,  [ 1.112,    3/8,            55   ,     0.220,    0.158]],\n                   [3/4,  [ 1.355,    1/2,            60   ,     0.248,    0.192]],\n                   [7/8,  [ 1.604,   9/16,            undef,     0.297,    undef]],\n                   [1,    [ 1.841,    5/8,            undef,     0.325,    undef]],\n                   [1.125,[ 2.079,    3/4,            undef,     0.358,    undef]],\n                   [1.25, [ 2.316,    7/8,            undef,     0.402,    undef]],\n                   [1.375,[ 2.688,    7/8,            undef,     0.402,    undef]],\n                   [1.5,  [ 2.938,      1,            undef,     0.435,    undef]],\n             ],\n             entry = struct_val(    angle==100 ? UTS_flat_small_100 \n                                  : small ? UTS_flat_small \n                                  : UTS_flat_large, \n                                diam),\n             dummy=assert(is_def(entry), str(\"Screw size \",diam,\" unsupported for head type \\\"\",head,\"\\\"\")),\n             a=[1.92+1.82, 1.88+1.8, 1.88+1.8]/2,\n             b=[.003+.013, .063+.073, .125+.135]/2,\n             smallsize = a[diamgroup]*diameter-b[diamgroup],\n     \n             csmall=[2.04, 2, 2],\n             dsmall=[.003, .063, .125], \n             dlarge = [-.031, .031, .062],\n             sharpsize = small ? csmall[diamgroup]*diameter-dsmall[diamgroup] // max theoretical (sharp) head diam\n                                     : diameter < 0.1 ? [0.138,0.168,0.0822,0.0949][(diameter - 0.06)/.013] \n                                     : 2*diameter-dlarge[diamgroup],\n             largesize = lerp(entry[0],sharpsize,.20),   // Have min size and max theory size.  Use point 20% up from min size\n             undercut_height = let(\n                                   a=[.432+.386, .417+.37, .417+.37]/2,\n                                   b=[.001+.005, .026+.029, .052+.055]/2\n                               )\n                               a[diamgroup]*diameter + b[diamgroup],\n             e=undercut ? [.202+.134, .192+.129, .192+.129]/2 \n              : angle==100 ? [.222+.184]/2 \n              : [.288+.192, .274+.184, .274+.184]/2,\n             f=undercut ? [.002, .012+.011, .024+.019]/2\n              : angle==100 ? [.0005+.004]/2 \n              : [.004, .015+.017, .034+.027],\n             tipdepth_small = e[diamgroup]*diameter + f[diamgroup],\n             driveind = small && drive==\"phillips\" ? 0\n                      : !small && drive==\"hex\" ? 1 \n                      : drive==\"torx\" ? 2 \n                      : undef,\n             drive_dims = small ? (\n                            drive==\"phillips\" && !undercut ? [\n                                                            //  [\"drive_diameter\",INCH*entry[2]],\n                                                            //  [\"drive_width\",INCH*entry[4]],\n                                                              [\"drive_depth\",INCH*entry[3]]\n                                                             ]\n                          : drive==\"phillips\" && undercut ?  [\n                                                             // [\"drive_diameter\",INCH*entry[6]],\n                                                             // [\"drive_width\",INCH*entry[8]],\n                                                              [\"drive_depth\",INCH*entry[7]]\n                                                             ] \n                          : drive==\"slot\" ? [[\"drive_size\", INCH*entry[5]], \n                                             [\"drive_depth\", INCH*tipdepth_small]] :\n                            \n                            []\n                            )\n                         :\n                           (\n                             drive==\"hex\" ? [[\"drive_depth\", INCH*entry[3]]] :\n                             drive==\"torx\" ? [[\"drive_depth\", INCH*entry[4]]] : []\n                           )\n         )\n         [\n           [\"head\",\"flat\"],\n           [\"head_angle\",angle],\n           [\"head_size\", in_list(\"sharp\",headparts) ? sharpsize*INCH\n                        : small ? smallsize*INCH : largesize*INCH], //entry[0]*INCH],\n           [\"head_size_sharp\", sharpsize*INCH],\n           if (is_def(driveind)) [\"drive_size\", (drive==\"hex\"?INCH:1)*entry[driveind]],\n           if (undercut) [\"head_height\", undercut_height*INCH],\n           each drive_dims\n         ]\n     : []\n )\n concat([\n           [\"type\",\"screw_info\"],\n           [\"system\",\"UTS\"],\n           [\"diameter\",INCH*diameter],\n           [\"pitch\", pitch],\n           [\"drive\",drive]\n         ],\n         head_data\n );\n\n\nfunction _screw_info_metric(diam, pitch, head, thread, drive) =\n let(\n   pitch =\n     is_num(thread) ? thread :\n     is_def(pitch) ? pitch :\n     let(\n        tind=struct_val([[\"coarse\",0],\n                         [\"fine\",1],\n                         [\"extra fine\",2],[\"extrafine\",2],\n             [\"super fine\",3],[\"superfine\",3]],\n                         downcase(thread)),\n        dummy = assert(is_def(tind), str(\"Unknown thread type, \\\"\",thread,\"\\\"\")),\n                            // coarse  fine  xfine superfine\n        ISO_thread = [\n                      [1  , [0.25,    0.2 ,   undef, undef,]],\n                      [1.2, [0.25,    0.2 ,   undef, undef,]],\n                      [1.4, [0.3 ,    0.2 ,   undef, undef,]],\n                      [1.6, [0.35,    0.2 ,   undef, undef,]],\n                      [1.7, [0.35,   undef,   undef, undef,]],\n                      [1.8, [0.35,    0.2 ,   undef, undef,]],\n                      [2  , [0.4 ,    0.25,   undef, undef,]],\n                      [2.2, [0.45,    0.25,   undef, undef,]],\n                      [2.3, [0.4 ,   undef,   undef, undef,]],\n                      [2.5, [0.45,    0.35,   undef, undef,]],\n                      [2.6, [0.45,   undef,   undef, undef,]],\n                      [3  , [0.5 ,    0.35,   undef, undef,]],\n                      [3.5, [0.6 ,    0.35,   undef, undef,]],\n                      [4  , [0.7 ,    0.5 ,   undef, undef,]],\n                      [5  , [0.8 ,    0.5 ,   undef, undef,]],\n                      [6  , [1   ,    0.75,   undef, undef,]],\n                      [7  , [1   ,    0.75,   undef, undef,]],\n                      [8  , [1.25,    1   ,    0.75, undef,]],\n                      [9  , [1.25,    1   ,    0.75, undef,]],\n                      [10 , [1.5 ,    1.25,    1   ,  0.75,]],\n                      [11 , [1.5 ,    1   ,    0.75, undef,]],\n                      [12 , [1.75,    1.5 ,    1.25,  1,   ]],\n                      [14 , [2   ,    1.5 ,    1.25,  1,   ]],\n                      [16 , [2   ,    1.5 ,    1   , undef,]],\n                      [18 , [2.5 ,    2   ,    1.5 ,  1,   ]],\n                      [20 , [2.5 ,    2   ,    1.5 ,  1,   ]],\n                      [22 , [2.5 ,    2   ,    1.5 ,  1,]],\n                      [24 , [3   ,    2   ,    1.5 ,  1,]],\n                      [27 , [3   ,    2   ,    1.5 ,  1,]],\n                      [30 , [3.5 ,    3   ,    2   ,  1.5,]],\n                      [33 , [3.5 ,    3   ,    2   ,  1.5,]],\n                      [36 , [4   ,    3   ,    2   ,  1.5,]],\n                      [39 , [4   ,    3   ,    2   ,  1.5,]],\n                      [42 , [4.5 ,    4   ,    3   ,  2,]],\n                      [45 , [4.5 ,    4   ,    3   ,  2,]],\n                      [48 , [5   ,    4   ,    3   ,  2,]],\n                      [52 , [5   ,    4   ,    3   ,  2,]],\n                      [56 , [5.5 ,    4   ,    3   ,  2,]],\n                      [60 , [5.5 ,    4   ,    3   ,  2,]],\n                      [64 , [6   ,    4   ,    3   ,  2,]],\n                      [68 , [6   ,    4   ,    3   ,  2,]],\n                      [72 , [6   ,    4   ,    3   ,  2,]],\n                      [80 , [6   ,    4   ,    3   ,  2,]],\n                      [90 , [6   ,    4   ,    3   ,  2,]],\n                      [100, [6   ,    4   ,    3   ,  2,]],\n        ],\n        tentry = struct_val(ISO_thread, diam)\n     )\n     assert(is_def(tentry), str(\"Unknown screw size, M\",diam))\n     assert(is_def(tentry[tind]), str(\"No \",thread,\" pitch known for M\",diam))\n     tentry[tind],\n   \n   head_data =\n       head==\"none\" ? let(\n           metric_setscrew =\n               [\n                  //   hex    torx, torx depth, slot width, slot depth \n                [1.2, [undef, undef,   undef,    0.330,        0.460]],\n                [1.4, [0.7,   undef,   undef,    undef,        undef]],\n                [1.6, [0.7,   undef,   undef,    0.380,        0.650]],\n                [1.8, [0.7,   undef,   undef,    undef,        undef]],\n                [2,   [0.9,   undef,   undef,    0.380,        0.740]],\n                [2.5, [1.3,   undef,   undef,    0.530,        0.835]],\n                [3,   [1.5,     6,     0.77,     0.530,        0.925]],\n                [3.5, [undef, undef,   undef,    0.630,        1.085]],\n                [4,   [2,       8,     1.05,     0.730,        1.270]],\n                [5,   [2.5,    10,     1.24,     0.930,        1.455]],\n                [6,   [3,      15,     1.74,     1.130,        1.800]],\n                [8,   [4,      25,     2.24,     1.385,        2.250]],\n                [10,  [5,      40,     2.97,     1.785,        2.700]],\n                [12,  [6,      45,     3.48,     2.185,        3.200]],\n                [16,  [8,      55,     5.15]],\n                [20,  [10,   undef,    undef]],    \n               ],\n            entry = struct_val(metric_setscrew, diam),\n            dummy=assert(drive==\"none\" || is_undef(drive) || is_def(entry), str(\"Screw size M\",diam,\" unsupported for headless screws\")),\n            drive_dim = drive==\"hex\" ? [[\"drive_size\", entry[0]], [\"drive_depth\", diam/2]]\n                      : drive==\"torx\" ? [[\"drive_size\", entry[1]], [\"drive_depth\", entry[2]]]\n                      : drive==\"slot\" ? [[\"drive_size\", entry[3]], [\"drive_depth\", entry[4]]]\n                      : []\n           )\n           concat([[\"head\",\"none\"]], drive_dim) \n     : head==\"hex\" ? let(\n            metric_hex = [\n              // flat to flat width, height\n              [5, [8, 3.5]],\n              [6, [10,4]],\n              [8, [13, 5.3]],\n              [10, [17, 6.4]],\n              [12, [19, 7.5]],\n              [14, [22, 8.8]],\n              [16, [24, 10]],\n              [18, [27,11.5]],\n              [20, [30, 12.5]],\n              [24, [36, 15]],\n              [30, [46, 18.7]],\n            ],\n            entry = struct_val(metric_hex, diam)\n           )\n           assert(is_def(entry), str(\"Screw size M\",diam,\" unsupported for head type \\\"\",head,\"\\\"\"))\n           [[\"head\", \"hex\"], [\"head_size\", entry[0]], [\"head_height\", entry[1]]] \n     : in_list(head,[\"socket\",\"socket ribbed\"]) ? let(\n            // ISO 14579 gives dimensions for Torx (hexalobular) socket heads\n            metric_socket = [    // height = screw diameter\n                      //diam, hex, torx size, torx depth\n                [1.4, [2.5,   1.3]],\n                [1.6, [3,     1.5]],\n                [2,   [3.8,   1.5,    6,        0.775]],\n                [2.5, [4.5,     2,    8,        0.975]],\n                [2.6, [5,       2,    8,        1.05]],\n                [3,   [5.5,   2.5,    10,       1.14]],\n                [3.5, [6.2,   2.5]]   ,\n                [4,   [7,       3,    25,       1.61]],\n                [5,   [8.5,     4,    27,       1.84]],\n                [6,   [10,      5,    30,       2.22]],\n                [7,   [12,      6]],\n                [8,   [13,      6,    45,       3.115]],\n                [10,  [16,      8,    50,       3.82]],\n                [12,  [18,     10,    55,       5.015]],\n                [14,  [21,     12,    60,       5.805]],\n                [16,  [24,     14,    70,       6.815]],\n                [18,  [27,     14,    80,       7.75]],\n                [20,  [30,     17,    90,       8.945]],\n                [22,  [33,     17]],\n                [24,  [36,     19,    100,     10.79]],\n                [27,  [40,     19]],\n                [30,  [45,     22]],\n                [33,  [50,     24]],\n                [36,  [54,     27]],\n                [42,  [63,     32]],\n                [48,  [72,     36]],\n            ],\n            entry = struct_val(metric_socket, diam),\n            dummy=assert(is_def(entry), str(\"Screw size M\",diam,\" unsupported for head type \\\"\",head,\"\\\"\")),\n            drive_size =  drive==\"hex\" ? [[\"drive_size\",entry[1]],[\"drive_depth\",diam/2]] :\n                          drive==\"torx\" ? [[\"drive_size\", entry[2]], [\"drive_depth\", entry[3]]] :\n                          []\n            )\n            concat([[\"head\",head],[\"head_size\",entry[0]], [\"head_height\", diam]],drive_size) \n     : in_list(head,[\"pan\",\"pan round\",\"pan flat\"]) ? let (\n           metric_pan = [  // pan head for phillips or slotted, torx from ISO 14583\n                      //          head height\n                      // diam, slotted  phillips phillips size  phillips diam, phillips depth, ph width, slot width,slot depth, torx size, torx depth\n                 [1.6,   [3.2,   1  ,     1.3,        0,          undef,         undef,        undef,       0.4,      0.35]],\n                 [2,     [4,     1.3,     1.6,        1,          1.82,          1.19,         0.48,        0.5,      0.5,        6,         0.7]],\n                 [2.5,   [5,     1.5,     2,          1,          2.68,          1.53,         0.70,        0.6,      0.6,        8,         0.975]],\n                 [3,     [5.6,   1.8,     2.4,        1,          2.90,          1.76,         0.74,        0.8,      0.7,        10,        1.14]],\n                 [3.5,   [7,     2.1,     3.1,        2,          3.92,          1.95,         0.87,        1.0,      0.8,        15,        1.2]],\n                 [4,     [8,     2.4 ,    3.1,        2,          4.40,          2.45,         0.93,        1.2,      1.0,        20,        1.465]],\n                 [5,     [9.5,   3,       3.8,        2,          4.90,          2.95,         1.00,        1.2,      1.2,        25,        1.715]],\n                 [6,     [12,    3.6,     4.6,        3,          6.92,          3.81,         1.14,        1.6,      1.4,        30,        2.22]],\n                 [8,     [16,    4.8,     6,          4,          9.02,          4.88,         1.69,        2.0,      1.9,        45,        2.985]],\n                 [10,    [20,    6.0,     7.5,        4,          10.18,         5.09,         1.84,        2.5,      2.4,        50,        3.82]], \n            ],\n            type = head==\"pan\" ? (drive==\"slot\" ? \"pan flat\" : \"pan round\") : head,\n            htind = drive==\"slot\" ? 1 : 2,\n            entry = struct_val(metric_pan, diam),\n            dummy=assert(is_def(entry), str(\"Screw size M\",diam,\" unsupported for head type \\\"\",head,\"\\\"\")),\n            drive_size = drive==\"phillips\" ? [[\"drive_size\", entry[3]],\n                                              //[\"drive_diameter\", entry[4]],\n                                              [\"drive_depth\",entry[5]],\n                                              //[\"drive_width\",entry[6]]\n                                             ] \n                       : drive==\"torx\" ? [[\"drive_size\", entry[9]], [\"drive_depth\", entry[10]]]\n                       : drive==\"slot\" ? [[\"drive_size\", entry[7]], [\"drive_depth\", entry[8]]] \n                       : []\n           )\n           concat([[\"head\",type], [\"head_size\", entry[0]], [\"head_height\", entry[htind]]], drive_size) \n     : head==\"button\" || head==\"cheese\" ? let(\n            // hex drive depth from ISO 7380-1\n            metric_button = [    // button, hex drive\n                 //   head diam, height, hex, phillips, hex drive depth, torx size, torx depth\n                 [1.6, [2.9,     0.8,    0.9, undef,    0.55]], // These four cases,\n                 [2,   [3.5,     1.3,    1.3, undef,    0.69]], // extrapolated hex depth\n                 [2.2, [3.8,     0.9,    1.3, undef,    0.76]], //\n                 [2.5, [4.6,     1.5,    1.5, undef,    0.87]], //\n                 [3,   [5.7,     1.65,   2,   undef,    1.04,                8,      0.81]],\n                 [3.5, [5.7,     1.65,   2,   undef,    1.21]], // interpolated hex depth\n                 [4,   [7.6,     2.2,    2.5, undef,    1.30,                15,     1.3]],\n                 [5,   [9.5,     2.75,   3,   undef,    1.56,                25,     1.56]],\n                 [6,   [10.5,    3.3,    4,   undef,    2.08,                27,     2.08]],\n                 [8,   [14,      4.4,    5,   undef,    2.60,                40,     2.3]],\n                 [10,  [17.5,    5.5,    6,   undef,    3.12,                45,     2.69]],\n                 [12,  [21,      6.6,    8,   undef,    4.16,                55,     4.02]],    \n                 [16,  [28,      8.8,    10,  undef,    5.2]], \n             ],\n             metric_cheese = [   // slotted, phillips     ISO 1207, ISO 7048\n                                 // hex drive is not supported (hence undefs)\n                // head diam, head height, hex drive, phillips drive, slot width, slot depth, ph diam\n                [1,   [2,     0.7,         undef,      undef]],\n                [1.2, [2.3,   0.8,         undef,      undef]],\n                [1.4, [2.6,   0.9,         undef,      undef]],\n                [1.6, [3,     1,           undef,      undef,         0.4,        0.45]],\n                [2,   [3.8,   1.3,         undef,      1    ,         0.5,        0.6,        undef,       undef]],\n                [2.5, [4.5,   1.6,         undef,      1    ,         0.6,        0.7,          2.7,        1.20]],\n                [3,   [5.5,   2,           undef,      2    ,         0.8,        0.85,         3.5,        0.86]],\n                [3.5, [6,     2.4,         undef,      2    ,         1.0,        1.0,          3.8,        1.15]],\n                [4,   [7,     2.6,         undef,      2    ,         1.2,        1.1,          4.1,        1.45]],\n                [5,   [8.5,   3.3,         undef,      2    ,         1.2,        1.3,          4.8,        2.14]],\n                [6,   [10,    3.9,         undef,      3    ,         1.6,        1.6,          6.2,        2.25]],\n                [8,   [13,    5,           undef,      3    ,         2.0,        2.0,          7.7,        3.73]],\n                [10,  [16,    6,           undef,      undef,         2.5,        2.4,        undef,       undef]]\n             ],\n             metric_cheese_torx = [ // torx cheese, ISO 14580, the heads are taller than other cheese screws\n                      //head diam, head height, torx size, torx depth\n                [2,   [3.8,        1.55,         6,         0.775]],\n                [2.5, [4.5,        1.85,         8,         0.845]],\n                [3,   [5.5,        2.4,         10,         1.14]],\n                [3.5, [6,          2.6,         15,         1.2]],\n                [4,   [7,          3.1,         20,         1.465]],\n                [5,   [8.5,        3.65,        25,         1.715]],\n                [6,   [10,         4.4,         30,         2.095]],\n                [8,   [13,         5.8,         45,         2.855]],\n                [10,  [16,         6.9,         59,         3.235]]\n             ],\n\n             entry = struct_val( head==\"button\" ? metric_button \n                               : drive==\"torx\"? metric_cheese_torx \n                               : metric_cheese, \n                            diam),\n             dummy=assert(is_def(entry), str(\"Screw size M\",diam,\" unsupported for head type \\\"\",head,\"\\\"\")),\n             drive_index = drive==\"phillips\" ? 3 \n                         : drive==\"hex\" ? 2 \n                         : undef,\n             drive_dim = head==\"button\" && drive==\"hex\" ? [[\"drive_depth\", entry[4]]] \n                       : head==\"button\" && drive==\"torx\" ? [[\"drive_size\", entry[5]],[\"drive_depth\", entry[6]]] \n                       : head==\"cheese\" && drive==\"torx\" ? [[\"drive_size\", entry[2]],[\"drive_depth\", entry[3]]] \n                       : head==\"cheese\" && drive==\"slot\" ? [[\"drive_size\", entry[4]], [\"drive_depth\", entry[5]]] \n                       : head==\"cheese\" && drive==\"phillips\" ? [\n                                                                //[\"drive_diameter\", entry[6]],\n                                                                [\"drive_depth\", entry[7]],\n                                                                //[\"drive_width\", entry[6]/4]  // Fabricated this width value to fill in missing field\n                                                               ]  \n                       :[],\n             drive_size = is_def(drive_index) ? [[\"drive_size\", entry[drive_index]]] : []\n             )\n             concat([[\"head\",head],[\"head_size\",entry[0]], [\"head_height\", entry[1]]],drive_size, drive_dim) \n     : starts_with(head,\"flat \") || head==\"flat\" ?\n         let(\n             headparts = str_split(head,\" \",keep_nulls=false),\n             partsok = [for (part=headparts) if (!in_list(part, [\"flat\",\"small\",\"large\",\"sharp\",\"90\"])) part], \n             dummy1=assert(partsok==[], str(\"Unknown flat head parameter(s) \",partsok)),\n             dummy2=assert(!(in_list(\"small\",headparts) && in_list(\"large\",headparts)), \"Cannot specify large and small flat head at the same time\"),\n             small = in_list(\"small\",headparts) || (!in_list(\"large\",headparts) && drive!=\"hex\"),\n             metric_flat_large = [ // for hex drive from ISO-10642, don't know where torx came from\n                     // -- diam -----   hex size    hex depth     torx   torx depth\n                     // theory  actual\n                     //  max     min\n                  [3,  [6.72,     5.54,      2  ,       1.1,        10,   0.96]],\n                  [4,  [8.96,     7.53,      2.5,       1.5,        20,   1.34]],\n                  [5,  [11.20,    9.43,      3  ,       1.9,        25,   1.54]],\n                  [6,  [13.44,    11.34,     4  ,       2.2,        30,   1.91]],\n                  [8,  [17.92,    15.24,     5  ,       3.0,        40,   2.3]],\n                  [10, [22.4,     19.22,     6  ,       3.6,        50,   3.04]],\n                  [12, [26.88,    23.12,     8  ,       4.3]], \n                  [14, [30.8,     26.52,    10  ,       4.5]],\n                  [16, [33.6,     29.01,    10  ,       4.8]],\n                  [20, [40.32,    36.05,    12  ,       5.6]]    \n             ],\n             metric_flat_small = [ // Phillips from ISO 7046\n                                   // Slots from ISO 2009\n                                   // Torx from ISO 14581\n                    // theory    mean                                             nominal       mean             torx\n                    //  diam, actual diam  ph size, ph diam, ph depth, ph width, slot width, slot depth  torx   mean depth\n                 [1.6, [ 3.6,    2.85,         0,     1.6,    0.75,    undef,     0.4,         0.41,     undef,  undef  ]],\n                 [2,   [ 4.4,    3.65,         0,     1.9,    1.05,     0.53,     0.5,         0.5,         6,    0.575 ]],\n                 [2.5, [ 5.5,    4.55,         1,     2.9,    1.6,      0.74,     0.6,         0.625,       8,    0.725 ]],\n                 [3,   [ 6.3,    5.35,         1,     3.2,    1.90,     0.79,     0.8,         0.725,      10,    0.765 ]],\n                 [3.5, [ 8.2,    7.12,         2,     4.4,    2.15,     0.91,     1.0,         1.05,       15,    1.240 ]],\n                 [4,   [ 9.4,    8.22,         2,     4.6,    2.35,     0.96,     1.2,         1.15,       10,    1.335 ]],\n                 [5,   [10.4,    9.12,         2,     5.2,    2.95,     1.04,     1.2,         1.25,       25,    1.315 ]],\n                 [6,   [12.6,   11.085,        3,     6.8,    3.25,     1.12,     1.6,         1.4,        30,    1.585 ]],\n                 [8,   [17.3,   15.585,        4,     8.9,    4.30,     1.80,     2.0,         2.05,       45,    2.345 ]],\n                 [10,  [20  ,   18.04,         4,    10.0,    5.40,    undef,     2.5,         2.3,        50,    2.605 ]],\n                 [12,  [24  ,   21.75 ]],  // Additional screw head data from ISO 7721, but no driver data   \n                 [14,  [28  ,   25.25 ]],\n                 [16,  [32  ,   28.75 ]],\n                 [18,  [36  ,   32.2  ]],\n                 [20,  [40  ,   35.7  ]]\n             ],\n             entry = struct_val(small ? metric_flat_small : metric_flat_large, diam),\n             dummy=assert(is_def(entry), str(\"Screw size M\",diam,\" unsupported for head type \\\"\",head,\"\\\"\")),\n             driveind = small && drive==\"phillips\" ? 2\n                      : !small && drive==\"hex\" ? 2\n                      : !small && drive==\"torx\" ? 4\n                      : small && drive==\"torx\" ? 8 : undef,\n             drive_dim = small && drive==\"phillips\" ? [\n                                                      // [\"drive_diameter\", entry[3]],\n                                                       [\"drive_depth\",entry[4]],\n                                                      // [\"drive_width\", entry[5]]\n                                                      ] \n                       : small && drive==\"slot\" ? [[\"drive_size\", entry[6]], [\"drive_depth\", entry[7]]] \n                       : drive==\"torx\" ? [[\"drive_depth\", entry[driveind+1]]] \n                       : !small && drive==\"hex\" ? [[\"drive_depth\", entry[3]]]\n                       : [],\n             sharpsize = entry[0]\n         )\n         [\n           [\"head\",\"flat\"],\n           [\"head_angle\",90],\n           [\"head_size\", in_list(\"sharp\",headparts) ? sharpsize\n                       : small ? entry[1]              // entry is mean diameter\n                       : lerp(entry[1],entry[0],.2)],  // entry is min diameter, so enlarge it 20%\n           [\"head_size_sharp\", sharpsize],\n           if (is_def(driveind)) [\"drive_size\", entry[driveind]],\n           each drive_dim\n         ]\n     : [] \n )\n concat(\n        [\n          [\"type\",\"screw_info\"],\n          [\"system\",\"ISO\"],\n          [\"diameter\",diam],\n          [\"pitch\", pitch],\n          [\"drive\",drive]\n        ],\n        head_data\n );\n\nfunction _is_positive(x) = is_num(x) && x>0;\n\n\nfunction _validate_nut_spec(spec) =\n   let(\n       //dummy=echo_struct(spec,\"Screw Specification\"),\n       systemOK = in_list(struct_val(spec,\"system\"), [\"UTS\",\"ISO\"]),\n       diamOK = _is_positive(struct_val(spec, \"diameter\")),\n       pitch = struct_val(spec,\"pitch\"),\n       pitchOK = is_undef(pitch) || (is_num(pitch) && pitch>=0),\n       shape = struct_val(spec, \"shape\"),\n       shapeOK = shape==\"hex\" || shape==\"square\",\n       thicknessOK = _is_positive(struct_val(spec, \"thickness\")),\n       widthOK = _is_positive(struct_val(spec, \"width\"))\n    )\n    assert(systemOK, str(\"Nut spec has invalid \\\"system\\\", \", struct_val(spec,\"system\"), \".  Must be \\\"ISO\\\" or \\\"UTS\\\"\"))\n    assert(diamOK, str(\"Nut spec has invalid \\\"diameter\\\", \", struct_val(spec,\"diameter\")))\n    assert(pitchOK, str(\"Nut spec has invalid \\\"pitch\\\", \", pitch))\n    assert(shapeOK, str(\"Nut spec has invalid \\\"shape\\\", \", shape, \".  Must be \\\"square\\\" or \\\"hex\\\"\"))\n    assert(thicknessOK, str(\"Nut spec thickness is not a postive number: \",struct_val(spec,\"thickness\")))\n    assert(widthOK, str(\"Nut spec width is not a postive number: \",struct_val(spec,\"width\")))\n    spec;\n\n    \nfunction _validate_screw_spec(spec) =\n    let(\n        //dummy=echo_struct(spec,\"Screw Specification\"),\n        systemOK = in_list(struct_val(spec,\"system\"), [\"UTS\",\"ISO\"]),\n        diamOK = _is_positive(struct_val(spec, \"diameter\")),\n        pitch = struct_val(spec,\"pitch\"),\n        pitchOK = is_undef(pitch) || (is_num(pitch) && pitch>=0),\n        head = struct_val(spec,\"head\"),\n        headOK = head==\"none\" || \n                    (in_list(head, [\"cheese\",\"pan flat\",\"pan round\", \"flat\", \"button\",\"socket\",\"socket ribbed\", \"fillister\",\"round\",\"hex\"]) &&\n                     _is_positive(struct_val(spec, \"head_size\"))),\n        flatheadOK = (head!=\"flat\" || _is_positive(struct_val(spec,\"head_size_sharp\"))),\n        drive = struct_val(spec, \"drive\"),\n        driveOK = is_undef(drive) || drive==\"none\"\n                  || (_is_positive(struct_val(spec, \"drive_depth\")) && _is_positive(struct_val(spec, \"drive_size\")))\n    )\n    assert(systemOK, str(\"Screw spec has invalid \\\"system\\\", \", struct_val(spec,\"system\"), \".  Must be \\\"ISO\\\" or \\\"UTS\\\"\"))\n    assert(diamOK, str(\"Screw spec has invalid \\\"diameter\\\", \", struct_val(spec,\"diameter\")))\n    assert(pitchOK, str(\"Screw spec has invalid \\\"pitch\\\", \", pitch))\n    assert(headOK, \"Screw head type invalid or unknown for your screw type and size\")  // head is \"undef\" for invalid heads; we don't know what the user specified\n    assert(flatheadOK, \"Flat head screw invalid because no \\\"head_size_sharp\\\" value is present.\")\n    assert(driveOK, str(\"Screw drive type \\\"\",drive,\"\\\" invalid or unknown for your screw size or head type, \\\"\",head,\"\\\"\"))\n    spec;\n\n\n\n// Function: thread_specification()\n// Synopsis: Returns the thread geometry for a given screw.\n// Topics: Threading, Screws\n// See Also: screw(), screw_hole()\n// Usage:\n//   thread_specification(screw_spec, [tolerance], [internal])\n// Description:\n//   Determines actual thread geometry for a given screw with specified tolerance and nominal size.  See [tolerance](#subsection-tolerance) for\n//   information on tolerances.  If tolerance is omitted the default is used.  If tolerance\n//   is \"none\" or 0 then return the nominal thread geometry.  When `internal=true` the nut tolerance is used.  \n//   .\n//   The return value is a structure with the following fields:\n//   - pitch: the thread pitch\n//   - d_major: major diameter range\n//   - d_pitch: pitch diameter range\n//   - d_minor: minor diameter range\n//   - basic: vector `[minor, pitch, major]` of the nominal or \"basic\" diameters for the threads\n// Arguments:\n//   screw_spec = screw specification structure\n//   tolerance = thread geometry tolerance.  Default: For ISO, \"6g\" for screws, \"6H\" for internal threading (nuts).  For UTS, \"2A\" for screws, \"2B\" for internal threading (nuts).\n//   internal = true for internal threads.  Default: false\nfunction thread_specification(screw_spec, tolerance=undef, internal=false) =\n  let( \n       diam = _nominal_diam(screw_spec),\n       pitch = struct_val(screw_spec, \"pitch\"),\n       tspec = tolerance == 0 || tolerance==\"none\" ? _exact_thread_tolerance(diam, pitch)\n             :  struct_val(screw_spec,\"system\") == \"ISO\" ? _ISO_thread_tolerance(diam, pitch, internal, tolerance)\n             :  struct_val(screw_spec,\"system\") == \"UTS\" ? _UTS_thread_tolerance(diam, pitch, internal, tolerance)\n             :  assert(false,\"Unknown screw system \",struct_val(screw_spec,\"system\"))\n  )\n  assert(min(struct_val(tspec,\"d_minor\"))>0, \"Thread specification is too coarse for the diameter\")\n  tspec;\n\n\n\n\n\n// recess sizing:\n// http://www.fasnetdirect.com/refguide/Machinepancombo.pdf\n//\n/*   ASME B 18.6.3\nhttp://www.smithfast.com/newproducts/screws/msflathead/\n\n\n/* phillips recess diagram\n\nhttp://files.engineering.com/getfile.aspx?folder=76fb0d5e-1fff-4c49-87a5-05979477ca88&file=Noname.jpg&__hstc=212727627.6c577ef84c12d9cc69c819eea7be49d2.1563972499721.1563972499721.1563972499721.1&__hssc=212727627.1.1563972499721&__hsfp=165344926\n\n*/\n\n\n//\n// https://www.bayoucitybolt.com/socket-head-cap-screws-metric.html\n//\n// Torx drive depth for UTS and ISO (at least missing for \"flat small\", which means you can't select torx for this head type)\n// Handle generic phillips (e.g. ph2) or remove it?\n\n// https://www.fasteners.eu/tech-info/ISO/7721-2/\n//\n//    JIS \n//https://www.garagejournal.com/forum/media/jis-b-4633-vs-iso-8764-1-din-5260-ph.84492/\n\n//square:\n//https://www.aspenfasteners.com/content/pdf/square_drive_specification.pdf\n//http://www.globalfastener.com/standards/index.php?narr58=149\n//https://patents.google.com/patent/US1003657\n\n// thread standards:\n// https://www.gewinde-normen.de/en/index.html\n\n/////////////////////////////////////////////////////////////////////////////////////////*\n/////////////////////////////////////////////////////////////////////////////////////////*\n/////////////////////////////////////////////////////////////////////////////////////////*\n///  \n///  TODO list:\n///  \n///  need to make holes at actual size instead of nominal?\n///     or relative to actual size?\n///     That means I need to preserve thread= to specify this\n///  torx depth for UTS pan head\n///  $fn control\n///  phillips driver spec with ph# is confusing since it still looks up depth in tables\n///     and can give an error if it's not found\n///  torx depths missing for pan head\n///  support for square drive?  (It's in the ASME standard)\n///  \n/////////////////////////////////////////////////////////////////////////////////////////*\n/////////////////////////////////////////////////////////////////////////////////////////*\n/////////////////////////////////////////////////////////////////////////////////////////*\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-36", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: shapes2d.scad\n//   This file includes redefinitions of the core modules to\n//   work with attachment, and functional forms of those modules\n//   that produce paths.  You can create regular polygons\n//   with optional rounded corners and alignment features not\n//   available with circle().  The file also provides teardrop2d,\n//   which is useful for 3D printable holes.  \n//   Many of the commands have module forms that produce geometry and\n//   function forms that produce a path. \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: Attachable circles, squares, polygons, teardrop.  Can make geometry or paths.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\nuse <builtins.scad>\n\n\n// Section: 2D Primitives\n\n// Function&Module: square()\n// Synopsis: Creates a 2D square or rectangle.\n// SynTags: Geom, Path, Ext\n// Topics: Shapes (2D), Path Generators (2D)\n// See Also: rect()\n// Usage: As a Module\n//   square(size, [center], ...);\n// Usage: With Attachments\n//   square(size, [center], ...) [ATTACHMENTS];\n// Usage: As a Function\n//   path = square(size, [center], ...);\n// Description:\n//   When called as the built-in module, creates a 2D square or rectangle of the given size.\n//   When called as a function, returns a 2D path/list of points for a square/rectangle of the given size.\n// Arguments:\n//   size = The size of the square to create.  If given as a scalar, both X and Y will be the same size.\n//   center = If given and true, overrides `anchor` to be `CENTER`.  If given and false, overrides `anchor` to be `FRONT+LEFT`.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Example(2D):\n//   square(40);\n// Example(2D): Centered\n//   square([40,30], center=true);\n// Example(2D): Called as Function\n//   path = square([40,30], anchor=FRONT, spin=30);\n//   stroke(path, closed=true);\n//   move_copies(path) color(\"blue\") circle(d=2,$fn=8);\nfunction square(size=1, center, anchor, spin=0) =\n    let(\n        anchor = get_anchor(anchor, center, [-1,-1], [-1,-1]),\n        size = is_num(size)? [size,size] : point2d(size)\n    )\n    assert(all_positive(size), \"All components of size must be positive.\")\n    let(\n        path = [\n            [ size.x,-size.y],\n            [-size.x,-size.y],\n            [-size.x, size.y],\n            [ size.x, size.y],\n        ] / 2\n    ) reorient(anchor,spin, two_d=true, size=size, p=path);\n\n\nmodule square(size=1, center, anchor, spin) {\n    anchor = get_anchor(anchor, center, [-1,-1], [-1,-1]);\n    rsize = is_num(size)? [size,size] : point2d(size);\n    size = [for (c = rsize) max(0,c)];\n    attachable(anchor,spin, two_d=true, size=size) {\n        if (all_positive(size))\n            _square(size, center=true);\n        children();\n    }\n}\n\n\n\n// Function&Module: rect()\n// Synopsis: Creates a 2d rectangle with optional corner rounding.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: square()\n// Usage: As Module\n//   rect(size, [rounding], [chamfer], ...) [ATTACHMENTS];\n// Usage: As Function\n//   path = rect(size, [rounding], [chamfer], ...);\n// Description:\n//   When called as a module, creates a 2D rectangle of the given size, with optional rounding or chamfering.\n//   When called as a function, returns a 2D path/list of points for a square/rectangle of the given size.\n// Arguments:\n//   size = The size of the rectangle to create.  If given as a scalar, both X and Y will be the same size.\n//   ---\n//   rounding = The rounding radius for the corners.  If negative, produces external roundover spikes on the X axis. If given as a list of four numbers, gives individual radii for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-]. Default: 0 (no rounding)\n//   chamfer = The chamfer size for the corners.  If negative, produces external chamfer spikes on the X axis. If given as a list of four numbers, gives individual chamfers for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-].  Default: 0 (no chamfer)\n//   atype = The type of anchoring to use with `anchor=`.  Valid opptions are \"box\" and \"perim\".  This lets you choose between putting anchors on the rounded or chamfered perimeter, or on the square bounding box of the shape. Default: \"box\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Anchor Types:\n//   box = Anchor is with respect to the rectangular bounding box of the shape.\n//   perim = Anchors are placed along the rounded or chamfered perimeter of the shape.\n// Example(2D):\n//   rect(40);\n// Example(2D): Anchored\n//   rect([40,30], anchor=FRONT);\n// Example(2D): Spun\n//   rect([40,30], anchor=FRONT, spin=30);\n// Example(2D): Chamferred Rect\n//   rect([40,30], chamfer=5);\n// Example(2D): Rounded Rect\n//   rect([40,30], rounding=5);\n// Example(2D): Negative-Chamferred Rect\n//   rect([40,30], chamfer=-5);\n// Example(2D): Negative-Rounded Rect\n//   rect([40,30], rounding=-5);\n// Example(2D): Default \"box\" Anchors\n//   color(\"red\") rect([40,30]);\n//   rect([40,30], rounding=10)\n//       show_anchors();\n// Example(2D): \"perim\" Anchors\n//   rect([40,30], rounding=10, atype=\"perim\")\n//       show_anchors();\n// Example(2D): \"perim\" Anchors\n//   rect([40,30], rounding=[-10,-8,-3,-7], atype=\"perim\")\n//       show_anchors();\n// Example(2D): Mixed Chamferring and Rounding\n//   rect([40,30],rounding=[5,0,10,0],chamfer=[0,8,0,15],$fa=1,$fs=1);\n// Example(2D): Called as Function\n//   path = rect([40,30], chamfer=5, anchor=FRONT, spin=30);\n//   stroke(path, closed=true);\n//   move_copies(path) color(\"blue\") circle(d=2,$fn=8);\nmodule rect(size=1, rounding=0, atype=\"box\", chamfer=0, anchor=CENTER, spin=0) {\n    errchk = assert(in_list(atype, [\"box\", \"perim\"]));\n    size = [for (c = force_list(size,2)) max(0,c)];\n    if (!all_positive(size)) {\n        attachable(anchor,spin, two_d=true, size=size) {\n            union();\n            children();\n        }\n    } else if (rounding==0 && chamfer==0) {\n        attachable(anchor, spin, two_d=true, size=size) {\n            square(size, center=true);\n            children();\n        }\n    } else {\n        pts_over = rect(size=size, rounding=rounding, chamfer=chamfer, atype=atype, _return_override=true);\n        pts = pts_over[0];\n        override = pts_over[1];\n        attachable(anchor, spin, two_d=true, size=size,override=override) {\n            polygon(pts);\n            children();\n        }\n    }\n}\n\n\n\nfunction rect(size=1, rounding=0, chamfer=0, atype=\"box\", anchor=CENTER, spin=0, _return_override) =\n    assert(is_num(size)     || is_vector(size,2))\n    assert(is_num(chamfer)  || is_vector(chamfer,4))\n    assert(is_num(rounding) || is_vector(rounding,4))\n    assert(in_list(atype, [\"box\", \"perim\"]))\n    let(\n        anchor=_force_anchor_2d(anchor),\n        size = [for (c = force_list(size,2)) max(0,c)],\n        chamfer = force_list(chamfer,4), \n        rounding = force_list(rounding,4)\n    )\n    assert(all_nonnegative(size), \"All components of size must be >=0\")\n    all_zero(concat(chamfer,rounding),0) ?\n        let(\n             path = [\n                 [ size.x/2, -size.y/2],\n                 [-size.x/2, -size.y/2],\n                 [-size.x/2,  size.y/2],\n                 [ size.x/2,  size.y/2],\n             ]\n        )\n        rot(spin, p=move(-v_mul(anchor,size/2), p=path))\n    :\n    assert(all_zero(v_mul(chamfer,rounding),0), \"Cannot specify chamfer and rounding at the same corner\")\n    let(\n        quadorder = [3,2,1,0],\n        quadpos = [[1,1],[-1,1],[-1,-1],[1,-1]],\n        eps = 1e-9,\n        insets = [for (i=[0:3]) abs(chamfer[i])>=eps? chamfer[i] : abs(rounding[i])>=eps? rounding[i] : 0],\n        insets_x = max(insets[0]+insets[1],insets[2]+insets[3]),\n        insets_y = max(insets[0]+insets[3],insets[1]+insets[2])\n    )\n    assert(insets_x <= size.x, \"Requested roundings and/or chamfers exceed the rect width.\")\n    assert(insets_y <= size.y, \"Requested roundings and/or chamfers exceed the rect height.\")\n    let(\n        corners = [\n            for(i = [0:3])\n            let(\n                quad = quadorder[i],\n                qinset = insets[quad],\n                qpos = quadpos[quad],\n                qchamf = chamfer[quad],\n                qround = rounding[quad],\n                cverts = quant(segs(abs(qinset)),4)/4,\n                step = 90/cverts,\n                cp = v_mul(size/2-[qinset,abs(qinset)], qpos),\n                qpts = abs(qchamf) >= eps? [[0,abs(qinset)], [qinset,0]] :\n                    abs(qround) >= eps? [for (j=[0:1:cverts]) let(a=90-j*step) v_mul(polar_to_xy(abs(qinset),a),[sign(qinset),1])] :\n                    [[0,0]],\n                qfpts = [for (p=qpts) v_mul(p,qpos)],\n                qrpts = qpos.x*qpos.y < 0? reverse(qfpts) : qfpts,\n                cornerpt = atype==\"box\" || (qround==0 && qchamf==0) ? undef\n                         : qround<0 || qchamf<0 ? [[0,-qpos.y*min(qround,qchamf)]]\n                         : [for(seg=pair(qrpts)) let(isect=line_intersection(seg, [[0,0],qpos],SEGMENT,LINE)) if (is_def(isect) && isect!=seg[0]) isect]\n              )\n            assert(is_undef(cornerpt) || len(cornerpt)==1,\"Cannot find corner point to anchor\")\n            [move(cp, p=qrpts), is_undef(cornerpt)? undef : move(cp,p=cornerpt[0])]\n        ],\n        path = deduplicate(flatten(column(corners,0)),closed=true),\n        override = [for(i=[0:3])\n                      let(quad=quadorder[i])\n                      if (is_def(corners[i][1])) [quadpos[quad], [corners[i][1], min(chamfer[quad],rounding[quad])<0 ? [quadpos[quad].x,0] : undef]]]\n      ) _return_override ? [reorient(anchor,spin, two_d=true, size=size, p=path, override=override), override]\n                       : reorient(anchor,spin, two_d=true, size=size, p=path, override=override);\n\n\n// Function&Module: circle()\n// Synopsis: Creates the approximation of a circle.\n// SynTags: Geom, Path, Ext\n// Topics: Shapes (2D), Path Generators (2D)\n// See Also: ellipse(), circle_2tangents(), circle_3points()\n// Usage: As a Module\n//   circle(r|d=, ...) [ATTACHMENTS];\n//   circle(points=) [ATTACHMENTS];\n//   circle(r|d=, corner=) [ATTACHMENTS];\n// Usage: As a Function\n//   path = circle(r|d=, ...);\n//   path = circle(points=);\n//   path = circle(r|d=, corner=);\n// Description:\n//   When called as the built-in module, creates a 2D polygon that approximates a circle of the given size.\n//   When called as a function, returns a 2D list of points (path) for a polygon that approximates a circle of the given size.\n//   If `corner=` is given three 2D points, centers the circle so that it will be tangent to both segments of the path, on the inside corner.\n//   If `points=` is given three 2D points, centers and sizes the circle so that it passes through all three points.\n// Arguments:\n//   r = The radius of the circle to create.\n//   d = The diameter of the circle to create.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Example(2D): By Radius\n//   circle(r=25);\n// Example(2D): By Diameter\n//   circle(d=50);\n// Example(2D): Fit to Three Points\n//   pts = [[50,25], [25,-25], [-10,0]];\n//   circle(points=pts);\n//   color(\"red\") move_copies(pts) circle();\n// Example(2D): Fit Tangent to Inside Corner of Two Segments\n//   path = [[50,25], [-10,0], [25,-25]];\n//   circle(corner=path, r=15);\n//   color(\"red\") stroke(path);\n// Example(2D): Called as Function\n//   path = circle(d=50, anchor=FRONT, spin=45);\n//   stroke(path);\nfunction circle(r, d, points, corner, anchor=CENTER, spin=0) =\n    assert(is_undef(corner) || (is_path(corner,[2]) && len(corner) == 3))\n    assert(is_undef(points) || is_undef(corner), \"Cannot specify both points and corner.\")\n    let(\n        data = is_def(points)?\n                assert(is_path(points,[2]) && len(points) == 3)\n                assert(is_undef(corner), \"Cannot specify corner= when points= is given.\")\n                assert(is_undef(r) && is_undef(d), \"Cannot specify r= or d= when points= is given.\")\n                let( c = circle_3points(points) )\n                assert(!is_undef(c[0]), \"Points cannot be collinear.\")\n                let( cp = c[0], r = c[1]  )\n                [cp, r] :\n            is_def(corner)?\n                assert(is_path(corner,[2]) && len(corner) == 3)\n                assert(is_undef(points), \"Cannot specify points= when corner= is given.\")\n                let(\n                    r = get_radius(r=r, d=d, dflt=1),\n                    c = circle_2tangents(r=r, pt1=corner[0], pt2=corner[1], pt3=corner[2])\n                )\n                assert(c!=undef, \"Corner path cannot be collinear.\")\n                let( cp = c[0] )\n                [cp, r] :\n            let(\n                cp = [0, 0],\n                r = get_radius(r=r, d=d, dflt=1)\n            ) [cp, r],\n        cp = data[0],\n        r = data[1]\n    )\n    assert(r>0, \"Radius/diameter must be positive\")\n    let(\n        sides = segs(r),\n        path = [for (i=[0:1:sides-1]) let(a=360-i*360/sides) r*[cos(a),sin(a)]+cp]\n    ) reorient(anchor,spin, two_d=true, r=r, p=path);\n\nmodule circle(r, d, points, corner, anchor=CENTER, spin=0) {\n    if (is_path(points)) {\n        c = circle_3points(points);\n        check = assert(c!=undef && c[0] != undef, \"Points must not be collinear.\");\n        cp = c[0];\n        r = c[1];\n        translate(cp) {\n            attachable(anchor,spin, two_d=true, r=r) {\n                if (r>0) _circle(r=r);\n                children();\n            }\n        }\n    } else if (is_path(corner)) {\n        r = get_radius(r=r, d=d, dflt=1);\n        c = circle_2tangents(r=r, pt1=corner[0], pt2=corner[1], pt3=corner[2]);\n        check = assert(c != undef && c[0] != undef, \"Points must not be collinear.\");\n        cp = c[0];\n        translate(cp) {\n            attachable(anchor,spin, two_d=true, r=r) {\n                if (r>0) _circle(r=r);\n                children();\n            }\n        }\n    } else {\n        r = get_radius(r=r, d=d, dflt=1);\n        attachable(anchor,spin, two_d=true, r=r) {\n            if (r>0) _circle(r=r);\n            children();\n        }\n    }\n}\n\n\n\n// Function&Module: ellipse()\n// Synopsis: Creates the approximation of an ellipse or a circle.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: circle(), circle_2tangents(), circle_3points()\n// Usage: As a Module\n//   ellipse(r|d=, [realign=], [circum=], [uniform=], ...) [ATTACHMENTS];\n// Usage: As a Function\n//   path = ellipse(r|d=, [realign=], [circum=], [uniform=], ...);\n// Description:\n//   When called as a module, creates a 2D polygon that approximates a circle or ellipse of the given size.\n//   When called as a function, returns a 2D list of points (path) for a polygon that approximates a circle or ellipse of the given size.\n//   By default the point list or shape is the same as the one you would get by scaling the output of {{circle()}}, but with this module your\n//   attachments to the ellipse will retain their dimensions, whereas scaling a circle with attachments will also scale the attachments.\n//   If you set `uniform` to true then you will get a polygon with congruent sides whose vertices lie on the ellipse.  The `circum` option\n//   requests a polygon that circumscribes the requested ellipse (so the specified ellipse will fit into the resulting polygon).  Note that\n//   you cannot gives `circum=true` and `uniform=true`.  \n// Arguments:\n//   r = Radius of the circle or pair of semiaxes of ellipse \n//   ---\n//   d = Diameter of the circle or a pair giving the full X and Y axis lengths.  \n//   realign = If false starts the approximate ellipse with a point on the X+ axis.  If true the midpoint of a side is on the X+ axis and the first point of the polygon is below the X+ axis.  This can result in a very different polygon when $fn is small.  Default: false\n//   uniform = If true, the polygon that approximates the circle will have segments of equal length.  Only works if `circum=false`.  Default: false\n//   circum = If true, the polygon that approximates the circle will be upsized slightly to circumscribe the theoretical circle.  If false, it inscribes the theoretical circle.  If this is true then `uniform` must be false.  Default: false\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Example(2D): By Radius\n//   ellipse(r=25);\n// Example(2D): By Diameter\n//   ellipse(d=50);\n// Example(2D): Anchoring\n//   ellipse(d=50, anchor=FRONT);\n// Example(2D): Spin\n//   ellipse(d=50, anchor=FRONT, spin=45);\n// Example(NORENDER): Called as Function\n//   path = ellipse(d=50, anchor=FRONT, spin=45);\n// Example(2D,NoAxes): Uniformly sampled hexagon at the top, regular non-uniform one at the bottom\n//   r=[10,3];\n//   ydistribute(7){\n//     union(){\n//       stroke([ellipse(r=r, $fn=100)],width=0.05,color=\"blue\");\n//       stroke([ellipse(r=r, $fn=6)],width=0.1,color=\"red\");\n//     }\n//     union(){\n//       stroke([ellipse(r=r, $fn=100)],width=0.05,color=\"blue\");\n//       stroke([ellipse(r=r, $fn=6,uniform=true)],width=0.1,color=\"red\");\n//     }\n//   }\n// Example(2D): The realigned hexagons are even more different\n//   r=[10,3];\n//   ydistribute(7){\n//     union(){\n//       stroke([ellipse(r=r, $fn=100)],width=0.05,color=\"blue\");\n//       stroke([ellipse(r=r, $fn=6,realign=true)],width=0.1,color=\"red\");\n//     }\n//     union(){\n//       stroke([ellipse(r=r, $fn=100)],width=0.05,color=\"blue\");\n//       stroke([ellipse(r=r, $fn=6,realign=true,uniform=true)],width=0.1,color=\"red\");\n//     }\n//   }\n// Example(2D): For odd $fn the result may not look very elliptical:\n//    r=[10,3];\n//    ydistribute(7){\n//      union(){\n//        stroke([ellipse(r=r, $fn=100)],width=0.05,color=\"blue\");\n//        stroke([ellipse(r=r, $fn=5,realign=false)],width=0.1,color=\"red\");\n//      }\n//      union(){\n//        stroke([ellipse(r=r, $fn=100)],width=0.05,color=\"blue\");\n//        stroke([ellipse(r=r, $fn=5,realign=false,uniform=true)],width=0.1,color=\"red\");\n//      }\n//    }\n// Example(2D): The same ellipse, turned 90 deg, gives a very different result:\n//   r=[3,10];\n//   xdistribute(7){\n//     union(){\n//       stroke([ellipse(r=r, $fn=100)],width=0.1,color=\"blue\");\n//       stroke([ellipse(r=r, $fn=5,realign=false)],width=0.2,color=\"red\");\n//     }\n//     union(){\n//       stroke([ellipse(r=r, $fn=100)],width=0.1,color=\"blue\");\n//       stroke([ellipse(r=r, $fn=5,realign=false,uniform=true)],width=0.2,color=\"red\");\n//     }\n//   }\nmodule ellipse(r, d, realign=false, circum=false, uniform=false, anchor=CENTER, spin=0)\n{\n    r = force_list(get_radius(r=r, d=d, dflt=1),2);\n    dummy = assert(is_vector(r,2) && all_positive(r), \"Invalid radius or diameter for ellipse\");\n    sides = segs(max(r));\n    sc = circum? (1 / cos(180/sides)) : 1;\n    rx = r.x * sc;\n    ry = r.y * sc;\n    attachable(anchor,spin, two_d=true, r=[rx,ry]) {\n        if (uniform) {\n            check = assert(!circum, \"Circum option not allowed when \\\"uniform\\\" is true\");\n            polygon(ellipse(r,realign=realign, circum=circum, uniform=true));\n        }\n        else if (rx < ry) {\n            xscale(rx/ry) {\n                zrot(realign? 180/sides : 0) {\n                    circle(r=ry, $fn=sides);\n                }\n            }\n        } else {\n            yscale(ry/rx) {\n                zrot(realign? 180/sides : 0) {\n                    circle(r=rx, $fn=sides);\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Iterative refinement to produce an inscribed polygon\n// in an ellipse whose side lengths are all equal\nfunction _ellipse_refine(a,b,N, _theta=[]) =\n   len(_theta)==0? _ellipse_refine(a,b,N,lerpn(0,360,N,endpoint=false))\n   :\n   let(\n       pts = [for(t=_theta) [a*cos(t),b*sin(t)]],\n       lenlist= path_segment_lengths(pts,closed=true),\n       meanlen = mean(lenlist),\n       error = lenlist/meanlen\n   )\n   all_equal(error,EPSILON) ? pts\n   :\n   let(\n        dtheta = [each deltas(_theta),\n                  360-last(_theta)],\n        newdtheta = [for(i=idx(dtheta)) dtheta[i]/error[i]],\n        adjusted = [0,each cumsum(list_head(newdtheta / sum(newdtheta) * 360))]\n   )\n   _ellipse_refine(a,b,N,adjusted);\n\n\n\n\nfunction _ellipse_refine_realign(a,b,N, _theta=[],i=0) =\n   len(_theta)==0?\n         _ellipse_refine_realign(a,b,N, count(N-1,180/N,360/N))\n   :\n   let(\n       pts = [for(t=_theta) [a*cos(t),b*sin(t)],\n              [a*cos(_theta[0]), -b*sin(_theta[0])]],\n       lenlist= path_segment_lengths(pts,closed=true),\n       meanlen = mean(lenlist),\n       error = lenlist/meanlen\n   )\n   all_equal(error,EPSILON) ? pts\n   :\n   let(\n        dtheta = [each deltas(_theta),\n                  360-last(_theta)-_theta[0],\n                  2*_theta[0]],\n        newdtheta = [for(i=idx(dtheta)) dtheta[i]/error[i]],\n        normdtheta = newdtheta / sum(newdtheta) * 360,\n        adjusted = cumsum([last(normdtheta)/2, each list_head(normdtheta, -3)])\n   )\n   _ellipse_refine_realign(a,b,N,adjusted, i+1);\n\n\n\nfunction ellipse(r, d, realign=false, circum=false, uniform=false, anchor=CENTER, spin=0) =\n    let(\n        r = force_list(get_radius(r=r, d=d, dflt=1),2),\n        sides = segs(max(r))\n    )\n    assert(all_positive(r), \"All components of the radius must be positive.\")\n    uniform\n      ? assert(!circum, \"Circum option not allowed when \\\"uniform\\\" is true\")\n        reorient(anchor,spin,\n            two_d=true, r=[r.x,r.y],\n            p=realign\n              ? reverse(_ellipse_refine_realign(r.x,r.y,sides))\n              : reverse_polygon(_ellipse_refine(r.x,r.y,sides))\n        )\n      : let(\n            offset = realign? 180/sides : 0,\n            sc = circum? (1 / cos(180/sides)) : 1,\n            rx = r.x * sc,\n            ry = r.y * sc,\n            pts = [\n                for (i=[0:1:sides-1])\n                let (a = 360-offset-i*360/sides)\n                [rx*cos(a), ry*sin(a)]\n            ]\n        ) reorient(anchor,spin, two_d=true, r=[rx,ry], p=pts);\n\n\n// Section: Polygons\n\n// Function&Module: regular_ngon()\n// Synopsis: Creates a regular N-sided polygon.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: debug_polygon(), circle(), pentagon(), hexagon(), octagon(), ellipse(), star()\n// Usage:\n//   regular_ngon(n, r|d=|or=|od=, [realign=]) [ATTACHMENTS];\n//   regular_ngon(n, ir=|id=, [realign=]) [ATTACHMENTS];\n//   regular_ngon(n, side=, [realign=]) [ATTACHMENTS];\n// Description:\n//   When called as a function, returns a 2D path for a regular N-sided polygon.\n//   When called as a module, creates a 2D regular N-sided polygon.\n// Arguments:\n//   n = The number of sides.\n//   r/or = Outside radius, at points.\n//   ---\n//   d/od = Outside diameter, at points.\n//   ir = Inside radius, at center of sides.\n//   id = Inside diameter, at center of sides.\n//   side = Length of each side.\n//   rounding = Radius of rounding for the tips of the polygon.  Default: 0 (no rounding)\n//   realign = If false, vertex 0 will lie on the X+ axis.  If true then the midpoint of the last edge will lie on the X+ axis, and vertex 0 will be below the X axis.    Default: false\n//   align_tip = If given as a 2D vector, rotates the whole shape so that the first vertex points in that direction.  This occurs before spin.\n//   align_side = If given as a 2D vector, rotates the whole shape so that the normal of side0 points in that direction.  This occurs before spin.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Extra Anchors:\n//   \"tip0\", \"tip1\", etc. = Each tip has an anchor, pointing outwards.\n//   \"side0\", \"side1\", etc. = The center of each side has an anchor, pointing outwards.\n// Example(2D): by Outer Size\n//   regular_ngon(n=5, or=30);\n//   regular_ngon(n=5, od=60);\n// Example(2D): by Inner Size\n//   regular_ngon(n=5, ir=30);\n//   regular_ngon(n=5, id=60);\n// Example(2D): by Side Length\n//   regular_ngon(n=8, side=20);\n// Example(2D): Realigned\n//   regular_ngon(n=8, side=20, realign=true);\n// Example(2D): Alignment by Tip\n//   regular_ngon(n=5, r=30, align_tip=BACK+RIGHT)\n//       attach(\"tip0\", FWD) color(\"blue\")\n//           stroke([[0,0],[0,7]], endcap2=\"arrow2\");\n// Example(2D): Alignment by Side\n//   regular_ngon(n=5, r=30, align_side=BACK+RIGHT)\n//       attach(\"side0\", FWD) color(\"blue\")\n//           stroke([[0,0],[0,7]], endcap2=\"arrow2\");\n// Example(2D): Rounded\n//   regular_ngon(n=5, od=100, rounding=20, $fn=20);\n// Example(2D): Called as Function\n//   stroke(closed=true, regular_ngon(n=6, or=30));\nfunction regular_ngon(n=6, r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0, _mat, _anchs) =\n    assert(is_int(n) && n>=3)\n    assert(is_undef(align_tip) || is_vector(align_tip))\n    assert(is_undef(align_side) || is_vector(align_side))\n    assert(is_undef(align_tip) || is_undef(align_side), \"Can only specify one of align_tip and align-side\")\n    let(\n        sc = 1/cos(180/n),\n        ir = is_finite(ir)? ir*sc : undef,\n        id = is_finite(id)? id*sc : undef,\n        side = is_finite(side)? side/2/sin(180/n) : undef,\n        r = get_radius(r1=ir, r2=or, r=r, d1=id, d2=od, d=d, dflt=side)\n    )\n    assert(!is_undef(r), \"regular_ngon(): need to specify one of r, d, or, od, ir, id, side.\")\n    assert(all_positive([r]), \"polygon size must be a positive value\")\n    let(\n        inset = opp_ang_to_hyp(rounding, (180-360/n)/2),\n        mat = !is_undef(_mat) ? _mat :\n            ( realign? zrot(-180/n) : ident(4)) * (\n                !is_undef(align_tip)? rot(from=RIGHT, to=point2d(align_tip)) :\n                !is_undef(align_side)? rot(from=RIGHT, to=point2d(align_side)) * zrot(180/n) :\n                1\n            ),\n        path4 = rounding==0? ellipse(r=r, $fn=n) : (\n            let(\n                steps = floor(segs(r)/n),\n                step = 360/n/steps,\n                path2 = [\n                    for (i = [0:1:n-1]) let(\n                        a = 360 - i*360/n,\n                        p = polar_to_xy(r-inset, a)\n                    )\n                    each arc(n=steps, cp=p, r=rounding, start=a+180/n, angle=-360/n)\n                ],\n                maxx_idx = max_index(column(path2,0)),\n                path3 = list_rotate(path2,maxx_idx)\n            ) path3\n        ),\n        path = apply(mat, path4),\n        anchors = !is_undef(_anchs) ? _anchs :\n            !is_string(anchor)? [] : [\n            for (i = [0:1:n-1]) let(\n                a1 = 360 - i*360/n,\n                a2 = a1 - 360/n,\n                p1 = apply(mat, polar_to_xy(r,a1)),\n                p2 = apply(mat, polar_to_xy(r,a2)),\n                tipp = apply(mat, polar_to_xy(r-inset+rounding,a1)),\n                pos = (p1+p2)/2\n            ) each [\n                named_anchor(str(\"tip\",i), tipp, unit(tipp,BACK), 0),\n                named_anchor(str(\"side\",i), pos, unit(pos,BACK), 0),\n            ]\n        ]\n    ) reorient(anchor,spin, two_d=true, path=path, extent=false, p=path, anchors=anchors);\n\n\nmodule regular_ngon(n=6, r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0) {\n    sc = 1/cos(180/n);\n    ir = is_finite(ir)? ir*sc : undef;\n    id = is_finite(id)? id*sc : undef;\n    side = is_finite(side)? side/2/sin(180/n) : undef;\n    r = get_radius(r1=ir, r2=or, r=r, d1=id, d2=od, d=d, dflt=side);\n    check = assert(!is_undef(r), \"regular_ngon(): need to specify one of r, d, or, od, ir, id, side.\")\n            assert(all_positive([r]), \"polygon size must be a positive value\");\n    mat = ( realign? zrot(-180/n) : ident(4) ) * (\n            !is_undef(align_tip)? rot(from=RIGHT, to=point2d(align_tip)) :\n            !is_undef(align_side)? rot(from=RIGHT, to=point2d(align_side)) * zrot(180/n) :\n            1\n        );\n    inset = opp_ang_to_hyp(rounding, (180-360/n)/2);\n    anchors = [\n        for (i = [0:1:n-1]) let(\n            a1 = 360 - i*360/n,\n            a2 = a1 - 360/n,\n            p1 = apply(mat, polar_to_xy(r,a1)),\n            p2 = apply(mat, polar_to_xy(r,a2)),\n            tipp = apply(mat, polar_to_xy(r-inset+rounding,a1)),\n            pos = (p1+p2)/2\n        ) each [\n            named_anchor(str(\"tip\",i), tipp, unit(tipp,BACK), 0),\n            named_anchor(str(\"side\",i), pos, unit(pos,BACK), 0),\n        ]\n    ];\n    path = regular_ngon(n=n, r=r, rounding=rounding, _mat=mat, _anchs=anchors);\n    attachable(anchor,spin, two_d=true, path=path, extent=false, anchors=anchors) {\n        polygon(path);\n        children();\n    }\n}\n\n\n// Function&Module: pentagon()\n// Synopsis: Creates a regular pentagon.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: circle(), regular_ngon(), hexagon(), octagon(), ellipse(), star()\n// Usage:\n//   pentagon(or|od=, [realign=], [align_tip=|align_side=]) [ATTACHMENTS];\n//   pentagon(ir=|id=, [realign=], [align_tip=|align_side=]) [ATTACHMENTS];\n//   pentagon(side=, [realign=], [align_tip=|align_side=]) [ATTACHMENTS];\n// Usage: as function\n//   path = pentagon(...);\n// Description:\n//   When called as a function, returns a 2D path for a regular pentagon.\n//   When called as a module, creates a 2D regular pentagon.\n// Arguments:\n//   r/or = Outside radius, at points.\n//   ---\n//   d/od = Outside diameter, at points.\n//   ir = Inside radius, at center of sides.\n//   id = Inside diameter, at center of sides.\n//   side = Length of each side.\n//   rounding = Radius of rounding for the tips of the polygon.  Default: 0 (no rounding)\n//   realign = If false, vertex 0 will lie on the X+ axis.  If true then the midpoint of the last edge will lie on the X+ axis, and vertex 0 will be below the X axis.    Default: false\n//   align_tip = If given as a 2D vector, rotates the whole shape so that the first vertex points in that direction.  This occurs before spin.\n//   align_side = If given as a 2D vector, rotates the whole shape so that the normal of side0 points in that direction.  This occurs before spin.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Extra Anchors:\n//   \"tip0\" ... \"tip4\" = Each tip has an anchor, pointing outwards.\n//   \"side0\" ... \"side4\" = The center of each side has an anchor, pointing outwards.\n// Example(2D): by Outer Size\n//   pentagon(or=30);\n//   pentagon(od=60);\n// Example(2D): by Inner Size\n//   pentagon(ir=30);\n//   pentagon(id=60);\n// Example(2D): by Side Length\n//   pentagon(side=20);\n// Example(2D): Realigned\n//   pentagon(side=20, realign=true);\n// Example(2D): Alignment by Tip\n//   pentagon(r=30, align_tip=BACK+RIGHT)\n//       attach(\"tip0\", FWD) color(\"blue\")\n//           stroke([[0,0],[0,7]], endcap2=\"arrow2\");\n// Example(2D): Alignment by Side\n//   pentagon(r=30, align_side=BACK+RIGHT)\n//       attach(\"side0\", FWD) color(\"blue\")\n//           stroke([[0,0],[0,7]], endcap2=\"arrow2\");\n// Example(2D): Rounded\n//   pentagon(od=100, rounding=20, $fn=20);\n// Example(2D): Called as Function\n//   stroke(closed=true, pentagon(or=30));\nfunction pentagon(r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0) =\n    regular_ngon(n=5, r=r, d=d, or=or, od=od, ir=ir, id=id, side=side, rounding=rounding, realign=realign, align_tip=align_tip, align_side=align_side, anchor=anchor, spin=spin);\n\n\nmodule pentagon(r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0)\n    regular_ngon(n=5, r=r, d=d, or=or, od=od, ir=ir, id=id, side=side, rounding=rounding, realign=realign, align_tip=align_tip, align_side=align_side, anchor=anchor, spin=spin) children();\n\n\n// Function&Module: hexagon()\n// Synopsis: Creates a regular hexagon.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: circle(), regular_ngon(), pentagon(), octagon(), ellipse(), star()\n// Usage: As Module\n//   hexagon(r/or, [realign=], <align_tip=|align_side=>, [rounding=], ...) [ATTACHMENTS];\n//   hexagon(d=/od=, ...) [ATTACHMENTS];\n//   hexagon(ir=/id=, ...) [ATTACHMENTS];\n//   hexagon(side=, ...) [ATTACHMENTS];\n// Usage: As Function\n//   path = hexagon(...);\n// Description:\n//   When called as a function, returns a 2D path for a regular hexagon.\n//   When called as a module, creates a 2D regular hexagon.\n// Arguments:\n//   r/or = Outside radius, at points.\n//   ---\n//   d/od = Outside diameter, at points.\n//   ir = Inside radius, at center of sides.\n//   id = Inside diameter, at center of sides.\n//   side = Length of each side.\n//   rounding = Radius of rounding for the tips of the polygon.  Default: 0 (no rounding)\n//   realign = If false, vertex 0 will lie on the X+ axis.  If true then the midpoint of the last edge will lie on the X+ axis, and vertex 0 will be below the X axis.    Default: false\n//   align_tip = If given as a 2D vector, rotates the whole shape so that the first vertex points in that direction.  This occurs before spin.\n//   align_side = If given as a 2D vector, rotates the whole shape so that the normal of side0 points in that direction.  This occurs before spin.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Extra Anchors:\n//   \"tip0\" ... \"tip5\" = Each tip has an anchor, pointing outwards.\n//   \"side0\" ... \"side5\" = The center of each side has an anchor, pointing outwards.\n// Example(2D): by Outer Size\n//   hexagon(or=30);\n//   hexagon(od=60);\n// Example(2D): by Inner Size\n//   hexagon(ir=30);\n//   hexagon(id=60);\n// Example(2D): by Side Length\n//   hexagon(side=20);\n// Example(2D): Realigned\n//   hexagon(side=20, realign=true);\n// Example(2D): Alignment by Tip\n//   hexagon(r=30, align_tip=BACK+RIGHT)\n//       attach(\"tip0\", FWD) color(\"blue\")\n//           stroke([[0,0],[0,7]], endcap2=\"arrow2\");\n// Example(2D): Alignment by Side\n//   hexagon(r=30, align_side=BACK+RIGHT)\n//       attach(\"side0\", FWD) color(\"blue\")\n//           stroke([[0,0],[0,7]], endcap2=\"arrow2\");\n// Example(2D): Rounded\n//   hexagon(od=100, rounding=20, $fn=20);\n// Example(2D): Called as Function\n//   stroke(closed=true, hexagon(or=30));\nfunction hexagon(r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0) =\n    regular_ngon(n=6, r=r, d=d, or=or, od=od, ir=ir, id=id, side=side, rounding=rounding, realign=realign, align_tip=align_tip, align_side=align_side, anchor=anchor, spin=spin);\n\n\nmodule hexagon(r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0)\n    regular_ngon(n=6, r=r, d=d, or=or, od=od, ir=ir, id=id, side=side, rounding=rounding, realign=realign, align_tip=align_tip, align_side=align_side, anchor=anchor, spin=spin) children();\n\n\n// Function&Module: octagon()\n// Synopsis: Creates a regular octagon.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: circle(), regular_ngon(), pentagon(), hexagon(), ellipse(), star()\n// Usage: As Module\n//   octagon(r/or, [realign=], [align_tip=|align_side=], [rounding=], ...) [ATTACHMENTS];\n//   octagon(d=/od=, ...) [ATTACHMENTS];\n//   octagon(ir=/id=, ...) [ATTACHMENTS];\n//   octagon(side=, ...) [ATTACHMENTS];\n// Usage: As Function\n//   path = octagon(...);\n// Description:\n//   When called as a function, returns a 2D path for a regular octagon.\n//   When called as a module, creates a 2D regular octagon.\n// Arguments:\n//   r/or = Outside radius, at points.\n//   d/od = Outside diameter, at points.\n//   ir = Inside radius, at center of sides.\n//   id = Inside diameter, at center of sides.\n//   side = Length of each side.\n//   rounding = Radius of rounding for the tips of the polygon.  Default: 0 (no rounding)\n//   realign = If false, vertex 0 will lie on the X+ axis.  If true then the midpoint of the last edge will lie on the X+ axis, and vertex 0 will be below the X axis.    Default: false\n//   align_tip = If given as a 2D vector, rotates the whole shape so that the first vertex points in that direction.  This occurs before spin.\n//   align_side = If given as a 2D vector, rotates the whole shape so that the normal of side0 points in that direction.  This occurs before spin.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Extra Anchors:\n//   \"tip0\" ... \"tip7\" = Each tip has an anchor, pointing outwards.\n//   \"side0\" ... \"side7\" = The center of each side has an anchor, pointing outwards.\n// Example(2D): by Outer Size\n//   octagon(or=30);\n//   octagon(od=60);\n// Example(2D): by Inner Size\n//   octagon(ir=30);\n//   octagon(id=60);\n// Example(2D): by Side Length\n//   octagon(side=20);\n// Example(2D): Realigned\n//   octagon(side=20, realign=true);\n// Example(2D): Alignment by Tip\n//   octagon(r=30, align_tip=BACK+RIGHT)\n//       attach(\"tip0\", FWD) color(\"blue\")\n//           stroke([[0,0],[0,7]], endcap2=\"arrow2\");\n// Example(2D): Alignment by Side\n//   octagon(r=30, align_side=BACK+RIGHT)\n//       attach(\"side0\", FWD) color(\"blue\")\n//           stroke([[0,0],[0,7]], endcap2=\"arrow2\");\n// Example(2D): Rounded\n//   octagon(od=100, rounding=20, $fn=20);\n// Example(2D): Called as Function\n//   stroke(closed=true, octagon(or=30));\nfunction octagon(r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0) =\n    regular_ngon(n=8, r=r, d=d, or=or, od=od, ir=ir, id=id, side=side, rounding=rounding, realign=realign, align_tip=align_tip, align_side=align_side, anchor=anchor, spin=spin);\n\n\nmodule octagon(r, d, or, od, ir, id, side, rounding=0, realign=false, align_tip, align_side, anchor=CENTER, spin=0)\n    regular_ngon(n=8, r=r, d=d, or=or, od=od, ir=ir, id=id, side=side, rounding=rounding, realign=realign, align_tip=align_tip, align_side=align_side, anchor=anchor, spin=spin) children();\n\n\n// Function&Module: right_triangle()\n// Synopsis: Creates a right triangle.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: square(), rect(), regular_ngon(), pentagon(), hexagon(), octagon(), star()\n// Usage: As Module\n//   right_triangle(size, [center], ...) [ATTACHMENTS];\n// Usage: As Function\n//   path = right_triangle(size, [center], ...);\n// Description:\n//   When called as a module, creates a right triangle with the Hypotenuse in the X+Y+ quadrant.\n//   When called as a function, returns a 2D path for a right triangle with the Hypotenuse in the X+Y+ quadrant.\n// Arguments:\n//   size = The width and length of the right triangle, given as a scalar or an XY vector.\n//   center = If true, forces `anchor=CENTER`.  If false, forces `anchor=[-1,-1]`.  Default: undef (use `anchor=`)\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Extra Anchors:\n//   hypot = Center of angled side, perpendicular to that side.\n// Example(2D):\n//   right_triangle([40,30]);\n// Example(2D): With `center=true`\n//   right_triangle([40,30], center=true);\n// Example(2D): Standard Anchors\n//   right_triangle([80,30], center=true)\n//       show_anchors(custom=false);\n//   color([0.5,0.5,0.5,0.1])\n//       square([80,30], center=true);\n// Example(2D): Named Anchors\n//   right_triangle([80,30], center=true)\n//       show_anchors(std=false);\nfunction right_triangle(size=[1,1], center, anchor, spin=0) =\n    let(\n        size = is_num(size)? [size,size] : size,\n        anchor = get_anchor(anchor, center, [-1,-1], [-1,-1])\n    )\n    assert(is_vector(size,2))\n    assert(min(size)>0, \"Must give positive size\")\n    let(\n        path = [ [size.x/2,-size.y/2], [-size.x/2,-size.y/2], [-size.x/2,size.y/2] ],\n        anchors = [\n            named_anchor(\"hypot\", CTR, unit([size.y,size.x])),\n        ]\n    ) reorient(anchor,spin, two_d=true, size=[size.x,size.y], anchors=anchors, p=path);\n\nmodule right_triangle(size=[1,1], center, anchor, spin=0) {\n    size = is_num(size)? [size,size] : size;\n    anchor = get_anchor(anchor, center, [-1,-1], [-1,-1]);\n    check = assert(is_vector(size,2));\n    path = right_triangle(size, anchor=\"origin\");\n    anchors = [\n        named_anchor(\"hypot\", CTR, unit([size.y,size.x])),\n    ];\n    attachable(anchor,spin, two_d=true, size=[size.x,size.y], anchors=anchors) {\n        polygon(path);\n        children();\n    }\n}\n\n\n// Function&Module: trapezoid()\n// Synopsis: Creates a trapezoid with parallel top and bottom sides.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: rect(), square()\n// Usage: As Module\n//   trapezoid(h, w1, w2, [shift=], [rounding=], [chamfer=], [flip=], ...) [ATTACHMENTS];\n//   trapezoid(h, w1, ang=, [rounding=], [chamfer=], [flip=], ...) [ATTACHMENTS];\n//   trapezoid(h, w2=, ang=, [rounding=], [chamfer=], [flip=], ...) [ATTACHMENTS];\n//   trapezoid(w1=, w2=, ang=, [rounding=], [chamfer=], [flip=], ...) [ATTACHMENTS];\n// Usage: As Function\n//   path = trapezoid(...);\n// Description:\n//   When called as a function, returns a 2D path for a trapezoid with parallel front and back (top and bottom) sides. \n//   When called as a module, creates a 2D trapezoid.  You can specify the trapezoid by giving its height and the lengths\n//   of its two bases.  Alternatively, you can omit one of those parameters and specify the lower angle(s).\n//   The shift parameter, which cannot be combined with ang, shifts the back (top) of the trapezoid to the right.  \n// Arguments:\n//   h = The Y axis height of the trapezoid.\n//   w1 = The X axis width of the front end of the trapezoid.\n//   w2 = The X axis width of the back end of the trapezoid.\n//   ---\n//   ang = Specify the bottom angle(s) of the trapezoid.  Can give a scalar for an isosceles trapezoid or a list of two angles, the left angle and right angle.  You must omit one of `h`, `w1`, or `w2` to allow the freedom to control the angles. \n//   shift = Scalar value to shift the back of the trapezoid along the X axis by.  Cannot be combined with ang.  Default: 0\n//   rounding = The rounding radius for the corners.  If given as a list of four numbers, gives individual radii for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-]. Default: 0 (no rounding)\n//   chamfer = The Length of the chamfer faces at the corners.  If given as a list of four numbers, gives individual chamfers for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-].  Default: 0 (no chamfer)\n//   flip = If true, negative roundings and chamfers will point forward and back instead of left and right.  Default: `false`.\n//   atype = The type of anchoring to use with `anchor=`.  Valid opptions are \"box\" and \"perim\".  This lets you choose between putting anchors on the rounded or chamfered perimeter, or on the square bounding box of the shape. Default: \"box\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Anchor Types:\n//   box = Anchor is with respect to the rectangular bounding box of the shape.\n//   perim = Anchors are placed along the rounded or chamfered perimeter of the shape.\n// Examples(2D):\n//   trapezoid(h=30, w1=40, w2=20);\n//   trapezoid(h=25, w1=20, w2=35);\n//   trapezoid(h=20, w1=40, w2=0);\n//   trapezoid(h=20, w1=30, ang=60);\n//   trapezoid(h=20, w1=20, ang=120);\n//   trapezoid(h=20, w2=10, ang=60);\n//   trapezoid(h=20, w1=50, ang=[40,60]);\n//   trapezoid(w1=30, w2=10, ang=[30,90]);\n// Example(2D): Chamfered Trapezoid\n//   trapezoid(h=30, w1=60, w2=40, chamfer=5);\n// Example(2D): Negative Chamfered Trapezoid\n//   trapezoid(h=30, w1=60, w2=40, chamfer=-5);\n// Example(2D): Flipped Negative Chamfered Trapezoid\n//   trapezoid(h=30, w1=60, w2=40, chamfer=-5, flip=true);\n// Example(2D): Rounded Trapezoid\n//   trapezoid(h=30, w1=60, w2=40, rounding=5);\n// Example(2D): Negative Rounded Trapezoid\n//   trapezoid(h=30, w1=60, w2=40, rounding=-5);\n// Example(2D): Flipped Negative Rounded Trapezoid\n//   trapezoid(h=30, w1=60, w2=40, rounding=-5, flip=true);\n// Example(2D): Mixed Chamfering and Rounding\n//   trapezoid(h=30, w1=60, w2=40, rounding=[5,0,-10,0],chamfer=[0,8,0,-15],$fa=1,$fs=1);\n// Example(2D): default anchors for roundings\n//   trapezoid(h=30, w1=100, ang=[66,44],rounding=5) show_anchors();\n// Example(2D): default anchors for negative roundings are still at the trapezoid corners\n//   trapezoid(h=30, w1=100, ang=[66,44],rounding=-5) show_anchors();\n// Example(2D): \"perim\" anchors are at the tips of negative roundings\n//   trapezoid(h=30, w1=100, ang=[66,44],rounding=-5, atype=\"perim\") show_anchors();\n// Example(2D): They point the other direction if you flip them\n//   trapezoid(h=30, w1=100, ang=[66,44],rounding=-5, atype=\"perim\",flip=true) show_anchors();\n// Example(2D): Called as Function\n//   stroke(closed=true, trapezoid(h=30, w1=40, w2=20));\n\nfunction _trapezoid_dims(h,w1,w2,shift,ang) = \n    let(  \n        h = is_def(h)? h\n          : num_defined([w1,w2,each ang])==4 ? (w1-w2) * sin(ang[0]) * sin(ang[1]) / sin(ang[0]+ang[1])\n          : undef\n    )\n    is_undef(h) ? [h]\n  :\n    let(\n        x1 = is_undef(ang[0]) || ang[0]==90 ? 0 : h/tan(ang[0]),\n        x2 = is_undef(ang[1]) || ang[1]==90 ? 0 : h/tan(ang[1]),\n        w1 = is_def(w1)? w1\n           : is_def(w2) && is_def(ang[0]) ? w2 + x1 + x2\n           : undef,\n        w2 = is_def(w2)? w2\n           : is_def(w1) && is_def(ang[0]) ? w1 - x1 - x2\n           : undef,\n        shift = first_defined([shift,(x1-x2)/2])\n    )\n    [h,w1,w2,shift];\n\n\n\nfunction trapezoid(h, w1, w2, ang, shift, chamfer=0, rounding=0, flip=false, anchor=CENTER, spin=0,atype=\"box\", _return_override, angle) =\n    assert(is_undef(angle), \"The angle parameter has been replaced by ang, which specifies trapezoid interior angle\")\n    assert(is_undef(h) || is_finite(h))\n    assert(is_undef(w1) || is_finite(w1))\n    assert(is_undef(w2) || is_finite(w2))\n    assert(is_undef(ang) || is_finite(ang) || is_vector(ang,2))\n    assert(num_defined([h, w1, w2, ang]) == 3, \"Must give exactly 3 of the arguments h, w1, w2, and angle.\")\n    assert(is_undef(shift) || is_finite(shift))\n    assert(num_defined([shift,ang])<2, \"Cannot specify shift and ang together\")\n    assert(is_finite(chamfer)  || is_vector(chamfer,4))\n    assert(is_finite(rounding) || is_vector(rounding,4))\n    let(\n        ang = force_list(ang,2),\n        angOK = len(ang)==2 && (ang==[undef,undef] || (all_positive(ang) && ang[0]<180 && ang[1]<180))\n    )\n    assert(angOK, \"trapezoid angles must be scalar or 2-vector, strictly between 0 and 180\")\n    let(\n        h_w1_w2_shift = _trapezoid_dims(h,w1,w2,shift,ang),\n        h = h_w1_w2_shift[0],\n        w1 = h_w1_w2_shift[1],\n        w2 = h_w1_w2_shift[2],\n        shift = h_w1_w2_shift[3],\n        chamfer = force_list(chamfer,4),\n        rounding = force_list(rounding,4)\n    )\n    assert(all_zero(v_mul(chamfer,rounding),0), \"Cannot specify chamfer and rounding at the same corner\")\n    let(\n        srads = chamfer+rounding, \n        rads = v_abs(srads)\n    )\n    assert(w1>=0 && w2>=0 && h>0, \"Degenerate trapezoid geometry.\")\n    assert(w1+w2>0, \"Degenerate trapezoid geometry.\")\n    let(\n        base = [\n            [ w2/2+shift, h/2],\n            [-w2/2+shift, h/2],\n            [-w1/2,-h/2],\n            [ w1/2,-h/2],\n        ],\n        ang1 = v_theta(base[0]-base[3])-90,\n        ang2 = v_theta(base[1]-base[2])-90,\n        angs = [ang1, ang2, ang2, ang1],\n        qdirs = [[1,1], [-1,1], [-1,-1], [1,-1]],\n        hyps = [for (i=[0:3]) adj_ang_to_hyp(rads[i],angs[i])],\n        offs = [\n            for (i=[0:3]) let(\n                xoff = adj_ang_to_opp(rads[i],angs[i]),\n                a = [xoff, -rads[i]] * qdirs[i].y * (srads[i]<0 && flip? -1 : 1),\n                b = a + [hyps[i] * qdirs[i].x * (srads[i]<0 && !flip? 1 : -1), 0]\n            ) b\n        ],\n        corners = [\n             (\n                let(i = 0)\n                rads[i] == 0? [base[i]]\n              : srads[i] > 0? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[angs[i], 90], r=rads[i])\n              : flip? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[angs[i],-90], r=rads[i])\n              : arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[180+angs[i],90], r=rads[i])\n            ),\n             (\n                let(i = 1)\n                rads[i] == 0? [base[i]] \n              : srads[i] > 0? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[90,180+angs[i]], r=rads[i]) \n              : flip? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[270,180+angs[i]], r=rads[i]) \n              : arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[90,angs[i]], r=rads[i])\n            ),\n             (\n                let(i = 2)\n                rads[i] == 0? [base[i]] \n              : srads[i] > 0? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[180+angs[i],270], r=rads[i]) \n              : flip? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[180+angs[i],90], r=rads[i]) \n              : arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[angs[i],-90], r=rads[i])\n            ),\n             (\n                let(i = 3)\n                rads[i] == 0? [base[i]] \n              : srads[i] > 0? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[-90,angs[i]], r=rads[i]) \n              : flip? arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[90,angs[i]], r=rads[i]) \n              : arc(n=rounding[i]?undef:2, cp=base[i]+offs[i], angle=[270,180+angs[i]], r=rads[i])\n            ),\n        ],\n        path = reverse(flatten(corners)),\n        override = [for(i=[0:3])\n                      if (atype!=\"box\" && srads[i]!=0)\n                         srads[i]>0?\n                             let(dir = unit(base[i]-select(base,i-1)) + unit(base[i]-select(base,i+1)),\n                                pt=[for(seg=pair(corners[i])) let(isect=line_intersection(seg, [base[i],base[i]+dir],SEGMENT,LINE))\n                                                             if (is_def(isect) && isect!=seg[0]) isect]\n                             )\n                             [qdirs[i], [pt[0], undef]]\n                        : flip?\n                            let(  dir=unit(base[i] - select(base,i+(i%2==0?-1:1))))\n                            [qdirs[i], [select(corners[i],i%2==0?0:-1), dir]]\n                        : let( dir = [qdirs[i].x,0])\n                            [qdirs[i], [select(corners[i],i%2==0?-1:0), dir]]]\n    ) _return_override ? [reorient(anchor,spin, two_d=true, size=[w1,h], size2=w2, shift=shift, p=path, override=override),override]\n                       : reorient(anchor,spin, two_d=true, size=[w1,h], size2=w2, shift=shift, p=path, override=override);\n\n\n\n\nmodule trapezoid(h, w1, w2, ang, shift, chamfer=0, rounding=0, flip=false, anchor=CENTER, spin=0, atype=\"box\", angle) {\n    path_over = trapezoid(h=h, w1=w1, w2=w2, ang=ang, shift=shift, chamfer=chamfer, rounding=rounding,\n                          flip=flip, angle=angle,atype=atype,anchor=\"origin\",_return_override=true);\n    path=path_over[0];\n    override = path_over[1];\n    ang = force_list(ang,2);\n    h_w1_w2_shift = _trapezoid_dims(h,w1,w2,shift,ang);\n    h = h_w1_w2_shift[0];\n    w1 = h_w1_w2_shift[1];\n    w2 = h_w1_w2_shift[2];\n    shift = h_w1_w2_shift[3];\n    attachable(anchor,spin, two_d=true, size=[w1,h], size2=w2, shift=shift, override=override) {\n        polygon(path);\n        children();\n    }\n}\n\n\n\n// Function&Module: star()\n// Synopsis: Creates a star-shaped polygon or returns a star-shaped region.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: circle(), ellipse(), regular_ngon()\n// Usage: As Module\n//   star(n, r/or, ir, [realign=], [align_tip=], [align_pit=], ...) [ATTACHMENTS];\n//   star(n, r/or, step=, ...) [ATTACHMENTS];\n// Usage: As Function\n//   path = star(n, r/or, ir, [realign=], [align_tip=], [align_pit=], ...);\n//   path = star(n, r/or, step=, ...);\n// Description:\n//   When called as a function, returns the path needed to create a star polygon with N points.\n//   When called as a module, creates a star polygon with N points.\n// Arguments:\n//   n = The number of stellate tips on the star.\n//   r/or = The radius to the tips of the star.\n//   ir = The radius to the inner corners of the star.\n//   ---\n//   d/od = The diameter to the tips of the star.\n//   id = The diameter to the inner corners of the star.\n//   step = Calculates the radius of the inner star corners by virtually drawing a straight line `step` tips around the star.  2 <= step < n/2\n//   realign = If false, vertex 0 will lie on the X+ axis.  If true then the midpoint of the last edge will lie on the X+ axis, and vertex 0 will be below the X axis.    Default: false\n//   align_tip = If given as a 2D vector, rotates the whole shape so that the first star tip points in that direction.  This occurs before spin.\n//   align_pit = If given as a 2D vector, rotates the whole shape so that the first inner corner is pointed towards that direction.  This occurs before spin.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   atype = Choose \"hull\" or \"intersect\" anchor methods.  Default: \"hull\"\n// Extra Anchors:\n//   \"tip0\" ... \"tip4\" = Each tip has an anchor, pointing outwards.\n//   \"pit0\" ... \"pit4\" = The inside corner between each tip has an anchor, pointing outwards.\n//   \"midpt0\" ... \"midpt4\" = The center-point between each pair of tips has an anchor, pointing outwards.\n// Examples(2D):\n//   star(n=5, r=50, ir=25);\n//   star(n=5, r=50, step=2);\n//   star(n=7, r=50, step=2);\n//   star(n=7, r=50, step=3);\n// Example(2D): Realigned\n//   star(n=7, r=50, step=3, realign=true);\n// Example(2D): Alignment by Tip\n//   star(n=5, ir=15, or=30, align_tip=BACK+RIGHT)\n//       attach(\"tip0\", FWD) color(\"blue\")\n//           stroke([[0,0],[0,7]], endcap2=\"arrow2\");\n// Example(2D): Alignment by Pit\n//   star(n=5, ir=15, or=30, align_pit=BACK+RIGHT)\n//       attach(\"pit0\", FWD) color(\"blue\")\n//           stroke([[0,0],[0,7]], endcap2=\"arrow2\");\n// Example(2D): Called as Function\n//   stroke(closed=true, star(n=5, r=50, ir=25));\nfunction star(n, r, ir, d, or, od, id, step, realign=false, align_tip, align_pit, anchor=CENTER, spin=0, atype=\"hull\", _mat, _anchs) =\n    assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\")  \n    assert(is_undef(align_tip) || is_vector(align_tip))\n    assert(is_undef(align_pit) || is_vector(align_pit))\n    assert(is_undef(align_tip) || is_undef(align_pit), \"Can only specify one of align_tip and align_pit\")\n    assert(is_def(n), \"Must specify number of points, n\")\n    let(\n        r = get_radius(r1=or, d1=od, r=r, d=d),\n        count = num_defined([ir,id,step]),\n        stepOK = is_undef(step) || (step>1 && step<n/2)\n    )\n    assert(count==1, \"Must specify exactly one of ir, id, step\")\n    assert(stepOK,  n==4 ? \"Parameter 'step' not allowed for 4 point stars\"\n                  : n==5 || n==6 ? str(\"Parameter 'step' must be 2 for \",n,\" point stars\")\n                  : str(\"Parameter 'step' must be between 2 and \",floor(n/2-1/2),\" for \",n,\" point stars\"))\n    let(\n        mat = !is_undef(_mat) ? _mat :\n            ( realign? zrot(-180/n) : ident(4) ) * (\n                !is_undef(align_tip)? rot(from=RIGHT, to=point2d(align_tip)) :\n                !is_undef(align_pit)? rot(from=RIGHT, to=point2d(align_pit)) * zrot(180/n) :\n                1\n            ),\n        stepr = is_undef(step)? r : r*cos(180*step/n)/cos(180*(step-1)/n),\n        ir = get_radius(r=ir, d=id, dflt=stepr),\n        offset = realign? 180/n : 0,\n        path1 = [for(i=[2*n:-1:1]) let(theta=180*i/n, radius=(i%2)?ir:r) radius*[cos(theta), sin(theta)]],\n        path = apply(mat, path1),\n        anchors = !is_undef(_anchs) ? _anchs :\n            !is_string(anchor)? [] : [\n            for (i = [0:1:n-1]) let(\n                a1 = 360 - i*360/n,\n                a2 = a1 - 180/n,\n                a3 = a1 - 360/n,\n                p1 = apply(mat, polar_to_xy(r,a1)),\n                p2 = apply(mat, polar_to_xy(ir,a2)),\n                p3 = apply(mat, polar_to_xy(r,a3)),\n                pos = (p1+p3)/2\n            ) each [\n                named_anchor(str(\"tip\",i), p1, unit(p1,BACK), 0),\n                named_anchor(str(\"pit\",i), p2, unit(p2,BACK), 0),\n                named_anchor(str(\"midpt\",i), pos, unit(pos,BACK), 0),\n            ]\n        ]\n    ) reorient(anchor,spin, two_d=true, path=path, p=path, extent=atype==\"hull\", anchors=anchors);\n\n\nmodule star(n, r, ir, d, or, od, id, step, realign=false, align_tip, align_pit, anchor=CENTER, spin=0, atype=\"hull\") {\n    checks =\n        assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\")\n        assert(is_undef(align_tip) || is_vector(align_tip))\n        assert(is_undef(align_pit) || is_vector(align_pit))\n        assert(is_undef(align_tip) || is_undef(align_pit), \"Can only specify one of align_tip and align_pit\");\n    r = get_radius(r1=or, d1=od, r=r, d=d, dflt=undef);\n    stepr = is_undef(step)? r : r*cos(180*step/n)/cos(180*(step-1)/n);\n    ir = get_radius(r=ir, d=id, dflt=stepr);\n    mat = ( realign? zrot(-180/n) : ident(4) ) * (\n            !is_undef(align_tip)? rot(from=RIGHT, to=point2d(align_tip)) :\n            !is_undef(align_pit)? rot(from=RIGHT, to=point2d(align_pit)) * zrot(180/n) :\n            1\n        );\n    anchors = [\n        for (i = [0:1:n-1]) let(\n            a1 = 360 - i*360/n - (realign? 180/n : 0),\n            a2 = a1 - 180/n,\n            a3 = a1 - 360/n,\n            p1 = apply(mat, polar_to_xy(r,a1)),\n            p2 = apply(mat, polar_to_xy(ir,a2)),\n            p3 = apply(mat, polar_to_xy(r,a3)),\n            pos = (p1+p3)/2\n        ) each [\n            named_anchor(str(\"tip\",i), p1, unit(p1,BACK), 0),\n            named_anchor(str(\"pit\",i), p2, unit(p2,BACK), 0),\n            named_anchor(str(\"midpt\",i), pos, unit(pos,BACK), 0),\n        ]\n    ];\n    path = star(n=n, r=r, ir=ir, realign=realign, _mat=mat, _anchs=anchors);\n    attachable(anchor,spin, two_d=true, path=path, extent=atype==\"hull\", anchors=anchors) {\n        polygon(path);\n        children();\n    }\n}\n\n\n\n/// Internal Function: _path_add_jitter()\n/// Topics: Paths\n/// See Also: jittered_poly()\n/// Usage:\n///   jpath = _path_add_jitter(path, [dist], [closed=]);\n/// Description:\n///   Adds tiny jitter offsets to collinear points in the given path so that they\n///   are no longer collinear.  This is useful for preserving subdivision on long\n///   straight segments, when making geometry with `polygon()`, for use with\n///   `linear_exrtrude()` with a `twist()`.\n/// Arguments:\n///   path = The path to add jitter to.\n///   dist = The amount to jitter points by.  Default: 1/512 (0.00195)\n///   ---\n///   closed = If true, treat path like a closed polygon.  Default: true\n/// Example(3D):\n///   d = 100; h = 75; quadsize = 5;\n///   path = pentagon(d=d);\n///   spath = subdivide_path(path, maxlen=quadsize, closed=true);\n///   jpath = _path_add_jitter(spath, closed=true);\n///   linear_extrude(height=h, twist=72, slices=h/quadsize)\n///      polygon(jpath);\nfunction _path_add_jitter(path, dist=1/512, closed=true) =\n    assert(is_path(path))\n    assert(is_finite(dist))\n    assert(is_bool(closed))\n    [\n        path[0],\n        for (i=idx(path,s=1,e=closed?-1:-2)) let(\n            n = line_normal([path[i-1],path[i]])\n        ) path[i] + n * (is_collinear(select(path,i-1,i+1))? (dist * ((i%2)*2-1)) : 0),\n        if (!closed) last(path)\n    ];\n\n\n\n// Module: jittered_poly()\n// Synopsis: Creates a polygon with extra points for smoother twisted extrusions.\n// SynTags: Geom\n// Topics: Extrusions\n// See Also: subdivide_path()\n// Usage:\n//   jittered_poly(path, [dist]);\n// Description:\n//   Creates a 2D polygon shape from the given path in such a way that any extra\n//   collinear points are not stripped out in the way that `polygon()` normally does.\n//   This is useful for refining the mesh of a `linear_extrude()` with twist.\n// Arguments:\n//   path = The path to add jitter to.\n//   dist = The amount to jitter points by.  Default: 1/512 (0.00195)\n// Example:\n//   d = 100; h = 75; quadsize = 5;\n//   path = pentagon(d=d);\n//   spath = subdivide_path(path, maxlen=quadsize, closed=true);\n//   linear_extrude(height=h, twist=72, slices=h/quadsize)\n//      jittered_poly(spath);\nmodule jittered_poly(path, dist=1/512) {\n    no_children($children);\n    polygon(_path_add_jitter(path, dist, closed=true));\n}\n\n\n// Section: Curved 2D Shapes\n\n\n// Function&Module: teardrop2d()\n// Synopsis: Creates a 2D teardrop shape.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: teardrop(), onion()\n// Description:\n//   When called as a module, makes a 2D teardrop shape. Useful for extruding into 3D printable holes as it limits overhang to 45 degrees.  Uses \"intersect\" style anchoring.  \n//   The cap_h parameter truncates the top of the teardrop.  If cap_h is taller than the untruncated form then\n//   the result will be the full, untruncated shape.  The segments of the bottom section of the teardrop are\n//   calculated to be the same as a circle or cylinder when rotated 90 degrees.  (Note that this agreement is poor when `$fn=6` or `$fn=7`.  \n//   If `$fn` is a multiple of four then the teardrop will reach its extremes on all four axes.  The circum option\n//   produces a teardrop that circumscribes the circle; in this case set `realign=true` to get a teardrop that meets its internal extremes\n//   on the axes.  \n//   When called as a function, returns a 2D path to for a teardrop shape.\n//\n// Usage: As Module\n//   teardrop2d(r/d=, [ang], [cap_h]) [ATTACHMENTS];\n// Usage: As Function\n//   path = teardrop2d(r|d=, [ang], [cap_h]);\n//\n// Arguments:\n//   r = radius of circular part of teardrop.  (Default: 1)\n//   ang = angle of hat walls from the Y axis (half the angle of the peak).  (Default: 45 degrees)\n//   cap_h = if given, height above center where the shape will be truncated.\n//   ---\n//   d = diameter of circular portion of bottom. (Use instead of r)\n//   circum = if true, create a circumscribing teardrop.  Default: false\n//   realign = if true, change whether bottom of teardrop is a point or a flat.  Default: false\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//\n// Example(2D): Typical Shape\n//   teardrop2d(r=30, ang=30);\n// Example(2D): Crop Cap\n//   teardrop2d(r=30, ang=30, cap_h=40);\n// Example(2D): Close Crop\n//   teardrop2d(r=30, ang=30, cap_h=20);\nmodule teardrop2d(r, ang=45, cap_h, d, circum=false, realign=false, anchor=CENTER, spin=0)\n{\n    path = teardrop2d(r=r, d=d, ang=ang, circum=circum, realign=realign, cap_h=cap_h);\n    attachable(anchor,spin, two_d=true, path=path, extent=false) {\n        polygon(path);\n        children();\n    }\n}\n\n// _extrapt = true causes the point to be duplicated so a teardrop with no cap\n// has the same point count as one with a cap.  \n\nfunction teardrop2d(r, ang=45, cap_h, d, circum=false, realign=false, anchor=CENTER, spin=0, _extrapt=false) =\n    let(\n        r = get_radius(r=r, d=d, dflt=1),\n        minheight = r*sin(ang),\n        maxheight = r/sin(ang), //cos(90-ang),\n        pointycap = is_undef(cap_h) || cap_h>=maxheight\n    )\n    assert(is_undef(cap_h) || cap_h>=minheight, str(\"cap_h cannot be less than \",minheight,\" but it is \",cap_h))\n    let(\n        cap = [\n                pointycap? [0,maxheight] : [(maxheight-cap_h)*tan(ang), cap_h],\n                r*[cos(ang),sin(ang)]\n              ],\n        fullcircle = ellipse(r=r, realign=realign, circum=circum,spin=90),        \n        \n        // Chose the point on the circle that is lower than the cap but also creates a segment bigger than\n        // seglen/skipfactor so we don't have a teeny tiny segment at the end of the cap, except for the hexagoin\n        // case which is treated specially\n        skipfactor = len(fullcircle)==6 ? 15 : 3,\n        path = !circum ?\n                  let(seglen = norm(fullcircle[0]-fullcircle[1]))\n                  [\n                   each cap,\n                   for (p=fullcircle)\n                          if (\n                               p.y<last(cap).y-EPSILON\n                                 && norm([abs(p.x)-last(cap).x,p.y-last(cap.y)])>seglen/skipfactor\n                             ) p,\n                   xflip(cap[1]),\n                   if (_extrapt || !pointycap) xflip(cap[0])\n                  ]\n             : let(\n                   isect = [for(i=[0:1:len(fullcircle)/4])\n                               let(p = line_intersection(cap, select(fullcircle,[i,i+1]), bounded1=RAY, bounded2=SEGMENT))\n                               if (p) [i,p]\n                           ],\n                   i = last(isect)[0],\n                   p = last(isect)[1]\n               )\n               [\n                 cap[0],\n                 p,\n                 each select(fullcircle,i+1,-i-1-(realign?1:0)),\n                 xflip(p),\n                 if(_extrapt || !pointycap) xflip(cap[0])\n               ]\n    )\n    reorient(anchor,spin, two_d=true, path=path, p=path, extent=false);\n\n\n\n// Function&Module: egg()\n// Synopsis: Creates an egg-shaped 2d object.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: circle(), ellipse(), glued_circles()\n// Usage: As Module\n//   egg(length, r1|d1=, r2|d2=, R|D=) [ATTACHMENTS];\n// Usage: As Function\n//   path = egg(length, r1|d1=, r2|d2=, R|D=);\n// Description:\n//   When called as a module, constructs an egg-shaped object by connecting two circles with convex arcs that are tangent to the circles.\n//   You specify the length of the egg, the radii of the two circles, and the desired arc radius.\n//   Note that because the side radius, R, is often much larger than the end radii, you may get better\n//   results using `$fs` and `$fa` to control the number of semgments rather than using `$fn`.\n//   This shape may be useful for creating a cam. \n//   When called as a function, returns a 2D path for an egg-shaped object. \n// Arguments:\n//   length = length of the egg\n//   r1 = radius of the left-hand circle\n//   r2 = radius of the right-hand circle\n//   R = radius of the joining arcs\n//   ---\n//   d1 = diameter of the left-hand circle\n//   d2 = diameter of the right-hand circle\n//   D = diameter of the joining arcs\n// Extra Anchors:\n//   \"left\" = center of the left circle\n//   \"right\" = center of the right circle\n// Example(2D,NoAxes): This first example shows how the egg is constructed from two circles and two joining arcs.\n//   $fn=100;\n//   color(\"red\") stroke(egg(78,25,12, 60),closed=true);\n//   stroke([left(14,circle(25)),\n//           right(27,circle(12))]);\n// Example(2D,Anim,VPD=250,VPR=[0,0,0]): Varying length between circles\n//   r1 = 25; r2 = 12; R = 65;\n//   length = floor(lookup($t, [[0,55], [0.5,90], [1,55]]));\n//   egg(length,r1,r2,R,$fn=180);\n//   color(\"black\") text(str(\"length=\",length), size=8, halign=\"center\", valign=\"center\");\n// Example(2D,Anim,VPD=250,VPR=[0,0,0]): Varying tangent arc radius R\n//   length = 78; r1 = 25; r2 = 12;\n//   R = floor(lookup($t, [[0,45], [0.5,150], [1,45]]));\n//   egg(length,r1,r2,R,$fn=180);\n//   color(\"black\") text(str(\"R=\",R), size=8, halign=\"center\", valign=\"center\");\n// Example(2D,Anim,VPD=250,VPR=[0,0,0]): Varying circle radius r2\n//   length = 78; r1 = 25; R = 65;\n//   r2 = floor(lookup($t, [[0,5], [0.5,30], [1,5]]));\n//   egg(length,r1,r2,R,$fn=180);\n//   color(\"black\") text(str(\"r2=\",r2), size=8, halign=\"center\", valign=\"center\");\nfunction egg(length, r1, r2, R, d1, d2, D, anchor=CENTER, spin=0) =\n    let(\n        r1 = get_radius(r1=r1,d1=d1),\n        r2 = get_radius(r1=r2,d1=d2),\n        D = get_radius(r1=R, d1=D)\n    )\n    assert(length>0)\n    assert(R>length/2, \"Side radius R must be larger than length/2\")\n    assert(length>r1+r2, \"Length must be longer than 2*(r1+r2)\")\n    assert(length>2*r2, \"Length must be longer than 2*r2\")\n    assert(length>2*r1, \"Length must be longer than 2*r1\")  \n    let(\n        c1 = [-length/2+r1,0],\n        c2 = [length/2-r2,0],\n        Rmin = (r1+r2+norm(c1-c2))/2,\n        Mlist = circle_circle_intersection(R-r1, c1, R-r2, c2),\n        arcparms = reverse([for(M=Mlist) [M, c1+r1*unit(c1-M), c2+r2*unit(c2-M)]]),\n        path = concat(\n                      arc(r=r2, cp=c2, points=[[length/2,0],arcparms[0][2]],endpoint=false),\n                      arc(r=R, cp=arcparms[0][0], points=select(arcparms[0],[2,1]),endpoint=false),\n                      arc(r=r1, points=[arcparms[0][1], [-length/2,0], arcparms[1][1]],endpoint=false),\n                      arc(r=R, cp=arcparms[1][0], points=select(arcparms[1],[1,2]),endpoint=false),\n                      arc(r=r2, cp=c2, points=[arcparms[1][2], [length/2,0]],endpoint=false)\n        ),\n        anchors = [named_anchor(\"left\", c1, BACK, 0),\n                   named_anchor(\"right\", c2, BACK, 0)]\n    )\n    reorient(anchor, spin, two_d=true, path=path, extent=true, p=path, anchors=anchors);\n\nmodule egg(length,r1,r2,R,d1,d2,D,anchor=CENTER, spin=0)\n{\n  path = egg(length,r1,r2,R,d1,d2,D);\n  anchors = [named_anchor(\"left\", [-length/2+r1,0], BACK, 0),\n             named_anchor(\"right\", [length/2-r2,0], BACK, 0)];\n  attachable(anchor, spin, two_d=true, path=path, extent=true, anchors=anchors){\n    polygon(path);\n    children();\n  }\n}\n\n\n// Function&Module: ring()\n// Synopsis: Draws a 2D ring or partial ring or returns a region or path\n// SynTags: Geom, Region, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Regions, Attachable\n// See Also: arc(), circle()\n//\n// Usage: ring or partial ring from radii/diameters\n//   region=ring(n, r1=|d1=, r2=|d2=, [full=], [angle=], [start=]);\n// Usage: ring or partial ring from radius and ring width\n//   region=ring(n, ring_width, r=|d=, [full=], [angle=], [start=]);\n// Usage: ring or partial ring passing through three points\n//   region=ring(n, [ring_width], [r=,d=], points=[P0,P1,P2], [full=]);\n// Usage: ring or partial ring from tangent point on segment `[P0,P1]` to the tangent point on segment `[P1,P2]`.\n//   region=ring(n, [ring_width], corner=[P0,P1,P2], [r=,d=], [r1|d1=], [r2=|d2=], [full=]);\n// Usage: ring or partial ring based on setting a width at the X axis and height above the X axis\n//   region=ring(n, [ring_width], [r=|d=], width=, thickness=, [full=]);\n// Usage: as a module\n//   ring(...) [ATTACHMENTS];\n// Description:\n//   If called as a function returns a region or path for a ring or part of a ring.  If called as a module, creates the corresponding 2D ring or partial ring shape.\n//   The geometry of the ring can be specified using any of the methods supported by {{arc()}}.  If `full` is true (the default) the ring will be complete and the\n//   returned value a region.  If `full` is false then the return is a path describing a partial ring.  The returned path is always clockwise with the larger radius arc first.\n//   A ring has two radii, the inner and outer.  When specifying geometry you must somehow specify one radius, which can be directly with `r=` or `r1=` or by giving a point list with \n//   or without a center point.  You specify the second radius by giving `r=` directly, or `r2=` if you used `r1=` for the first radius, or by giving `ring_width`.  If `ring_width`\n//   the second radius will be larger than the first; if `ring_width` is negative the second radius will be smaller. \n// Arguments:\n//   n = Number of vertices to use for the inner and outer portions of the ring\n//   ring_width = width of the ring.  Can be positive or negative\n//   ---\n//   r1/d1 = inner radius or diameter of the ring\n//   r2/d2 = outer radius or diameter of the ring\n//   r/d = second radius or diameter of ring when r1 or d1 are not given\n//   full = if true create a full ring, if false create a partial ring.  Default: true unless `angle` is given\n//   cp = Centerpoint of ring.\n//   points = Points on the ring boundary.\n//   corner = A path of two segments to fit the ring tangent to.\n//   long = if given with cp and points takes the long arc instead of the default short arc.  Default: false\n//   cw = if given with cp and 2 points takes the arc in the clockwise direction.  Default: false\n//   ccw = if given with cp and 2 points takes the arc in the counter-clockwise direction.  Default: false\n//   width = If given with `thickness`, ring is defined based on an arc with ends on X axis.\n//   thickness = If given with `width`, ring is defined based on an arc with ends on X axis, and this height above the X axis. \n//   start = Start angle of ring.  Default: 0\n//   angle = If scalar, the end angle in degrees relative to start parameter.  If a vector specifies start and end angles of ring.  \n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  (Module only) Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  (Module only) Default: `0`\n// Examples(2D):\n//   ring(r1=5,r2=7, n=32);\n//   ring(r=5,ring_width=-1, n=32);\n//   ring(r=7, n=5, ring_width=-4);\n//   ring(points=[[0,0],[3,3],[5,2]], ring_width=2, n=32);\n//   ring(points=[[0,0],[3,3],[5,2]], r=1, n=32);\n//   ring(cp=[3,3], points=[[4,4],[1,3]], ring_width=1);\n//   ring(corner=[[0,0],[4,4],[7,3]], r2=2, r1=1.5,n=22,full=false);\n//   ring(r1=5,r2=7, angle=[33,110], n=32);\n//   ring(r1=5,r2=7, angle=[0,360], n=32);  // full circle\n//   ring(r=5, points=[[0,0],[3,3],[5,2]], full=false, n=32);\n//   ring(32,-2, cp=[1,1], points=[[4,4],[-3,6]], full=false);\n//   ring(r=5,ring_width=-1, n=32);\n//   ring(points=[[0,0],[3,3],[5,2]], ring_width=2, n=32);\n//   ring(points=[[0,0],[3,3],[5,2]], r=1, n=32);\n//   ring(cp=[3,3], points=[[4,4],[1,3]], ring_width=1);\n// Example(2D): Using corner, the outer radius is the one tangent to the corner\n//   corner = [[0,0],[4,4],[7,3]];\n//   ring(corner=corner, r2=3, r1=2,n=22);\n//   stroke(corner, width=.1,color=\"red\");\n// Example(2D): For inner radius tangent to a corner, specify `r=` and `ring_width`.\n//   corner = [[0,0],[4,4],[7,3]];\n//   ring(corner=corner, r=3, ring_width=1,n=22,full=false);\n//   stroke(corner, width=.1,color=\"red\");\n// Example(2D):\n//   $fn=128;\n//   region = ring(width=5,thickness=1.5,ring_width=2);   \n//   path = ring(width=5,thickness=1.5,ring_width=2,full=false);\n//   stroke(region,width=.25);\n//   color(\"red\") dashed_stroke(path,dashpat=[1.5,1.5],closed=true,width=.25);\n\nmodule ring(n,ring_width,r,r1,r2,angle,d,d1,d2,cp,points,corner, width,thickness,start, long=false, full=true, cw=false,ccw=false, anchor=CENTER, spin=0)\n{\n  R = ring(n=n,r=r,ring_width=ring_width,r1=r1,r2=r2,angle=angle,d=d,d1=d1,d2=d2,cp=cp,points=points,corner=corner, width=width,thickness=thickness,start=start,\n           long=long, full=full, cw=cw, ccw=ccw);\n  attachable(anchor,spin,two_d=true,region=is_region(R)?R:undef,path=is_region(R)?undef:R,extent=false) {\n     region(R);\n     children();\n  }\n}  \n\nfunction ring(n,ring_width,r,r1,r2,angle,d,d1,d2,cp,points,corner, width,thickness,start, long=false, full=true, cw=false,ccw=false) =\n    let(\n        r1 = is_def(r1) ? assert(is_undef(d),\"Cannot define r1 and d1\")r1\n           : is_def(d1) ? d1/2\n           : undef,\n        r2 = is_def(r2) ? assert(is_undef(d),\"Cannot define r2 and d2\")r2\n           : is_def(d2) ? d2/2\n           : undef,\n        r = is_def(r) ? assert(is_undef(d),\"Cannot define r and d\")r\n          : is_def(d) ? d/2\n          : undef,\n        full = is_def(angle) ? false : full\n    )\n    assert(is_undef(start) || is_def(angle), \"start requires angle\")\n    assert(is_undef(angle) || !any_defined([thickness,width,points,corner]), \"Cannot give angle with points, corner, width or thickness\")\n    assert(!is_vector(angle,2) || abs(angle[1]-angle[0]) <= 360, \"angle gives more than 360 degrees\")\n    assert(is_undef(points) || is_path(points,2), str(\"Points must be a 2d vector\",points))\n    assert(!any_defined([points,thickness,width]) || num_defined([r1,r2])==0, \"Cannot give r1, r2, d1, or d2 with points, width or thickness\")\n    is_def(width) && is_def(thickness)?\n       assert(!any_defined([r,cp,points,angle,start]), \"Conflicting or invalid parameters to ring\")\n       assert(all_positive([width,thickness]), \"Width and thickness must be positive\")\n       ring(n=n,r=r,ring_width=ring_width,points=[[width/2,0], [0,thickness], [-width/2,0]],full=full)\n  : full && is_undef(cp) && is_def(points) ?\n       assert(is_def(points) && len(points)==3, \"Without cp given, must provide exactly three points\")\n       assert(num_defined([r,ring_width]), \"Must give r or ring_width with point list\")\n       let(\n            ctr_rad = circle_3points(points),\n            dummy=assert(is_def(ctr_rad[0]), \"Collinear points given to ring()\"),\n            part1 = move(ctr_rad[0],circle(r=ctr_rad[1], $fn=is_def(n) ? n : $fn)),\n            first_r = norm(part1[0]-ctr_rad[0]),\n            r = is_def(r) ? r : first_r+ring_width,\n            part2 = move(ctr_rad[0],circle(r=r, $fn=is_def(n) ? n : $fn))\n       )\n       assert(first_r!=r, \"Ring has zero width\")\n       (first_r>r ? [part1, reverse(part2)] : [part2, reverse(part1)])\n  : full && is_def(corner) ?\n       assert(is_path(corner,2) && len(corner)==3, \"corner must be a list of 3 points\")\n       assert(!any_defined([thickness,width,points,cp,angle.start]), \"Conflicting or invalid parameters to ring\")\n       let(parmok = (all_positive([r1,r2]) && num_defined([r,ring_width])==0) \n                      || (num_defined([r1,r2])==0 && all_positive([r]) && is_finite(ring_width)))\n       assert(parmok, \"With corner must give (r1 and r2) or (r and ring_width), but you gave some other combination\")\n       let(\n           newr1 = is_def(r1) ? min(r1,r2) : min(r,r+ring_width),\n           newr2 = is_def(r2) ? max(r2,r1) : max(r,r+ring_width),\n           data = circle_2tangents(newr2,corner[0],corner[1],corner[2]),\n           cp=data[0]\n       )\n       [move(cp,circle($fn=is_def(n) ? n : $fn, r=newr2)),move(cp, circle( $fn=is_def(n) ? n : $fn, r=newr1))]\n  : full && is_def(cp) && is_def(points) ?\n       assert(in_list(len(points),[1,2]), \"With cp must give a list of one or two points.\")\n       assert(num_defined([r,ring_width]), \"Must give r or ring_width with point list\")\n       let(\n           first_r=norm(points[0]-cp),\n           part1 = move(cp,circle(r=first_r, $fn=is_def(n) ? n : $fn)),\n           r = is_def(r) ? r : first_r+ring_width,\n           part2 = move(cp,circle(r=r, $fn=is_def(n) ? n : $fn))\n       )\n       assert(first_r!=r, \"Ring has zero width\")\n       first_r>r ? [part1, reverse(part2)] : [part2, reverse(part1)]\n  : full || angle==360 || (is_vector(angle,2) && abs(angle[1]-angle[0])==360) ?\n      let(parmok = (all_positive([r1,r2]) && num_defined([r,ring_width])==0) \n                     || (num_defined([r1,r2])==0 && all_positive([r]) && is_finite(ring_width)))\n      assert(parmok, \"Must give (r1 and r2) or (r and ring_width), but you gave some other combination\")\n      let(\n          newr1 = is_def(r1) ? min(r1,r2) : min(r,r+ring_width),\n          newr2 = is_def(r2) ? max(r2,r1) : max(r,r+ring_width),\n          cp = default(cp,[0,0])\n      )\n      [move(cp,circle($fn=is_def(n) ? n : $fn, r=newr2)),move(cp, circle( $fn=is_def(n) ? n : $fn, r=newr1))]\n  :  let(\n         parmRok = (all_positive([r1,r2]) && num_defined([r,ring_width])==0) \n                     || (num_defined([r1,r2])==0 && all_positive([r]) && is_finite(ring_width)),\n         pass_r = any_defined([points,thickness]) ? assert(!any_defined([r1,r2]),\"Cannot give r1, d1, r2, or d2 with a point list or width & thickness\")\n                                                    assert(num_defined([ring_width,r])==1, \"Must defined exactly one of r and ring_width when using a pointlist or width & thickness\")\n                                                    undef \n                : assert(num_defined([r,r2])==1,\"Cannot give r or d and r1 or d1\") first_defined([r,r2]),\n         base_arc = clockwise_polygon(arc(r=pass_r,n=n,angle=angle,cp=cp,points=points, corner=corner, width=width, thickness=thickness,start=start, long=long, cw=cw,ccw=ccw,wedge=true)),\n         center = base_arc[0],\n         arc1 = list_tail(base_arc,1),\n         r_actual = norm(center-arc1[0]),\n         new_r = is_def(ring_width) ? r_actual+ring_width\n               : first_defined([r,r1]),\n         pts = [center+new_r*unit(arc1[0]-center), center+new_r*unit(arc1[floor(len(arc1)/2)]-center), center+new_r*unit(last(arc1)-center)],\n         second=arc(n=n,points=pts),\n         arc2 = is_polygon_clockwise(second) ? second : reverse(second) \n     ) new_r>r_actual ? concat(arc2, reverse(arc1)) : concat(arc1,reverse(arc2));\n\n\n// Function&Module: glued_circles()\n// Synopsis: Creates a shape of two circles joined by a curved waist.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: circle(), ellipse(), egg()\n// Usage: As Module\n//   glued_circles(r/d=, [spread], [tangent], ...) [ATTACHMENTS];\n// Usage: As Function\n//   path = glued_circles(r/d=, [spread], [tangent], ...);\n// Description:\n//   When called as a function, returns a 2D path forming a shape of two circles joined by curved waist.\n//   When called as a module, creates a 2D shape of two circles joined by curved waist.  Uses \"hull\" style anchoring.  \n// Arguments:\n//   r = The radius of the end circles.\n//   spread = The distance between the centers of the end circles.  Default: 10\n//   tangent = The angle in degrees of the tangent point for the joining arcs, measured away from the Y axis.  Default: 30\n//   ---\n//   d = The diameter of the end circles.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Examples(2D):\n//   glued_circles(r=15, spread=40, tangent=45);\n//   glued_circles(d=30, spread=30, tangent=30);\n//   glued_circles(d=30, spread=30, tangent=15);\n//   glued_circles(d=30, spread=30, tangent=-30);\n// Example(2D): Called as Function\n//   stroke(closed=true, glued_circles(r=15, spread=40, tangent=45));\nfunction glued_circles(r, spread=10, tangent=30, d, anchor=CENTER, spin=0) =\n    let(\n        r = get_radius(r=r, d=d, dflt=10),\n        r2 = (spread/2 / sin(tangent)) - r,\n        cp1 = [spread/2, 0],\n        cp2 = [0, (r+r2)*cos(tangent)],\n        sa1 = 90-tangent,\n        ea1 = 270+tangent,\n        lobearc = ea1-sa1,\n        lobesegs = ceil(segs(r)*lobearc/360),\n        sa2 = 270-tangent,\n        ea2 = 270+tangent,\n        subarc = ea2-sa2,\n        arcsegs = ceil(segs(r2)*abs(subarc)/360),\n        // In the tangent zero case the inner curves are missing so we need to complete the two\n        // outer curves.  In the other case the inner curves are present and endpoint=false\n        // prevents point duplication.  \n        path = tangent==0 ?\n                    concat(arc(n=lobesegs+1, r=r, cp=-cp1, angle=[sa1,ea1]),\n                           arc(n=lobesegs+1, r=r, cp=cp1, angle=[sa1+180,ea1+180]))\n                :\n                    concat(arc(n=lobesegs, r=r, cp=-cp1, angle=[sa1,ea1], endpoint=false),\n                           [for(theta=lerpn(ea2+180,ea2-subarc+180,arcsegs,endpoint=false))  r2*[cos(theta),sin(theta)] - cp2],\n                           arc(n=lobesegs, r=r, cp=cp1, angle=[sa1+180,ea1+180], endpoint=false),\n                           [for(theta=lerpn(ea2,ea2-subarc,arcsegs,endpoint=false))  r2*[cos(theta),sin(theta)] + cp2]),\n        maxx_idx = max_index(column(path,0)),\n        path2 = reverse_polygon(list_rotate(path,maxx_idx))\n    ) reorient(anchor,spin, two_d=true, path=path2, extent=true, p=path2);\n\n\nmodule glued_circles(r, spread=10, tangent=30, d, anchor=CENTER, spin=0) {\n    path = glued_circles(r=r, d=d, spread=spread, tangent=tangent);\n    attachable(anchor,spin, two_d=true, path=path, extent=true) {\n        polygon(path);\n        children();\n    }\n}\n\n\n\nfunction _superformula(theta,m1,m2,n1,n2=1,n3=1,a=1,b=1) =\n    pow(pow(abs(cos(m1*theta/4)/a),n2)+pow(abs(sin(m2*theta/4)/b),n3),-1/n1);\n\n// Function&Module: supershape()\n// Synopsis: Creates a 2D [Superformula](https://en.wikipedia.org/wiki/Superformula) shape.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: circle(), ellipse()\n// Usage: As Module\n//   supershape([step],[n=], [m1=], [m2=], [n1=], [n2=], [n3=], [a=], [b=], [r=/d=]) [ATTACHMENTS];\n// Usage: As Function\n//   path = supershape([step], [n=], [m1=], [m2=], [n1=], [n2=], [n3=], [a=], [b=], [r=/d=]);\n// Description:\n//   When called as a function, returns a 2D path for the outline of the [Superformula](https://en.wikipedia.org/wiki/Superformula) shape.\n//   When called as a module, creates a 2D [Superformula](https://en.wikipedia.org/wiki/Superformula) shape.\n//   Note that the \"hull\" type anchoring (the default) is more intuitive for concave star-like shapes, but the anchor points do not\n//   necesarily lie on the line of the anchor vector, which can be confusing, especially for simpler, ellipse-like shapes.\n//   Note that the default step angle of 0.5 is very fine and can be slow, but due to the complex curves of the supershape,\n//   many points are often required to give a good result.  \n// Arguments:\n//   step = The angle step size for sampling the superformula shape.  Smaller steps are slower but more accurate.  Default: 0.5\n//   ---\n//   n = Produce n points as output.  Alternative to step.  Not to be confused with shape parameters n1 and n2.  \n//   m1 = The m1 argument for the superformula. Default: 4.\n//   m2 = The m2 argument for the superformula. Default: m1.\n//   n1 = The n1 argument for the superformula. Default: 1.\n//   n2 = The n2 argument for the superformula. Default: n1.\n//   n3 = The n3 argument for the superformula. Default: n2.\n//   a = The a argument for the superformula.  Default: 1.\n//   b = The b argument for the superformula.  Default: a.\n//   r = Radius of the shape.  Scale shape to fit in a circle of radius r.\n//   d = Diameter of the shape.  Scale shape to fit in a circle of diameter d.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   atype = Select \"hull\" or \"intersect\" style anchoring.  Default: \"hull\". \n// Example(2D):\n//   supershape(step=0.5,m1=16,m2=16,n1=0.5,n2=0.5,n3=16,r=50);\n// Example(2D): Called as Function\n//   stroke(closed=true, supershape(step=0.5,m1=16,m2=16,n1=0.5,n2=0.5,n3=16,d=100));\n// Examples(2D,Med):\n//   for(n=[2:5]) right(2.5*(n-2)) supershape(m1=4,m2=4,n1=n,a=1,b=2);  // Superellipses\n//   m=[2,3,5,7]; for(i=[0:3]) right(2.5*i) supershape(.5,m1=m[i],n1=1);\n//   m=[6,8,10,12]; for(i=[0:3]) right(2.7*i) supershape(.5,m1=m[i],n1=1,b=1.5);  // m should be even\n//   m=[1,2,3,5]; for(i=[0:3]) fwd(1.5*i) supershape(m1=m[i],n1=0.4);\n//   supershape(m1=5, n1=4, n2=1); right(2.5) supershape(m1=5, n1=40, n2=10);\n//   m=[2,3,5,7]; for(i=[0:3]) right(2.5*i) supershape(m1=m[i], n1=60, n2=55, n3=30);\n//   n=[0.5,0.2,0.1,0.02]; for(i=[0:3]) right(2.5*i) supershape(m1=5,n1=n[i], n2=1.7);\n//   supershape(m1=2, n1=1, n2=4, n3=8);\n//   supershape(m1=7, n1=2, n2=8, n3=4);\n//   supershape(m1=7, n1=3, n2=4, n3=17);\n//   supershape(m1=4, n1=1/2, n2=1/2, n3=4);\n//   supershape(m1=4, n1=4.0,n2=16, n3=1.5, a=0.9, b=9);\n//   for(i=[1:4]) right(3*i) supershape(m1=i, m2=3*i, n1=2);\n//   m=[4,6,10]; for(i=[0:2]) right(i*5) supershape(m1=m[i], n1=12, n2=8, n3=5, a=2.7);\n//   for(i=[-1.5:3:1.5]) right(i*1.5) supershape(m1=2,m2=10,n1=i,n2=1);\n//   for(i=[1:3],j=[-1,1]) translate([3.5*i,1.5*j])supershape(m1=4,m2=6,n1=i*j,n2=1);\n//   for(i=[1:3]) right(2.5*i)supershape(step=.5,m1=88, m2=64, n1=-i*i,n2=1,r=1);\n// Examples:\n//   linear_extrude(height=0.3, scale=0) supershape(step=1, m1=6, n1=0.4, n2=0, n3=6);\n//   linear_extrude(height=5, scale=0) supershape(step=1, b=3, m1=6, n1=3.8, n2=16, n3=10);\nfunction supershape(step=0.5, n, m1=4, m2, n1=1, n2, n3, a=1, b, r, d,anchor=CENTER, spin=0, atype=\"hull\") =\n    assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\")\n    let(\n        n = first_defined([n, ceil(360/step)]),\n        angs = lerpn(360,0,n,endpoint=false),  \n        r = get_radius(r=r, d=d, dflt=undef),\n        m2 = is_def(m2) ? m2 : m1,\n        n2 = is_def(n2) ? n2 : n1,\n        n3 = is_def(n3) ? n3 : n2,\n        b = is_def(b) ? b : a,\n        // superformula returns r(theta), the point in polar coordinates\n        rvals = [for (theta = angs) _superformula(theta=theta,m1=m1,m2=m2,n1=n1,n2=n2,n3=n3,a=a,b=b)],\n        scale = is_def(r) ? r/max(rvals) : 1,\n        path = [for (i=idx(angs)) scale*rvals[i]*[cos(angs[i]), sin(angs[i])]]\n    ) reorient(anchor,spin, two_d=true, path=path, p=path, extent=atype==\"hull\");\n\nmodule supershape(step=0.5,n,m1=4,m2=undef,n1,n2=undef,n3=undef,a=1,b=undef, r=undef, d=undef, anchor=CENTER, spin=0, atype=\"hull\") {\n    check = assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\");\n    path = supershape(step=step,n=n,m1=m1,m2=m2,n1=n1,n2=n2,n3=n3,a=a,b=b,r=r,d=d);\n    attachable(anchor,spin,extent=atype==\"hull\", two_d=true, path=path) {\n        polygon(path);\n        children();\n    }\n}\n\n\n// Function&Module: reuleaux_polygon()\n// Synopsis: Creates a constant-width shape that is not circular.\n// SynTags: Geom, Path\n// Topics: Shapes (2D), Paths (2D), Path Generators, Attachable\n// See Also: regular_ngon(), pentagon(), hexagon(), octagon()\n// Usage: As Module\n//   reuleaux_polygon(n, r|d=, ...) [ATTACHMENTS];\n// Usage: As Function\n//   path = reuleaux_polygon(n, r|d=, ...);\n// Description:\n//   When called as a module, reates a 2D Reuleaux Polygon; a constant width shape that is not circular.  Uses \"intersect\" type anchoring.  \n//   When called as a function, returns a 2D path for a Reulaux Polygon.\n// Arguments:\n//   n = Number of \"sides\" to the Reuleaux Polygon.  Must be an odd positive number.  Default: 3\n//   r = Radius of the shape.  Scale shape to fit in a circle of radius r.\n//   ---\n//   d = Diameter of the shape.  Scale shape to fit in a circle of diameter d.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Extra Anchors:\n//   \"tip0\", \"tip1\", etc. = Each tip has an anchor, pointing outwards.\n// Examples(2D):\n//   reuleaux_polygon(n=3, r=50);\n//   reuleaux_polygon(n=5, d=100);\n// Examples(2D): Standard vector anchors are based on extents\n//   reuleaux_polygon(n=3, d=50) show_anchors(custom=false);\n// Examples(2D): Named anchors exist for the tips\n//   reuleaux_polygon(n=3, d=50) show_anchors(std=false);\nmodule reuleaux_polygon(n=3, r, d, anchor=CENTER, spin=0) {\n    check = assert(n>=3 && (n%2)==1);\n    r = get_radius(r=r, d=d, dflt=1);\n    path = reuleaux_polygon(n=n, r=r);\n    anchors = [\n        for (i = [0:1:n-1]) let(\n            ca = 360 - i * 360/n,\n            cp = polar_to_xy(r, ca)\n        ) named_anchor(str(\"tip\",i), cp, unit(cp,BACK), 0),\n    ];\n    attachable(anchor,spin, two_d=true, path=path, extent=false, anchors=anchors) {\n        polygon(path);\n        children();\n    }\n}\n\n\nfunction reuleaux_polygon(n=3, r, d, anchor=CENTER, spin=0) =\n    assert(n>=3 && (n%2)==1)\n    let(\n        r = get_radius(r=r, d=d, dflt=1),\n        ssegs = max(3,ceil(segs(r)/n)),\n        slen = norm(polar_to_xy(r,0)-polar_to_xy(r,180-180/n)),\n        path = [\n            for (i = [0:1:n-1]) let(\n                ca = 180 - (i+0.5) * 360/n,\n                sa = ca + 180 + (90/n),\n                ea = ca + 180 - (90/n),\n                cp = polar_to_xy(r, ca)\n            ) each arc(n=ssegs-1, r=slen, cp=cp, angle=[sa,ea], endpoint=false)\n        ],\n        anchors = [\n            for (i = [0:1:n-1]) let(\n                ca = 360 - i * 360/n,\n                cp = polar_to_xy(r, ca)\n            ) named_anchor(str(\"tip\",i), cp, unit(cp,BACK), 0),\n        ]\n    ) reorient(anchor,spin, two_d=true, path=path, extent=false, anchors=anchors, p=path);\n\n\n\n// Section: Text\n\n// Module: text()\n// Synopsis: Creates an attachable block of text.\n// SynTags: Geom\n// Topics: Attachments, Text\n// See Also: text3d(), attachable()\n// Usage:\n//   text(text, [size], [font], ...);\n// Description:\n//   Creates a 3D text block that can be attached to other attachable objects.\n//   You cannot attach children to text.\n//   .\n//   Historically fonts were specified by their \"body size\", the height of the metal body\n//   on which the glyphs were cast.  This means the size was an upper bound on the size\n//   of the font glyphs, not a direct measurement of their size.  In digital typesetting,\n//   the metal body is replaced by an invisible box, the em square, whose side length is\n//   defined to be the font's size.  The glyphs can be contained in that square, or they\n//   can extend beyond it, depending on the choices made by the font designer.  As a\n//   result, the meaning of font size varies between fonts: two fonts at the \"same\" size\n//   can differ significantly in the actual size of their characters.  Typographers\n//   customarily specify the size in the units of \"points\".  A point is 1/72 inch.  In\n//   OpenSCAD, you specify the size in OpenSCAD units (often treated as millimeters for 3d\n//   printing), so if you want points you will need to perform a suitable unit conversion.\n//   In addition, the OpenSCAD font system has a bug: if you specify size=s you will\n//   instead get a font whose size is s/0.72.  For many fonts this means the size of\n//   capital letters will be approximately equal to s, because it is common for fonts to\n//   use about 70% of their height for the ascenders in the font.  To get the customary\n//   font size, you should multiply your desired size by 0.72.\n//   .\n//   To find the fonts that you have available in your OpenSCAD installation,\n//   go to the Help menu and select \"Font List\".  \n// Arguments:\n//   text = Text to create.\n//   size = The font will be created at this size divided by 0.72.   Default: 10\n//   font = Font to use.  Default: \"Liberation Sans\"\n//   ---\n//   halign = If given, specifies the horizontal alignment of the text.  `\"left\"`, `\"center\"`, or `\"right\"`.  Overrides `anchor=`.\n//   valign = If given, specifies the vertical alignment of the text.  `\"top\"`, `\"center\"`, `\"baseline\"` or `\"bottom\"`.  Overrides `anchor=`.\n//   spacing = The relative spacing multiplier between characters.  Default: `1.0`\n//   direction = The text direction.  `\"ltr\"` for left to right.  `\"rtl\"` for right to left. `\"ttb\"` for top to bottom. `\"btt\"` for bottom to top.  Default: `\"ltr\"`\n//   language = The language the text is in.  Default: `\"en\"`\n//   script = The script the text is in.  Default: `\"latin\"`\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `\"baseline\"`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n// Extra Anchors:\n//   \"baseline\" = Anchors at the baseline of the text, at the start of the string.\n//   str(\"baseline\",VECTOR) = Anchors at the baseline of the text, modified by the X and Z components of the appended vector.\n// Examples(2D):\n//   text(\"Foobar\", size=10);\n//   text(\"Foobar\", size=12, font=\"Helvetica\");\n//   text(\"Foobar\", anchor=CENTER);\n//   text(\"Foobar\", anchor=str(\"baseline\",CENTER));\n// Example: Using line_copies() distributor\n//   txt = \"This is the string.\";\n//   line_copies(spacing=[10,-5],n=len(txt))\n//       text(txt[$idx], size=10, anchor=CENTER);\n// Example: Using arc_copies() distributor\n//   txt = \"This is the string\";\n//   arc_copies(r=50, n=len(txt), sa=0, ea=180)\n//       text(select(txt,-1-$idx), size=10, anchor=str(\"baseline\",CENTER), spin=-90);\nmodule text(text, size=10, font=\"Helvetica\", halign, valign, spacing=1.0, direction=\"ltr\", language=\"en\", script=\"latin\", anchor=\"baseline\", spin=0) {\n    no_children($children);\n    dummy1 =\n        assert(is_undef(anchor) || is_vector(anchor) || is_string(anchor), str(\"Got: \",anchor))\n        assert(is_undef(spin)   || is_vector(spin,3) || is_num(spin), str(\"Got: \",spin));\n    anchor = default(anchor, CENTER);\n    spin =   default(spin,   0);\n    geom = attach_geom(size=[size,size],two_d=true);\n    anch = !any([for (c=anchor) c==\"[\"])? anchor :\n        let(\n            parts = str_split(str_split(str_split(anchor,\"]\")[0],\"[\")[1],\",\"),\n            vec = [for (p=parts) parse_float(str_strip(p,\" \",start=true))]\n        ) vec;\n    ha = halign!=undef? halign :\n        anchor==\"baseline\"? \"left\" :\n        anchor==anch && is_string(anchor)? \"center\" :\n        anch.x<0? \"left\" :\n        anch.x>0? \"right\" :\n        \"center\";\n    va = valign != undef? valign :\n        starts_with(anchor,\"baseline\")? \"baseline\" :\n        anchor==anch && is_string(anchor)? \"center\" :\n        anch.y<0? \"bottom\" :\n        anch.y>0? \"top\" :\n        \"center\";\n    base = anchor==\"baseline\"? CENTER :\n        anchor==anch && is_string(anchor)? CENTER :\n        anch.z<0? BOTTOM :\n        anch.z>0? TOP :\n        CENTER;\n    m = _attach_transform(base,spin,undef,geom);\n    multmatrix(m) {\n        $parent_anchor = anchor;\n        $parent_spin   = spin;\n        $parent_orient = undef;\n        $parent_geom   = geom;\n        $parent_size   = _attach_geom_size(geom);\n        $attach_to   = undef;\n        if (_is_shown()){\n            _color($color) {\n                _text(\n                    text=text, size=size, font=font,\n                    halign=ha, valign=va, spacing=spacing,\n                    direction=direction, language=language,\n                    script=script\n                );\n            }\n        }\n    }\n}\n\n\n// Section: Rounding 2D shapes\n\n// Module: round2d()\n// Synopsis: Rounds the corners of 2d objects.\n// SynTags: Geom\n// Topics: Rounding\n// See Also: shell2d(), round3d(), minkowski_difference()\n// Usage:\n//   round2d(r) [ATTACHMENTS];\n//   round2d(or=) [ATTACHMENTS];\n//   round2d(ir=) [ATTACHMENTS];\n//   round2d(or=, ir=) [ATTACHMENTS];\n// Description:\n//   Rounds arbitrary 2D objects.  Giving `r` rounds all concave and convex corners.  Giving just `ir`\n//   rounds just concave corners.  Giving just `or` rounds convex corners.  Giving both `ir` and `or`\n//   can let you round to different radii for concave and convex corners.  The 2D object must not have\n//   any parts narrower than twice the `or` radius.  Such parts will disappear.\n// Arguments:\n//   r = Radius to round all concave and convex corners to.\n//   ---\n//   or = Radius to round only outside (convex) corners to.  Use instead of `r`.\n//   ir = Radius to round only inside (concave) corners to.  Use instead of `r`.\n// Examples(2D):\n//   round2d(r=10) {square([40,100], center=true); square([100,40], center=true);}\n//   round2d(or=10) {square([40,100], center=true); square([100,40], center=true);}\n//   round2d(ir=10) {square([40,100], center=true); square([100,40], center=true);}\n//   round2d(or=16,ir=8) {square([40,100], center=true); square([100,40], center=true);}\nmodule round2d(r, or, ir)\n{\n    or = get_radius(r1=or, r=r, dflt=0);\n    ir = get_radius(r1=ir, r=r, dflt=0);\n    offset(or) offset(-ir-or) offset(delta=ir,chamfer=true) children();\n}\n\n\n// Module: shell2d()\n// Synopsis: Creates a shell from 2D children.\n// SynTags: Geom\n// Topics: Shell\n// See Also: round2d(), round3d(), minkowski_difference()\n// Usage:\n//   shell2d(thickness, [or], [ir])\n// Description:\n//   Creates a hollow shell from 2D children, with optional rounding.\n// Arguments:\n//   thickness = Thickness of the shell.  Positive to expand outward, negative to shrink inward, or a two-element list to do both.\n//   or = Radius to round corners on the outside of the shell.  If given a list of 2 radii, [CONVEX,CONCAVE], specifies the radii for convex and concave corners separately.  Default: 0 (no outside rounding)\n//   ir = Radius to round corners on the inside of the shell.  If given a list of 2 radii, [CONVEX,CONCAVE], specifies the radii for convex and concave corners separately.  Default: 0 (no inside rounding)\n// Examples(2D):\n//   shell2d(10) {square([40,100], center=true); square([100,40], center=true);}\n//   shell2d(-10) {square([40,100], center=true); square([100,40], center=true);}\n//   shell2d([-10,10]) {square([40,100], center=true); square([100,40], center=true);}\n//   shell2d(10,or=10) {square([40,100], center=true); square([100,40], center=true);}\n//   shell2d(10,ir=10) {square([40,100], center=true); square([100,40], center=true);}\n//   shell2d(10,or=[10,0]) {square([40,100], center=true); square([100,40], center=true);}\n//   shell2d(10,or=[0,10]) {square([40,100], center=true); square([100,40], center=true);}\n//   shell2d(10,ir=[10,0]) {square([40,100], center=true); square([100,40], center=true);}\n//   shell2d(10,ir=[0,10]) {square([40,100], center=true); square([100,40], center=true);}\n//   shell2d(8,or=[16,8],ir=[16,8]) {square([40,100], center=true); square([100,40], center=true);}\nmodule shell2d(thickness, or=0, ir=0)\n{\n    thickness = is_num(thickness)? (\n        thickness<0? [thickness,0] : [0,thickness]\n    ) : (thickness[0]>thickness[1])? (\n        [thickness[1],thickness[0]]\n    ) : thickness;\n    orad = is_finite(or)? [or,or] : or;\n    irad = is_finite(ir)? [ir,ir] : ir;\n    difference() {\n        round2d(or=orad[0],ir=orad[1])\n            offset(delta=thickness[1])\n                children();\n        round2d(or=irad[1],ir=irad[0])\n            offset(delta=thickness[0])\n                children();\n    }\n}\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-37", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: shapes3d.scad\n//   Some standard modules for making 3d shapes with attachment support, and function forms\n//   that produce a VNF.  Also included are shortcuts cylinders in each orientation and extended versions of\n//   the standard modules that provide roundovers and chamfers.  The spheroid() module provides\n//   several different ways to make a sphere, and the text modules let you write text on a path\n//   so you can place it on a curved object.  A ruler lets you measure objects.\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: Attachable cubes, cylinders, spheres, ruler, and text.  Many can produce a VNF.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\nuse <builtins.scad>\n\n\n// Section: Cuboids, Prismoids and Pyramids\n\n// Function&Module: cube()\n// Synopsis: Creates a cube with anchors for attaching children.\n// SynTags: Geom, VNF, Ext\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See Also: cuboid(), prismoid()\n// Usage: As Module (as in native OpenSCAD)\n//   cube(size, [center]);\n// Usage: With BOSL2 Attachment extensions\n//   cube(size, [center], [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n// Usage: As Function (BOSL2 extension)\n//   vnf = cube(size, ...);\n// Description:\n//   Creates a 3D cubic object.\n//   This module extends the built-in cube()` module by providing support for attachments and a function form.  \n//   When called as a function, returns a [VNF](vnf.scad) for a cube.\n// Arguments:\n//   size = The size of the cube.\n//   center = If given, overrides `anchor`.  A true value sets `anchor=CENTER`, false sets `anchor=FRONT+LEFT+BOTTOM`.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example: Simple cube.\n//   cube(40);\n// Example: Rectangular cube.\n//   cube([20,40,50]);\n// Example: Anchoring.\n//   cube([20,40,50], anchor=BOTTOM+FRONT);\n// Example: Spin.\n//   cube([20,40,50], anchor=BOTTOM+FRONT, spin=30);\n// Example: Orientation.\n//   cube([20,40,50], anchor=BOTTOM+FRONT, spin=30, orient=FWD);\n// Example: Standard Connectors.\n//   cube(40, center=true) show_anchors();\n// Example: Called as Function\n//   vnf = cube([20,40,50]);\n//   vnf_polyhedron(vnf);\n\nmodule cube(size=1, center, anchor, spin=0, orient=UP)\n{\n    anchor = get_anchor(anchor, center, -[1,1,1], -[1,1,1]);\n    size = scalar_vec3(size);\n    attachable(anchor,spin,orient, size=size) {\n        _cube(size, center=true);\n        children();\n    }\n}\n\nfunction cube(size=1, center, anchor, spin=0, orient=UP) =\n    let(\n        siz = scalar_vec3(size)\n    )\n    assert(all_positive(siz), \"All size components must be positive.\")\n    let(\n        anchor = get_anchor(anchor, center, -[1,1,1], -[1,1,1]),\n        unscaled = [\n            [-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],\n            [-1,-1, 1],[1,-1, 1],[1,1, 1],[-1,1, 1],\n        ]/2,\n        verts = is_num(size)? unscaled * size :\n            is_vector(size,3)? [for (p=unscaled) v_mul(p,size)] :\n            assert(is_num(size) || is_vector(size,3)),\n        faces = [\n            [0,1,2], [0,2,3],  //BOTTOM\n            [0,4,5], [0,5,1],  //FRONT\n            [1,5,6], [1,6,2],  //RIGHT\n            [2,6,7], [2,7,3],  //BACK\n            [3,7,4], [3,4,0],  //LEFT\n            [6,4,7], [6,5,4]   //TOP\n        ]\n    ) [reorient(anchor,spin,orient, size=siz, p=verts), faces];\n\n\n\n// Module: cuboid()\n// Synopsis: Creates a cube with chamfering and roundovers.\n// SynTags: Geom\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See Also: prismoid(), rounded_prism()\n// Usage: Standard Cubes\n//   cuboid(size, [anchor=], [spin=], [orient=]);\n//   cuboid(size, p1=, ...);\n//   cuboid(p1=, p2=, ...);\n// Usage: Chamfered Cubes\n//   cuboid(size, [chamfer=], [edges=], [except=], [trimcorners=], ...);\n// Usage: Rounded Cubes\n//   cuboid(size, [rounding=], [teardrop=], [edges=], [except=], [trimcorners=], ...);\n// Usage: Attaching children\n//   cuboid(...) ATTACHMENTS;\n//\n// Description:\n//   Creates a cube or cuboid object, with optional chamfering or rounding of edges and corners.\n//   You cannot mix chamfering and rounding: just one edge treatment with the same size applies to all selected edges.\n//   Negative chamfers and roundings can be applied to create external fillets, but they\n//   only apply to edges around the top or bottom faces.  If you specify an edge set other than \"ALL\"\n//   with negative roundings or chamfers then you will get an error.  See [Specifying Edges](attachments.scad#section-specifying-edges)\n//   for information on how to specify edge sets.\n// Arguments:\n//   size = The size of the cube, a number or length 3 vector.\n//   ---\n//   chamfer = Size of chamfer, inset from sides.  Default: No chamfering.\n//   rounding = Radius of the edge rounding.  Default: No rounding.\n//   edges = Edges to mask.  See [Specifying Edges](attachments.scad#section-specifying-edges).  Default: all edges.\n//   except = Edges to explicitly NOT mask.  See [Specifying Edges](attachments.scad#section-specifying-edges).  Default: No edges.\n//   trimcorners = If true, rounds or chamfers corners where three chamfered/rounded edges meet.  Default: `true`\n//   teardrop = If given as a number, rounding around the bottom edge of the cuboid won't exceed this many degrees from vertical.  If true, the limit angle is 45 degrees.  Default: `false`\n//   p1 = Align the cuboid's corner at `p1`, if given.  Forces `anchor=FRONT+LEFT+BOTTOM`.\n//   p2 = If given with `p1`, defines the cornerpoints of the cuboid.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example: Simple regular cube.\n//   cuboid(40);\n// Example: Cube with minimum cornerpoint given.\n//   cuboid(20, p1=[10,0,0]);\n// Example: Rectangular cube, with given X, Y, and Z sizes.\n//   cuboid([20,40,50]);\n// Example: Cube by Opposing Corners.\n//   cuboid(p1=[0,10,0], p2=[20,30,30]);\n// Example: Chamferred Edges and Corners.\n//   cuboid([30,40,50], chamfer=5);\n// Example: Chamferred Edges, Untrimmed Corners.\n//   cuboid([30,40,50], chamfer=5, trimcorners=false);\n// Example: Rounded Edges and Corners\n//   cuboid([30,40,50], rounding=10);\n// Example(VPR=[100,0,25],VPD=180): Rounded Edges and Corners with Teardrop Bottoms\n//   cuboid([30,40,50], rounding=10, teardrop=true);\n// Example: Rounded Edges, Untrimmed Corners\n//   cuboid([30,40,50], rounding=10, trimcorners=false);\n// Example: Chamferring Selected Edges\n//   cuboid(\n//       [30,40,50], chamfer=5,\n//       edges=[TOP+FRONT,TOP+RIGHT,FRONT+RIGHT],\n//       $fn=24\n//   );\n// Example: Rounding Selected Edges\n//   cuboid(\n//       [30,40,50], rounding=5,\n//       edges=[TOP+FRONT,TOP+RIGHT,FRONT+RIGHT],\n//       $fn=24\n//   );\n// Example: Negative Chamferring\n//   cuboid(\n//       [30,40,50], chamfer=-5,\n//       edges=[TOP,BOT], except=RIGHT,\n//       $fn=24\n//   );\n// Example: Negative Chamferring, Untrimmed Corners\n//   cuboid(\n//       [30,40,50], chamfer=-5,\n//       edges=[TOP,BOT], except=RIGHT,\n//       trimcorners=false, $fn=24\n//   );\n// Example: Negative Rounding\n//   cuboid(\n//       [30,40,50], rounding=-5,\n//       edges=[TOP,BOT], except=RIGHT,\n//       $fn=24\n//   );\n// Example: Negative Rounding, Untrimmed Corners\n//   cuboid(\n//       [30,40,50], rounding=-5,\n//       edges=[TOP,BOT], except=RIGHT,\n//       trimcorners=false, $fn=24\n//   );\n// Example: Roundings and Chamfers can be as large as the full size of the cuboid, so long as the edges would not interfere.\n//   cuboid([40,20,10], rounding=20, edges=[FWD+RIGHT,BACK+LEFT]);\n// Example: Standard Connectors\n//   cuboid(40) show_anchors();\n\nmodule cuboid(\n    size=[1,1,1],\n    p1, p2,\n    chamfer,\n    rounding,\n    edges=EDGES_ALL,\n    except=[],\n    except_edges,\n    trimcorners=true,\n    teardrop=false,\n    anchor=CENTER,\n    spin=0,\n    orient=UP\n) {\n    module trunc_cube(s,corner) {\n        multmatrix(\n            (corner.x<0? xflip() : ident(4)) *\n            (corner.y<0? yflip() : ident(4)) *\n            (corner.z<0? zflip() : ident(4)) *\n            scale(s+[1,1,1]*0.001) *\n            move(-[1,1,1]/2)\n        ) polyhedron(\n            [[1,1,1],[1,1,0],[1,0,0],[0,1,1],[0,1,0],[1,0,1],[0,0,1]],\n            [[0,1,2],[2,5,0],[0,5,6],[0,6,3],[0,3,4],[0,4,1],[1,4,2],[3,6,4],[5,2,6],[2,4,6]]\n        );\n    }\n    module xtcyl(l,r) {\n        if (teardrop) {\n            teardrop(r=r, l=l, cap_h=r, ang=teardrop, spin=90, orient=DOWN);\n        } else {\n            yrot(90) cyl(l=l, r=r);\n        }\n    }\n    module ytcyl(l,r) {\n        if (teardrop) {\n            teardrop(r=r, l=l, cap_h=r, ang=teardrop, spin=0, orient=DOWN);\n        } else {\n            zrot(90) yrot(90) cyl(l=l, r=r);\n        }\n    }\n    module tsphere(r) {\n        if (teardrop) {\n            onion(r=r, cap_h=r, ang=teardrop, orient=DOWN);\n        } else {\n            spheroid(r=r, style=\"octa\", orient=DOWN);\n        }\n    }\n    module corner_shape(corner) {\n        e = _corner_edges(edges, corner);\n        cnt = sum(e);\n        r = first_defined([chamfer, rounding]);\n        dummy = assert(is_finite(r) && !approx(r,0));\n        c = [r,r,r];\n        m = 0.01;\n        c2 = v_mul(corner,c/2);\n        c3 = v_mul(corner,c-[1,1,1]*m/2);\n        $fn = is_finite(chamfer)? 4 : quantup(segs(r),4);\n        translate(v_mul(corner, size/2-c)) {\n            if (cnt == 0 || approx(r,0)) {\n                translate(c3) cube(m, center=true);\n            } else if (cnt == 1) {\n                if (e.x) {\n                    right(c3.x) {\n                        intersection() {\n                            xtcyl(l=m, r=r);\n                            multmatrix(\n                                (corner.y<0? yflip() : ident(4)) *\n                                (corner.z<0? zflip() : ident(4))\n                            ) {\n                                yrot(-90) linear_extrude(height=m+0.1, center=true) {\n                                    polygon([[r,0],[0.999*r,0],[0,0.999*r],[0,r],[r,r]]);\n                                }\n                            }\n                        }\n                    }\n                } else if (e.y) {\n                    back(c3.y) {\n                        intersection() {\n                            ytcyl(l=m, r=r);\n                            multmatrix(\n                                (corner.x<0? xflip() : ident(4)) *\n                                (corner.z<0? zflip() : ident(4))\n                            ) {\n                                xrot(90) linear_extrude(height=m+0.1, center=true) {\n                                    polygon([[r,0],[0.999*r,0],[0,0.999*r],[0,r],[r,r]]);\n                                }\n                            }\n                        }\n                    }\n                } else if (e.z) {\n                    up(c3.z) {\n                        intersection() {\n                            zcyl(l=m, r=r);\n                            multmatrix(\n                                (corner.x<0? xflip() : ident(4)) *\n                                (corner.y<0? yflip() : ident(4))\n                            ) {\n                                linear_extrude(height=m+0.1, center=true) {\n                                    polygon([[r,0],[0.999*r,0],[0,0.999*r],[0,r],[r,r]]);\n                                }\n                            }\n                        }\n                    }\n                }\n            } else if (cnt == 2) {\n                intersection() {\n                    if (!e.x) {\n                        intersection() {\n                            ytcyl(l=c.y*2, r=r);\n                            zcyl(l=c.z*2, r=r);\n                        }\n                    } else if (!e.y) {\n                        intersection() {\n                            xtcyl(l=c.x*2, r=r);\n                            zcyl(l=c.z*2, r=r);\n                        }\n                    } else {\n                        intersection() {\n                            xtcyl(l=c.x*2, r=r);\n                            ytcyl(l=c.y*2, r=r);\n                        }\n                    }\n                    translate(c2) trunc_cube(c,corner); // Trim to just the octant.\n                }\n            } else {\n                intersection() {\n                    if (trimcorners) {\n                        tsphere(r=r);\n                    } else {\n                        intersection() {\n                            xtcyl(l=c.x*2, r=r);\n                            ytcyl(l=c.y*2, r=r);\n                            zcyl(l=c.z*2, r=r);\n                        }\n                    }\n                    translate(c2) trunc_cube(c,corner); // Trim to just the octant.\n                }\n            }\n        }\n    }\n\n    size = scalar_vec3(size);\n    edges = _edges(edges, except=first_defined([except_edges,except]));\n    teardrop = is_bool(teardrop)&&teardrop? 45 : teardrop;\n    chamfer = approx(chamfer,0) ? undef : chamfer;\n    rounding = approx(rounding,0) ? undef : rounding;\n    checks =\n        assert(is_vector(size,3))\n        assert(all_nonnegative(size), \"All components of size= must be >=0\")\n        assert(is_undef(chamfer) || is_finite(chamfer),\"chamfer must be a finite value\")\n        assert(is_undef(rounding) || is_finite(rounding),\"rounding must be a finite value\")\n        assert(is_undef(rounding) || is_undef(chamfer), \"Cannot specify nonzero value for both chamfer and rounding\")\n        assert(teardrop==false || (is_finite(teardrop) && teardrop>0 && teardrop<=90), \"teardrop must be either false or an angle number between 0 and 90\")\n        assert(is_undef(p1) || is_vector(p1))\n        assert(is_undef(p2) || is_vector(p2))\n        assert(is_bool(trimcorners));\n    if (!is_undef(p1)) {\n        if (!is_undef(p2)) {\n            translate(pointlist_bounds([p1,p2])[0]) {\n                cuboid(size=v_abs(p2-p1), chamfer=chamfer, rounding=rounding, edges=edges, trimcorners=trimcorners, anchor=-[1,1,1]) children();\n            }\n        } else {\n            translate(p1) {\n                cuboid(size=size, chamfer=chamfer, rounding=rounding, edges=edges, trimcorners=trimcorners, anchor=-[1,1,1]) children();\n            }\n        }\n    } else {\n        rr = max(default(chamfer,0), default(rounding,0));\n        if (rr>0) {\n            minx = max(\n                edges.y[0] + edges.y[1], edges.y[2] + edges.y[3],\n                edges.z[0] + edges.z[1], edges.z[2] + edges.z[3],\n                edges.y[0] + edges.z[1], edges.y[0] + edges.z[3],\n                edges.y[1] + edges.z[0], edges.y[1] + edges.z[2],\n                edges.y[2] + edges.z[1], edges.y[2] + edges.z[3],\n                edges.y[3] + edges.z[0], edges.y[3] + edges.z[2]\n            ) * rr;\n            miny = max(\n                edges.x[0] + edges.x[1], edges.x[2] + edges.x[3],\n                edges.z[0] + edges.z[2], edges.z[1] + edges.z[3],\n                edges.x[0] + edges.z[2], edges.x[0] + edges.z[3],\n                edges.x[1] + edges.z[0], edges.x[1] + edges.z[1],\n                edges.x[2] + edges.z[2], edges.x[2] + edges.z[3],\n                edges.x[3] + edges.z[0], edges.x[3] + edges.z[1]\n            ) * rr;\n            minz = max(\n                edges.x[0] + edges.x[2], edges.x[1] + edges.x[3],\n                edges.y[0] + edges.y[2], edges.y[1] + edges.y[3],\n                edges.x[0] + edges.y[2], edges.x[0] + edges.y[3],\n                edges.x[1] + edges.y[2], edges.x[1] + edges.y[3],\n                edges.x[2] + edges.y[0], edges.x[2] + edges.y[1],\n                edges.x[3] + edges.y[0], edges.x[3] + edges.y[1]\n            ) * rr;\n            check =\n                assert(minx <= size.x, \"Rounding or chamfering too large for cuboid size in the X axis.\")\n                assert(miny <= size.y, \"Rounding or chamfering too large for cuboid size in the Y axis.\")\n                assert(minz <= size.z, \"Rounding or chamfering too large for cuboid size in the Z axis.\")\n            ;\n        }\n        majrots = [[0,90,0], [90,0,0], [0,0,0]];\n        attachable(anchor,spin,orient, size=size) {\n            if (is_finite(chamfer) && !approx(chamfer,0)) {\n                if (edges == EDGES_ALL && trimcorners) {\n                    if (chamfer<0) {\n                        cube(size, center=true) {\n                            attach(TOP,overlap=0) prismoid([size.x,size.y], [size.x-2*chamfer,size.y-2*chamfer], h=-chamfer, anchor=TOP);\n                            attach(BOT,overlap=0) prismoid([size.x,size.y], [size.x-2*chamfer,size.y-2*chamfer], h=-chamfer, anchor=TOP);\n                        }\n                    } else {\n                        isize = [for (v = size) max(0.001, v-2*chamfer)];\n                        hull() {\n                            cube([ size.x, isize.y, isize.z], center=true);\n                            cube([isize.x,  size.y, isize.z], center=true);\n                            cube([isize.x, isize.y,  size.z], center=true);\n                        }\n                    }\n                } else if (chamfer<0) {\n                    checks = assert(edges == EDGES_ALL || edges[2] == [0,0,0,0], \"Cannot use negative chamfer with Z aligned edges.\");\n                    ach = abs(chamfer);\n                    cube(size, center=true);\n\n                    // External-Chamfer mask edges\n                    difference() {\n                        union() {\n                            for (i = [0:3], axis=[0:1]) {\n                                if (edges[axis][i]>0) {\n                                    vec = EDGE_OFFSETS[axis][i];\n                                    translate(v_mul(vec/2, size+[ach,ach,-ach])) {\n                                        rotate(majrots[axis]) {\n                                            cube([ach, ach, size[axis]], center=true);\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Add multi-edge corners.\n                            if (trimcorners) {\n                                for (za=[-1,1], ya=[-1,1], xa=[-1,1]) {\n                                    ce = _corner_edges(edges, [xa,ya,za]);\n                                    if (ce.x + ce.y > 1) {\n                                        translate(v_mul([xa,ya,za]/2, size+[ach-0.01,ach-0.01,-ach])) {\n                                            cube([ach+0.01,ach+0.01,ach], center=true);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        // Remove bevels from overhangs.\n                        for (i = [0:3], axis=[0:1]) {\n                            if (edges[axis][i]>0) {\n                                vec = EDGE_OFFSETS[axis][i];\n                                translate(v_mul(vec/2, size+[2*ach,2*ach,-2*ach])) {\n                                    rotate(majrots[axis]) {\n                                        zrot(45) cube([ach*sqrt(2), ach*sqrt(2), size[axis]+2.1*ach], center=true);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    hull() {\n                        corner_shape([-1,-1,-1]);\n                        corner_shape([ 1,-1,-1]);\n                        corner_shape([-1, 1,-1]);\n                        corner_shape([ 1, 1,-1]);\n                        corner_shape([-1,-1, 1]);\n                        corner_shape([ 1,-1, 1]);\n                        corner_shape([-1, 1, 1]);\n                        corner_shape([ 1, 1, 1]);\n                    }\n                }\n            } else if (is_finite(rounding) && !approx(rounding,0)) {\n                sides = quantup(segs(rounding),4);\n                if (edges == EDGES_ALL) {\n                    if(rounding<0) {\n                        cube(size, center=true);\n                        zflip_copy() {\n                            up(size.z/2) {\n                                difference() {\n                                    down(-rounding/2) cube([size.x-2*rounding, size.y-2*rounding, -rounding], center=true);\n                                    down(-rounding) {\n                                        ycopies(size.y-2*rounding) xcyl(l=size.x-3*rounding, r=-rounding);\n                                        xcopies(size.x-2*rounding) ycyl(l=size.y-3*rounding, r=-rounding);\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        isize = [for (v = size) max(0.001, v-2*rounding)];\n                        minkowski() {\n                            cube(isize, center=true);\n                            if (trimcorners) {\n                                tsphere(r=rounding, $fn=sides);\n                            } else {\n                                intersection() {\n                                    xtcyl(r=rounding, l=rounding*2, $fn=sides);\n                                    ytcyl(r=rounding, l=rounding*2, $fn=sides);\n                                    cyl(r=rounding, h=rounding*2, $fn=sides);\n                                }\n                            }\n                        }\n                    }\n                } else if (rounding<0) {\n                    checks = assert(edges == EDGES_ALL || edges[2] == [0,0,0,0], \"Cannot use negative rounding with Z aligned edges.\");\n                    ard = abs(rounding);\n                    cube(size, center=true);\n\n                    // External-Rounding mask edges\n                    difference() {\n                        union() {\n                            for (i = [0:3], axis=[0:1]) {\n                                if (edges[axis][i]>0) {\n                                    vec = EDGE_OFFSETS[axis][i];\n                                    translate(v_mul(vec/2, size+[ard,ard,-ard]-[0.01,0.01,0])) {\n                                        rotate(majrots[axis]) {\n                                            cube([ard, ard, size[axis]], center=true);\n                                        }\n                                    }\n                                }\n                            }\n\n                            // Add multi-edge corners.\n                            if (trimcorners) {\n                                for (za=[-1,1], ya=[-1,1], xa=[-1,1]) {\n                                    ce = _corner_edges(edges, [xa,ya,za]);\n                                    if (ce.x + ce.y > 1) {\n                                        translate(v_mul([xa,ya,za]/2, size+[ard-0.01,ard-0.01,-ard])) {\n                                            cube([ard+0.01,ard+0.01,ard], center=true);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        // Remove roundings from overhangs.\n                        for (i = [0:3], axis=[0:1]) {\n                            if (edges[axis][i]>0) {\n                                vec = EDGE_OFFSETS[axis][i];\n                                translate(v_mul(vec/2, size+[2*ard,2*ard,-2*ard])) {\n                                    rotate(majrots[axis]) {\n                                        cyl(l=size[axis]+2.1*ard, r=ard);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    hull() {\n                        corner_shape([-1,-1,-1]);\n                        corner_shape([ 1,-1,-1]);\n                        corner_shape([-1, 1,-1]);\n                        corner_shape([ 1, 1,-1]);\n                        corner_shape([-1,-1, 1]);\n                        corner_shape([ 1,-1, 1]);\n                        corner_shape([-1, 1, 1]);\n                        corner_shape([ 1, 1, 1]);\n                    }\n                }\n            } else {\n                cube(size=size, center=true);\n            }\n            children();\n        }\n    }\n}\n\n\nfunction cuboid(\n    size=[1,1,1],\n    p1, p2,\n    chamfer,\n    rounding,\n    edges=EDGES_ALL,\n    except_edges=[],\n    trimcorners=true,\n    anchor=CENTER,\n    spin=0,\n    orient=UP\n) = no_function(\"cuboid\");\n\n\n\n// Function&Module: prismoid()\n// Synopsis: Creates a rectangular prismoid shape with optional roundovers and chamfering.\n// SynTags: Geom, VNF\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See Also: cuboid(), rounded_prism(), trapezoid(), edge_profile()\n// Usage: \n//   prismoid(size1, size2, [h|l|height|length], [shift], [xang=], [yang=], ...) [ATTACHMENTS];\n// Usage: Chamfered and/or Rounded Prismoids\n//   prismoid(size1, size2, h|l|height|length, [chamfer=], [rounding=]...) [ATTACHMENTS];\n//   prismoid(size1, size2, h|l|height|length, [chamfer1=], [chamfer2=], [rounding1=], [rounding2=], ...) [ATTACHMENTS];\n// Usage: As Function\n//   vnf = prismoid(...);\n// Description:\n//   Creates a rectangular prismoid shape with optional roundovers and chamfering.\n//   You can only round or chamfer the vertical(ish) edges.  For those edges, you can\n//   specify rounding and/or chamferring per-edge, and for top and bottom separately.\n//   If you want to round the bottom or top edges see {{rounded_prism()}}.\n//   .\n//   Specification of the prismoid is similar to specification for {{trapezoid()}}.  You can specify the dimensions of the\n//   bottom and top and its height to get a symmetric prismoid.  You can use the shift argument to shift the top face around.\n//   You can also specify base angles either in the X direction, Y direction or both.  In order to avoid overspecification,\n//   you may need to specify a parameter such as size2 as a list of two values, one of which is undef.  For example,\n//   specifying `size2=[100,undef]` sets the size in the X direction but allows the size in the Y direction to be computed based on yang.\n// Arguments:\n//   size1 = [width, length] of the bottom end of the prism.\n//   size2 = [width, length] of the top end of the prism.\n//   h/l/height/length = Height of the prism.\n//   shift = [X,Y] amount to shift the center of the top end with respect to the center of the bottom end.\n//   ---\n//   xang = base angle in the X direction.  Can be a scalar or list of two values, one of which may be undef\n//   yang = base angle in the Y direction.  Can be a scalar or list of two values, one of which may be undef\n//   rounding = The roundover radius for the vertical-ish edges of the prismoid.  If given as a list of four numbers, gives individual radii for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-]. Default: 0 (no rounding)\n//   rounding1 = The roundover radius for the bottom of the vertical-ish edges of the prismoid.  If given as a list of four numbers, gives individual radii for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-].\n//   rounding2 = The roundover radius for the top of the vertical-ish edges of the prismoid.  If given as a list of four numbers, gives individual radii for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-].\n//   chamfer = The chamfer size for the vertical-ish edges of the prismoid.  If given as a list of four numbers, gives individual chamfers for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-].  Default: 0 (no chamfer)\n//   chamfer1 = The chamfer size for the bottom of the vertical-ish edges of the prismoid.  If given as a list of four numbers, gives individual chamfers for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-].\n//   chamfer2 = The chamfer size for the top of the vertical-ish edges of the prismoid.  If given as a list of four numbers, gives individual chamfers for each corner, in the order [X+Y+,X-Y+,X-Y-,X+Y-].\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `BOTTOM`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Example: Truncated Pyramid\n//   prismoid(size1=[35,50], size2=[20,30], h=20);\n// Example: Rectangular Pyramid\n//   prismoid([40,40], [0,0], h=20);\n// Example: Prism\n//   prismoid(size1=[40,40], size2=[0,40], h=20);\n// Example: Wedge\n//   prismoid(size1=[60,35], size2=[30,0], h=30);\n// Example: Truncated Tetrahedron\n//   prismoid(size1=[10,40], size2=[40,10], h=40);\n// Example: Inverted Truncated Pyramid\n//   prismoid(size1=[15,5], size2=[30,20], h=20);\n// Example: Right Prism\n//   prismoid(size1=[30,60], size2=[0,60], shift=[-15,0], h=30);\n// Example(FlatSpin,VPD=160,VPT=[0,0,10]): Shifting/Skewing\n//   prismoid(size1=[50,30], size2=[20,20], h=20, shift=[15,5]);\n// Example: Specifying bottom, height and angle\n//   prismoid(size1=[100,75], h=30, xang=50, yang=70);\n// Example: Specifying top, height and angle, with asymmetric angles\n//   prismoid(size2=[100,75], h=30, xang=[50,60], yang=[70,40]);\n// Example: Specifying top, bottom and angle for X and using that to define height.  Note that giving yang here would likely give a conflicting height calculation, which is not allowed.  \n//   prismoid(size1=[100,75], size2=[75,35], xang=50);\n// Example: The same as the previous example but we give a shift in Y.  Note that shift.x must be undef because you cannot give combine an angle with a shift, so a shift.x value would conflict with xang being defined.  \n//   prismoid(size1=[100,75], size2=[75,35], xang=50, shift=[undef,20]);\n// Example:  The X dimensions defined by the base length, angle and height; the Y dimensions defined by the top length, angle, and height. \n//   prismoid(size1=[100,undef], size2=[undef,75], h=30, xang=[20,90], yang=30);\n// Example: Rounding\n//   prismoid(100, 80, rounding=10, h=30);\n// Example: Chamfers\n//   prismoid(100, 80, chamfer=5, h=30);\n// Example: Gradiant Rounding\n//   prismoid(100, 80, rounding1=10, rounding2=0, h=30);\n// Example: Per Corner Rounding\n//   prismoid(100, 80, rounding=[0,5,10,15], h=30);\n// Example: Per Corner Chamfer\n//   prismoid(100, 80, chamfer=[0,5,10,15], h=30);\n// Example: Mixing Chamfer and Rounding\n//   prismoid(\n//       100, 80, h=30,\n//       chamfer=[0,5,0,10],\n//       rounding=[5,0,10,0]\n//   );\n// Example: Really Mixing It Up\n//   prismoid(\n//       size1=[100,80], size2=[80,60], h=20,\n//       chamfer1=[0,5,0,10], chamfer2=[5,0,10,0],\n//       rounding1=[5,0,10,0], rounding2=[0,5,0,10]\n//   );\n// Example: How to Round a Top or Bottom Edge\n//   diff()\n//   prismoid([50,30], [30,20], shift=[3,6], h=15, rounding=[5,0,5,0]) {\n//       edge_profile([TOP+RIGHT, BOT+FRONT], excess=10, convexity=20) {\n//           mask2d_roundover(h=5,mask_angle=$edge_angle);\n//       }\n//   }\n// Example(Spin,VPD=160,VPT=[0,0,10]): Standard Connectors\n//   prismoid(size1=[50,30], size2=[20,20], h=20, shift=[15,5])\n//       show_anchors();\n\nmodule prismoid(\n    size1=undef, size2=undef, h, shift=[undef,undef],\n    xang, yang,\n    rounding=0, rounding1, rounding2,\n    chamfer=0, chamfer1, chamfer2,\n    l, height, length, center,\n    anchor, spin=0, orient=UP\n)\n{\n    vnf_s1_s2_shift = prismoid(\n        size1=size1, size2=size2, h=h, shift=shift,\n        xang=xang, yang=yang, \n        rounding=rounding, chamfer=chamfer, \n        rounding1=rounding1, rounding2=rounding2,\n        chamfer1=chamfer1, chamfer2=chamfer2,\n        l=l, height=height, length=length, anchor=BOT, _return_dim=true\n    );\n    anchor = get_anchor(anchor, center, BOT, BOT);\n    attachable(anchor,spin,orient, size=vnf_s1_s2_shift[1], size2=vnf_s1_s2_shift[2], shift=vnf_s1_s2_shift[3]) {\n        down(vnf_s1_s2_shift[1].z/2)\n            vnf_polyhedron(vnf_s1_s2_shift[0], convexity=4);\n        children();\n    }\n}\n\nfunction prismoid(\n    size1, size2, h, shift=[0,0],\n    rounding=0, rounding1, rounding2,\n    chamfer=0, chamfer1, chamfer2,\n    l, height, length, center,\n    anchor=DOWN, spin=0, orient=UP, xang, yang,\n    _return_dim=false\n    \n) =\n    assert(is_undef(shift) || is_num(shift) || len(shift)==2, \"shift must be a number or list of length 2\")\n    assert(is_undef(size1) || is_num(size1) || len(size1)==2, \"size1 must be a number or list of length 2\")\n    assert(is_undef(size2) || is_num(size2) || len(size2)==2, \"size2 must be a number or list of length 2\")  \n    let(\n        xang = force_list(xang,2),\n        yang = force_list(yang,2),\n        yangOK = len(yang)==2 && (yang==[undef,undef] || (all_positive(yang) && yang[0]<180 && yang[1]<180)),\n        xangOK = len(xang)==2 && (xang==[undef,undef] || (all_positive(xang) && xang[0]<180 && xang[1]<180)),\n        size1=force_list(size1,2),\n        size2=force_list(size2,2),\n        h=first_defined([l,h,length,height]),\n        shift = force_list(shift,2)\n    )\n    assert(xangOK, \"prismoid angles must be scalar or 2-vector, strictly between 0 and 180\")\n    assert(yangOK, \"prismoid angles must be scalar or 2-vector, strictly between 0 and 180\")\n    assert(xang==[undef,undef] || shift.x==undef, \"Cannot specify xang and a shift.x value together\")\n    assert(yang==[undef,undef] || shift.y==undef, \"Cannot specify yang and a shift.y value together\")\n    assert(all_positive([h]) || is_undef(h), \"h must be a positive value\")\n    let(\n        hx = _trapezoid_dims(h,size1.x,size2.x,shift.x,xang)[0],\n        hy = _trapezoid_dims(h,size1.y,size2.y,shift.y,yang)[0]\n    )\n    assert(num_defined([hx,hy])>0, \"Height not given and specification does not determine prismoid height\")\n    assert(hx==undef || hy==undef || approx(hx,hy),\n           str(\"X and Y angle specifications give rise to conflicting height values \",hx,\" and \",hy))\n    let(\n        h = first_defined([hx,hy]),\n        x_h_w1_w2_shift = _trapezoid_dims(h,size1.x,size2.x,shift.x,xang),\n        y_h_w1_w2_shift = _trapezoid_dims(h,size1.y,size2.y,shift.y,yang)\n    )\n    let(\n        s1 = [x_h_w1_w2_shift[1], y_h_w1_w2_shift[1]],\n        s2 = [x_h_w1_w2_shift[2], y_h_w1_w2_shift[2]],\n        shift = [x_h_w1_w2_shift[3], y_h_w1_w2_shift[3]]\n    )\n    assert(is_vector(s1,2), \"Insufficient information to define prismoid\")\n    assert(is_vector(s2,2), \"Insufficient information to define prismoid\")\n    assert(all_nonnegative(concat(s1,s2)),\"Degenerate prismoid geometry\")\n    assert(s1.x+s2.x>0 && s1.y+s2.y>0, \"Degenerate prismoid geometry\")\n    assert(is_num(rounding) || is_vector(rounding,4), \"rounding must be a number or 4-vector\")\n    assert(is_undef(rounding1) || is_num(rounding1) || is_vector(rounding1,4), \"rounding1 must be a number or 4-vector\")\n    assert(is_undef(rounding2) || is_num(rounding2) || is_vector(rounding2,4), \"rounding2 must be a number or 4-vector\")\n    assert(is_num(chamfer) || is_vector(chamfer,4), \"chamfer must be a number or 4-vector\")\n    assert(is_undef(chamfer1) || is_num(chamfer1) || is_vector(chamfer1,4), \"chamfer1 must be a number or 4-vector\")\n    assert(is_undef(chamfer2) || is_num(chamfer2) || is_vector(chamfer2,4), \"chamfer2 must be a number or 4-vector\")\n    let(\n        chamfer1=force_list(default(chamfer1,chamfer),4),\n        chamfer2=force_list(default(chamfer2,chamfer),4),\n        rounding1=force_list(default(rounding1,rounding),4),\n        rounding2=force_list(default(rounding2,rounding),4)\n    )\n    assert(all_nonnegative(chamfer1), \"chamfer/chamfer1 must be non-negative\")\n    assert(all_nonnegative(chamfer2), \"chamfer/chamfer2 must be non-negative\")\n    assert(all_nonnegative(rounding1), \"rounding/rounding1 must be non-negative\")\n    assert(all_nonnegative(rounding2), \"rounding/rounding2 must be non-negative\")        \n    assert(all_zero(v_mul(rounding1,chamfer1),0),\n           \"rounding1 and chamfer1 (possibly inherited from rounding and chamfer) cannot both be nonzero at the same corner\")\n    assert(all_zero(v_mul(rounding2,chamfer2),0),\n           \"rounding2 and chamfer2 (possibly inherited from rounding and chamfer) cannot both be nonzero at the same corner\")\n    let(\n        rounding1 = default(rounding1, rounding),\n        rounding2 = default(rounding2, rounding),\n        chamfer1 = default(chamfer1, chamfer),\n        chamfer2 = default(chamfer2, chamfer),\n        anchor = get_anchor(anchor, center, BOT, BOT),\n        path1 = rect(s1, rounding=rounding1, chamfer=chamfer1, anchor=CTR),\n        path2 = rect(s2, rounding=rounding2, chamfer=chamfer2, anchor=CTR),\n        points = [\n                    each path3d(path1, -h/2),\n                    each path3d(move(shift, path2), +h/2),\n                 ],\n        faces = hull(points),\n        vnf = [points, faces]\n    )\n    _return_dim ? [reorient(anchor,spin,orient, size=[s1.x,s1.y,h], size2=s2, shift=shift, p=vnf),point3d(s1,h),s2,shift]\n                : reorient(anchor,spin,orient, size=[s1.x,s1.y,h], size2=s2, shift=shift, p=vnf);\n\n\n// Function&Module: octahedron()\n// Synopsis: Creates an octahedron with axis-aligned points.\n// SynTags: Geom, VNF\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See Also: prismoid()\n// Usage: As Module\n//   octahedron(size, ...) [ATTACHMENTS];\n// Usage: As Function\n//   vnf = octahedron(size, ...);\n// Description:\n//   When called as a module, creates an octahedron with axis-aligned points.\n//   When called as a function, creates a [VNF](vnf.scad) of an octahedron with axis-aligned points.\n// Arguments:\n//   size = Width of the octahedron, tip to tip.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   octahedron(size=40);\n// Example: Anchors\n//   octahedron(size=40) show_anchors();\n\nmodule octahedron(size=1, anchor=CENTER, spin=0, orient=UP) {\n    vnf = octahedron(size=size);\n    attachable(anchor,spin,orient, vnf=vnf, extent=true) {\n        vnf_polyhedron(vnf, convexity=2);\n        children();\n    }\n}\n\nfunction octahedron(size=1, anchor=CENTER, spin=0, orient=UP) =\n    let(\n        size = scalar_vec3(size),\n        s = size/2,\n        vnf = [\n            [ [0,0,s.z], [s.x,0,0], [0,s.y,0], [-s.x,0,0], [0,-s.y,0], [0,0,-s.z] ],\n            [ [0,2,1], [0,3,2], [0,4,3], [0,1,4], [5,1,2], [5,2,3], [5,3,4], [5,4,1] ]\n        ]\n    ) reorient(anchor,spin,orient, vnf=vnf, extent=true, p=vnf);\n\n\n// Module: rect_tube()\n// Synopsis: Creates a rectangular tube.\n// SynTags: Geom\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See Also: tube()\n// Usage: Typical Rectangular Tubes\n//   rect_tube(h, size, isize, [center], [shift]);\n//   rect_tube(h, size, wall=, [center=]);\n//   rect_tube(h, isize=, wall=, [center=]);\n// Usage: Tapering Rectangular Tubes\n//   rect_tube(h, size1=, size2=, wall=, ...);\n//   rect_tube(h, isize1=, isize2=, wall=, ...);\n//   rect_tube(h, size1=, size2=, isize1=, isize2=, ...);\n// Usage: Chamfered\n//   rect_tube(h, size, isize, chamfer=, ...);\n//   rect_tube(h, size, isize, chamfer1=, chamfer2= ...);\n//   rect_tube(h, size, isize, ichamfer=, ...);\n//   rect_tube(h, size, isize, ichamfer1=, ichamfer2= ...);\n//   rect_tube(h, size, isize, chamfer=, ichamfer=, ...);\n// Usage: Rounded\n//   rect_tube(h, size, isize, rounding=, ...);\n//   rect_tube(h, size, isize, rounding1=, rounding2= ...);\n//   rect_tube(h, size, isize, irounding=, ...);\n//   rect_tube(h, size, isize, irounding1=, irounding2= ...);\n//   rect_tube(h, size, isize, rounding=, irounding=, ...);\n// Usage: Attaching Children\n//   rect_tube(...) ATTACHMENTS;\n//\n// Description:\n//   Creates a rectangular or prismoid tube with optional roundovers and/or chamfers.\n//   You can only round or chamfer the vertical(ish) edges.  For those edges, you can\n//   specify rounding and/or chamferring per-edge, and for top and bottom, inside and\n//   outside  separately.\n//   .\n//   By default if you specify a chamfer or rounding then it applies as specified to the\n//   outside, and an inside rounding is calculated that will maintain constant width\n//   if your wall thickness is uniform.  If the wall thickness is not uniform, the default\n//   inside rounding is calculated based on the smaller of the two wall thicknesses.\n//   Note that the values of the more specific chamfers and roundings inherit from the\n//   more general ones, so `rounding2` is determined from `rounding`.  The constant\n//   width default will apply when the inner rounding and chamfer are both undef.\n//   You can give an inner chamfer or rounding as a list with undef entries if you want to specify\n//   some corner roundings and allow others to be computed.  \n// Arguments:\n//   h/l/height/length = The height or length of the rectangular tube.  Default: 1\n//   size = The outer [X,Y] size of the rectangular tube.\n//   isize = The inner [X,Y] size of the rectangular tube.\n//   center = If given, overrides `anchor`.  A true value sets `anchor=CENTER`, false sets `anchor=UP`.\n//   shift = [X,Y] amount to shift the center of the top end with respect to the center of the bottom end.\n//   ---\n//   wall = The thickness of the rectangular tube wall.\n//   size1 = The [X,Y] size of the outside of the bottom of the rectangular tube.\n//   size2 = The [X,Y] size of the outside of the top of the rectangular tube.\n//   isize1 = The [X,Y] size of the inside of the bottom of the rectangular tube.\n//   isize2 = The [X,Y] size of the inside of the top of the rectangular tube.\n//   rounding = The roundover radius for the outside edges of the rectangular tube.\n//   rounding1 = The roundover radius for the outside bottom corner of the rectangular tube.\n//   rounding2 = The roundover radius for the outside top corner of the rectangular tube.\n//   chamfer = The chamfer size for the outside edges of the rectangular tube.\n//   chamfer1 = The chamfer size for the outside bottom corner of the rectangular tube.\n//   chamfer2 = The chamfer size for the outside top corner of the rectangular tube.\n//   irounding = The roundover radius for the inside edges of the rectangular tube. Default: Computed for uniform wall thickness (see above)\n//   irounding1 = The roundover radius for the inside bottom corner of the rectangular tube.\n//   irounding2 = The roundover radius for the inside top corner of the rectangular tube.\n//   ichamfer = The chamfer size for the inside edges of the rectangular tube.  Default: Computed for uniform wall thickness (see above)\n//   ichamfer1 = The chamfer size for the inside bottom corner of the rectangular tube.\n//   ichamfer2 = The chamfer size for the inside top corner of the rectangular tube.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `BOTTOM`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples:\n//   rect_tube(size=50, wall=5, h=30);\n//   rect_tube(size=[100,60], wall=5, h=30);\n//   rect_tube(isize=[60,80], wall=5, h=30);\n//   rect_tube(size=[100,60], isize=[90,50], h=30);\n//   rect_tube(size1=[100,60], size2=[70,40], wall=5, h=30);\n// Example:\n//   rect_tube(\n//       size1=[100,60], size2=[70,40],\n//       isize1=[40,20], isize2=[65,35], h=15\n//   );\n// Example: With rounding\n//   rect_tube(size=100, wall=5, rounding=10, h=30);\n// Example: With rounding\n//   rect_tube(size=100, wall=5, chamfer=10, h=30);\n// Example: Outer Rounding Only\n//   rect_tube(size=100, wall=5, rounding=10, irounding=0, h=30);\n// Example: Outer Chamfer Only\n//   rect_tube(size=100, wall=5, chamfer=5, ichamfer=0, h=30);\n// Example: Outer Rounding, Inner Chamfer\n//   rect_tube(size=100, wall=5, rounding=10, ichamfer=8, h=30);\n// Example: Inner Rounding, Outer Chamfer\n//   rect_tube(size=100, wall=5, chamfer=10, irounding=8, h=30);\n// Example: Gradiant Rounding\n//   rect_tube(\n//       size1=100, size2=80, wall=5, h=30,\n//       rounding1=10, rounding2=0,\n//       irounding1=8, irounding2=0\n//   );\n// Example: Per Corner Rounding\n//   rect_tube(\n//       size=100, wall=10, h=30,\n//       rounding=[0,5,10,15], irounding=0\n//   );\n// Example: Per Corner Chamfer\n//   rect_tube(\n//       size=100, wall=10, h=30,\n//       chamfer=[0,5,10,15], ichamfer=0\n//   );\n// Example: Mixing Chamfer and Rounding\n//   rect_tube(\n//       size=100, wall=10, h=30,\n//       chamfer=[0,10,0,20], \n//       rounding=[10,0,20,0]\n//   );\n// Example: Really Mixing It Up\n//   rect_tube(\n//       size1=[100,80], size2=[80,60],\n//       isize1=[50,30], isize2=[70,50], h=20,\n//       chamfer1=[0,5,0,10], ichamfer1=[0,3,0,8],\n//       chamfer2=[5,0,10,0], ichamfer2=[3,0,8,0],\n//       rounding1=[5,0,10,0], irounding1=[3,0,8,0],\n//       rounding2=[0,5,0,10], irounding2=[0,3,0,8]\n//   );\n// Example: Some interiors chamfered, others with default rounding\n//   rect_tube(\n//       size=100, wall=10, h=30,\n//       rounding=[0,10,20,30], ichamfer=[8,8,undef,undef]\n//   );\n\n\n\nfunction _rect_tube_rounding(factor,ir,r,alternative,size,isize) =\n    let(wall = min(size-isize)/2*factor)\n    [for(i=[0:3])\n      is_def(ir[i]) ? ir[i]\n    : is_undef(alternative[i]) ? max(0,r[i]-wall)\n    : 0\n    ];\n    \nmodule rect_tube(\n    h, size, isize, center, shift=[0,0],\n    wall, size1, size2, isize1, isize2,\n    rounding=0, rounding1, rounding2,\n    irounding=undef, irounding1=undef, irounding2=undef,\n    chamfer=0, chamfer1, chamfer2,\n    ichamfer=undef, ichamfer1=undef, ichamfer2=undef,\n    anchor, spin=0, orient=UP,\n    l, length, height\n) {\n    h = one_defined([h,l,length,height],\"h,l,length,height\");\n    checks =\n        assert(is_num(h), \"l or h argument required.\")\n        assert(is_vector(shift,2));\n    s1 = is_num(size1)? [size1, size1] :\n        is_vector(size1,2)? size1 :\n        is_num(size)? [size, size] :\n        is_vector(size,2)? size :\n        undef;\n    s2 = is_num(size2)? [size2, size2] :\n        is_vector(size2,2)? size2 :\n        is_num(size)? [size, size] :\n        is_vector(size,2)? size :\n        undef;\n    is1 = is_num(isize1)? [isize1, isize1] :\n        is_vector(isize1,2)? isize1 :\n        is_num(isize)? [isize, isize] :\n        is_vector(isize,2)? isize :\n        undef;\n    is2 = is_num(isize2)? [isize2, isize2] :\n        is_vector(isize2,2)? isize2 :\n        is_num(isize)? [isize, isize] :\n        is_vector(isize,2)? isize :\n        undef;\n    size1 = is_def(s1)? s1 :\n        (is_def(wall) && is_def(is1))? (is1+2*[wall,wall]) :\n        undef;\n    size2 = is_def(s2)? s2 :\n        (is_def(wall) && is_def(is2))? (is2+2*[wall,wall]) :\n        undef;\n    isize1 = is_def(is1)? is1 :\n        (is_def(wall) && is_def(s1))? (s1-2*[wall,wall]) :\n        undef;\n    isize2 = is_def(is2)? is2 :\n        (is_def(wall) && is_def(s2))? (s2-2*[wall,wall]) :\n        undef;\n    checks2 =\n        assert(wall==undef || is_num(wall))\n        assert(size1!=undef, \"Bad size/size1 argument.\")\n        assert(size2!=undef, \"Bad size/size2 argument.\")\n        assert(isize1!=undef, \"Bad isize/isize1 argument.\")\n        assert(isize2!=undef, \"Bad isize/isize2 argument.\")\n        assert(isize1.x < size1.x, \"Inner size is larger than outer size.\")\n        assert(isize1.y < size1.y, \"Inner size is larger than outer size.\")\n        assert(isize2.x < size2.x, \"Inner size is larger than outer size.\")\n        assert(isize2.y < size2.y, \"Inner size is larger than outer size.\")\n        assert(is_num(rounding) || is_vector(rounding,4), \"rounding must be a number or 4-vector\")\n        assert(is_undef(rounding1) || is_num(rounding1) || is_vector(rounding1,4), \"rounding1 must be a number or 4-vector\")\n        assert(is_undef(rounding2) || is_num(rounding2) || is_vector(rounding2,4), \"rounding2 must be a number or 4-vector\")\n        assert(is_num(chamfer) || is_vector(chamfer,4), \"chamfer must be a number or 4-vector\")\n        assert(is_undef(chamfer1) || is_num(chamfer1) || is_vector(chamfer1,4), \"chamfer1 must be a number or 4-vector\")\n        assert(is_undef(chamfer2) || is_num(chamfer2) || is_vector(chamfer2,4), \"chamfer2 must be a number or 4-vector\")\n        assert(is_undef(irounding) || is_num(irounding) || (is_list(irounding) && len(irounding)==4), \"irounding must be a number or 4-vector\")\n        assert(is_undef(irounding1) || is_num(irounding1) || (is_list(irounding1) && len(irounding1)==4), \"irounding1 must be a number or 4-vector\")\n        assert(is_undef(irounding2) || is_num(irounding2) || (is_list(irounding2) && len(irounding2)==4), \"irounding2 must be a number or 4-vector\")      \n        assert(is_undef(ichamfer) || is_num(ichamfer) || (is_list(ichamfer) && len(ichamfer)==4), \"ichamfer must be a number or 4-vector\")\n        assert(is_undef(ichamfer1) || is_num(ichamfer1) || (is_list(ichamfer1) && len(ichamfer1)==4), \"ichamfer1 must be a number or 4-vector\")\n        assert(is_undef(ichamfer2) || is_num(ichamfer2) || (is_list(ichamfer2) && len(ichamfer2)==4), \"ichamfer2 must be a number or 4-vector\");\n    chamfer1=force_list(default(chamfer1,chamfer),4);\n    chamfer2=force_list(default(chamfer2,chamfer),4);\n    rounding1=force_list(default(rounding1,rounding),4);\n    rounding2=force_list(default(rounding2,rounding),4);\n    checks3 =\n        assert(all_nonnegative(chamfer1), \"chamfer/chamfer1 must be non-negative\")\n        assert(all_nonnegative(chamfer2), \"chamfer/chamfer2 must be non-negative\")\n        assert(all_nonnegative(rounding1), \"rounding/rounding1 must be non-negative\")\n        assert(all_nonnegative(rounding2), \"rounding/rounding2 must be non-negative\")        \n        assert(all_zero(v_mul(rounding1,chamfer1),0), \"rounding1 and chamfer1 (possibly inherited from rounding and chamfer) cannot both be nonzero at the same corner\")\n        assert(all_zero(v_mul(rounding2,chamfer2),0), \"rounding2 and chamfer2 (possibly inherited from rounding and chamfer) cannot both be nonzero at the same corner\");\n    irounding1_temp = force_list(default(irounding1,irounding),4);\n    irounding2_temp = force_list(default(irounding2,irounding),4);    \n    ichamfer1_temp = force_list(default(ichamfer1,ichamfer),4);\n    ichamfer2_temp = force_list(default(ichamfer2,ichamfer),4);\n    checksignr1 = [for(entry=irounding1_temp) if (is_def(entry) && entry<0) 1]==[];\n    checksignr2 = [for(entry=irounding2_temp) if (is_def(entry) && entry<0) 1]==[];    \n    checksignc1 = [for(entry=ichamfer1_temp) if (is_def(entry) && entry<0) 1]==[];\n    checksignc2 = [for(entry=ichamfer2_temp) if (is_def(entry) && entry<0) 1]==[];\n    checkconflict1 = [for(i=[0:3]) if (is_def(irounding1_temp[i]) && is_def(ichamfer1_temp[i]) && irounding1_temp[i]!=0 && ichamfer1_temp[i]!=0) 1]==[];\n    checkconflict2 = [for(i=[0:3]) if (is_def(irounding2_temp[i]) && is_def(ichamfer2_temp[i]) && irounding2_temp[i]!=0 && ichamfer2_temp[i]!=0) 1]==[];\n    checks4 =\n        assert(checksignr1, \"irounding/irounding1 must be non-negative\")\n        assert(checksignr2, \"irounding/irounding2 must be non-negative\")\n        assert(checksignc1, \"ichamfer/ichamfer1 must be non-negative\")\n        assert(checksignc2, \"ichamfer/ichamfer2 must be non-negative\")\n        assert(checkconflict1, \"irounding1 and ichamfer1 (possibly inherited from irounding and ichamfer) cannot both be nonzero at the swame corner\")\n        assert(checkconflict2, \"irounding2 and ichamfer2 (possibly inherited from irounding and ichamfer) cannot both be nonzero at the swame corner\");\n    irounding1 = _rect_tube_rounding(1,irounding1_temp, rounding1, ichamfer1_temp, size1, isize1);\n    irounding2 = _rect_tube_rounding(1,irounding2_temp, rounding2, ichamfer2_temp, size2, isize2);\n    ichamfer1 = _rect_tube_rounding(1/sqrt(2),ichamfer1_temp, chamfer1, irounding1_temp, size1, isize1);\n    ichamfer2 = _rect_tube_rounding(1/sqrt(2),ichamfer2_temp, chamfer2, irounding2_temp, size2, isize2);\n    anchor = get_anchor(anchor, center, BOT, BOT);\n    attachable(anchor,spin,orient, size=[each size1, h], size2=size2, shift=shift) {\n        down(h/2) {\n            difference() {\n                prismoid(\n                    size1, size2, h=h, shift=shift,\n                    rounding1=rounding1, rounding2=rounding2,\n                    chamfer1=chamfer1, chamfer2=chamfer2,\n                    anchor=BOT\n                );\n                down(0.01) prismoid(\n                    isize1, isize2, h=h+0.02, shift=shift,\n                    rounding1=irounding1, rounding2=irounding2,\n                    chamfer1=ichamfer1, chamfer2=ichamfer2,\n                    anchor=BOT\n                );\n            }\n        }\n        children();\n    }\n}\n\nfunction rect_tube(\n    h, size, isize, center, shift=[0,0],\n    wall, size1, size2, isize1, isize2,\n    rounding=0, rounding1, rounding2,\n    irounding, irounding1, irounding2,\n    chamfer=0, chamfer1, chamfer2,\n    ichamfer, ichamfer1, ichamfer2,\n    anchor, spin=0, orient=UP,\n    l, length, height\n) = no_function(\"rect_tube\");\n\n\n// Function&Module: wedge()\n// Synopsis: Creates a 3d triangular wedge.\n// SynTags: Geom, VNF\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See also: prismoid(), rounded_prism(), pie_slice()\n// Usage: As Module\n//   wedge(size, [center], ...) [ATTACHMENTS];\n// Usage: As Function\n//   vnf = wedge(size, [center], ...);\n//\n// Description:\n//   When called as a module, creates a 3D triangular wedge with the hypotenuse in the X+Z+ quadrant.\n//   When called as a function, creates a VNF for a 3D triangular wedge with the hypotenuse in the X+Z+ quadrant.\n//\n// Arguments:\n//   size = [width, thickness, height]\n//   center = If given, overrides `anchor`.  A true value sets `anchor=CENTER`, false sets `anchor=UP`.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `FRONT+LEFT+BOTTOM`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Extra Anchors:\n//   hypot = Center of angled wedge face, perpendicular to that face.\n//   hypot_left = Left side of angled wedge face, bisecting the angle between the left side and angled faces.\n//   hypot_right = Right side of angled wedge face, bisecting the angle between the right side and angled faces.\n//\n// Example: Centered\n//   wedge([20, 40, 15], center=true);\n// Example: *Non*-Centered\n//   wedge([20, 40, 15]);\n// Example: Standard Anchors\n//   wedge([40, 80, 30], center=true)\n//       show_anchors(custom=false);\n//   color([0.5,0.5,0.5,0.1])\n//       cube([40, 80, 30], center=true);\n// Example: Named Anchors\n//   wedge([40, 80, 30], center=true)\n//       show_anchors(std=false);\n\nmodule wedge(size=[1, 1, 1], center, anchor, spin=0, orient=UP)\n{\n    size = scalar_vec3(size);\n    anchor = get_anchor(anchor, center, -[1,1,1], -[1,1,1]);\n    vnf = wedge(size, anchor=\"origin\");\n    anchors = [\n        named_anchor(\"hypot\", CTR, unit([0,size.z,size.y],UP)),\n        named_anchor(\"hypot_left\", [-size.x/2,0,0], unit(unit([0,size.z,size.y],UP)+LEFT)),\n        named_anchor(\"hypot_right\", [size.x/2,0,0], unit(unit([0,size.z,size.y],UP)+RIGHT)),\n    ];\n    attachable(anchor,spin,orient, size=size, anchors=anchors) {\n        if (size.z > 0) {\n            vnf_polyhedron(vnf);\n        }\n        children();\n    }\n}\n\n\nfunction wedge(size=[1,1,1], center, anchor, spin=0, orient=UP) =\n    let(\n        size = scalar_vec3(size),\n        anchor = get_anchor(anchor, center, -[1,1,1], -[1,1,1]),\n        pts = [\n            [ 1,1,-1], [ 1,-1,-1], [ 1,-1,1],\n            [-1,1,-1], [-1,-1,-1], [-1,-1,1],\n        ],\n        faces = [\n            [0,1,2], [3,5,4], [0,3,1], [1,3,4],\n            [1,4,2], [2,4,5], [2,5,3], [0,2,3],\n        ],\n        vnf = [scale(size/2,p=pts), faces],\n        anchors = [\n            named_anchor(\"hypot\", CTR, unit([0,size.z,size.y],UP)),\n            named_anchor(\"hypot_left\", [-size.x/2,0,0], unit(unit([0,size.z,size.y],UP)+LEFT)),\n            named_anchor(\"hypot_right\", [size.x/2,0,0], unit(unit([0,size.z,size.y],UP)+RIGHT)),\n        ]\n    )\n    reorient(anchor,spin,orient, size=size, anchors=anchors, p=vnf);\n\n\n// Section: Cylinders\n\n\n// Function&Module: cylinder()\n// Synopsis: Creates an attachable cylinder.\n// SynTags: Geom, VNF, Ext\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See Also: cyl()\n// Usage: As Module (as in native OpenSCAD)\n//   cylinder(h, r=/d=, [center=]);\n//   cylinder(h, r1/d1=, r2/d2=, [center=]);\n// Usage: With BOSL2 anchoring and attachment extensions\n//   cylinder(h, r=/d=, [center=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n//   cylinder(h, r1/d1=, r2/d2=, [center=], [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n// Usage: As Function (BOSL2 extension)\n//   vnf = cylinder(h, r=/d=, ...);\n//   vnf = cylinder(h, r1/d1=, r2/d2=, ...);\n// Description:\n//   Creates a 3D cylinder or conic object.\n//   This modules extends the built-in `cylinder()` module by adding support for attachment and by adding a function version.   \n//   When called as a function, returns a [VNF](vnf.scad) for a cylinder.  \n// Arguments:\n//   h = The height of the cylinder.\n//   r1 = The bottom radius of the cylinder.  (Before orientation.)\n//   r2 = The top radius of the cylinder.  (Before orientation.)\n//   center = If given, overrides `anchor`.  A true value sets `anchor=CENTER`, false sets `anchor=BOTTOM`.  Default: false\n//   ---\n//   d1 = The bottom diameter of the cylinder.  (Before orientation.)\n//   d2 = The top diameter of the cylinder.  (Before orientation.)\n//   r = The radius of the cylinder.\n//   d = The diameter of the cylinder.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example: By Radius\n//   xdistribute(30) {\n//       cylinder(h=40, r=10);\n//       cylinder(h=40, r1=10, r2=5);\n//   }\n// Example: By Diameter\n//   xdistribute(30) {\n//       cylinder(h=40, d=25);\n//       cylinder(h=40, d1=25, d2=10);\n//   }\n// Example(Med): Anchoring\n//   cylinder(h=40, r1=10, r2=5, anchor=BOTTOM+FRONT);\n// Example(Med): Spin\n//   cylinder(h=40, r1=10, r2=5, anchor=BOTTOM+FRONT, spin=45);\n// Example(Med): Orient\n//   cylinder(h=40, r1=10, r2=5, anchor=BOTTOM+FRONT, spin=45, orient=FWD);\n// Example(Big): Standard Connectors\n//   xdistribute(40) {\n//       cylinder(h=30, d=25) show_anchors();\n//       cylinder(h=30, d1=25, d2=10) show_anchors();\n//   }\n\nmodule cylinder(h, r1, r2, center, r, d, d1, d2, anchor, spin=0, orient=UP)\n{\n    anchor = get_anchor(anchor, center, BOTTOM, BOTTOM);\n    r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1);\n    r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1);\n    h = default(h,1);\n    attachable(anchor,spin,orient, r1=r1, r2=r2, l=h) {\n        _cylinder(h=h, r1=r1, r2=r2, center=true);\n        children();\n    }\n}\n\nfunction cylinder(h, r1, r2, center, r, d, d1, d2, anchor, spin=0, orient=UP) =\n    let(\n        anchor = get_anchor(anchor, center, BOTTOM, BOTTOM),\n        r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1),\n        r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1),\n        l = default(h,1),\n        sides = segs(max(r1,r2)),\n        verts = [\n            for (i=[0:1:sides-1]) let(a=360*(1-i/sides)) [r1*cos(a),r1*sin(a),-l/2],\n            for (i=[0:1:sides-1]) let(a=360*(1-i/sides)) [r2*cos(a),r2*sin(a), l/2],\n        ],\n        faces = [\n            [for (i=[0:1:sides-1]) sides-1-i],\n            for (i=[0:1:sides-1]) [i, ((i+1)%sides)+sides, i+sides],\n            for (i=[0:1:sides-1]) [i, (i+1)%sides, ((i+1)%sides)+sides],\n            [for (i=[0:1:sides-1]) sides+i]\n        ]\n    ) [reorient(anchor,spin,orient, l=l, r1=r1, r2=r2, p=verts), faces];\n\n\n\n// Function&Module: cyl()\n// Synopsis: Creates an attachable cylinder with roundovers and chamfering.\n// SynTags: Geom, VNF\n// Topics: Cylinders, Textures, Rounding, Chamfers\n// See Also: texture(), rotate_sweep(), cylinder()\n// Usage: Normal Cylinders\n//   cyl(l|h|length|height, r, [center], [circum=], [realign=]) [ATTACHMENTS];\n//   cyl(l|h|length|height, d=, ...) [ATTACHMENTS];\n//   cyl(l|h|length|height, r1=, r2=, ...) [ATTACHMENTS];\n//   cyl(l|h|length|height, d1=, d2=, ...) [ATTACHMENTS];\n//\n// Usage: Chamferred Cylinders\n//   cyl(l|h|length|height, r|d, chamfer=, [chamfang=], [from_end=], ...);\n//   cyl(l|h|length|height, r|d, chamfer1=, [chamfang1=], [from_end=], ...);\n//   cyl(l|h|length|height, r|d, chamfer2=, [chamfang2=], [from_end=], ...);\n//   cyl(l|h|length|height, r|d, chamfer1=, chamfer2=, [chamfang1=], [chamfang2=], [from_end=], ...);\n//\n// Usage: Rounded End Cylinders\n//   cyl(l|h|length|height, r|d, rounding=, ...);\n//   cyl(l|h|length|height, r|d, rounding1=, ...);\n//   cyl(l|h|length|height, r|d, rounding2=, ...);\n//   cyl(l|h|length|height, r|d, rounding1=, rounding2=, ...);\n//\n// Usage: Textured Cylinders\n//   cyl(l|h|length|height, r|d, texture=, [tex_size=]|[tex_reps=], [tex_depth=], [tex_rot=], [tex_samples=], [style=], [tex_taper=], [tex_inset=], ...);\n//   cyl(l|h|length|height, r1=, r2=, texture=, [tex_size=]|[tex_reps=], [tex_depth=], [tex_rot=], [tex_samples=], [style=], [tex_taper=], [tex_inset=], ...);\n//   cyl(l|h|length|height, d1=, d2=, texture=, [tex_size=]|[tex_reps=], [tex_depth=], [tex_rot=], [tex_samples=], [style=], [tex_taper=], [tex_inset=], ...);\n//\n// Usage: Caled as a function to get a VNF\n//   vnf = cyl(...);\n//\n// Description:\n//   Creates cylinders in various anchorings and orientations, with optional rounding, chamfers, or textures.\n//   You can use `h` and `l` interchangably, and all variants allow specifying size by either `r`|`d`,\n//   or `r1`|`d1` and `r2`|`d2`.  Note: the chamfers and rounding cannot be cumulatively longer than\n//   the cylinder or cone's sloped side.  The more specific parameters like chamfer1 or rounding2 override the more\n//   general ones like chamfer or rounding, so if you specify `rounding=3, chamfer2=3` you will get a chamfer at the top and\n//   rounding at the bottom.\n// Figure(2D,Big,NoAxes,VPR = [0, 0, 0], VPT = [0,0,0], VPD = 82): Chamfers on cones can be tricky.  This figure shows chamfers of the same size and same angle, A=30 degrees.  Note that the angle is measured on the inside, and produces a quite different looking chamfer at the top and bottom of the cone.  Straight black arrows mark the size of the chamfers, which may not even appear the same size visually.  When you do not give an angle, the triangle that is cut off will be isoceles, like the triangle at the top, with two equal angles.\n//  color(\"lightgray\")\n//  projection()\n//      cyl(r2=10, r1=20, l=20,chamfang=30, chamfer=0,orient=BACK);\n//  projection()\n//      cyl(r2=10, r1=20, l=20,chamfang=30, chamfer=8,orient=BACK);\n//  color(\"black\"){\n//      fwd(9.6)right(20-4.8)text(\"A\",size=1.3);\n//      fwd(-8.4)right(10-4.9)text(\"A\",size=1.3);\n//      right(20-8)fwd(10.5)stroke([[0,0],[8,0]], endcaps=\"arrow2\",width=.15);\n//      right(10-8)fwd(-10.5)stroke([[0,0],[8,0]], endcaps=\"arrow2\",width=.15);\n//      stroke(arc(cp=[2,10], angle=[0,-30], n=20, r=5), width=.18, endcaps=\"arrow2\");\n//      stroke(arc(cp=[12,-10], angle=[0,30], n=20, r=5), width=.18, endcaps=\"arrow2\");\n//  }\n// Figure(2D,Big,NoAxes,VPR = [0, 0, 0], VPT = [0,0,0], VPD = 82): The cone in this example is narrow but has the same slope.  With negative chamfers, the angle A=30 degrees is on the outside.  The chamfers are again quite different looking.  As before, the default will feature two congruent angles, and in this case it happens at the bottom of the cone but not the top.  The straight arrows again show the size of the chamfer.\n//  r1=10-7.5;r2=20-7.5;\n//  color(\"lightgray\")\n//  projection()\n//      cyl(r2=r1, r1=r2, l=20,chamfang=30, chamfer=-8,orient=BACK);\n//  projection()\n//      cyl(r2=r1, r1=r2, l=20,chamfang=30, chamfer=0,orient=BACK);\n//  color(\"black\"){\n//      fwd(9.7)right(r2+3.8)text(\"A\",size=1.3);\n//      fwd(-8.5)right(r1+3.7)text(\"A\",size=1.3);\n//      right(r2)fwd(10.5)stroke([[0,0],[8,0]], endcaps=\"arrow2\",width=.15);\n//      right(r1)fwd(-10.5)stroke([[0,0],[8,0]], endcaps=\"arrow2\",width=.15);\n//      stroke(arc(cp=[r1+8,10], angle=[180,180+30], n=20, r=5), width=.18, endcaps=\"arrow2\");\n//      stroke(arc(cp=[r2+8,-10], angle=[180-30,180], n=20, r=5), width=.18, endcaps=\"arrow2\");\n//  }\n// Arguments:\n//   l / h / length / height = Length of cylinder along oriented axis.  Default: 1\n//   r = Radius of cylinder.  Default: 1\n//   center = If given, overrides `anchor`.  A true value sets `anchor=CENTER`, false sets `anchor=DOWN`.\n//   ---\n//   r1 = Radius of the negative (X-, Y-, Z-) end of cylinder.\n//   r2 = Radius of the positive (X+, Y+, Z+) end of cylinder.\n//   d = Diameter of cylinder.\n//   d1 = Diameter of the negative (X-, Y-, Z-) end of cylinder.\n//   d2 = Diameter of the positive (X+, Y+, Z+) end of cylinder.\n//   circum = If true, cylinder should circumscribe the circle of the given size.  Otherwise inscribes.  Default: `false`\n//   shift = [X,Y] amount to shift the center of the top end with respect to the center of the bottom end.\n//   chamfer = The size of the chamfers on the ends of the cylinder.  (Also see: `from_end=`)  Default: none.\n//   chamfer1 = The size of the chamfer on the bottom end of the cylinder.  (Also see: `from_end1=`)  Default: none.\n//   chamfer2 = The size of the chamfer on the top end of the cylinder.  (Also see: `from_end2=`)  Default: none.\n//   chamfang = The angle in degrees of the chamfers away from the ends of the cylinder.  Default: Chamfer angle is halfway between the endcap and cone face.\n//   chamfang1 = The angle in degrees of the bottom chamfer away from the bottom end of the cylinder.  Default: Chamfer angle is halfway between the endcap and cone face.\n//   chamfang2 = The angle in degrees of the top chamfer away from the top end of the cylinder.  Default: Chamfer angle is halfway between the endcap and cone face.\n//   from_end = If true, chamfer is measured along the conic face from the ends of the cylinder, instead of inset from the edge.  Default: `false`.\n//   from_end1 = If true, chamfer on the bottom end of the cylinder is measured along the conic face from the end of the cylinder, instead of inset from the edge.  Default: `false`.\n//   from_end2 = If true, chamfer on the top end of the cylinder is measured along the conic face from the end of the cylinder, instead of inset from the edge.  Default: `false`.\n//   rounding = The radius of the rounding on the ends of the cylinder.  Default: none.\n//   rounding1 = The radius of the rounding on the bottom end of the cylinder.\n//   rounding2 = The radius of the rounding on the top end of the cylinder.\n//   realign = If true, rotate the cylinder by half the angle of one face.\n//   teardrop = If given as a number, rounding around the bottom edge of the cylinder won't exceed this many degrees from vertical.  If true, the limit angle is 45 degrees.  Default: `false`\n//   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0), or a VNF tile that defines the texture to apply to vertical surfaces.  See {{texture()}} for what named textures are supported.\n//   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`\n//   tex_reps = If given instead of tex_size, a 2-vector giving the number of texture tile repetitions in the horizontal and vertical directions.\n//   tex_inset = If numeric, lowers the texture into the surface by the specified proportion, e.g. 0.5 would lower it half way into the surface.  If `true`, insets by exactly its full depth.  Default: `false`\n//   tex_rot = Rotate texture by specified angle, which must be a multiple of 90 degrees.  Default: 0\n//   tex_depth = Specify texture depth; if negative, invert the texture.  Default: 1.  \n//   tex_samples = Minimum number of \"bend points\" to have in VNF texture tiles.  Default: 8\n//   tex_taper = If given as a number, tapers the texture height to zero over the first and last given percentage of the path.  If given as a lookup table with indices between 0 and 100, uses the percentage lookup table to ramp the texture heights.  Default: `undef` (no taper)\n//   style = {{vnf_vertex_array()}} style used to triangulate heightfield textures.  Default: \"min_edge\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n//\n// Example: By Radius\n//   xdistribute(30) {\n//       cyl(l=40, r=10);\n//       cyl(l=40, r1=10, r2=5);\n//   }\n//\n// Example: By Diameter\n//   xdistribute(30) {\n//       cyl(l=40, d=25);\n//       cyl(l=40, d1=25, d2=10);\n//   }\n//\n// Example: Chamferring\n//   xdistribute(60) {\n//       // Shown Left to right.\n//       cyl(l=40, d=40, chamfer=7);  // Default chamfang=45\n//       cyl(l=40, d=40, chamfer=7, chamfang=30, from_end=false);\n//       cyl(l=40, d=40, chamfer=7, chamfang=30, from_end=true);\n//   }\n//\n// Example: Rounding\n//   cyl(l=40, d=40, rounding=10);\n//\n// Example(VPD=175;VPR=[90,0,0]): Teardrop Bottom Rounding\n//   cyl(l=40, d=40, rounding=10, teardrop=true);\n//\n// Example: Heterogenous Chamfers and Rounding\n//   ydistribute(80) {\n//       // Shown Front to Back.\n//       cyl(l=40, d=40, rounding1=15, orient=UP);\n//       cyl(l=40, d=40, chamfer2=5, orient=UP);\n//       cyl(l=40, d=40, chamfer1=12, rounding2=10, orient=UP);\n//   }\n//\n// Example: Putting it all together\n//   cyl(\n//       l=20, d1=25, d2=15,\n//       chamfer1=5, chamfang1=60,\n//       from_end=true, rounding2=5\n//   );\n//\n// Example: External Chamfers\n//   cyl(l=50, r=30, chamfer=-5, chamfang=30, $fa=1, $fs=1);\n//\n// Example: External Roundings\n//   cyl(l=50, r=30, rounding1=-5, rounding2=5, $fa=1, $fs=1);\n//\n// Example(Med): Standard Connectors\n//   xdistribute(40) {\n//       cyl(l=30, d=25) show_anchors();\n//       cyl(l=30, d1=25, d2=10) show_anchors();\n//   }\n//\n// Example: Texturing with heightfield diamonds\n//   cyl(h=40, r=20, texture=\"diamonds\", tex_size=[5,5]);\n//\n// Example: Texturing with heightfield pyramids\n//   cyl(h=40, r1=20, r2=15,\n//       texture=\"pyramids\", tex_size=[5,5],\n//       style=\"convex\");\n//\n// Example: Texturing with heightfield truncated pyramids\n//   cyl(h=40, r1=20, r2=15, chamfer=5,\n//       texture=\"trunc_pyramids\",\n//       tex_size=[5,5], style=\"convex\");\n//\n// Example: Texturing with VNF tile \"dots\"\n//   cyl(h=40, r1=20, r2=15, rounding=9,\n//       texture=\"dots\", tex_size=[5,5],\n//       tex_samples=6);\n//\n// Example: Texturing with VNF tile \"bricks_vnf\"\n//   cyl(h=50, r1=25, r2=20, shift=[0,10], rounding1=-10,\n//       texture=\"bricks_vnf\", tex_size=[10,10],\n//       tex_depth=0.5, style=\"concave\");\n//\n// Example: No Texture Taper\n//   cyl(d1=25, d2=20, h=30, rounding=5,\n//       texture=\"trunc_ribs\", tex_size=[5,1]);\n//\n// Example: Taper Texure at Extreme Ends\n//   cyl(d1=25, d2=20, h=30, rounding=5,\n//       texture=\"trunc_ribs\", tex_taper=0,\n//       tex_size=[5,1]);\n//\n// Example: Taper Texture over First and Last 10%\n//   cyl(d1=25, d2=20, h=30, rounding=5,\n//       texture=\"trunc_ribs\", tex_taper=10,\n//       tex_size=[5,1]);\n//\n// Example: Making a Clay Pattern Roller\n//   tex = [\n//       [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],\n//       [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],\n//       [1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,],\n//       [1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,],\n//       [0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,],\n//       [0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,],\n//       [0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,0,],\n//       [0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,0,],\n//       [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,],\n//       [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,],\n//       [0,1,1,0,0,1,1,1,1,1,1,0,0,1,1,0,],\n//       [0,1,1,0,0,1,1,1,1,1,1,0,0,1,1,0,],\n//       [0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,],\n//       [0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,],\n//       [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,],\n//       [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,],\n//       [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],\n//   ];\n//   diff()\n//   cyl(d=20*10/PI, h=10, chamfer=0,\n//       texture=tex, tex_reps=[20,1], tex_depth=-1,\n//       tex_taper=undef, style=\"concave\") {\n//           attach([TOP,BOT]) {\n//               cyl(d1=20*10/PI, d2=30, h=5, anchor=BOT)\n//                   attach(TOP) {\n//                       tag(\"remove\") zscale(0.5) up(3) sphere(d=15);\n//                   }\n//           }\n//   }\n\nfunction cyl(\n    h, r, center,\n    l, r1, r2,\n    d, d1, d2,\n    length, height,\n    chamfer, chamfer1, chamfer2,\n    chamfang, chamfang1, chamfang2,\n    rounding, rounding1, rounding2,\n    circum=false, realign=false, shift=[0,0],\n    teardrop=false,\n    from_end, from_end1, from_end2,\n    texture, tex_size=[5,5], tex_reps, tex_counts,\n    tex_inset=false, tex_rot=0,\n    tex_scale, tex_depth, tex_samples, length, height, \n    tex_taper, style, tex_style,\n    anchor, spin=0, orient=UP\n) =\n    assert(num_defined([style,tex_style])<2, \"In cyl() the 'tex_style' parameters has been replaced by 'style'.  You cannot give both.\")\n    assert(num_defined([tex_reps,tex_counts])<2, \"In cyl() the 'tex_counts' parameters has been replaced by 'tex_reps'.  You cannot give both.\")    \n    assert(num_defined([tex_scale,tex_depth])<2, \"In linear_sweep() the 'tex_scale' parameter has been replaced by 'tex_depth'.  You cannot give both.\")\n    let(\n        style = is_def(tex_style)? echo(\"In cyl() the 'tex_style' parameter is deprecated and has been replaced by 'style'\")tex_style\n              : default(style,\"min_edge\"),\n        tex_reps = is_def(tex_counts)? echo(\"In cyl() the 'tex_counts' parameter is deprecated and has been replaced by 'tex_reps'\")tex_counts\n                 : tex_reps,\n        tex_depth = is_def(tex_scale)? echo(\"In rotate_sweep() the 'tex_scale' parameter is deprecated and has been replaced by 'tex_depth'\")tex_scale\n                  : default(tex_depth,1),\n        l = one_defined([l, h, length, height],\"l,h,length,height\",dflt=1),\n        _r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1),\n        _r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1),\n        sides = segs(max(_r1,_r2)),\n        sc = circum? 1/cos(180/sides) : 1,\n        r1 = _r1 * sc,\n        r2 = _r2 * sc,\n        phi = atan2(l, r2-r1),\n        anchor = get_anchor(anchor,center,BOT,CENTER)\n    )\n    assert(is_finite(l), \"l/h/length/height must be a finite number.\")\n    assert(is_finite(r1), \"r/r1/d/d1 must be a finite number.\")\n    assert(is_finite(r2), \"r2 or d2 must be a finite number.\")\n    assert(is_vector(shift,2), \"shift must be a 2D vector.\")\n    let(\n        vnf = !any_defined([chamfer, chamfer1, chamfer2, rounding, rounding1, rounding2, texture])\n          ? cylinder(h=l, r1=r1, r2=r2, center=true, $fn=sides)\n          : let(\n                vang = atan2(r1-r2,l),\n                _chamf1 = first_defined([chamfer1, if (is_undef(rounding1)) chamfer, 0]),\n                _chamf2 = first_defined([chamfer2, if (is_undef(rounding2)) chamfer, 0]),\n                _fromend1 = first_defined([from_end1, from_end, false]),\n                _fromend2 = first_defined([from_end2, from_end, false]),\n                chang1 = first_defined([chamfang1, chamfang, 45+sign(_chamf1)*vang/2]),\n                chang2 = first_defined([chamfang2, chamfang, 45-sign(_chamf2)*vang/2]),\n                round1 = first_defined([rounding1, if (is_undef(chamfer1)) rounding, 0]),\n                round2 = first_defined([rounding2, if (is_undef(chamfer2)) rounding, 0]),\n                checks1 =\n                    assert(is_finite(_chamf1), \"chamfer1 must be a finite number if given.\")\n                    assert(is_finite(_chamf2), \"chamfer2 must be a finite number if given.\")\n                    assert(is_finite(chang1) && chang1>0, \"chamfang1 must be a positive number if given.\")\n                    assert(is_finite(chang2) && chang2>0, \"chamfang2 must be a positive number if given.\")\n                    assert(chang1<90+sign(_chamf1)*vang, \"chamfang1 must be smaller than the cone face angle\")\n                    assert(chang2<90-sign(_chamf2)*vang, \"chamfang2 must be smaller than the cone face angle\")\n                    assert(num_defined([chamfer1,rounding1])<2, \"cannot define both chamfer1 and rounding1\")\n                    assert(num_defined([chamfer2,rounding2])<2, \"cannot define both chamfer2 and rounding2\")\n                    assert(num_defined([chamfer,rounding])<2, \"cannot define both chamfer and rounding\")                                \n                    undef,\n                chamf1r = !_chamf1? 0\n                        : !_fromend1? _chamf1\n                        : law_of_sines(a=_chamf1, A=chang1, B=180-chang1-(90-sign(_chamf2)*vang)),\n                chamf2r = !_chamf2? 0\n                        : !_fromend2? _chamf2\n                        : law_of_sines(a=_chamf2, A=chang2, B=180-chang2-(90+sign(_chamf2)*vang)),\n                chamf1l = !_chamf1? 0\n                        : _fromend1? abs(_chamf1)\n                        : abs(law_of_sines(a=_chamf1, A=180-chang1-(90-sign(_chamf1)*vang), B=chang1)),\n                chamf2l = !_chamf2? 0\n                        : _fromend2? abs(_chamf2)\n                        : abs(law_of_sines(a=_chamf2, A=180-chang2-(90+sign(_chamf2)*vang), B=chang2)),\n                facelen = adj_ang_to_hyp(l, abs(vang)),\n\n                cp1 = [r1,-l/2],\n                cp2 = [r2,+l/2],\n                roundlen1 = round1 >= 0 ? round1/tan(45-vang/2)\n                                        : round1/tan(45+vang/2),\n                roundlen2 = round2 >=0 ? round2/tan(45+vang/2)\n                                       : round2/tan(45-vang/2),\n                dy1 = abs(_chamf1 ? chamf1l : round1 ? roundlen1 : 0), \n                dy2 = abs(_chamf2 ? chamf2l : round2 ? roundlen2 : 0),\n\n                td_ang = teardrop == true? 45 :\n                    teardrop == false? 90 :\n                    assert(is_finite(teardrop))\n                    assert(teardrop>=0 && teardrop<=90)\n                    teardrop,\n\n                checks2 =\n                    assert(is_finite(round1), \"rounding1 must be a number if given.\")\n                    assert(is_finite(round2), \"rounding2 must be a number if given.\")\n                    assert(chamf1r <= r1, \"chamfer1 is larger than the r1 radius of the cylinder.\")\n                    assert(chamf2r <= r2, \"chamfer2 is larger than the r2 radius of the cylinder.\")\n                    assert(roundlen1 <= r1, \"size of rounding1 is larger than the r1 radius of the cylinder.\")\n                    assert(roundlen2 <= r2, \"size of rounding2 is larger than the r2 radius of the cylinder.\")\n                    assert(dy1+dy2 <= facelen, \"Chamfers/roundings don't fit on the cylinder/cone.  They exceed the length of the cylinder/cone face.\")\n                    undef,\n                path = [\n                    if (texture==undef) [0,-l/2],\n\n                    if (!approx(chamf1r,0))\n                        each [\n                            [r1, -l/2] + polar_to_xy(chamf1r,180),\n                            [r1, -l/2] + polar_to_xy(chamf1l,90+vang),\n                        ]\n                    else if (!approx(round1,0) && td_ang < 90)\n                        each _teardrop_corner(r=round1, corner=[[max(0,r1-2*roundlen1),-l/2],[r1,-l/2],[r2,l/2]], ang=td_ang)\n                    else if (!approx(round1,0) && td_ang >= 90)\n                        each arc(r=abs(round1), corner=[[max(0,r1-2*roundlen1),-l/2],[r1,-l/2],[r2,l/2]])\n                    else [r1,-l/2],\n\n                    if (is_finite(chamf2r) && !approx(chamf2r,0))\n                        each [\n                            [r2, l/2] + polar_to_xy(chamf2l,270+vang),\n                            [r2, l/2] + polar_to_xy(chamf2r,180),\n                        ]\n                    else if (is_finite(round2) && !approx(round2,0))\n                        each arc(r=abs(round2), corner=[[r1,-l/2],[r2,l/2],[max(0,r2-2*roundlen2),l/2]])\n                    else [r2,l/2],\n\n                    if (texture==undef) [0,l/2],\n                ]\n            ) rotate_sweep(path,\n                texture=texture, tex_reps=tex_reps, tex_size=tex_size,\n                tex_inset=tex_inset, tex_rot=tex_rot,\n                tex_depth=tex_depth, tex_samples=tex_samples,\n                tex_taper=tex_taper, style=style, closed=false\n            ),\n        skmat = down(l/2) *\n            skew(sxz=shift.x/l, syz=shift.y/l) *\n            up(l/2) *\n            zrot(realign? 180/sides : 0),\n        ovnf = apply(skmat, vnf)\n    )\n    reorient(anchor,spin,orient, r1=r1, r2=r2, l=l, shift=shift, p=ovnf);\n\n\nfunction _teardrop_corner(r, corner, ang=45) =\n    let(\n        check = assert(len(corner)==3)\n            assert(is_finite(r))\n            assert(is_finite(ang)),\n        cp = circle_2tangents(abs(r), corner)[0],\n        path1 = arc(r=abs(r), corner=corner),\n        path2 = [\n            for (p = select(path1,0,-2))\n                if (abs(modang(v_theta(p-cp)-90)) <= 180-ang) p,\n            last(path1)\n        ],\n        path = [\n            line_intersection([corner[0],corner[1]],[path2[0],path2[0]+polar_to_xy(1,-90-ang*sign(r))]),\n            each path2\n        ]\n    ) path;\n\n\nmodule cyl(\n    h, r, center,\n    l, r1, r2,\n    d, d1, d2,\n    chamfer, chamfer1, chamfer2,\n    chamfang, chamfang1, chamfang2,\n    rounding, rounding1, rounding2,\n    circum=false, realign=false, shift=[0,0],\n    teardrop=false,\n    from_end, from_end1, from_end2,\n    texture, tex_size=[5,5], tex_reps, tex_counts,\n    tex_inset=false, tex_rot=0,\n    tex_scale, tex_depth, tex_samples, length, height, \n    tex_taper, style, tex_style,\n    anchor, spin=0, orient=UP\n) {\n    dummy=\n      assert(num_defined([style,tex_style])<2, \"In cyl() the 'tex_style' parameters has been replaced by 'style'.  You cannot give both.\")\n      assert(num_defined([tex_reps,tex_counts])<2, \"In cyl() the 'tex_counts' parameters has been replaced by 'tex_reps'.  You cannot give both.\")\n      assert(num_defined([tex_scale,tex_depth])<2, \"In cyl() the 'tex_scale' parameter has been replaced by 'tex_depth'.  You cannot give both.\");\n    style = is_def(tex_style)? echo(\"In cyl the 'tex_style()' parameters is deprecated and has been replaced by 'style'\")tex_style\n          : default(style,\"min_edge\");\n    tex_reps = is_def(tex_counts)? echo(\"In cyl() the 'tex_counts' parameter is deprecated and has been replaced by 'tex_reps'\")tex_counts\n             : tex_reps;\n    tex_depth = is_def(tex_scale)? echo(\"In rotate_sweep() the 'tex_scale' parameter is deprecated and has been replaced by 'tex_depth'\")tex_scale\n              : default(tex_depth,1);\n    l = one_defined([l, h, length, height],\"l,h,length,height\",dflt=1);\n    _r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1);\n    _r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1);\n    sides = segs(max(_r1,_r2));\n    sc = circum? 1/cos(180/sides) : 1;\n    r1 = _r1 * sc;\n    r2 = _r2 * sc;\n    phi = atan2(l, r2-r1);\n    anchor = get_anchor(anchor,center,BOT,CENTER);\n    skmat = down(l/2) * skew(sxz=shift.x/l, syz=shift.y/l) * up(l/2);\n    attachable(anchor,spin,orient, r1=r1, r2=r2, l=l, shift=shift) {\n        multmatrix(skmat)\n        zrot(realign? 180/sides : 0) {\n            if (!any_defined([chamfer, chamfer1, chamfer2, rounding, rounding1, rounding2, texture])) {\n                cylinder(h=l, r1=r1, r2=r2, center=true, $fn=sides);\n            } else {\n                vnf = cyl(\n                    l=l, r1=r1, r2=r2, center=true, \n                    chamfer=chamfer, chamfer1=chamfer1, chamfer2=chamfer2,\n                    chamfang=chamfang, chamfang1=chamfang1, chamfang2=chamfang2,\n                    rounding=rounding, rounding1=rounding1, rounding2=rounding2,\n                    from_end=from_end, from_end1=from_end1, from_end2=from_end2,\n                    teardrop=teardrop,\n                    texture=texture, tex_size=tex_size,\n                    tex_reps=tex_reps, tex_depth=tex_depth,\n                    tex_inset=tex_inset, tex_rot=tex_rot,\n                    style=style, tex_taper=tex_taper,\n                    tex_samples=tex_samples\n                );\n                vnf_polyhedron(vnf, convexity=texture!=undef? 2 : 10);\n            }\n        }\n        children();\n    }\n}\n\n\n\n// Module: xcyl()\n// Synopsis: creates a cylinder oriented along the X axis.\n// SynTags: Geom\n// Topics: Cylinders, Textures, Rounding, Chamfers\n// See Also: texture(), rotate_sweep(), cyl()\n// Description:\n//   Creates an attachable cylinder with roundovers and chamfering oriented along the X axis.\n//\n// Usage: Typical\n//   xcyl(l|h|length|height, r|d=, [anchor=], ...) [ATTACHMENTS];\n//   xcyl(l|h|length|height, r1=|d1=, r2=|d2=, [anchor=], ...) [ATTACHMENTS];\n//\n// Arguments:\n//   l / h / length / height = Length of cylinder along oriented axis. Default: 1\n//   r = Radius of cylinder.  Default: 1\n//   ---\n//   r1 = Optional radius of left (X-) end of cylinder.\n//   r2 = Optional radius of right (X+) end of cylinder.\n//   d = Optional diameter of cylinder. (use instead of `r`)\n//   d1 = Optional diameter of left (X-) end of cylinder.\n//   d2 = Optional diameter of right (X+) end of cylinder.\n//   circum = If true, cylinder should circumscribe the circle of the given size.  Otherwise inscribes.  Default: `false`\n//   chamfer = The size of the chamfers on the ends of the cylinder.  Default: none.\n//   chamfer1 = The size of the chamfer on the left end of the cylinder.  Default: none.\n//   chamfer2 = The size of the chamfer on the right end of the cylinder.  Default: none.\n//   chamfang = The angle in degrees of the chamfers on the ends of the cylinder.\n//   chamfang1 = The angle in degrees of the chamfer on the left end of the cylinder.\n//   chamfang2 = The angle in degrees of the chamfer on the right end of the cylinder.\n//   from_end = If true, chamfer is measured from the end of the cylinder, instead of inset from the edge.  Default: `false`.\n//   rounding = The radius of the rounding on the ends of the cylinder.  Default: none.\n//   rounding1 = The radius of the rounding on the left end of the cylinder.\n//   rounding2 = The radius of the rounding on the right end of the cylinder.\n//   realign = If true, rotate the cylinder by half the angle of one face.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Example: By Radius\n//   ydistribute(50) {\n//       xcyl(l=35, r=10);\n//       xcyl(l=35, r1=15, r2=5);\n//   }\n//\n// Example: By Diameter\n//   ydistribute(50) {\n//       xcyl(l=35, d=20);\n//       xcyl(l=35, d1=30, d2=10);\n//   }\n\nfunction xcyl(\n    h, r, d, r1, r2, d1, d2, l, \n    chamfer, chamfer1, chamfer2,\n    chamfang, chamfang1, chamfang2,\n    rounding, rounding1, rounding2,\n    circum=false, realign=false, from_end=false, length, height,\n    anchor=CENTER, spin=0, orient=UP\n) = no_function(\"xcyl\");\n\nmodule xcyl(\n    h, r, d, r1, r2, d1, d2, l, \n    chamfer, chamfer1, chamfer2,\n    chamfang, chamfang1, chamfang2,\n    rounding, rounding1, rounding2,\n    circum=false, realign=false, from_end=false, length, height,\n    anchor=CENTER, spin=0, orient=UP\n) {\n    r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1);\n    r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1);\n    l = one_defined([l,h,length,height],\"l,h,length,height\",1);\n    attachable(anchor,spin,orient, r1=r1, r2=r2, l=l, axis=RIGHT) {\n        cyl(\n            l=l, r1=r1, r2=r2,\n            chamfer=chamfer, chamfer1=chamfer1, chamfer2=chamfer2,\n            chamfang=chamfang, chamfang1=chamfang1, chamfang2=chamfang2,\n            rounding=rounding, rounding1=rounding1, rounding2=rounding2,\n            circum=circum, realign=realign, from_end=from_end,\n            anchor=CENTER, orient=RIGHT\n        );\n        children();\n    }\n}\n\n\n// Module: ycyl()\n// Synopsis: Creates a cylinder oriented along the y axis.\n// SynTags: Geom\n// Topics: Cylinders, Textures, Rounding, Chamfers\n// See Also: texture(), rotate_sweep(), cyl()\n// Description:\n//   Creates an attachable cylinder with roundovers and chamfering oriented along the y axis.\n//\n// Usage: Typical\n//   ycyl(l|h|length|height, r|d=, [anchor=], ...) [ATTACHMENTS];\n//   ycyl(l|h|length|height, r1=|d1=, r2=|d2=, [anchor=], ...) [ATTACHMENTS];\n//\n// Arguments:\n//   l / h / length / height = Length of cylinder along oriented axis. (Default: `1.0`)\n//   r = Radius of cylinder.\n//   ---\n//   r1 = Radius of front (Y-) end of cone.\n//   r2 = Radius of back (Y+) end of one.\n//   d = Diameter of cylinder.\n//   d1 = Diameter of front (Y-) end of one.\n//   d2 = Diameter of back (Y+) end of one.\n//   circum = If true, cylinder should circumscribe the circle of the given size.  Otherwise inscribes.  Default: `false`\n//   chamfer = The size of the chamfers on the ends of the cylinder.  Default: none.\n//   chamfer1 = The size of the chamfer on the front end of the cylinder.  Default: none.\n//   chamfer2 = The size of the chamfer on the back end of the cylinder.  Default: none.\n//   chamfang = The angle in degrees of the chamfers on the ends of the cylinder.\n//   chamfang1 = The angle in degrees of the chamfer on the front end of the cylinder.\n//   chamfang2 = The angle in degrees of the chamfer on the back end of the cylinder.\n//   from_end = If true, chamfer is measured from the end of the cylinder, instead of inset from the edge.  Default: `false`.\n//   rounding = The radius of the rounding on the ends of the cylinder.  Default: none.\n//   rounding1 = The radius of the rounding on the front end of the cylinder.\n//   rounding2 = The radius of the rounding on the back end of the cylinder.\n//   realign = If true, rotate the cylinder by half the angle of one face.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Example: By Radius\n//   xdistribute(50) {\n//       ycyl(l=35, r=10);\n//       ycyl(l=35, r1=15, r2=5);\n//   }\n//\n// Example: By Diameter\n//   xdistribute(50) {\n//       ycyl(l=35, d=20);\n//       ycyl(l=35, d1=30, d2=10);\n//   }\n\nfunction ycyl(\n    h, r, d, r1, r2, d1, d2, l,\n    chamfer, chamfer1, chamfer2,\n    chamfang, chamfang1, chamfang2,\n    rounding, rounding1, rounding2,\n    circum=false, realign=false, from_end=false,height,length,\n    anchor=CENTER, spin=0, orient=UP\n) = no_function(\"ycyl\");\n\n\nmodule ycyl(\n    h, r, d, r1, r2, d1, d2, l,\n    chamfer, chamfer1, chamfer2,\n    chamfang, chamfang1, chamfang2,\n    rounding, rounding1, rounding2,\n    circum=false, realign=false, from_end=false,height,length,\n    anchor=CENTER, spin=0, orient=UP\n) {\n    r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1);\n    r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1);\n    l = one_defined([l,h,length,height],\"l,h,length,height\",1);\n    attachable(anchor,spin,orient, r1=r1, r2=r2, l=l, axis=BACK) {\n        cyl(\n            l=l, r1=r1, r2=r2,\n            chamfer=chamfer, chamfer1=chamfer1, chamfer2=chamfer2,\n            chamfang=chamfang, chamfang1=chamfang1, chamfang2=chamfang2,\n            rounding=rounding, rounding1=rounding1, rounding2=rounding2,\n            circum=circum, realign=realign, from_end=from_end,\n            anchor=CENTER, orient=BACK\n        );\n        children();\n    }\n}\n\n\n\n// Module: zcyl()\n// Synopsis: Creates a cylinder oriented along the Z axis.\n// SynTags: Geom\n// Topics: Cylinders, Textures, Rounding, Chamfers\n// See Also: texture(), rotate_sweep(), cyl()\n// Description:\n//   Creates an attachable cylinder with roundovers and chamfering oriented along the Z axis.\n//\n// Usage: Typical\n//   zcyl(l|h|length|height, r|d=, [anchor=],...) [ATTACHMENTS];\n//   zcyl(l|h|length|height, r1=|d1=, r2=|d2=, [anchor=],...);\n//\n// Arguments:\n//   l / h / length / height = Length of cylinder along oriented axis. (Default: 1.0)\n//   r = Radius of cylinder.\n//   ---\n//   r1 = Radius of front (Y-) end of cone.\n//   r2 = Radius of back (Y+) end of one.\n//   d = Diameter of cylinder.\n//   d1 = Diameter of front (Y-) end of one.\n//   d2 = Diameter of back (Y+) end of one.\n//   circum = If true, cylinder should circumscribe the circle of the given size.  Otherwise inscribes.  Default: `false`\n//   chamfer = The size of the chamfers on the ends of the cylinder.  Default: none.\n//   chamfer1 = The size of the chamfer on the bottom end of the cylinder.  Default: none.\n//   chamfer2 = The size of the chamfer on the top end of the cylinder.  Default: none.\n//   chamfang = The angle in degrees of the chamfers on the ends of the cylinder.\n//   chamfang1 = The angle in degrees of the chamfer on the bottom end of the cylinder.\n//   chamfang2 = The angle in degrees of the chamfer on the top end of the cylinder.\n//   from_end = If true, chamfer is measured from the end of the cylinder, instead of inset from the edge.  Default: `false`.\n//   rounding = The radius of the rounding on the ends of the cylinder.  Default: none.\n//   rounding1 = The radius of the rounding on the bottom end of the cylinder.\n//   rounding2 = The radius of the rounding on the top end of the cylinder.\n//   realign = If true, rotate the cylinder by half the angle of one face.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Example: By Radius\n//   xdistribute(50) {\n//       zcyl(l=35, r=10);\n//       zcyl(l=35, r1=15, r2=5);\n//   }\n//\n// Example: By Diameter\n//   xdistribute(50) {\n//       zcyl(l=35, d=20);\n//       zcyl(l=35, d1=30, d2=10);\n//   }\n\nfunction zcyl(\n    h, r, d, r1, r2, d1, d2, l,\n    chamfer, chamfer1, chamfer2,\n    chamfang, chamfang1, chamfang2,\n    rounding, rounding1, rounding2,\n    circum=false, realign=false, from_end=false, length, height,\n    anchor=CENTER, spin=0, orient=UP\n) = no_function(\"zcyl\");\n\nmodule zcyl(\n    h, r, d, r1, r2, d1, d2, l,\n    chamfer, chamfer1, chamfer2,\n    chamfang, chamfang1, chamfang2,\n    rounding, rounding1, rounding2,\n    circum=false, realign=false, from_end=false, length, height,\n    anchor=CENTER, spin=0, orient=UP\n) {\n    r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=1);\n    r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=1);\n    l = one_defined([l,h,length,height],\"l,h,length,height\",1);\n    attachable(anchor,spin,orient, r1=r1, r2=r2, l=l) {\n        cyl(\n            l=l, r1=r1, r2=r2,\n            chamfer=chamfer, chamfer1=chamfer1, chamfer2=chamfer2,\n            chamfang=chamfang, chamfang1=chamfang1, chamfang2=chamfang2,\n            rounding=rounding, rounding1=rounding1, rounding2=rounding2,\n            circum=circum, realign=realign, from_end=from_end,\n            anchor=CENTER\n        );\n        children();\n    }\n}\n\n\n\n// Module: tube()\n// Synopsis: Creates a cylindrical or conical tube.\n// SynTags: Geom\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See Also: rect_tube()\n// Description:\n//   Makes a hollow tube that can be cylindrical or conical by specifying inner and outer dimensions or by giving one dimension and\n//   wall thickness. \n// Usage: Basic cylindrical tube, specifying inner and outer radius or diameter\n//   tube(h|l, or, ir, [center], [realign=], [anchor=], [spin=],[orient=]) [ATTACHMENTS];\n//   tube(h|l, od=, id=, ...)  [ATTACHMENTS];\n// Usage: Specify wall thickness\n//   tube(h|l, or|od=|ir=|id=, wall=, ...) [ATTACHMENTS];\n// Usage: Conical tubes\n//   tube(h|l, ir1=|id1=, ir2=|id2=, or1=|od1=, or2=|od2=, ...) [ATTACHMENTS];\n//   tube(h|l, or1=|od1=, or2=|od2=, wall=, ...) [ATTACHMENTS];\n// Arguments:\n//   h / l = height of tube. Default: 1\n//   or = Outer radius of tube. Default: 1\n//   ir = Inner radius of tube.\n//   center = If given, overrides `anchor`.  A true value sets `anchor=CENTER`, false sets `anchor=DOWN`.\n//   ---\n//   od = Outer diameter of tube.\n//   id = Inner diameter of tube.\n//   wall = horizontal thickness of tube wall. Default 1\n//   or1 = Outer radius of bottom of tube.  Default: value of r)\n//   or2 = Outer radius of top of tube.  Default: value of r)\n//   od1 = Outer diameter of bottom of tube.\n//   od2 = Outer diameter of top of tube.\n//   ir1 = Inner radius of bottom of tube.\n//   ir2 = Inner radius of top of tube.\n//   id1 = Inner diameter of bottom of tube.\n//   id2 = Inner diameter of top of tube.\n//   realign = If true, rotate the tube by half the angle of one face.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Example: These all Produce the Same Tube\n//   tube(h=30, or=40, wall=5);\n//   tube(h=30, ir=35, wall=5);\n//   tube(h=30, or=40, ir=35);\n//   tube(h=30, od=80, id=70);\n// Example: These all Produce the Same Conical Tube\n//   tube(h=30, or1=40, or2=25, wall=5);\n//   tube(h=30, ir1=35, or2=20, wall=5);\n//   tube(h=30, or1=40, or2=25, ir1=35, ir2=20);\n// Example: Circular Wedge\n//   tube(h=30, or1=40, or2=30, ir1=20, ir2=30);\n// Example: Standard Connectors\n//   tube(h=30, or=40, wall=5) show_anchors();\n\nfunction tube(\n     h, or, ir, center,\n    od, id, wall,\n    or1, or2, od1, od2,\n    ir1, ir2, id1, id2,\n    realign=false, l, length, height,\n    anchor, spin=0, orient=UP\n) = no_function(\"tube\");\n\nmodule tube(\n    h, or, ir, center,\n    od, id, wall,\n    or1, or2, od1, od2,\n    ir1, ir2, id1, id2,\n    realign=false, l, length, height,\n    anchor, spin=0, orient=UP\n) {\n    h = one_defined([h,l,height,length],\"h,l,height,length\",dflt=1);\n    orr1 = get_radius(r1=or1, r=or, d1=od1, d=od, dflt=undef);\n    orr2 = get_radius(r1=or2, r=or, d1=od2, d=od, dflt=undef);\n    irr1 = get_radius(r1=ir1, r=ir, d1=id1, d=id, dflt=undef);\n    irr2 = get_radius(r1=ir2, r=ir, d1=id2, d=id, dflt=undef);\n    wall = default(wall, 1);\n    r1 = default(orr1, u_add(irr1,wall));\n    r2 = default(orr2, u_add(irr2,wall));\n    ir1 = default(irr1, u_sub(orr1,wall));\n    ir2 = default(irr2, u_sub(orr2,wall));\n    checks =\n        assert(all_defined([r1, r2, ir1, ir2]), \"Must specify two of inner radius/diam, outer radius/diam, and wall width.\")\n        assert(ir1 <= r1, \"Inner radius is larger than outer radius.\")\n        assert(ir2 <= r2, \"Inner radius is larger than outer radius.\");\n    sides = segs(max(r1,r2));\n    anchor = get_anchor(anchor, center, BOT, CENTER);\n    attachable(anchor,spin,orient, r1=r1, r2=r2, l=h) {\n        zrot(realign? 180/sides : 0) {\n            difference() {\n                cyl(h=h, r1=r1, r2=r2, $fn=sides) children();\n                cyl(h=h+0.05, r1=ir1, r2=ir2);\n            }\n        }\n        children();\n    }\n}\n\n\n\n// Function&Module: pie_slice()\n// Synopsis: Creates a pie slice shape.\n// SynTags: Geom, VNF\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See Also: wedge()\n// Description:\n//   Creates a pie slice shape.\n//\n// Usage: As Module\n//   pie_slice(l|h=|height=|length=, r, ang, [center]);\n//   pie_slice(l|h=|height=|length=, d=, ang=, ...);\n//   pie_slice(l|h=|height=|length=, r1=|d1=, r2=|d2=, ang=, ...);\n// Usage: As Function\n//   vnf = pie_slice(l|h=|height=|length=, r, ang, [center]);\n//   vnf = pie_slice(l|h=|height=|length=, d=, ang=, ...);\n//   vnf = pie_slice(l|h=|height=|length=, r1=|d1=, r2=|d2=, ang=, ...);\n// Usage: Attaching Children\n//   pie_slice(l|h, r, ang, ...) ATTACHMENTS;\n//\n// Arguments:\n//   h / l / height / length = height of pie slice.\n//   r = radius of pie slice.\n//   ang = pie slice angle in degrees.\n//   center = If given, overrides `anchor`.  A true value sets `anchor=CENTER`, false sets `anchor=UP`.\n//   ---\n//   r1 = bottom radius of pie slice.\n//   r2 = top radius of pie slice.\n//   d = diameter of pie slice.\n//   d1 = bottom diameter of pie slice.\n//   d2 = top diameter of pie slice.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Example: Cylindrical Pie Slice\n//   pie_slice(ang=45, l=20, r=30);\n// Example: Conical Pie Slice\n//   pie_slice(ang=60, l=20, d1=50, d2=70);\n// Example: Big Slice\n//   pie_slice(ang=300, l=20, d1=50, d2=70);\n// Example: Generating a VNF\n//   vnf = pie_slice(ang=150, l=20, r1=30, r2=50);\n//   vnf_polyhedron(vnf);\n\nmodule pie_slice(\n    h, r, ang=30, center,\n    r1, r2, d, d1, d2, l, length, height,\n    anchor, spin=0, orient=UP\n) {\n    l = one_defined([l, h,height,length],\"l,h,height,length\",dflt=1);\n    r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=10);\n    r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=10);\n    maxd = max(r1,r2)+0.1;\n    anchor = get_anchor(anchor, center, BOT, BOT);\n    attachable(anchor,spin,orient, r1=r1, r2=r2, l=l) {\n        difference() {\n            cyl(r1=r1, r2=r2, h=l);\n            if (ang<180) rotate(ang) back(maxd/2) cube([2*maxd, maxd, l+0.1], center=true);\n            difference() {\n                fwd(maxd/2) cube([2*maxd, maxd, l+0.2], center=true);\n                if (ang>180) rotate(ang-180) back(maxd/2) cube([2*maxd, maxd, l+0.1], center=true);\n            }\n        }\n        children();\n    }\n}\n\nfunction pie_slice(\n    h, r, ang=30, center,\n    r1, r2, d, d1, d2, l, length, height,\n    anchor, spin=0, orient=UP\n) = let(\n        anchor = get_anchor(anchor, center, BOT, BOT),\n        l = one_defined([l, h,height,length],\"l,h,height,length\",dflt=1),\n        r1 = get_radius(r1=r1, r=r, d1=d1, d=d, dflt=10),\n        r2 = get_radius(r1=r2, r=r, d1=d2, d=d, dflt=10),\n        maxd = max(r1,r2)+0.1,\n        sides = ceil(segs(max(r1,r2))*ang/360),\n        step = ang/sides,\n        vnf = vnf_vertex_array(\n            points=[\n                for (u = [0,1]) let(\n                    h = lerp(-l/2,l/2,u),\n                    r = lerp(r1,r2,u)\n                ) [\n                    for (theta = [0:step:ang+EPSILON])\n                        cylindrical_to_xyz(r,theta,h),\n                    [0,0,h]\n                ]\n            ],\n            col_wrap=true, caps=true, reverse=true\n        )\n    ) reorient(anchor,spin,orient, r1=r1, r2=r2, l=l, p=vnf);\n\n\n\n// Section: Other Round Objects\n\n\n// Function&Module: sphere()\n// Synopsis: Creates an attachable spherical object.\n// SynTags: Geom, VNF, Ext\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See Also: spheroid()\n// Usage: As Module (native OpenSCAD)\n//   sphere(r|d=);\n// Usage: Using BOSL2 attachments extensions\n//   sphere(r|d=, [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n// Usage: As Function (BOSL2 extension)\n//   vnf = sphere(r|d=, [anchor=], [spin=], [orient=]) [ATTACHMENTS];\n// Description:\n//   Creates a sphere object.\n//   This module extends the built-in `sphere()` module by providing support for BOSL2 anchoring and attachments, and a function form. \n//   When called as a function, returns a [VNF](vnf.scad) for a sphere.\n// Arguments:\n//   r = Radius of the sphere.\n//   ---\n//   d = Diameter of the sphere.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example: By Radius\n//   sphere(r=50);\n// Example: By Diameter\n//   sphere(d=100);\n// Example: Anchoring\n//   sphere(d=100, anchor=FRONT);\n// Example: Spin\n//   sphere(d=100, anchor=FRONT, spin=45);\n// Example: Orientation\n//   sphere(d=100, anchor=FRONT, spin=45, orient=FWD);\n// Example: Standard Connectors\n//   sphere(d=50) show_anchors();\n\nmodule sphere(r, d, anchor=CENTER, spin=0, orient=UP) {\n    r = get_radius(r=r, d=d, dflt=1);\n    attachable(anchor,spin,orient, r=r) {\n            _sphere(r=r);\n            children();\n    }\n}\n\nfunction sphere(r, d, anchor=CENTER, spin=0, orient=UP) =\n    spheroid(r=r, d=d, style=\"orig\", anchor=anchor, spin=spin, orient=orient);\n\n\n// Function&Module: spheroid()\n// Synopsis: Creates an attachable spherical object with controllable triangulation.\n// SynTags: Geom, VNF\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See Also: sphere()\n// Usage: Typical\n//   spheroid(r|d, [circum], [style]) [ATTACHMENTS];\n// Usage: As Function\n//   vnf = spheroid(r|d, [circum], [style]);\n// Description:\n//   Creates a spheroid object, with support for anchoring and attachments.\n//   This is a drop-in replacement for the built-in `sphere()` module.\n//   When called as a function, returns a [VNF](vnf.scad) for a spheroid.\n//   The exact triangulation of this spheroid can be controlled via the `style=`\n//   argument, where the value can be one of `\"orig\"`, `\"aligned\"`, `\"stagger\"`,\n//   `\"octa\"`, or `\"icosa\"`.\n//   - `style=\"orig\"` constructs a sphere the same way that the OpenSCAD `sphere()` built-in does.\n//   - `style=\"aligned\"` constructs a sphere where, if `$fn` is a multiple of 4, it has vertices at all axis maxima and minima.  ie: its bounding box is exactly the sphere diameter in length on all three axes.  This is the default.\n//   - `style=\"stagger\"` forms a sphere where all faces are triangular, but the top and bottom poles have thinner triangles.\n//   - `style=\"octa\"` forms a sphere by subdividing an octahedron.  This makes more uniform faces over the entirety of the sphere, and guarantees the bounding box is the sphere diameter in size on all axes.  The effective `$fn` value is quantized to a multiple of 4.  This is used in constructing rounded corners for various other shapes.\n//   - `style=\"icosa\"` forms a sphere by subdividing an icosahedron.  This makes even more uniform faces over the whole sphere.  The effective `$fn` value is quantized to a multiple of 5.  This sphere has a guaranteed bounding box when `$fn` is a multiple of 10.\n//   .\n//   By default the object spheroid() produces is a polyhedron whose vertices all lie on the requested sphere.  This means\n//   the approximating polyhedron is inscribed in the sphere.\n//   The `circum` argument requests a circumscribing sphere, where the true sphere is\n//   inside and tangent to all the faces of the approximating polyhedron.  To produce\n//   a circumscribing polyhedron, we use the dual polyhedron of the basic form.  The dual of a polyhedron is\n//   a new polyhedron whose vertices are obtained from the faces of the parent polyhedron.\n//   The \"orig\" and \"align\" forms are duals of each other.  If you request a circumscribing polyhedron in\n//   these styles then the polyhedron will look the same as the default inscribing form.  But for the other\n//   styles, the duals are completely different from their parents, and from each other.  Generation of the circumscribed versions (duals)\n//   for \"octa\" and \"icosa\" is fast if you use the module form but can be very slow (several minutes) if you use the functional\n//   form and choose a large $fn value.\n//   .\n//   With style=\"align\", the circumscribed sphere has its maximum radius on the X and Y axes\n//   but is undersized on the Z axis.  With style=\"octa\" the circumscribed sphere has faces at each axis, so\n//   the radius on the axes is equal to the specified radius, which is the *minimum* radius of the circumscribed sphere.\n//   The same thing is true for style=\"icosa\" when $fn is a multiple of 10.  This would enable you to create spherical\n//   holes with guaranteed on-axis dimensions.\n// Arguments:\n//   r = Radius of the spheroid.\n//   style = The style of the spheroid's construction. One of \"orig\", \"aligned\", \"stagger\", \"octa\", or \"icosa\".  Default: \"aligned\"\n//   ---\n//   d = Diameter of the spheroid.\n//   circum = If true, the approximate sphere circumscribes the true sphere of the requested size.  Otherwise inscribes.  Note that for some styles, the circumscribed sphere looks different than the inscribed sphere.  Default: false (inscribes)\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example: By Radius\n//   spheroid(r=50);\n// Example: By Diameter\n//   spheroid(d=100);\n// Example: style=\"orig\"\n//   spheroid(d=100, style=\"orig\", $fn=10);\n// Example: style=\"aligned\"\n//   spheroid(d=100, style=\"aligned\", $fn=10);\n// Example: style=\"stagger\"\n//   spheroid(d=100, style=\"stagger\", $fn=10);\n// Example: style=\"stagger\" with circum=true\n//   spheroid(d=100, style=\"stagger\", circum=true, $fn=10);\n// Example: style=\"octa\", octahedral based tesselation.  In this style, $fn is quantized to a multiple of 4.\n//   spheroid(d=100, style=\"octa\", $fn=10);\n// Example: style=\"octa\", with circum=true, produces mostly very irregular hexagonal faces\n//   spheroid(d=100, style=\"octa\", circum=true, $fn=16);\n// Example: style=\"icosa\", icosahedral based tesselation.  In this style, $fn is quantized to a multiple of 5.\n//   spheroid(d=100, style=\"icosa\", $fn=10);\n// Example: style=\"icosa\", circum=true.  This style has hexagons and 12 pentagons, similar to (but not the same as) a soccer ball.\n//   spheroid(d=100, style=\"icosa\", circum=true, $fn=10);\n// Example: Anchoring\n//   spheroid(d=100, anchor=FRONT);\n// Example: Spin\n//   spheroid(d=100, anchor=FRONT, spin=45);\n// Example: Orientation\n//   spheroid(d=100, anchor=FRONT, spin=45, orient=FWD);\n// Example: Standard Connectors\n//   spheroid(d=50) show_anchors();\n// Example: Called as Function\n//   vnf = spheroid(d=100, style=\"icosa\");\n//   vnf_polyhedron(vnf);\n// Example: With \"orig\" the circumscribing sphere has the same form.  The green sphere is a tiny bit oversized so it pokes through the low points in the circumscribed sphere with low $fn.  This demonstrates that these spheres are in fact circumscribing.\n//   color(\"green\")spheroid(r=10.01, $fn=256);\n//   spheroid(r=10, style=\"orig\", circum=true, $fn=16);\n// Example: With \"aligned\" the same is true: the circumscribing sphere is also aligned, if $fn is divisible by 4.\n//   color(\"green\")spheroid(r=10.01, $fn=256);\n//   spheroid(r=10, style=\"aligned\", circum=true, $fn=16);\n// Example: For the other styles, the circumscribing sphere is different, as shown here with \"stagger\"\n//   color(\"green\")spheroid(r=10.01, $fn=256);\n//   spheroid(r=10, style=\"stagger\", circum=true, $fn=16);\n// Example: The dual of \"octa\" that provides the circumscribing sphere has weird asymmetric hexagonal faces:\n//   color(\"green\")spheroid(r=10.01, $fn=256);\n//   spheroid(r=10, style=\"octa\", circum=true, $fn=16);\n// Example: The dual of \"icosa\" features hexagons and always 12 pentagons:\n//   color(\"green\")spheroid(r=10.01, $fn=256);\n//   spheroid(r=10, style=\"icosa\", circum=true, $fn=16);\n\nmodule spheroid(r, style=\"aligned\", d, circum=false, dual=false, anchor=CENTER, spin=0, orient=UP)\n{\n    r = get_radius(r=r, d=d, dflt=1);\n    sides = segs(r);\n    vsides = ceil(sides/2);\n    attachable(anchor,spin,orient, r=r) {\n        if (style==\"orig\" && !circum) {\n            merids = [ for (i=[0:1:vsides-1]) 90-(i+0.5)*180/vsides ];\n            path = [\n                let(a = merids[0]) [0, sin(a)],\n                for (a=merids) [cos(a), sin(a)],\n                let(a = last(merids)) [0, sin(a)]\n            ];\n            scale(r) rotate(180) rotate_extrude(convexity=2,$fn=sides) polygon(path);\n        }\n        // Don't now how to construct faces for these efficiently, so use hull_points, which\n        // is very much faster than using hull() as happens in the spheroid() function\n        else if (circum && (style==\"octa\" || style==\"icosa\")) {\n            orig_sphere = spheroid(r,style,circum=false);\n            dualvert = _dual_vertices(orig_sphere);\n            hull_points(dualvert,fast=true);\n        } else {\n            vnf = spheroid(r=r, circum=circum, style=style);\n            vnf_polyhedron(vnf, convexity=2);\n        }\n        children();\n    }\n}\n\n\n// p is a list of 3 points defining a triangle in any dimension.  N is the number of extra points\n// to add, so output triangle has N+2 points on each side.\nfunction _subsample_triangle(p,N) =\n    [for(i=[0:N+1]) [for (j=[0:N+1-i]) unit(lerp(p[0],p[1],i/(N+1)) + (p[2]-p[0])*j/(N+1))]];\n\n\n// Input should have only triangular faces\nfunction _dual_vertices(vnf) =\n  let(vert=vnf[0])\n  [for(face=vnf[1])\n      let(planes = select(vert,face))\n      //linear_solve3(planes, [for(p=planes) p*p])\n      linear_solve3(select(planes,0,2), [for(i=[0:2]) planes[i]*planes[i]]) // Handle larger faces, maybe?\n  ];\n\n\nfunction spheroid(r, style=\"aligned\", d, circum=false, anchor=CENTER, spin=0, orient=UP) =\n    let(\n        r = get_radius(r=r, d=d, dflt=1),\n        hsides = segs(r),\n        vsides = max(2,ceil(hsides/2)),\n        octa_steps = round(max(4,hsides)/4),\n        icosa_steps = round(max(5,hsides)/5),\n        stagger = style==\"stagger\"\n     )\n     circum && style==\"orig\" ?\n         let(\n              orig_sphere = spheroid(r,\"aligned\",circum=false),\n              dualvert = zrot(360/hsides/2,_dual_vertices(orig_sphere)),\n              culledvert = [\n                              [for(i=[0:2:2*hsides-1]) dualvert[i]],\n                              for(j=[1:vsides-2])\n                                 [for(i=[0:2:2*hsides-1]) dualvert[j*2*hsides+i]],\n                              [for(i=[1:2:2*hsides-1]) dualvert[i]]\n                           ],\n              vnf = vnf_vertex_array(culledvert,col_wrap=true,caps=true)\n          )\n          [reorient(anchor,spin,orient, r=r, p=vnf[0]), vnf[1]]\n     :\n     circum && (style==\"octa\" || style==\"icosa\") ?\n         let(\n              orig_sphere = spheroid(r,style,circum=false),\n              dualvert = _dual_vertices(orig_sphere),\n              faces = hull(dualvert)\n         )\n         [reorient(anchor,spin,orient, r=r, p=dualvert), faces]\n     :\n     style==\"icosa\" ?    // subdivide faces of an icosahedron and project them onto a sphere\n         let(\n             N = icosa_steps-1,\n             // construct an icosahedron\n             icovert=[ for(i=[-1,1], j=[-1,1]) each [[0,i,j*PHI], [i,j*PHI,0], [j*PHI,0,i]]],\n             icoface = hull(icovert),\n             // Subsample face 0 of the icosahedron\n             face0 = select(icovert,icoface[0]),\n             sampled = r * _subsample_triangle(face0,N),\n             dir0 = mean(face0),\n             point0 = face0[0]-dir0,\n             // Make a rotated copy of the subsampled triangle on each icosahedral face\n             tri_list = [sampled,\n                         for(i=[1:1:len(icoface)-1])\n                 let(face = select(icovert,icoface[i]))\n                 apply(frame_map(z=mean(face),x=face[0]-mean(face))\n                        *frame_map(z=dir0,x=point0,reverse=true),\n                       sampled)],\n             // faces for the first triangle group\n             faces = vnf_tri_array(tri_list[0],reverse=true)[1],\n             size = repeat((N+2)*(N+3)/2,3),\n             // Expand to full face list\n             fullfaces = [for(i=idx(tri_list)) each [for(f=faces) f+i*size]],\n             fullvert = flatten(flatten(tri_list))    // eliminate triangle structure\n         )\n         [reorient(anchor,spin,orient, r=r, p=fullvert), fullfaces]\n     :\n     let(\n        verts = circum && style==\"stagger\" ? _dual_vertices(spheroid(r,style,circum=false))\n              : circum && style==\"aligned\" ?\n                     let(\n                         orig_sphere = spheroid(r,\"orig\",circum=false),\n                         dualvert = _dual_vertices(orig_sphere),\n                         culledvert = zrot(360/hsides/2,\n                                           [dualvert[0],\n                                            for(i=[2:2:len(dualvert)-1]) dualvert[i],\n                                            dualvert[1]])\n                      )\n                      culledvert\n              : style==\"orig\"? [\n                                 for (i=[0:1:vsides-1])\n                                     let(phi = (i+0.5)*180/(vsides))\n                                     for (j=[0:1:hsides-1])\n                                         let(theta = j*360/hsides)\n                                         spherical_to_xyz(r, theta, phi),\n                               ]\n              : style==\"aligned\" || style==\"stagger\"?\n                         [ spherical_to_xyz(r, 0, 0),\n                           for (i=[1:1:vsides-1])\n                               let(phi = i*180/vsides)\n                               for (j=[0:1:hsides-1])\n                                   let(theta = (j+((stagger && i%2!=0)?0.5:0))*360/hsides)\n                                   spherical_to_xyz(r, theta, phi),\n                           spherical_to_xyz(r, 0, 180)\n                         ]\n              : style==\"octa\"?\n                      let(\n                           meridians = [\n                                        1,\n                                        for (i = [1:1:octa_steps]) i*4,\n                                        for (i = [octa_steps-1:-1:1]) i*4,\n                                        1,\n                                       ]\n                      )\n                      [\n                       for (i=idx(meridians), j=[0:1:meridians[i]-1])\n                           spherical_to_xyz(r, j*360/meridians[i], i*180/(len(meridians)-1))\n                      ]\n              : assert(in_list(style,[\"orig\",\"aligned\",\"stagger\",\"octa\",\"icosa\"])),\n        lv = len(verts),\n        faces = circum && style==\"stagger\" ?\n                     let(ptcount=2*hsides)\n                     [\n                       [for(i=[ptcount-2:-2:0]) i],\n                       for(j=[0:hsides-1])\n                           [j*2, (j*2+2)%ptcount,ptcount+(j*2+2)%ptcount,ptcount+(j*2+3)%ptcount,ptcount+j*2],\n                       for(i=[1:vsides-3])\n                           let(base=ptcount*i)\n                           for(j=[0:hsides-1])\n                               i%2==0 ? [base+2*j, base+(2*j+1)%ptcount, base+(2*j+2)%ptcount,\n                                        base+ptcount+(2*j)%ptcount, base+ptcount+(2*j+1)%ptcount, base+ptcount+(2*j-2+ptcount)%ptcount]\n                                      : [base+(1+2*j)%ptcount, base+(2*j)%ptcount, base+(2*j+3)%ptcount,\n                                         base+ptcount+(3+2*j)%ptcount, base+ptcount+(2*j+2)%ptcount,base+ptcount+(2*j+1)%ptcount],\n                       for(j=[0:hsides-1])\n                          vsides%2==0\n                            ? [(j*2+3)%ptcount, j*2+1, lv-ptcount+(2+j*2)%ptcount, lv-ptcount+(3+j*2)%ptcount, lv-ptcount+(4+j*2)%ptcount]\n                            : [(j*2+3)%ptcount, j*2+1, lv-ptcount+(1+j*2)%ptcount, lv-ptcount+(j*2)%ptcount, lv-ptcount+(3+j*2)%ptcount],\n                       [for(i=[1:2:ptcount-1]) i],\n                     ]\n              : style==\"aligned\" || style==\"stagger\" ?  // includes case of aligned with circum == true\n                     [\n                       for (i=[0:1:hsides-1])\n                           let(b2 = lv-2-hsides)\n                           each [\n                                 [i+1, 0, ((i+1)%hsides)+1],\n                                 [lv-1, b2+i+1, b2+((i+1)%hsides)+1],\n                                ],\n                       for (i=[0:1:vsides-3], j=[0:1:hsides-1])\n                           let(base = 1 + hsides*i)\n                           each (\n                                 (stagger && i%2!=0)? [\n                                     [base+j, base+hsides+j%hsides, base+hsides+(j+hsides-1)%hsides],\n                                     [base+j, base+(j+1)%hsides, base+hsides+j],\n                                 ] : [\n                                     [base+j, base+(j+1)%hsides, base+hsides+(j+1)%hsides],\n                                     [base+j, base+hsides+(j+1)%hsides, base+hsides+j],\n                                 ]\n                           )\n                     ]\n              : style==\"orig\"? [\n                                [for (i=[0:1:hsides-1]) hsides-i-1],\n                                [for (i=[0:1:hsides-1]) lv-hsides+i],\n                                for (i=[0:1:vsides-2], j=[0:1:hsides-1])\n                                    each [\n                                          [(i+1)*hsides+j, i*hsides+j, i*hsides+(j+1)%hsides],\n                                          [(i+1)*hsides+j, i*hsides+(j+1)%hsides, (i+1)*hsides+(j+1)%hsides],\n                                    ]\n                               ]\n              : /*style==\"octa\"?*/\n                     let(\n                         meridians = [\n                                      0, 1,\n                                      for (i = [1:1:octa_steps]) i*4,\n                                      for (i = [octa_steps-1:-1:1]) i*4,\n                                      1,\n                                     ],\n                         offs = cumsum(meridians),\n                         pc = last(offs)-1,\n                         os = octa_steps * 2\n                     )\n                     [\n                      for (i=[0:1:3]) [0, 1+(i+1)%4, 1+i],\n                      for (i=[0:1:3]) [pc-0, pc-(1+(i+1)%4), pc-(1+i)],\n                      for (i=[1:1:octa_steps-1])\n                          let(m = meridians[i+2]/4)\n                          for (j=[0:1:3], k=[0:1:m-1])\n                              let(\n                                  m1 = meridians[i+1],\n                                  m2 = meridians[i+2],\n                                  p1 = offs[i+0] + (j*m1/4 + k+0) % m1,\n                                  p2 = offs[i+0] + (j*m1/4 + k+1) % m1,\n                                  p3 = offs[i+1] + (j*m2/4 + k+0) % m2,\n                                  p4 = offs[i+1] + (j*m2/4 + k+1) % m2,\n                                  p5 = offs[os-i+0] + (j*m1/4 + k+0) % m1,\n                                  p6 = offs[os-i+0] + (j*m1/4 + k+1) % m1,\n                                  p7 = offs[os-i-1] + (j*m2/4 + k+0) % m2,\n                                  p8 = offs[os-i-1] + (j*m2/4 + k+1) % m2\n                              )\n                              each [\n                                    [p1, p4, p3],\n                                    if (k<m-1) [p1, p2, p4],\n                                    [p5, p7, p8],\n                                    if (k<m-1) [p5, p8, p6],\n                                   ],\n                     ]\n    ) [reorient(anchor,spin,orient, r=r, p=verts), faces];\n\n\n\n// Function&Module: torus()\n// Synopsis: Creates an attachable torus.\n// SynTags: Geom, VNF\n// Topics: Shapes (3D), Attachable, VNF Generators\n// See Also: spheroid(), cyl()\n//\n// Usage: As Module\n//   torus(r_maj|d_maj, r_min|d_min, [center], ...) [ATTACHMENTS];\n//   torus(or|od, ir|id, ...) [ATTACHMENTS];\n//   torus(r_maj|d_maj, or|od, ...) [ATTACHMENTS];\n//   torus(r_maj|d_maj, ir|id, ...) [ATTACHMENTS];\n//   torus(r_min|d_min, or|od, ...) [ATTACHMENTS];\n//   torus(r_min|d_min, ir|id, ...) [ATTACHMENTS];\n// Usage: As Function\n//   vnf = torus(r_maj|d_maj, r_min|d_min, [center], ...);\n//   vnf = torus(or|od, ir|id, ...);\n//   vnf = torus(r_maj|d_maj, or|od, ...);\n//   vnf = torus(r_maj|d_maj, ir|id, ...);\n//   vnf = torus(r_min|d_min, or|od, ...);\n//   vnf = torus(r_min|d_min, ir|id, ...);\n//\n// Description:\n//   Creates an attachable toroidal shape.\n//\n// Figure(2D,Med):\n//   module dashcirc(r,start=0,angle=359.9,dashlen=5) let(step=360*dashlen/(2*r*PI)) for(a=[start:step:start+angle]) stroke(arc(r=r,start=a,angle=step/2));\n//   r = 75; r2 = 30;\n//   down(r2+0.1) #torus(r_maj=r, r_min=r2, $fn=72);\n//   color(\"blue\") linear_extrude(height=0.01) {\n//       dashcirc(r=r,start=15,angle=45);\n//       dashcirc(r=r-r2, start=90+15, angle=60);\n//       dashcirc(r=r+r2, start=180+45, angle=30);\n//       dashcirc(r=r+r2, start=15, angle=30);\n//   }\n//   rot(240) color(\"blue\") linear_extrude(height=0.01) {\n//       stroke([[0,0],[r+r2,0]], endcaps=\"arrow2\",width=2);\n//       right(r) fwd(9) rot(-240) text(\"or\",size=10,anchor=CENTER);\n//   }\n//   rot(135) color(\"blue\") linear_extrude(height=0.01) {\n//       stroke([[0,0],[r-r2,0]], endcaps=\"arrow2\",width=2);\n//       right((r-r2)/2) back(8) rot(-135) text(\"ir\",size=10,anchor=CENTER);\n//   }\n//   rot(45) color(\"blue\") linear_extrude(height=0.01) {\n//       stroke([[0,0],[r,0]], endcaps=\"arrow2\",width=2);\n//       right(r/2) back(8) text(\"r_maj\",size=9,anchor=CENTER);\n//   }\n//   rot(30) color(\"blue\") linear_extrude(height=0.01) {\n//       stroke([[r,0],[r+r2,0]], endcaps=\"arrow2\",width=2);\n//       right(r+r2/2) fwd(8) text(\"r_min\",size=7,anchor=CENTER);\n//   }\n//\n// Arguments:\n//   r_maj = major radius of torus ring. (use with 'r_min', or 'd_min')\n//   r_min = minor radius of torus ring. (use with 'r_maj', or 'd_maj')\n//   center = If given, overrides `anchor`.  A true value sets `anchor=CENTER`, false sets `anchor=DOWN`.\n//   ---\n//   d_maj  = major diameter of torus ring. (use with 'r_min', or 'd_min')\n//   d_min = minor diameter of torus ring. (use with 'r_maj', or 'd_maj')\n//   or = outer radius of the torus. (use with 'ir', or 'id')\n//   ir = inside radius of the torus. (use with 'or', or 'od')\n//   od = outer diameter of the torus. (use with 'ir' or 'id')\n//   id = inside diameter of the torus. (use with 'or' or 'od')\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Example:\n//   // These all produce the same torus.\n//   torus(r_maj=22.5, r_min=7.5);\n//   torus(d_maj=45, d_min=15);\n//   torus(or=30, ir=15);\n//   torus(od=60, id=30);\n//   torus(d_maj=45, id=30);\n//   torus(d_maj=45, od=60);\n//   torus(d_min=15, id=30);\n//   torus(d_min=15, od=60);\n//   vnf_polyhedron(torus(d_min=15, od=60), convexity=4);\n// Example: Standard Connectors\n//   torus(od=60, id=30) show_anchors();\n\nmodule torus(\n    r_maj, r_min, center,\n    d_maj, d_min,\n    or, od, ir, id,\n    anchor, spin=0, orient=UP\n) {\n    _or = get_radius(r=or, d=od, dflt=undef);\n    _ir = get_radius(r=ir, d=id, dflt=undef);\n    _r_maj = get_radius(r=r_maj, d=d_maj, dflt=undef);\n    _r_min = get_radius(r=r_min, d=d_min, dflt=undef);\n    maj_rad = is_finite(_r_maj)? _r_maj :\n        is_finite(_ir) && is_finite(_or)? (_or + _ir)/2 :\n        is_finite(_ir) && is_finite(_r_min)? (_ir + _r_min) :\n        is_finite(_or) && is_finite(_r_min)? (_or - _r_min) :\n        assert(false, \"Bad Parameters\");\n    min_rad = is_finite(_r_min)? _r_min :\n        is_finite(_ir)? (maj_rad - _ir) :\n        is_finite(_or)? (_or - maj_rad) :\n        assert(false, \"Bad Parameters\");\n    anchor = get_anchor(anchor, center, BOT, CENTER);\n    attachable(anchor,spin,orient, r=(maj_rad+min_rad), l=min_rad*2) {\n        rotate_extrude(convexity=4) {\n            right_half(s=min_rad*2, planar=true)\n                right(maj_rad)\n                    circle(r=min_rad);\n        }\n        children();\n    }\n}\n\n\nfunction torus(\n    r_maj, r_min, center,\n    d_maj, d_min,\n    or, od, ir, id,\n    anchor, spin=0, orient=UP\n) = let(\n    _or = get_radius(r=or, d=od, dflt=undef),\n    _ir = get_radius(r=ir, d=id, dflt=undef),\n    _r_maj = get_radius(r=r_maj, d=d_maj, dflt=undef),\n    _r_min = get_radius(r=r_min, d=d_min, dflt=undef),\n    maj_rad = is_finite(_r_maj)? _r_maj :\n        is_finite(_ir) && is_finite(_or)? (_or + _ir)/2 :\n        is_finite(_ir) && is_finite(_r_min)? (_ir + _r_min) :\n        is_finite(_or) && is_finite(_r_min)? (_or - _r_min) :\n        assert(false, \"Bad Parameters\"),\n    min_rad = is_finite(_r_min)? _r_min :\n        is_finite(_ir)? (maj_rad - _ir) :\n        is_finite(_or)? (_or - maj_rad) :\n        assert(false, \"Bad Parameters\"),\n    anchor = get_anchor(anchor, center, BOT, CENTER),\n    maj_sides = segs(maj_rad+min_rad),\n    maj_step = 360 / maj_sides,\n    min_sides = segs(min_rad),\n    min_step = 360 / min_sides,\n    xyprofile = min_rad <= maj_rad? right(maj_rad, p=circle(r=min_rad)) :\n        right_half(p=right(maj_rad, p=circle(r=min_rad)))[0],\n    profile = xrot(90, p=path3d(xyprofile)),\n    vnf = vnf_vertex_array(\n        points=[for (a=[0:maj_step:360-EPSILON]) zrot(a, p=profile)],\n        caps=false, col_wrap=true, row_wrap=true, reverse=true\n    )\n) reorient(anchor,spin,orient, r=(maj_rad+min_rad), l=min_rad*2, p=vnf);\n\n\n// Function&Module: teardrop()\n// Synopsis: Creates a teardrop shape.\n// SynTags: Geom, VNF\n// Topics: Shapes (3D), Attachable, VNF Generators, FDM Optimized\n// See Also: onion(), teardrop2d()\n// Description:\n//   Makes a teardrop shape in the XZ plane. Useful for 3D printable holes.\n//   Optional chamfers can be added with positive or negative distances.  A positive distance\n//   specifies the amount to inset the chamfer along the front/back faces of the shape.\n//   The chamfer will extend the same y distance into the shape.  If the radii are the same\n//   then the chamfer will be a 45 degree chamfer, but in other cases it will not.\n//   Note that with caps, the chamfer must not be so big that it makes the cap height illegal.  \n//\n// Usage: Typical\n//   teardrop(h|l=|length=|height=, r, [ang], [cap_h], [chamfer=], ...) [ATTACHMENTS];\n//   teardrop(h|l=|length=|height=, d=, [ang=], [cap_h=], [chamfer=], ...) [ATTACHMENTS];\n// Usage: Psuedo-Conical\n//   teardrop(h|l=|height=|length=, r1=, r2=, [ang=], [cap_h1=], [cap_h2=], ...)  [ATTACHMENTS];\n//   teardrop(h|l=|height=|length=, d1=, d2=, [ang=], [cap_h1=], [cap_h2=], ...)  [ATTACHMENTS];\n// Usage: As Function\n//   vnf = teardrop(h|l=|height=|length=, r|d=, [ang=], [cap_h=], ...);\n//   vnf = teardrop(h|l=|height=|length=, r1=|d1=, r2=|d2=, [ang=], [cap_h=], ...);\n//   vnf = teardrop(h|l=|height=|length=, r1=|d1=, r2=|d2=, [ang=], [cap_h1=], [cap_h2=], ...);\n//\n// Arguments:\n//   h / l / height / length = Thickness of teardrop. Default: 1\n//   r = Radius of circular part of teardrop.  Default: 1\n//   ang = Angle of hat walls from the Z axis.  Default: 45 degrees\n//   cap_h = If given, height above center where the shape will be truncated. Default: `undef` (no truncation)\n//   ---\n//   circum = produce a circumscribing teardrop shape.  Default: false\n//   r1 = Radius of circular portion of the front end of the teardrop shape.\n//   r2 = Radius of circular portion of the back end of the teardrop shape.\n//   d = Diameter of circular portion of the teardrop shape.\n//   d1 = Diameter of circular portion of the front end of the teardrop shape.\n//   d2 = Diameter of circular portion of the back end of the teardrop shape.\n//   cap_h1 = If given, height above center where the shape will be truncated, on the front side. Default: `undef` (no truncation)\n//   cap_h2 = If given, height above center where the shape will be truncated, on the back side. Default: `undef` (no truncation)\n//   chamfer = Specifies size of chamfer as distance along the bottom and top faces.  Default: 0\n//   chamfer1 = Specifies size of chamfer on bottom as distance along bottom face.  Default: 0\n//   chamfer2 = Specifies size of chamfer on top as distance along top face.  Default: 0\n//   realign = Passes realign option to teardrop2d, which shifts face alignment.  Default: false\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Extra Anchors:\n//   cap = The center of the top of the cap, oriented with the cap face normal.\n//   cap_fwd = The front edge of the cap.\n//   cap_back = The back edge of the cap.\n//\n// Example: Typical Shape\n//   teardrop(r=30, h=10, ang=30);\n// Example: Crop Cap\n//   teardrop(r=30, h=10, ang=30, cap_h=40);\n// Example: Close Crop\n//   teardrop(r=30, h=10, ang=30, cap_h=20);\n// Example: Psuedo-Conical\n//   teardrop(r1=20, r2=30, h=40, cap_h1=25, cap_h2=35);\n// Example: Adding chamfers can be useful for a teardrop hole mask\n//   teardrop(r=10, l=50, chamfer1=2, chamfer2=-1.5);\n// Example: Getting a VNF\n//   vnf = teardrop(r1=25, r2=30, l=20, cap_h1=25, cap_h2=35);\n//   vnf_polyhedron(vnf);\n// Example: Standard Conical Connectors\n//   teardrop(d1=20, d2=30, h=20, cap_h1=11, cap_h2=16)\n//       show_anchors(custom=false);\n// Example(Spin,VPD=150,Med): Named Conical Connectors\n//   teardrop(d1=20, d2=30, h=20, cap_h1=11, cap_h2=16)\n//       show_anchors(std=false);\n\nmodule teardrop(h, r, ang=45, cap_h, r1, r2, d, d1, d2, cap_h1, cap_h2, l, length, height, circum=false, realign=false,\n                chamfer, chamfer1, chamfer2,anchor=CENTER, spin=0, orient=UP)\n{\n    length = one_defined([l, h, length, height],\"l,h,length,height\");\n    dummy=assert(is_finite(length) && length>0, \"length must be positive\");\n    r1 = get_radius(r=r, r1=r1, d=d, d1=d1);\n    r2 = get_radius(r=r, r1=r2, d=d, d1=d2);\n    tip_y1 = r1/cos(90-ang);\n    tip_y2 = r2/cos(90-ang);\n    _cap_h1 = min(default(cap_h1, tip_y1), tip_y1);\n    _cap_h2 = min(default(cap_h2, tip_y2), tip_y2);\n    capvec = unit([0, _cap_h1-_cap_h2, length]);\n    anchors = [\n        named_anchor(\"cap\",      [0,0,(_cap_h1+_cap_h2)/2], capvec),\n        named_anchor(\"cap_fwd\",  [0,-length/2,_cap_h1],         unit((capvec+FWD)/2)),\n        named_anchor(\"cap_back\", [0,+length/2,_cap_h2],         unit((capvec+BACK)/2), 180),\n    ];\n    attachable(anchor,spin,orient, r1=r1, r2=r2, l=length, axis=BACK, anchors=anchors)\n    {\n        vnf_polyhedron(teardrop(ang=ang,cap_h=cap_h,r1=r1,r2=r2,cap_h1=cap_h1,cap_h2=cap_h2,circum=circum,realign=realign,\n                                length=length, chamfer1=chamfer1,chamfer2=chamfer2,chamfer=chamfer));\n        children();\n    }\n}\n\n\nfunction teardrop(h, r, ang=45, cap_h, r1, r2, d, d1, d2, cap_h1, cap_h2,  chamfer, chamfer1, chamfer2, circum=false, realign=false,\n                  l, length, height, anchor=CENTER, spin=0, orient=UP) =\n    let(\n        r1 = get_radius(r=r, r1=r1, d=d, d1=d1, dflt=1),\n        r2 = get_radius(r=r, r1=r2, d=d, d1=d2, dflt=1),\n        length = one_defined([l, h, length, height],\"l,h,length,height\"),\n        dummy0=assert(is_finite(length) && length>0, \"length must be positive\"),\n        cap_h1 = first_defined([cap_h1, cap_h]),\n        cap_h2 = first_defined([cap_h2, cap_h]),\n        chamfer1 = first_defined([chamfer1,chamfer,0]),\n        chamfer2 = first_defined([chamfer2,chamfer,0]),    \n        sides = segs(max(r1,r2)),\n        profile1 = teardrop2d(r=r1, ang=ang, cap_h=cap_h1, $fn=sides, circum=circum, realign=realign,_extrapt=true),\n        profile2 = teardrop2d(r=r2, ang=ang, cap_h=cap_h2, $fn=sides, circum=circum, realign=realign,_extrapt=true),\n        tip_y1 = r1/cos(90-ang),\n        tip_y2 = r2/cos(90-ang),\n        _cap_h1 = min(default(cap_h1, tip_y1), tip_y1),\n        _cap_h2 = min(default(cap_h2, tip_y2), tip_y2),\n        capvec = unit([0, _cap_h1-_cap_h2, length]),\n        dummy=\n          assert(abs(chamfer1)+abs(chamfer2) <= length,\"chamfers are too big to fit in the length\")\n          assert(chamfer1<=r1 && chamfer2<=r2, \"Chamfers cannot be larger than raduis\")\n          assert(is_undef(cap_h1) || cap_h1-chamfer1 > r1*sin(ang), \"chamfer1 is too big to work with the specified cap_h1\")\n          assert(is_undef(cap_h2) || cap_h2-chamfer2 > r2*sin(ang), \"chamfer2 is too big to work with the specified cap_h2\"),\n        cprof1 = r1==chamfer1 ? repeat([0,0],len(profile1))\n                              : teardrop2d(r=r1-chamfer1, ang=ang, cap_h=u_add(cap_h1,-chamfer1), $fn=sides, circum=circum, realign=realign,_extrapt=true),\n        cprof2 = r2==chamfer2 ? repeat([0,0],len(profile2))\n                              : teardrop2d(r=r2-chamfer2, ang=ang, cap_h=u_add(cap_h2,-chamfer2), $fn=sides, circum=circum, realign=realign,_extrapt=true),\n        anchors = [\n            named_anchor(\"cap\",      [0,0,(_cap_h1+_cap_h2)/2], capvec),\n            named_anchor(\"cap_fwd\",  [0,-length/2,_cap_h1],         unit((capvec+FWD)/2)),\n            named_anchor(\"cap_back\", [0,+length/2,_cap_h2],         unit((capvec+BACK)/2), 180),\n        ],\n        vnf = vnf_vertex_array(\n            points = [\n                if (chamfer1!=0) fwd(length/2, xrot(90, path3d(cprof1))),\n                fwd(length/2-abs(chamfer1), xrot(90, path3d(profile1))),\n                back(length/2-abs(chamfer2), xrot(90, path3d(profile2))),\n                if (chamfer2!=0) back(length/2, xrot(90, path3d(cprof2))),\n            ],\n            caps=true, col_wrap=true, reverse=true\n        )\n    ) reorient(anchor,spin,orient, r1=r1, r2=r2, l=l, axis=BACK, anchors=anchors, p=vnf);\n\n\n// Function&Module: onion()\n// Synopsis: Creates an attachable onion-like shape.\n// SynTags: Geom, VNF\n// Topics: Shapes (3D), Attachable, VNF Generators, FDM Optimized\n// See Also: teardrop(), teardrop2d()\n// Description:\n//   Creates a sphere with a conical hat, to make a 3D teardrop.\n//\n// Usage: As Module\n//   onion(r|d=, [ang=], [cap_h=], [circum=], [realign=], ...) [ATTACHMENTS];\n// Usage: As Function\n//   vnf = onion(r|d=, [ang=], [cap_h=], [circum=], [realign=], ...);\n//\n// Arguments:\n//   r = radius of spherical portion of the bottom. Default: 1\n//   ang = Angle of cone on top from vertical. Default: 45 degrees\n//   cap_h = If given, height above sphere center to truncate teardrop shape.  Default: `undef` (no truncation)\n//   ---\n//   circum = set to true to circumscribe the specified radius/diameter.  Default: False\n//   realign = adjust point alignment to determine if bottom is flat or pointy.  Default: False\n//   d = diameter of spherical portion of bottom.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Extra Anchors:\n//   cap = The center of the top of the cap, oriented with the cap face normal.\n//   tip = The position where an un-capped onion would come to a point, oriented in the direction the point is from the center.\n//\n// Example: Typical Shape\n//   onion(r=30, ang=30);\n// Example: Crop Cap\n//   onion(r=30, ang=30, cap_h=40);\n// Example: Close Crop\n//   onion(r=30, ang=30, cap_h=20);\n// Example: Onions are useful for making the tops of large cylindrical voids.\n//   difference() {\n//       cuboid([100,50,100], anchor=FWD+BOT);\n//       down(0.1)\n//           cylinder(h=50,d=50,anchor=BOT)\n//               attach(TOP)\n//                   onion(d=50, cap_h=30);\n//   }\n// Example: Standard Connectors\n//   onion(d=30, ang=30, cap_h=20) show_anchors();\n\nmodule onion(r, ang=45, cap_h, d, circum=false, realign=false, anchor=CENTER, spin=0, orient=UP)\n{\n    r = get_radius(r=r, d=d, dflt=1);\n    xyprofile = teardrop2d(r=r, ang=ang, cap_h=cap_h, circum=circum, realign=realign);\n    tip_h = max(column(xyprofile,1));\n    _cap_h = min(default(cap_h,tip_h), tip_h);\n    anchors = [\n        [\"cap\", [0,0,_cap_h], UP, 0],\n        [\"tip\", [0,0,tip_h], UP, 0]\n    ];\n    attachable(anchor,spin,orient, r=r, anchors=anchors) {\n        rotate_extrude(convexity=2) {\n            difference() {\n                polygon(xyprofile);\n                square([2*r,2*max(_cap_h,r)+1], anchor=RIGHT);\n            }\n        }\n        children();\n    }\n}\n\n\nfunction onion(r, ang=45, cap_h, d, anchor=CENTER, spin=0, orient=UP) =\n    let(\n        r = get_radius(r=r, d=d, dflt=1),\n        xyprofile = right_half(p=teardrop2d(r=r, ang=ang, cap_h=cap_h))[0],\n        profile = xrot(90, p=path3d(xyprofile)),\n        tip_h = max(column(xyprofile,1)),\n        _cap_h = min(default(cap_h,tip_h), tip_h),\n        anchors = [\n            [\"cap\", [0,0,_cap_h], UP, 0],\n            [\"tip\", [0,0,tip_h], UP, 0]\n        ],\n        sides = segs(r),\n        step = 360 / sides,\n        vnf = vnf_vertex_array(\n            points=[for (a = [0:step:360-EPSILON]) zrot(a, p=profile)],\n            caps=false, col_wrap=true, row_wrap=true, reverse=true\n        )\n    ) reorient(anchor,spin,orient, r=r, anchors=anchors, p=vnf);\n\n\n// Section: Text\n\n// Module: text3d()\n// Synopsis: Creates an attachable 3d text block.\n// SynTags: Geom\n// Topics: Attachments, Text\n// See Also: path_text(), text() \n// Usage:\n//   text3d(text, [h], [size], [font], [language=], [script=], [direction=], [atype=], [anchor=], [spin=], [orient=]);\n// Description:\n//   Creates a 3D text block that supports anchoring and attachment to attachable objects.  You cannot attach children to text.\n//   .\n//   Historically fonts were specified by their \"body size\", the height of the metal body\n//   on which the glyphs were cast.  This means the size was an upper bound on the size\n//   of the font glyphs, not a direct measurement of their size.  In digital typesetting,\n//   the metal body is replaced by an invisible box, the em square, whose side length is\n//   defined to be the font's size.  The glyphs can be contained in that square, or they\n//   can extend beyond it, depending on the choices made by the font designer.  As a\n//   result, the meaning of font size varies between fonts: two fonts at the \"same\" size\n//   can differ significantly in the actual size of their characters.  Typographers\n//   customarily specify the size in the units of \"points\".  A point is 1/72 inch.  In\n//   OpenSCAD, you specify the size in OpenSCAD units (often treated as millimeters for 3d\n//   printing), so if you want points you will need to perform a suitable unit conversion.\n//   In addition, the OpenSCAD font system has a bug: if you specify size=s you will\n//   instead get a font whose size is s/0.72.  For many fonts this means the size of\n//   capital letters will be approximately equal to s, because it is common for fonts to\n//   use about 70% of their height for the ascenders in the font.  To get the customary\n//   font size, you should multiply your desired size by 0.72.\n//   .\n//   To find the fonts that you have available in your OpenSCAD installation,\n//   go to the Help menu and select \"Font List\".\n// Arguments:\n//   text = Text to create.\n//   h / height / thickness = Extrusion height for the text.  Default: 1\n//   size = The font will be created at this size divided by 0.72.   Default: 10\n//   font = Font to use.  Default: \"Liberation Sans\" (standard OpenSCAD default)\n//   ---\n//   spacing = The relative spacing multiplier between characters.  Default: `1.0`\n//   direction = The text direction.  `\"ltr\"` for left to right.  `\"rtl\"` for right to left. `\"ttb\"` for top to bottom. `\"btt\"` for bottom to top.  Default: `\"ltr\"`\n//   language = The language the text is in.  Default: `\"en\"`\n//   script = The script the text is in.  Default: `\"latin\"`\n//   atype = Change vertical center between \"baseline\" and \"ycenter\".  Default: \"baseline\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `\"baseline\"`\n//   center = Center the text.  Equivalent to `atype=\"center\", anchor=CENTER`.  Default: false\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Anchor Types:\n//   baseline = Anchor center is relative to text baseline\n//   ycenter = Anchor center is relative to the actualy y direction center of the text\n// Examples:\n//   text3d(\"Fogmobar\", h=3, size=10);\n//   text3d(\"Fogmobar\", h=2, size=12, font=\"Helvetica\");\n//   text3d(\"Fogmobar\", h=2, anchor=CENTER);\n//   text3d(\"Fogmobar\", h=2, anchor=CENTER, atype=\"ycenter\");\n//   text3d(\"Fogmobar\", h=2, anchor=RIGHT);\n//   text3d(\"Fogmobar\", h=2, anchor=RIGHT+BOT, atype=\"ycenter\");\nmodule text3d(text, h, size=10, font=\"Helvetica\", spacing=1.0, direction=\"ltr\", language=\"en\", script=\"latin\",\n              height, thickness, atype, center=false,\n              anchor, spin=0, orient=UP) {\n    no_children($children);\n    h = one_defined([h,height,thickness],\"h,height,thickness\",dflt=1);\n    assert(is_undef(atype) || in_list(atype,[\"ycenter\",\"baseline\"]), \"atype must be \\\"ycenter\\\" or \\\"baseline\\\"\");\n    assert(is_bool(center));\n    atype = default(atype, center?\"ycenter\":\"baseline\");\n    anchor = default(anchor, center?CENTER:LEFT);\n    geom = attach_geom(size=[size,size,h]);\n    ha = anchor.x<0? \"left\" \n       : anchor.x>0? \"right\" \n       : \"center\";\n    va = anchor.y<0? \"bottom\" \n       : anchor.y>0? \"top\" \n       : atype==\"baseline\"? \"baseline\"\n       : \"center\";\n    m = _attach_transform([0,0,anchor.z],spin,orient,geom);\n    multmatrix(m) {\n        $parent_anchor = anchor;\n        $parent_spin   = spin;\n        $parent_orient = orient;\n        $parent_geom   = geom;\n        $parent_size   = _attach_geom_size(geom);\n        $attach_to   = undef;\n        if (_is_shown()) {\n            _color($color) {\n                linear_extrude(height=h, center=true)\n                    _text(\n                        text=text, size=size, font=font,\n                        halign=ha, valign=va, spacing=spacing,\n                        direction=direction, language=language,\n                        script=script\n                    );\n            }\n        }\n    }\n}\n\n\n// This could be replaced with _cut_to_seg_u_form\nfunction _cut_interp(pathcut, path, data) =\n  [for(entry=pathcut)\n    let(\n       a = path[entry[1]-1],\n        b = path[entry[1]],\n        c = entry[0],\n        i = max_index(v_abs(b-a)),\n        factor = (c[i]-a[i])/(b[i]-a[i])\n    )\n    (1-factor)*data[entry[1]-1]+ factor * data[entry[1]]\n  ];\n\n\n// Module: path_text()\n// Synopsis: Creates 2d or 3d text placed along a path.\n// SynTags: Geom\n// Topics: Text, Paths, Paths (2D), Paths (3D), Path Generators, Path Generators (2D)\n// See Also, text(), text2d()\n// Usage:\n//   path_text(path, text, [size], [thickness], [font], [lettersize=], [offset=], [reverse=], [normal=], [top=], [textmetrics=], [kern=])\n// Description:\n//   Place the text letter by letter onto the specified path using textmetrics (if available and requested)\n//   or user specified letter spacing.  The path can be 2D or 3D.  In 2D the text appears along the path with letters upright\n//   as determined by the path direction.  In 3D by default letters are positioned on the tangent line to the path with the path normal\n//   pointing toward the reader.  The path normal points away from the center of curvature (the opposite of the normal produced\n//   by path_normals()).  Note that this means that if the center of curvature switches sides the text will flip upside down.\n//   If you want text on such a path you must supply your own normal or top vector.\n//   .\n//   Text appears starting at the beginning of the path, so if the 3D path moves right to left\n//   then a left-to-right reading language will display in the wrong order. (For a 2D path text will appear upside down.)\n//   The text for a 3D path appears positioned to be read from \"outside\" of the curve (from a point on the other side of the\n//   curve from the center of curvature).  If you need the text to read properly from the inside, you can set reverse to\n//   true to flip the text, or supply your own normal.\n//   .\n//   If you do not have the experimental textmetrics feature enabled then you must specify the space for the letters\n//   using lettersize, which can be a scalar or array.  You will have the easiest time getting good results by using\n//   a monospace font such as Courier.  Note that even with text metrics, spacing may be different because path_text()\n//   doesn't do kerning to adjust positions of individual glyphs.  Also if your font has ligatures they won't be used.\n//   .\n//   By default letters appear centered on the path.  The offset can be specified to shift letters toward the reader (in\n//   the direction of the normal).\n//   .\n//   You can specify your own normal by setting `normal` to a direction or a list of directions.  Your normal vector should\n//   point toward the reader.  You can also specify\n//   top, which directs the top of the letters in a desired direction.  If you specify your own directions and they\n//   are not perpendicular to the path then the direction you specify will take priority and the\n//   letters will not rest on the tangent line of the path.  Note that the normal or top directions that you\n//   specify must not be parallel to the path.\n//   .\n//   Historically fonts were specified by their \"body size\", the height of the metal body\n//   on which the glyphs were cast.  This means the size was an upper bound on the size\n//   of the font glyphs, not a direct measurement of their size.  In digital typesetting,\n//   the metal body is replaced by an invisible box, the em square, whose side length is\n//   defined to be the font's size.  The glyphs can be contained in that square, or they\n//   can extend beyond it, depending on the choices made by the font designer.  As a\n//   result, the meaning of font size varies between fonts: two fonts at the \"same\" size\n//   can differ significantly in the actual size of their characters.  Typographers\n//   customarily specify the size in the units of \"points\".  A point is 1/72 inch.  In\n//   OpenSCAD, you specify the size in OpenSCAD units (often treated as millimeters for 3d\n//   printing), so if you want points you will need to perform a suitable unit conversion.\n//   In addition, the OpenSCAD font system has a bug: if you specify size=s you will\n//   instead get a font whose size is s/0.72.  For many fonts this means the size of\n//   capital letters will be approximately equal to s, because it is common for fonts to\n//   use about 70% of their height for the ascenders in the font.  To get the customary\n//   font size, you should multiply your desired size by 0.72.\n//   .\n//   To find the fonts that you have available in your OpenSCAD installation,\n//   go to the Help menu and select \"Font List\".\n// Arguments:\n//   path = path to place the text on\n//   text = text to create\n//   size = The font will be created at this size divided by 0.72.   \n//   thickness / h / height = thickness of letters (not allowed for 2D path)\n//   font = font to use.  Default: \"Liberation Sans\"\n//   ---\n//   lettersize = scalar or array giving size of letters\n//   center = center text on the path instead of starting at the first point.  Default: false\n//   offset = distance to shift letters \"up\" (towards the reader).  Not allowed for 2D path.  Default: 0\n//   normal = direction or list of directions pointing towards the reader of the text.  Not allowed for 2D path.\n//   top = direction or list of directions pointing toward the top of the text\n//   reverse = reverse the letters if true.  Not allowed for 2D path.  Default: false\n//   textmetrics = if set to true and lettersize is not given then use the experimental textmetrics feature.  You must be running a dev snapshot that includes this feature and have the feature turned on in your preferences.  Default: false\n//   valign = align text to the path using \"top\", \"bottom\", \"center\" or \"baseline\".  You can also adjust position with a numerical offset as in \"top-5\" or \"bottom+2\".  This only works with textmetrics enabled.  You can give a simple numerical offset, which will be relative to the baseline and works even without textmetrics.  Default: \"baseline\"\n//   kern = scalar or array giving spacing adjusments between each letter.  If it's an array it should have one less entry than the text string.  Default: 0\n//   language = text language, passed to OpenSCAD `text()`.  Default: \"en\"\n//   script = text script, passed to OpenSCAD `text()`.  Default: \"latin\" \n// Example(3D,NoScales):  The examples use Courier, a monospaced font.  The width is 1/1.2 times the specified size for this font.  This text could wrap around a cylinder.\n//   path = path3d(arc(100, r=25, angle=[245, 370]));\n//   color(\"red\")stroke(path, width=.3);\n//   path_text(path, \"Example text\", font=\"Courier\", size=5, lettersize = 5/1.2);\n// Example(3D,NoScales): By setting the normal to UP we can get text that lies flat, for writing around the edge of a disk:\n//   path = path3d(arc(100, r=25, angle=[245, 370]));\n//   color(\"red\")stroke(path, width=.3);\n//   path_text(path, \"Example text\", font=\"Courier\", size=5, lettersize = 5/1.2, normal=UP);\n// Example(3D,NoScales):  If we want text that reads from the other side we can use reverse.  Note we have to reverse the direction of the path and also set the reverse option.\n//   path = reverse(path3d(arc(100, r=25, angle=[65, 190])));\n//   color(\"red\")stroke(path, width=.3);\n//   path_text(path, \"Example text\", font=\"Courier\", size=5, lettersize = 5/1.2, reverse=true);\n// Example(3D,Med,NoScales): text debossed onto a cylinder in a spiral.  The text is 1 unit deep because it is half in, half out.\n//   text = (\"A long text example to wrap around a cylinder, possibly for a few times.\");\n//   L = 5*len(text);\n//   maxang = 360*L/(PI*50);\n//   spiral = [for(a=[0:1:maxang]) [25*cos(a), 25*sin(a), 10-30/maxang*a]];\n//   difference(){\n//     cyl(d=50, l=50, $fn=120);\n//     path_text(spiral, text, size=5, lettersize=5/1.2, font=\"Courier\", thickness=2);\n//   }\n// Example(3D,Med,NoScales): Same example but text embossed.  Make sure you have enough depth for the letters to fully overlap the object.\n//   text = (\"A long text example to wrap around a cylinder, possibly for a few times.\");\n//   L = 5*len(text);\n//   maxang = 360*L/(PI*50);\n//   spiral = [for(a=[0:1:maxang]) [25*cos(a), 25*sin(a), 10-30/maxang*a]];\n//   cyl(d=50, l=50, $fn=120);\n//   path_text(spiral, text, size=5, lettersize=5/1.2, font=\"Courier\", thickness=2);\n// Example(3D,NoScales): Here the text baseline sits on the path.  (Note the default orientation makes text readable from below, so we specify the normal.)\n//   path = arc(100, points = [[-20, 0, 20], [0,0,5], [20,0,20]]);\n//   color(\"red\")stroke(path,width=.2);\n//   path_text(path, \"Example Text\", size=5, lettersize=5/1.2, font=\"Courier\", normal=FRONT);\n// Example(3D,NoScales): If we use top to orient the text upward, the text baseline is no longer aligned with the path.\n//   path = arc(100, points = [[-20, 0, 20], [0,0,5], [20,0,20]]);\n//   color(\"red\")stroke(path,width=.2);\n//   path_text(path, \"Example Text\", size=5, lettersize=5/1.2, font=\"Courier\", top=UP);\n// Example(3D,Med,NoScales): This sine wave wrapped around the cylinder has a twisting normal that produces wild letter layout.  We fix it with a custom normal which is different at every path point.\n//   path = [for(theta = [0:360]) [25*cos(theta), 25*sin(theta), 4*cos(theta*4)]];\n//   normal = [for(theta = [0:360]) [cos(theta), sin(theta),0]];\n//   zrot(-120)\n//   difference(){\n//     cyl(r=25, h=20, $fn=120);\n//     path_text(path, \"A sine wave wiggles\", font=\"Courier\", lettersize=5/1.2, size=5, normal=normal);\n//   }\n// Example(3D,Med,NoScales): The path center of curvature changes, and the text flips.\n//   path =  zrot(-120,p=path3d( concat(arc(100, r=25, angle=[0,90]), back(50,p=arc(100, r=25, angle=[268, 180])))));\n//   color(\"red\")stroke(path,width=.2);\n//   path_text(path, \"A shorter example\",  size=5, lettersize=5/1.2, font=\"Courier\", thickness=2);\n// Example(3D,Med,NoScales): We can fix it with top:\n//   path =  zrot(-120,p=path3d( concat(arc(100, r=25, angle=[0,90]), back(50,p=arc(100, r=25, angle=[268, 180])))));\n//   color(\"red\")stroke(path,width=.2);\n//   path_text(path, \"A shorter example\",  size=5, lettersize=5/1.2, font=\"Courier\", thickness=2, top=UP);\n// Example(2D,NoScales): With a 2D path instead of 3D there's no ambiguity about direction and it works by default:\n//   path =  zrot(-120,p=concat(arc(100, r=25, angle=[0,90]), back(50,p=arc(100, r=25, angle=[268, 180]))));\n//   color(\"red\")stroke(path,width=.2);\n//   path_text(path, \"A shorter example\",  size=5, lettersize=5/1.2, font=\"Courier\");\n// Example(3D,NoScales): The kern parameter lets you adjust the letter spacing either with a uniform value for each letter, or with an array to make adjustments throughout the text.  Here we show a case where adding some extra space gives a better look in a tight circle.  When textmetrics are off, `lettersize` can do this job, but with textmetrics, you'll need to use `kern` to make adjustments relative to the text metric sizes.\n//   path = path3d(arc(100, r=12, angle=[150, 450]));\n//   color(\"red\")stroke(path, width=.3);\n//   kern = [1,1.2,1,1,.3,-.2,1,0,.8,1,1.1];\n//   path_text(path, \"Example text\", font=\"Courier\", size=5, lettersize = 5/1.2, kern=kern, normal=UP);\n\nmodule path_text(path, text, font, size, thickness, lettersize, offset=0, reverse=false, normal, top, center=false,\n                 textmetrics=false, kern=0, height,h, valign=\"baseline\", language, script)\n{\n  no_children($children);\n  dummy2=assert(is_path(path,[2,3]),\"Must supply a 2d or 3d path\")\n         assert(num_defined([normal,top])<=1, \"Cannot define both \\\"normal\\\" and \\\"top\\\"\")\n         assert(all_positive([size]), \"Must give positive text size\");\n  dim = len(path[0]);\n  normalok = is_undef(normal) || is_vector(normal,3) || (is_path(normal,3) && len(normal)==len(path));\n  topok = is_undef(top) || is_vector(top,dim) || (dim==2 && is_vector(top,3) && top[2]==0)\n                        || (is_path(top,dim) && len(top)==len(path));\n  dummy4 = assert(dim==3 || !any_defined([thickness,h,height]), \"Cannot give a thickness or height with 2d path\")\n           assert(dim==3 || !reverse, \"Reverse not allowed with 2d path\")\n           assert(dim==3 || offset==0, \"Cannot give offset with 2d path\")\n           assert(dim==3 || is_undef(normal), \"Cannot define \\\"normal\\\" for a 2d path, only \\\"top\\\"\")\n           assert(normalok,\"\\\"normal\\\" must be a vector or path compatible with the given path\")\n           assert(topok,\"\\\"top\\\" must be a vector or path compatible with the given path\");\n  thickness = one_defined([thickness,h,height],\"thickness,h,height\",dflt=1);\n  normal = is_vector(normal) ? repeat(normal, len(path))\n         : is_def(normal) ? normal\n         : undef;\n\n  top = is_vector(top) ? repeat(dim==2?point2d(top):top, len(path))\n         : is_def(top) ? top\n         : undef;\n\n  kern = force_list(kern, len(text)-1);\n  dummy3 = assert(is_list(kern) && len(kern)==len(text)-1, \"kern must be a scalar or list whose length is len(text)-1\");\n\n  lsize = is_def(lettersize) ? force_list(lettersize, len(text))\n        : textmetrics ? [for(letter=text) let(t=textmetrics(letter, font=font, size=size)) t.advance[0]]\n        : assert(false, \"textmetrics disabled: Must specify letter size\");\n  lcenter = convolve(lsize,[1,1]/2)+[0,each kern,0] ;\n  textlength = sum(lsize)+sum(kern);\n\n  ascent = !textmetrics ? undef\n         : textmetrics(text, font=font, size=size).ascent;\n  descent = !textmetrics ? undef\n          : textmetrics(text, font=font, size=size).descent;\n\n  vadjustment = is_num(valign) ? -valign\n              : !textmetrics ? assert(valign==\"baseline\",\"valign requires textmetrics support\") 0\n              : let(\n                     table = [\n                              [\"baseline\", 0],\n                              [\"top\", -ascent],\n                              [\"bottom\", descent],\n                              [\"center\", (descent-ascent)/2]\n                             ],\n                     match = [for(i=idx(table)) if (starts_with(valign,table[i][0])) i]\n                )\n                assert(len(match)==1, \"Invalid valign value\")\n                table[match[0]][1] - parse_num(substr(valign,len(table[match[0]][0])));\n\n  dummy1 = assert(textlength<=path_length(path),\"Path is too short for the text\");\n\n  start = center ? (path_length(path) - textlength)/2 : 0;\n   \n  pts = path_cut_points(path, add_scalar(cumsum(lcenter),start), direction=true);\n\n  usernorm = is_def(normal);\n  usetop = is_def(top);\n  normpts = is_undef(normal) ? (reverse?1:-1)*column(pts,3) : _cut_interp(pts,path, normal);\n  toppts = is_undef(top) ? undef : _cut_interp(pts,path,top);\n  attachable(){\n    for (i = idx(text)) {\n      tangent = pts[i][2];\n      checks =\n          assert(!usetop || !approx(tangent*toppts[i],norm(top[i])*norm(tangent)),\n                 str(\"Specified top direction parallel to path at character \",i))\n          assert(usetop || !approx(tangent*normpts[i],norm(normpts[i])*norm(tangent)),\n                 str(\"Specified normal direction parallel to path at character \",i));\n      adjustment = usetop ?  (tangent*toppts[i])*toppts[i]/(toppts[i]*toppts[i])\n                 : usernorm ?  (tangent*normpts[i])*normpts[i]/(normpts[i]*normpts[i])\n                 : [0,0,0];\n      move(pts[i][0]) {\n        if (dim==3) {\n          frame_map(\n            x=tangent-adjustment,\n            z=usetop ? undef : normpts[i],\n            y=usetop ? toppts[i] : undef\n          ) up(offset-thickness/2) {\n            linear_extrude(height=thickness)\n              back(vadjustment)\n              {\n              left(lsize[i]/2)\n                text(text[i], font=font, size=size, language=language, script=script);\n              }\n          }\n        } else {\n            frame_map(\n              x=point3d(tangent-adjustment),\n              y=point3d(usetop ? toppts[i] : -normpts[i])\n            ) left(lsize[0]/2) {\n                text(text[i], font=font, size=size, language=language, script=script);\n            }\n        }\n      }\n    }\n    union();\n  }\n}\n\n\n\n// Section: Miscellaneous\n\n\n\n\n// Module: fillet()\n// Synopsis: Creates a smooth fillet between two faces.\n// SynTags: Geom, VNF\n// Topics: Shapes (3D), Attachable\n// See Also: mask2d_roundover()\n// Description:\n//   Creates a shape that can be unioned into a concave joint between two faces, to fillet them.\n//   Center this part along the concave edge to be chamfered and union it in.\n//\n// Usage: Typical\n//   fillet(l, r, [ang], [overlap], ...) [ATTACHMENTS];\n//   fillet(l|length=|h=|height=, d=, [ang=], [overlap=], ...) [ATTACHMENTS];\n//\n// Arguments:\n//   l / length / h / height = Length of edge to fillet.\n//   r = Radius of fillet.\n//   ang = Angle between faces to fillet.\n//   overlap = Overlap size for unioning with faces.\n//   ---\n//   d = Diameter of fillet.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `FRONT+LEFT`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Example:\n//   union() {\n//     translate([0,2,-4])\n//       cube([20, 4, 24], anchor=BOTTOM);\n//     translate([0,-10,-4])\n//       cube([20, 20, 4], anchor=BOTTOM);\n//     color(\"green\")\n//       fillet(\n//         l=20, r=10,\n//         spin=180, orient=RIGHT\n//       );\n//   }\n//\n// Examples:\n//   fillet(l=10, r=20, ang=60);\n//   fillet(l=10, r=20, ang=90);\n//   fillet(l=10, r=20, ang=120);\n//\n// Example: Using with Attachments\n//   cube(50,center=true) {\n//     position(FRONT+LEFT)\n//       fillet(l=50, r=10, spin=-90);\n//     position(BOT+FRONT)\n//       fillet(l=50, r=10, spin=180, orient=RIGHT);\n//   }\n\nmodule interior_fillet(l=1.0, r, ang=90, overlap=0.01, d, length, h, height, anchor=CENTER, spin=0, orient=UP)\n{\n    deprecate(\"fillet\");\n    fillet(l,r,ang,overlap,d,length,h,height,anchor,spin,orient);\n}\n\n\nmodule fillet(l=1.0, r, ang=90, overlap=0.01, d, length, h, height, anchor=CENTER, spin=0, orient=UP) {\n    l = one_defined([l,length,h,height],\"l,length,h,height\");\n    r = get_radius(r=r, d=d, dflt=1);\n    steps = ceil(segs(r)*(180-ang)/360);\n    arc = arc(n=steps+1, r=r, corner=[polar_to_xy(r,ang),[0,0],[r,0]]);\n    maxx = last(arc).x;\n    maxy = arc[0].y;\n    path = [\n        [maxx, -overlap],\n        polar_to_xy(overlap, 180+ang/2),\n        arc[0] + polar_to_xy(overlap, 90+ang),\n        each arc\n    ];\n    override = function (anchor)\n        anchor.x>=0 && anchor.y>=0 ? undef\n      : \n        [[max(0,anchor.x)*maxx, max(0,anchor.y)*maxy, anchor.z*l/2]];\n    attachable(anchor,spin,orient, size=[2*maxx,2*maxy,l],override=override) {      \n        if (l > 0) {\n            linear_extrude(height=l, convexity=4, center=true) {\n                polygon(path);\n            }\n        }\n        children();\n    }\n}\n\n\n// Function&Module: heightfield()\n// Synopsis: Generates a 3D surface from a 2D grid of values.\n// SynTags: Geom, VNF\n// Topics: Textures, Heightfield\n// See Also: cylindrical_heightfield()\n// Usage: As Module\n//   heightfield(data, [size], [bottom], [maxz], [xrange], [yrange], [style], [convexity], ...) [ATTACHMENTS];\n// Usage: As Function\n//   vnf = heightfield(data, [size], [bottom], [maxz], [xrange], [yrange], [style], ...);\n// Description:\n//   Given a regular rectangular 2D grid of scalar values, or a function literal, generates a 3D\n//   surface where the height at any given point is the scalar value for that position.\n//   One script to convert a grayscale image to a heightfield array in a .scad file can be found at:\n//   https://raw.githubusercontent.com/BelfrySCAD/BOSL2/master/scripts/img2scad.py\n// Arguments:\n//   data = This is either the 2D rectangular array of heights, or a function literal that takes X and Y arguments.\n//   size = The [X,Y] size of the surface to create.  If given as a scalar, use it for both X and Y sizes. Default: `[100,100]`\n//   bottom = The Z coordinate for the bottom of the heightfield object to create.  Any heights lower than this will be truncated to very slightly above this height.  Default: -20\n//   maxz = The maximum height to model.  Truncates anything taller to this height.  Set to INF for no truncation.  Default: 100\n//   xrange = A range of values to iterate X over when calculating a surface from a function literal.  Default: [-1 : 0.01 : 1]\n//   yrange = A range of values to iterate Y over when calculating a surface from a function literal.  Default: [-1 : 0.01 : 1]\n//   style = The style of subdividing the quads into faces.  Valid options are \"default\", \"alt\", and \"quincunx\".  Default: \"default\"\n//   ---\n//   convexity = Max number of times a line could intersect a wall of the surface being formed. Module only.  Default: 10\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   heightfield(size=[100,100], bottom=-20, data=[\n//       for (y=[-180:4:180]) [\n//           for(x=[-180:4:180])\n//           10*cos(3*norm([x,y]))\n//       ]\n//   ]);\n// Example:\n//   intersection() {\n//       heightfield(size=[100,100], data=[\n//           for (y=[-180:5:180]) [\n//               for(x=[-180:5:180])\n//               10+5*cos(3*x)*sin(3*y)\n//           ]\n//       ]);\n//       cylinder(h=50,d=100);\n//   }\n// Example: Heightfield by Function\n//   fn = function (x,y) 10*sin(x*360)*cos(y*360);\n//   heightfield(size=[100,100], data=fn);\n// Example: Heightfield by Function, with Specific Ranges\n//   fn = function (x,y) 2*cos(5*norm([x,y]));\n//   heightfield(\n//       size=[100,100], bottom=-20, data=fn,\n//       xrange=[-180:2:180], yrange=[-180:2:180]\n//   );\n\nmodule heightfield(data, size=[100,100], bottom=-20, maxz=100, xrange=[-1:0.04:1], yrange=[-1:0.04:1], style=\"default\", convexity=10, anchor=CENTER, spin=0, orient=UP)\n{\n    size = is_num(size)? [size,size] : point2d(size);\n    vnf = heightfield(data=data, size=size, xrange=xrange, yrange=yrange, bottom=bottom, maxz=maxz, style=style);\n    attachable(anchor,spin,orient, vnf=vnf) {\n        vnf_polyhedron(vnf, convexity=convexity);\n        children();\n    }\n}\n\n\nfunction heightfield(data, size=[100,100], bottom=-20, maxz=100, xrange=[-1:0.04:1], yrange=[-1:0.04:1], style=\"default\", anchor=CENTER, spin=0, orient=UP) =\n    assert(is_list(data) || is_function(data))\n    let(\n        size = is_num(size)? [size,size] : point2d(size),\n        xvals = is_list(data)\n          ? [for (i=idx(data[0])) i]\n          : assert(is_list(xrange)||is_range(xrange)) [for (x=xrange) x],\n        yvals = is_list(data)\n          ? [for (i=idx(data)) i]\n          : assert(is_list(yrange)||is_range(yrange)) [for (y=yrange) y],\n        xcnt = len(xvals),\n        minx = min(xvals),\n        maxx = max(xvals),\n        ycnt = len(yvals),\n        miny = min(yvals),\n        maxy = max(yvals),\n        verts = is_list(data) ? [\n                for (y = [0:1:ycnt-1]) [\n                    for (x = [0:1:xcnt-1]) [\n                        size.x * (x/(xcnt-1)-0.5),\n                        size.y * (y/(ycnt-1)-0.5),\n                        min(data[y][x],maxz)\n                    ]\n                ]\n            ] : [\n                for (y = yrange) [\n                    for (x = xrange) let(\n                        z = data(x,y)\n                    ) [\n                        size.x * ((x-minx)/(maxx-minx)-0.5),\n                        size.y * ((y-miny)/(maxy-miny)-0.5),\n                        min(maxz, max(bottom+0.1, default(z,0)))\n                    ]\n                ]\n            ],\n        vnf = vnf_join([\n            vnf_vertex_array(verts, style=style, reverse=true),\n            vnf_vertex_array([\n                verts[0],\n                [for (v=verts[0]) [v.x, v.y, bottom]],\n            ]),\n            vnf_vertex_array([\n                [for (v=verts[ycnt-1]) [v.x, v.y, bottom]],\n                verts[ycnt-1],\n            ]),\n            vnf_vertex_array([\n                [for (r=verts) let(v=r[0]) [v.x, v.y, bottom]],\n                [for (r=verts) let(v=r[0]) v],\n            ]),\n            vnf_vertex_array([\n                [for (r=verts) let(v=r[xcnt-1]) v],\n                [for (r=verts) let(v=r[xcnt-1]) [v.x, v.y, bottom]],\n            ]),\n            vnf_vertex_array([\n                [\n                    for (v=verts[0]) [v.x, v.y, bottom],\n                    for (r=verts) let(v=r[xcnt-1]) [v.x, v.y, bottom],\n                ], [\n                    for (r=verts) let(v=r[0]) [v.x, v.y, bottom],\n                    for (v=verts[ycnt-1]) [v.x, v.y, bottom],\n                ]\n            ])\n        ])\n    ) reorient(anchor,spin,orient, vnf=vnf, p=vnf);\n\n\n// Function&Module: cylindrical_heightfield()\n// Synopsis: Generates a cylindrical 3d surface from a 2D grid of values.\n// SynTags: Geom, VNF\n// Topics: Extrusion, Textures, Knurling, Heightfield\n// See Also: heightfield()\n// Usage: As Function\n//   vnf = cylindrical_heightfield(data, l|length=|h=|height=, r|d=, [base=], [transpose=], [aspect=]);\n// Usage: As Module\n//   cylindrical_heightfield(data, l|length=|h=|height=, r|d=, [base=], [transpose=], [aspect=]) [ATTACHMENTS];\n// Description:\n//   Given a regular rectangular 2D grid of scalar values, or a function literal of signature (x,y), generates\n//   a cylindrical 3D surface where the height at any given point above the radius `r=`, is the scalar value\n//   for that position.\n//   One script to convert a grayscale image to a heightfield array in a .scad file can be found at:\n//   https://raw.githubusercontent.com/BelfrySCAD/BOSL2/master/scripts/img2scad.py\n// Arguments:\n//   data = This is either the 2D rectangular array of heights, or a function literal of signature `(x, y)`.\n//   l / length / h / height = The length of the cylinder to wrap around.\n//   r = The radius of the cylinder to wrap around.\n//   ---\n//   r1 = The radius of the bottom of the cylinder to wrap around.\n//   r2 = The radius of the top of the cylinder to wrap around.\n//   d = The diameter of the cylinder to wrap around.\n//   d1 = The diameter of the bottom of the cylinder to wrap around.\n//   d2 = The diameter of the top of the cylinder to wrap around.\n//   base = The radius for the bottom of the heightfield object to create.  Any heights smaller than this will be truncated to very slightly above this height.  Default: -20\n//   transpose = If true, swaps the radial and length axes of the data.  Default: false\n//   aspect = The aspect ratio of the generated heightfield at the surface of the cylinder.  Default: 1\n//   xrange = A range of values to iterate X over when calculating a surface from a function literal.  Default: [-1 : 0.01 : 1]\n//   yrange = A range of values to iterate Y over when calculating a surface from a function literal.  Default: [-1 : 0.01 : 1]\n//   maxh = The maximum height above the radius to model.  Truncates anything taller to this height.  Default: 99\n//   style = The style of subdividing the quads into faces.  Valid options are \"default\", \"alt\", and \"quincunx\".  Default: \"default\"\n//   convexity = Max number of times a line could intersect a wall of the surface being formed. Module only.  Default: 10\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example(VPD=400;VPR=[55,0,150]):\n//   cylindrical_heightfield(l=100, r=30, base=5, data=[\n//       for (y=[-180:4:180]) [\n//           for(x=[-180:4:180])\n//           5*cos(5*norm([x,y]))+5\n//       ]\n//   ]);\n// Example(VPD=400;VPR=[55,0,150]):\n//   cylindrical_heightfield(l=100, r1=60, r2=30, base=5, data=[\n//       for (y=[-180:4:180]) [\n//           for(x=[-180:4:180])\n//           5*cos(5*norm([x,y]))+5\n//       ]\n//   ]);\n// Example(VPD=400;VPR=[55,0,150]): Heightfield by Function\n//   fn = function (x,y) 5*sin(x*360)*cos(y*360)+5;\n//   cylindrical_heightfield(l=100, r=30, data=fn);\n// Example(VPD=400;VPR=[55,0,150]): Heightfield by Function, with Specific Ranges\n//   fn = function (x,y) 2*cos(5*norm([x,y]));\n//   cylindrical_heightfield(\n//       l=100, r=30, base=5, data=fn,\n//       xrange=[-180:2:180], yrange=[-180:2:180]\n//   );\n\nfunction cylindrical_heightfield(\n    data, l, r, base=1,\n    transpose=false, aspect=1,\n    style=\"min_edge\", maxh=99,\n    xrange=[-1:0.01:1],\n    yrange=[-1:0.01:1],\n    r1, r2, d, d1, d2, h, height, length, \n    anchor=CTR, spin=0, orient=UP\n) =\n    let(\n        l = one_defined([l, h, height, length], \"l,h,height,l\"),\n        r1 = get_radius(r1=r1, r=r, d1=d1, d=d),\n        r2 = get_radius(r1=r2, r=r, d1=d2, d=d)\n    )\n    assert(is_finite(l) && l>0, \"Must supply one of l=, h=, or height= as a finite positive number.\")\n    assert(is_finite(r1) && r1>0, \"Must supply one of r=, r1=, d=, or d1= as a finite positive number.\")\n    assert(is_finite(r2) && r2>0, \"Must supply one of r=, r2=, d=, or d2= as a finite positive number.\")\n    assert(is_finite(base) && base>0, \"Must supply base= as a finite positive number.\")\n    assert(is_matrix(data)||is_function(data), \"data= must be a function literal, or contain a 2D array of numbers.\")\n    let(\n        xvals = is_list(data)? [for (x = idx(data[0])) x] :\n            is_range(xrange)? [for (x = xrange) x] :\n            assert(false, \"xrange= must be given as a range if data= is a function literal.\"),\n        yvals = is_list(data)? [for (y = idx(data)) y] :\n            is_range(yrange)? [for (y = yrange) y] :\n            assert(false, \"yrange= must be given as a range if data= is a function literal.\"),\n        xlen = len(xvals),\n        ylen = len(yvals),\n        stepy = l / (ylen-1),\n        stepx = stepy * aspect,\n        maxr = max(r1,r2),\n        circ = 2 * PI * maxr,\n        astep = 360 / circ * stepx,\n        arc = astep * (xlen-1),\n        bsteps = round(segs(maxr-base) * arc / 360),\n        bstep = arc / bsteps\n    )\n    assert(stepx*xlen <= circ, str(\"heightfield (\",xlen,\" x \",ylen,\") needs a radius of at least \",maxr*stepx*xlen/circ))\n    let(\n        verts = [\n            for (yi = idx(yvals)) let(\n                z = yi * stepy - l/2,\n                rr = lerp(r1, r2, yi/(ylen-1))\n            ) [\n                cylindrical_to_xyz(rr-base, -arc/2, z),\n                for (xi = idx(xvals)) let( a = xi*astep )\n                    let(\n                        rad = transpose? (\n                                is_list(data)? data[xi][yi] : data(yvals[yi],xvals[xi])\n                            ) : (\n                                is_list(data)? data[yi][xi] : data(xvals[xi],yvals[yi])\n                            ),\n                        rad2 = constrain(rad, 0.01-base, maxh)\n                    )\n                    cylindrical_to_xyz(rr+rad2, a-arc/2, z),\n                cylindrical_to_xyz(rr-base, arc/2, z),\n                for (b = [1:1:bsteps-1]) let( a = arc/2-b*bstep )\n                    cylindrical_to_xyz((z>0?r2:r1)-base, a, l/2*(z>0?1:-1)),\n            ]\n        ],\n        vnf = vnf_vertex_array(verts, caps=true, col_wrap=true, reverse=true, style=style)\n    ) reorient(anchor,spin,orient, r1=r1, r2=r2, l=l, p=vnf);\n\n\nmodule cylindrical_heightfield(\n    data, l, r, base=1,\n    transpose=false, aspect=1,\n    style=\"min_edge\", convexity=10,\n    xrange=[-1:0.01:1], yrange=[-1:0.01:1],\n    maxh=99, r1, r2, d, d1, d2, h, height, length,\n    anchor=CTR, spin=0, orient=UP\n) {\n    l = one_defined([l, h, height, length], \"l,h,height,length\");\n    r1 = get_radius(r1=r1, r=r, d1=d1, d=d);\n    r2 = get_radius(r1=r2, r=r, d1=d2, d=d);\n    vnf = cylindrical_heightfield(\n        data, l=l, r1=r1, r2=r2, base=base,\n        xrange=xrange, yrange=yrange,\n        maxh=maxh, transpose=transpose,\n        aspect=aspect, style=style\n    );\n    attachable(anchor,spin,orient, r1=r1, r2=r2, l=l) {\n        vnf_polyhedron(vnf, convexity=convexity);\n        children();\n    }\n}\n\n\n// Module: ruler()\n// Synopsis: Creates a ruler.\n// SynTags: Geom\n// Topics: Distance\n// Usage:\n//   ruler(length, width, [thickness=], [depth=], [labels=], [pipscale=], [maxscale=], [colors=], [alpha=], [unit=], [inch=]) [ATTACHMENTS];\n// Description:\n//   Creates an attachable ruler for checking dimensions of the model.\n// Arguments:\n//   length = length of the ruler.  Default 100\n//   width = width of the ruler.  Default: size of the largest unit division\n//   ---\n//   thickness = thickness of the ruler. Default: 1\n//   depth = the depth of mark subdivisions. Default: 3\n//   labels = draw numeric labels for depths where labels are larger than 1.  Default: false\n//   pipscale = width scale of the pips relative to the next size up.  Default: 1/3\n//   maxscale = log10 of the maximum width divisions to display.  Default: based on input length\n//   colors = colors to use for the ruler, a list of two values.  Default: `[\"black\",\"white\"]`\n//   alpha = transparency value.  Default: 1.0\n//   unit = unit to mark.  Scales the ruler marks to a different length.  Default: 1\n//   inch = set to true for a ruler scaled to inches (assuming base dimension is mm).  Default: false\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `LEFT+BACK+TOP`\n//   spin = Rotate this many degrees around the Z axis.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Examples(2D,Big):\n//   ruler(100,depth=3);\n//   ruler(100,depth=3,labels=true);\n//   ruler(27);\n//   ruler(27,maxscale=0);\n//   ruler(100,pipscale=3/4,depth=2);\n//   ruler(100,width=2,depth=2);\n// Example(2D,Big):  Metric vs Imperial\n//   ruler(12,width=50,inch=true,labels=true,maxscale=0);\n//   fwd(50)ruler(300,width=50,labels=true);\n\nmodule ruler(length=100, width, thickness=1, depth=3, labels=false, pipscale=1/3, maxscale,\n             colors=[\"black\",\"white\"], alpha=1.0, unit=1, inch=false, anchor=LEFT+BACK+TOP, spin=0, orient=UP)\n{\n    inchfactor = 25.4;\n    checks =\n        assert(depth<=5, \"Cannot render scales smaller than depth=5\")\n        assert(len(colors)==2, \"colors must contain a list of exactly two colors.\");\n    length = inch ? inchfactor * length : length;\n    unit = inch ? inchfactor*unit : unit;\n    maxscale = is_def(maxscale)? maxscale : floor(log(length/unit-EPSILON));\n    scales = unit * [for(logsize = [maxscale:-1:maxscale-depth+1]) pow(10,logsize)];\n    widthfactor = (1-pipscale) / (1-pow(pipscale,depth));\n    width = default(width, scales[0]);\n    widths = width * widthfactor * [for(logsize = [0:-1:-depth+1]) pow(pipscale,-logsize)];\n    offsets = concat([0],cumsum(widths));\n    attachable(anchor,spin,orient, size=[length,width,thickness]) {\n        translate([-length/2, -width/2, 0])\n        for(i=[0:1:len(scales)-1]) {\n            count = ceil(length/scales[i]);\n            fontsize = 0.5*min(widths[i], scales[i]/ceil(log(count*scales[i]/unit)));\n            back(offsets[i]) {\n                xcopies(scales[i], n=count, sp=[0,0,0]) union() {\n                    actlen = ($idx<count-1) || approx(length%scales[i],0) ? scales[i] : length % scales[i];\n                    color(colors[$idx%2], alpha=alpha) {\n                        w = i>0 ? quantup(widths[i],1/1024) : widths[i];    // What is the i>0 test supposed to do here?\n                        cube([quantup(actlen,1/1024),quantup(w,1/1024),thickness], anchor=FRONT+LEFT);\n                    }\n                    mark =\n                        i == 0 && $idx % 10 == 0 && $idx != 0 ? 0 :\n                        i == 0 && $idx % 10 == 9 && $idx != count-1 ? 1 :\n                        $idx % 10 == 4 ? 1 :\n                        $idx % 10 == 5 ? 0 : -1;\n                    flip = 1-mark*2;\n                    if (mark >= 0) {\n                        marklength = min(widths[i]/2, scales[i]*2);\n                        markwidth = marklength*0.4;\n                        translate([mark*scales[i], widths[i], 0]) {\n                            color(colors[1-$idx%2], alpha=alpha) {\n                                linear_extrude(height=thickness+scales[i]/100, convexity=2, center=true) {\n                                    polygon(scale([flip*markwidth, marklength],p=[[0,0], [1, -1], [0,-0.9]]));\n                                }\n                            }\n                        }\n                    }\n                    if (labels && scales[i]/unit+EPSILON >= 1) {\n                        color(colors[($idx+1)%2], alpha=alpha) {\n                            linear_extrude(height=thickness+scales[i]/100, convexity=2, center=true) {\n                                back(scales[i]*.02) {\n                                    text(text=str( $idx * scales[i] / unit), size=fontsize, halign=\"left\", valign=\"baseline\");\n                                }\n                            }\n                        }\n                    }\n\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-38", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: skin.scad\n//   This file provides functions and modules that construct shapes from a list of cross sections.\n//   In the case of skin() you specify each cross sectional shape yourself, and the number of\n//   points can vary.  The various forms of sweep use a fixed shape, which may follow a path, or\n//   be transformed in other ways to produce the list of cross sections.  In all cases it is the\n//   user's responsibility to avoid creating a self-intersecting shape, which will produce\n//   cryptic CGAL errors.  This file was inspired by list-comprehension-demos skin():\n//   - https://github.com/openscad/list-comprehension-demos/blob/master/skin.scad\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Advanced Modeling\n// FileSummary: Construct 3D shapes from 2D cross sections of the desired shape.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Skin and sweep\n\n// Function&Module: skin()\n// Synopsis: Connect a sequence of arbitrary polygons into a 3D object. \n// SynTags: VNF, Geom\n// Topics: Extrusion, Skin\n// See Also: sweep(), linear_sweep(), rotate_sweep(), spiral_sweep(), path_sweep(), offset_sweep()\n// Usage: As module:\n//   skin(profiles, slices, [z=], [refine=], [method=], [sampling=], [caps=], [closed=], [style=], [convexity=], [anchor=],[cp=],[spin=],[orient=],[atype=]) [ATTACHMENTS];\n// Usage: As function:\n//   vnf = skin(profiles, slices, [z=], [refine=], [method=], [sampling=], [caps=], [closed=], [style=], [anchor=],[cp=],[spin=],[orient=],[atype=]);\n// Description:\n//   Given a list of two or more path `profiles` in 3d space, produces faces to skin a surface between\n//   the profiles.  Optionally the first and last profiles can have endcaps, or the first and last profiles\n//   can be connected together.  Each profile should be roughly planar, but some variation is allowed.\n//   Each profile must rotate in the same clockwise direction.  If called as a function, returns a\n//   [VNF structure](vnf.scad) `[VERTICES, FACES]`.  If called as a module, creates a polyhedron\n//    of the skinned profiles.\n//   .\n//   The profiles can be specified either as a list of 3d curves or they can be specified as\n//   2d curves with heights given in the `z` parameter.  It is your responsibility to ensure\n//   that the resulting polyhedron is free from self-intersections, which would make it invalid\n//   and can result in cryptic CGAL errors upon rendering with a second object present, even though the polyhedron appears\n//   OK during preview or when rendered by itself.\n//   .\n//   For this operation to be well-defined, the profiles must all have the same vertex count and\n//   we must assume that profiles are aligned so that vertex `i` links to vertex `i` on all polygons.\n//   Many interesting cases do not comply with this restriction.  Two basic methods can handle\n//   these cases: either subdivide edges (insert additional points along edges)\n//   or duplicate vertcies (insert edges of length 0) so that both polygons have\n//   the same number of points.\n//   Duplicating vertices allows two distinct points in one polygon to connect to a single point\n//   in the other one, creating\n//   triangular faces.  You can adjust non-matching polygons yourself\n//   either by resampling them using {{subdivide_path()}} or by duplicating vertices using\n//   `repeat_entries`.  It is OK to pass a polygon that has the same vertex repeated, such as\n//   a square with 5 points (two of which are identical), so that it can match up to a pentagon.\n//   Such a combination would create a triangular face at the location of the duplicated vertex.\n//   Alternatively, `skin` provides methods (described below) for inserting additional vertices\n//   automatically to make incompatible paths match.\n//   .\n//   In order for skinned surfaces to look good it is usually necessary to use a fine sampling of\n//   points on all of the profiles, and a large number of extra interpolated slices between the\n//   profiles that you specify.  It is generally best if the triangles forming your polyhedron\n//   are approximately equilateral.  The `slices` parameter specifies the number of slices to insert\n//   between each pair of profiles, either a scalar to insert the same number everywhere, or a vector\n//   to insert a different number between each pair.\n//   .\n//   Resampling may occur, depending on the `method` parameter, to make profiles compatible.\n//   To force (possibly additional) resampling of the profiles to increase the point density you can set `refine=N`, which\n//   will multiply the number of points on your profile by `N`.  You can choose between two resampling\n//   schemes using the `sampling` option, which you can set to `\"length\"` or `\"segment\"`.\n//   The length resampling method resamples proportional to length.\n//   The segment method divides each segment of a profile into the same number of points.\n//   This means that if you refine a profile with the \"segment\" method you will get N points\n//   on each edge, but if you refine a profile with the \"length\" method you will get new points\n//   distributed around the profile based on length, so small segments will get fewer new points than longer ones.\n//   A uniform division may be impossible, in which case the code computes an approximation, which may result\n//   in arbitrary distribution of extra points.  See {{subdivide_path()}} for more details.\n//   Note that when dealing with continuous curves it is always better to adjust the\n//   sampling in your code to generate the desired sampling rather than using the `refine` argument.\n//   .\n//   You can choose from five methods for specifying alignment for incommensurate profiles.\n//   The available methods are `\"distance\"`, `\"fast_distance\"`, `\"tangent\"`, `\"direct\"` and `\"reindex\"`.\n//   It is useful to distinguish between continuous curves like a circle and discrete profiles\n//   like a hexagon or star, because the algorithms' suitability depend on this distinction.\n//   .\n//   The default method for aligning profiles is `method=\"direct\"`.\n//   If you simply supply a list of compatible profiles it will link them up\n//   exactly as you have provided them.  You may find that profiles you want to connect define the\n//   right shapes but the point lists don't start from points that you want aligned in your skinned\n//   polyhedron.  You can correct this yourself using `reindex_polygon`, or you can use the \"reindex\"\n//   method which will look for the index choice that will minimize the length of all of the edges\n//   in the polyhedron&mdash;it will produce the least twisted possible result.  This algorithm has quadratic\n//   run time so it can be slow with very large profiles.\n//   .\n//   When the profiles are incommensurate, the \"direct\" and \"reindex\" resample them to match.  As noted above,\n//   for continuous input curves, it is better to generate your curves directly at the desired sample size,\n//   but for mapping between a discrete profile like a hexagon and a circle, the hexagon must be resampled\n//   to match the circle.  When you use \"direct\" or \"reindex\" the default `sampling` value is\n//   of `sampling=\"length\"` to approximate a uniform length sampling of the profile.  This will generally\n//   produce the natural result for connecting two continuously sampled profiles or a continuous\n//   profile and a polygonal one.  However depending on your particular case,\n//   `sampling=\"segment\"` may produce a more pleasing result.  These two approaches differ only when\n//   the segments of your input profiles have unequal length.\n//   .\n//   The \"distance\", \"fast_distance\" and \"tangent\" methods work by duplicating vertices to create\n//   triangular faces.  In the skined object created by two polygons, every vertex of a polygon must\n//   have an edge that connects to some vertex on the other one.  If you connect two squares this can be\n//   accomplished with four edges, but if you want to connect a square to a pentagon you must add a\n//   fifth edge for the \"extra\" vertex on the pentagon.  You must now decide which vertex on the square to\n//   connect the \"extra\" edge to.  How do you decide where to put that fifth edge?  The \"distance\" method answers this\n//   question by using an optimization: it minimizes the total length of all the edges connecting\n//   the two polygons.   This algorithm generally produces a good result when both profiles are discrete ones with\n//   a small number of vertices.  It is computationally intensive (O(N^3)) and may be\n//   slow on large inputs.  The resulting surfaces generally have curved faces, so be\n//   sure to select a sufficiently large value for `slices` and `refine`.  Note that for\n//   this method, `sampling` must be set to `\"segment\"`, and hence this is the default setting.\n//   Using sampling by length would ignore the repeated vertices and ruin the alignment.\n//   The \"fast_distance\" method restricts the optimization by assuming that an edge should connect\n//   vertex 0 of the two polygons.  This reduces the run time to O(N^2) and makes\n//   the method usable on profiles with more points if you take care to index the inputs to match.\n//   .\n//   The `\"tangent\"` method generally produces good results when\n//   connecting a discrete polygon to a convex, finely sampled curve.  Given a polygon and a curve, consider one edge\n//   on the polygon.  Find a plane passing through the edge that is tangent to the curve.  The endpoints of the edge and\n//   the point of tangency define a triangular face in the output polyhedron.  If you work your way around the polygon\n//   edges, you can establish a series of triangular faces in this way, with edges linking the polygon to the curve.\n//   You can then complete the edge assignment by connecting all the edges in between the triangular faces together,\n//   with many edges meeting at each polygon vertex.  The result is an alternation of flat triangular faces with conical\n//   curves joining them.  Another way to think about it is that it splits the points on the curve up into groups and\n//   connects all the points in one group to the same vertex on the polygon.\n//   .\n//   The \"tangent\" method may fail if the curved profile is non-convex, or doesn't have enough points to distinguish\n//   all of the tangent points from each other.    The algorithm treats whichever input profile has fewer points as the polygon\n//   and the other one as the curve.  Using `refine` with this method will have little effect on the model, so\n//   you should do it only for agreement with other profiles, and these models are linear, so extra slices also\n//   have no effect.  For best efficiency set `refine=1` and `slices=0`.  As with the \"distance\" method, refinement\n//   must be done using the \"segment\" sampling scheme to preserve alignment across duplicated points.\n//   Note that the \"tangent\" method produces similar results to the \"distance\" method on curved inputs.  If this\n//   method fails due to concavity, \"fast_distance\" may be a good option.\n//   .\n//   It is possible to specify `method` and `refine` as arrays, but it is important to observe\n//   matching rules when you do this.  If a pair of profiles is connected using \"tangent\" or \"distance\"\n//   then the `refine` values for those two profiles must be equal.  If a profile is connected by\n//   a vertex duplicating method on one side and a resampling method on the other side, then\n//   `refine` must be set so that the resulting number of vertices matches the number that is\n//   used for the resampled profiles.  The best way to avoid confusion is to ensure that the\n//   profiles connected by \"direct\" or \"reindex\" all have the same number of points and at the\n//   transition, the refined number of points matches.\n//   .\n// Arguments:\n//   profiles = list of 2d or 3d profiles to be skinned.  (If 2d must also give `z`.)\n//   slices = scalar or vector number of slices to insert between each pair of profiles.  Set to zero to use only the profiles you provided.  Recommend starting with a value around 10.\n//   ---\n//   refine = resample profiles to this number of points per edge.  Can be a list to give a refinement for each profile.  Recommend using a value above 10 when using the \"distance\" or \"fast_distance\" methods.  Default: 1.\n//   sampling = sampling method to use with \"direct\" and \"reindex\" methods.  Can be \"length\" or \"segment\".  Ignored if any profile pair uses either the \"distance\", \"fast_distance\", or \"tangent\" methods.  Default: \"length\".\n//   closed = set to true to connect first and last profile (to make a torus).  Default: false\n//   caps = true to create endcap faces when closed is false.  Can be a length 2 boolean array.  Default is true if closed is false.\n//   method = method for connecting profiles, one of \"distance\", \"fast_distance\", \"tangent\", \"direct\" or \"reindex\".  Default: \"direct\".\n//   z = array of height values for each profile if the profiles are 2d\n//   convexity = convexity setting for use with polyhedron.  (module only) Default: 10\n//   anchor = Translate so anchor point is at the origin.  Default: \"origin\"\n//   spin = Rotate this many degrees around Z axis after anchor.  Default: 0\n//   orient = Vector to rotate top towards after spin\n//   atype = Select \"hull\" or \"intersect\" anchor types. Default: \"hull\"\n//   cp = Centerpoint for determining \"intersect\" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 3D point.  Default: \"centroid\"\n//   style = vnf_vertex_array style.  Default: \"min_edge\"\n// Anchor Types:\n//   \"hull\" = Anchors to the virtual convex hull of the shape.\n//   \"intersect\" = Anchors to the surface of the shape.\n// Example:\n//   skin([octagon(4), circle($fn=70,r=2)], z=[0,3], slices=10);\n// Example: Rotating the pentagon place the zero index at different locations, giving a twist\n//   skin([rot(90,p=pentagon(4)), circle($fn=80,r=2)], z=[0,3], slices=10);\n// Example: You can untwist it with the \"reindex\" method\n//   skin([rot(90,p=pentagon(4)), circle($fn=80,r=2)], z=[0,3], slices=10, method=\"reindex\");\n// Example: Offsetting the starting edge connects to circles in an interesting way:\n//   circ = circle($fn=80, r=3);\n//   skin([circ, rot(110,p=circ)], z=[0,5], slices=20);\n// Example(FlatSpin,VPD=20):\n//   skin([ yrot(37,p=path3d(circle($fn=128, r=4))), path3d(square(3),3)], method=\"reindex\",slices=10);\n// Example(FlatSpin,VPD=16): Ellipses connected with twist\n//   ellipse = xscale(2.5,p=circle($fn=80));\n//   skin([ellipse, rot(45,p=ellipse)], z=[0,1.5], slices=10);\n// Example(FlatSpin,VPD=16): Ellipses connected without a twist.  (Note ellipses stay in the same position: just the connecting edges are different.)\n//   ellipse = xscale(2.5,p=circle($fn=80));\n//   skin([ellipse, rot(45,p=ellipse)], z=[0,1.5], slices=10, method=\"reindex\");\n// Example(FlatSpin,VPD=500):\n//   $fn=24;\n//   skin([\n//         yrot(0, p=yscale(2,p=path3d(circle(d=75)))),\n//         [[40,0,100], [35,-15,100], [20,-30,100],[0,-40,100],[-40,0,100],[0,40,100],[20,30,100], [35,15,100]]\n//   ],slices=10);\n// Example(FlatSpin,VPD=600):\n//   $fn=48;\n//   skin([\n//       for (b=[0,90]) [\n//           for (a=[360:-360/$fn:0.01])\n//               point3d(polar_to_xy((100+50*cos((a+b)*2))/2,a),b/90*100)\n//       ]\n//   ], slices=20);\n// Example: Vaccum connector example from list-comprehension-demos\n//   include <BOSL2/rounding.scad>\n//   $fn=32;\n//   base = round_corners(square([2,4],center=true), radius=0.5);\n//   skin([\n//       path3d(base,0),\n//       path3d(base,2),\n//       path3d(circle(r=0.5),3),\n//       path3d(circle(r=0.5),4),\n//       for(i=[0:2]) each [path3d(circle(r=0.6), i+4),\n//                          path3d(circle(r=0.5), i+5)]\n//   ],slices=0);\n// Example: Vaccum nozzle example from list-comprehension-demos, using \"length\" sampling (the default)\n//   xrot(90)down(1.5)\n//   difference() {\n//       skin(\n//           [square([2,.2],center=true),\n//            circle($fn=64,r=0.5)], z=[0,3],\n//           slices=40,sampling=\"length\",method=\"reindex\");\n//       skin(\n//           [square([1.9,.1],center=true),\n//            circle($fn=64,r=0.45)], z=[-.01,3.01],\n//           slices=40,sampling=\"length\",method=\"reindex\");\n//   }\n// Example: Same thing with \"segment\" sampling\n//   xrot(90)down(1.5)\n//   difference() {\n//       skin(\n//           [square([2,.2],center=true),\n//            circle($fn=64,r=0.5)], z=[0,3],\n//           slices=40,sampling=\"segment\",method=\"reindex\");\n//       skin(\n//           [square([1.9,.1],center=true),\n//            circle($fn=64,r=0.45)], z=[-.01,3.01],\n//           slices=40,sampling=\"segment\",method=\"reindex\");\n//   }\n// Example: Forma Candle Holder (from list-comprehension-demos)\n//   r = 50;\n//   height = 140;\n//   layers = 10;\n//   wallthickness = 5;\n//   holeradius = r - wallthickness;\n//   difference() {\n//       skin([for (i=[0:layers-1]) zrot(-30*i,p=path3d(hexagon(ir=r),i*height/layers))],slices=0);\n//       up(height/layers) cylinder(r=holeradius, h=height);\n//   }\n// Example(FlatSpin,VPD=300): A box that is octagonal on the outside and circular on the inside\n//   height = 45;\n//   sub_base = octagon(d=71, rounding=2, $fn=128);\n//   base = octagon(d=75, rounding=2, $fn=128);\n//   interior = regular_ngon(n=len(base), d=60);\n//   right_half()\n//     skin([ sub_base, base, base, sub_base, interior], z=[0,2,height, height, 2], slices=0, refine=1, method=\"reindex\");\n// Example: Connecting a pentagon and circle with the \"tangent\" method produces large triangular faces and cone shaped corners.\n//   skin([pentagon(4), circle($fn=80,r=2)], z=[0,3], slices=10, method=\"tangent\");\n// Example: rounding corners of a square.  Note that `$fn` makes the number of points constant, and avoiding the `rounding=0` case keeps everything simple.  In this case, the connections between profiles are linear, so there is no benefit to setting `slices` bigger than zero.\n//   shapes = [for(i=[.01:.045:2])zrot(-i*180/2,cp=[-8,0,0],p=xrot(90,p=path3d(regular_ngon(n=4, side=4, rounding=i, $fn=64))))];\n//   rotate(180) skin( shapes, slices=0);\n// Example: Here's a simplified version of the above, with `i=0` included.  That first layer doesn't look good.\n//   shapes = [for(i=[0:.2:1]) path3d(regular_ngon(n=4, side=4, rounding=i, $fn=32),i*5)];\n//   skin(shapes, slices=0);\n// Example: You can fix it by specifying \"tangent\" for the first method, but you still need \"direct\" for the rest.\n//   shapes = [for(i=[0:.2:1]) path3d(regular_ngon(n=4, side=4, rounding=i, $fn=32),i*5)];\n//   skin(shapes, slices=0, method=concat([\"tangent\"],repeat(\"direct\",len(shapes)-2)));\n// Example(FlatSpin,VPD=35): Connecting square to pentagon using \"direct\" method.\n//   skin([regular_ngon(n=4, r=4), regular_ngon(n=5,r=5)], z=[0,4], refine=10, slices=10);\n// Example(FlatSpin,VPD=35): Connecting square to shifted pentagon using \"direct\" method.\n//   skin([regular_ngon(n=4, r=4), right(4,p=regular_ngon(n=5,r=5))], z=[0,4], refine=10, slices=10);\n// Example(FlatSpin,VPD=185): In this example reindexing does not fix the orientation of the triangle because it happens in 3d within skin(), so we have to reverse the triangle manually\n//   ellipse = yscale(3,circle(r=10, $fn=32));\n//   tri = move([-50/3,-9],[[0,0], [50,0], [0,27]]);\n//   skin([ellipse, reverse(tri)], z=[0,20], slices=20, method=\"reindex\");\n// Example(FlatSpin,VPD=185): You can get a nicer transition by rotating the polygons for better alignment.  You have to resample yourself before calling `align_polygon`. The orientation is fixed so we do not need to reverse.\n//   ellipse = yscale(3,circle(r=10, $fn=32));\n//   tri = move([-50/3,-9],\n//              subdivide_path([[0,0], [50,0], [0,27]], 32));\n//   aligned = align_polygon(ellipse,tri, [0:5:180]);\n//   skin([ellipse, aligned], z=[0,20], slices=20);\n// Example(FlatSpin,VPD=35): The \"distance\" method is a completely different approach.\n//   skin([regular_ngon(n=4, r=4), regular_ngon(n=5,r=5)], z=[0,4], refine=10, slices=10, method=\"distance\");\n// Example(FlatSpin,VPD=35,VPT=[0,0,4]): Connecting pentagon to heptagon inserts two triangular faces on each side\n//   small = path3d(circle(r=3, $fn=5));\n//   big = up(2,p=yrot( 0,p=path3d(circle(r=3, $fn=7), 6)));\n//   skin([small,big],method=\"distance\", slices=10, refine=10);\n// Example(FlatSpin,VPD=35,VPT=[0,0,4]): But just a slight rotation of the top profile moves the two triangles to one end\n//   small = path3d(circle(r=3, $fn=5));\n//   big = up(2,p=yrot(14,p=path3d(circle(r=3, $fn=7), 6)));\n//   skin([small,big],method=\"distance\", slices=10, refine=10);\n// Example(FlatSpin,VPD=32,VPT=[1.2,4.3,2]): Another \"distance\" example:\n//   off = [0,2];\n//   shape = turtle([\"right\",45,\"move\", \"left\",45,\"move\", \"left\",45, \"move\", \"jump\", [.5+sqrt(2)/2,8]]);\n//   rshape = rot(180,cp=centroid(shape)+off, p=shape);\n//   skin([shape,rshape],z=[0,4], method=\"distance\",slices=10,refine=15);\n// Example(FlatSpin,VPD=32,VPT=[1.2,4.3,2]): Slightly shifting the profile changes the optimal linkage\n//   off = [0,1];\n//   shape = turtle([\"right\",45,\"move\", \"left\",45,\"move\", \"left\",45, \"move\", \"jump\", [.5+sqrt(2)/2,8]]);\n//   rshape = rot(180,cp=centroid(shape)+off, p=shape);\n//   skin([shape,rshape],z=[0,4], method=\"distance\",slices=10,refine=15);\n// Example(FlatSpin,VPD=444,VPT=[0,0,50]): This optimal solution doesn't look terrible:\n//   prof1 = path3d([[-50,-50], [-50,50], [50,50], [25,25], [50,0], [25,-25], [50,-50]]);\n//   prof2 = path3d(regular_ngon(n=7, r=50),100);\n//   skin([prof1, prof2], method=\"distance\", slices=10, refine=10);\n// Example(FlatSpin,VPD=444,VPT=[0,0,50]): But this one looks better.  The \"distance\" method doesn't find it because it uses two more edges, so it clearly has a higher total edge distance.  We force it by doubling the first two vertices of one of the profiles.\n//   prof1 = path3d([[-50,-50], [-50,50], [50,50], [25,25], [50,0], [25,-25], [50,-50]]);\n//   prof2 = path3d(regular_ngon(n=7, r=50),100);\n//   skin([repeat_entries(prof1,[2,2,1,1,1,1,1]),\n//         prof2],\n//        method=\"distance\", slices=10, refine=10);\n// Example(FlatSpin,VPD=80,VPT=[0,0,7]): The \"distance\" method will often produces results similar to the \"tangent\" method if you use it with a polygon and a curve, but the results can also look like this:\n//   skin([path3d(circle($fn=128, r=10)), xrot(39, p=path3d(square([8,10]),10))],  method=\"distance\", slices=0);\n// Example(FlatSpin,VPD=80,VPT=[0,0,7]): Using the \"tangent\" method produces:\n//   skin([path3d(circle($fn=128, r=10)), xrot(39, p=path3d(square([8,10]),10))],  method=\"tangent\", slices=0);\n// Example(FlatSpin,VPD=74): Torus using hexagons and pentagons, where `closed=true`\n//   hex = right(7,p=path3d(hexagon(r=3)));\n//   pent = right(7,p=path3d(pentagon(r=3)));\n//   N=5;\n//   skin(\n//        [for(i=[0:2*N-1]) yrot(360*i/2/N, p=(i%2==0 ? hex : pent))],\n//        refine=1,slices=0,method=\"distance\",closed=true);\n// Example: A smooth morph is achieved when you can calculate all the slices yourself.  Since you provide all the slices, set `slices=0`.\n//   skin([for(n=[.1:.02:.5])\n//            yrot(n*60-.5*60,p=path3d(supershape(step=360/128,m1=5,n1=n, n2=1.7),5-10*n))],\n//        slices=0);\n// Example: Another smooth supershape morph:\n//   skin([for(alpha=[-.2:.05:1.5])\n//            path3d(supershape(step=360/256,m1=7, n1=lerp(2,3,alpha),\n//                              n2=lerp(8,4,alpha), n3=lerp(4,17,alpha)),alpha*5)],\n//        slices=0);\n// Example: Several polygons connected using \"distance\"\n//   skin([regular_ngon(n=4, r=3),\n//         regular_ngon(n=6, r=3),\n//         regular_ngon(n=9, r=4),\n//         rot(17,p=regular_ngon(n=6, r=3)),\n//         rot(37,p=regular_ngon(n=4, r=3))],\n//        z=[0,2,4,6,9], method=\"distance\", slices=10, refine=10);\n// Example(FlatSpin,VPD=935,VPT=[75,0,123]): Vertex count of the polygon changes at every profile\n//   skin([\n//       for (ang = [0:10:90])\n//       rot([0,ang,0], cp=[200,0,0], p=path3d(circle(d=100,$fn=12-(ang/10))))\n//   ],method=\"distance\",slices=10,refine=10);\n// Example: M\u00f6bius Strip.  This is a tricky model because when you work your way around to the connection, the direction of the profiles is flipped, so how can the proper geometry be created?  The trick is to duplicate the first profile and turn the caps off.  The model closes up and forms a valid polyhedron.\n//   skin([\n//     for (ang = [0:5:360])\n//     rot([0,ang,0], cp=[100,0,0], p=rot(ang/2, p=path3d(square([1,30],center=true))))\n//   ], caps=false, slices=0, refine=20);\n// Example: This model of two scutoids packed together is based on https://www.thingiverse.com/thing:3024272 by mathgrrl\n//   sidelen = 10;  // Side length of scutoid\n//   height = 25;   // Height of scutoid\n//   angle = -15;   // Angle (twists the entire form)\n//   push = -5;     // Push (translates the base away from the top)\n//   flare = 1;     // Flare (the two pieces will be different unless this is 1)\n//   midpoint = .5; // Height of the extra vertex (as a fraction of total height); the two pieces will be different unless this is .5)\n//   pushvec = rot(angle/2,p=push*RIGHT);  // Push direction is the average of the top and bottom mating edges\n//   pent = path3d(apply(move(pushvec)*rot(angle),pentagon(side=sidelen,align_side=RIGHT,anchor=\"side0\")));\n//   hex = path3d(hexagon(side=flare*sidelen, align_side=RIGHT, anchor=\"side0\"),height);\n//   pentmate = path3d(pentagon(side=flare*sidelen,align_side=LEFT,anchor=\"side0\"),height);\n//             // Native index would require mapping first and last vertices together, which is not allowed, so shift\n//   hexmate = list_rotate(\n//                           path3d(apply(move(pushvec)*rot(angle),hexagon(side=sidelen,align_side=LEFT,anchor=\"side0\"))),\n//                           -1);\n//   join_vertex = lerp(\n//                       mean(select(hex,1,2)),     // midpoint of \"extra\" hex edge\n//                       mean(select(hexmate,0,1)), // midpoint of \"extra\" hexmate edge\n//                       midpoint);\n//   augpent = repeat_entries(pent, [1,2,1,1,1]);         // Vertex 1 will split at the top forming a triangular face with the hexagon\n//   augpent_mate = repeat_entries(pentmate,[2,1,1,1,1]); // For mating pentagon it is vertex 0 that splits\n//              // Middle is the interpolation between top and bottom except for the join vertex, which is doubled because it splits\n//   middle = list_set(lerp(augpent,hex,midpoint),[1,2],[join_vertex,join_vertex]);\n//   middle_mate = list_set(lerp(hexmate,augpent_mate,midpoint), [0,1], [join_vertex,join_vertex]);\n//   skin([augpent,middle,hex],  slices=10, refine=10, sampling=\"segment\");\n//   color(\"green\")skin([augpent_mate,middle_mate,hexmate],  slices=10,refine=10, sampling=\"segment\");\n// Example: If you create a self-intersecting polyhedron the result is invalid.  In some cases self-intersection may be obvous.  Here is a more subtle example.\n//   skin([\n//          for (a = [0:30:180]) let(\n//              pos  = [-60*sin(a),     0, a    ],\n//              pos2 = [-60*sin(a+0.1), 0, a+0.1]\n//          ) move(pos,\n//              p=rot(from=UP, to=pos2-pos,\n//                  p=path3d(circle(d=150))\n//              )\n//          )\n//      ],refine=1,slices=0);\n//      color(\"red\") {\n//          zrot(25) fwd(130) xrot(75) {\n//              linear_extrude(height=0.1) {\n//                  ydistribute(25) {\n//                      text(text=\"BAD POLYHEDRONS!\", size=20, halign=\"center\", valign=\"center\");\n//                      text(text=\"CREASES MAKE\", size=20, halign=\"center\", valign=\"center\");\n//                  }\n//              }\n//          }\n//          up(160) zrot(25) fwd(130) xrot(75) {\n//              stroke(zrot(30, p=yscale(0.5, p=circle(d=120))),width=10,closed=true);\n//          }\n//      }\nmodule skin(profiles, slices, refine=1, method=\"direct\", sampling, caps, closed=false, z, style=\"min_edge\", convexity=10,\n            anchor=\"origin\",cp=\"centroid\",spin=0, orient=UP, atype=\"hull\")\n{\n    vnf = skin(profiles, slices, refine, method, sampling, caps, closed, z, style=style);\n    vnf_polyhedron(vnf,convexity=convexity,spin=spin,anchor=anchor,orient=orient,atype=atype,cp=cp)\n        children();\n}\n\n\nfunction skin(profiles, slices, refine=1, method=\"direct\", sampling, caps, closed=false, z, style=\"min_edge\",\n              anchor=\"origin\",cp=\"centroid\",spin=0, orient=UP, atype=\"hull\") =\n  assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\")\n  assert(is_def(slices),\"The slices argument must be specified.\")\n  assert(is_list(profiles) && len(profiles)>1, \"Must provide at least two profiles\")\n  let(\n       profiles = [for(p=profiles) if (is_region(p) && len(p)==1) p[0] else p]\n  )\n  let( bad = [for(i=idx(profiles)) if (!(is_path(profiles[i]) && len(profiles[i])>2)) i])\n  assert(len(bad)==0, str(\"Profiles \",bad,\" are not a paths or have length less than 3\"))\n  let(\n    profcount = len(profiles) - (closed?0:1),\n    legal_methods = [\"direct\",\"reindex\",\"distance\",\"fast_distance\",\"tangent\"],\n    caps = is_def(caps) ? caps :\n           closed ? false : true,\n    capsOK = is_bool(caps) || is_bool_list(caps,2),\n    fullcaps = is_bool(caps) ? [caps,caps] : caps,\n    refine = is_list(refine) ? refine : repeat(refine, len(profiles)),\n    slices = is_list(slices) ? slices : repeat(slices, profcount),\n    refineOK = [for(i=idx(refine)) if (refine[i]<=0 || !is_integer(refine[i])) i],\n    slicesOK = [for(i=idx(slices)) if (!is_integer(slices[i]) || slices[i]<0) i],\n    maxsize = max_length(profiles),\n    methodok = is_list(method) || in_list(method, legal_methods),\n    methodlistok = is_list(method) ? [for(i=idx(method)) if (!in_list(method[i], legal_methods)) i] : [],\n    method = is_string(method) ? repeat(method, profcount) : method,\n    // Define to be zero where a resampling method is used and 1 where a vertex duplicator is used\n    RESAMPLING = 0,\n    DUPLICATOR = 1,\n    method_type = [for(m = method) m==\"direct\" || m==\"reindex\" ? 0 : 1],\n    sampling = is_def(sampling) ? sampling :\n               in_list(DUPLICATOR,method_type) ? \"segment\" : \"length\"\n  )\n  assert(len(refine)==len(profiles), \"refine list is the wrong length\")\n  assert(len(slices)==profcount, str(\"slices list must have length \",profcount))\n  assert(slicesOK==[],str(\"slices must be nonnegative integers\"))\n  assert(refineOK==[],str(\"refine must be postive integer\"))\n  assert(methodok,str(\"method must be one of \",legal_methods,\". Got \",method))\n  assert(methodlistok==[], str(\"method list contains invalid method at \",methodlistok))\n  assert(len(method) == profcount,\"Method list is the wrong length\")\n  assert(in_list(sampling,[\"length\",\"segment\"]), \"sampling must be set to \\\"length\\\" or \\\"segment\\\"\")\n  assert(sampling==\"segment\" || (!in_list(\"distance\",method) && !in_list(\"fast_distance\",method) && !in_list(\"tangent\",method)), \"sampling is set to \\\"length\\\" which is only allowed with methods \\\"direct\\\" and \\\"reindex\\\"\")\n  assert(capsOK, \"caps must be boolean or a list of two booleans\")\n  assert(!closed || !caps, \"Cannot make closed shape with caps\")\n  let(\n    profile_dim=list_shape(profiles,2),\n    profiles_zcheck = (profile_dim != 2) || (profile_dim==2 && is_list(z) && len(z)==len(profiles)),\n    profiles_ok = (profile_dim==2 && is_list(z) && len(z)==len(profiles)) || profile_dim==3\n  )\n  assert(profiles_zcheck, \"z parameter is invalid or has the wrong length.\")\n  assert(profiles_ok,\"Profiles must all be 3d or must all be 2d, with matching length z parameter.\")\n  assert(is_undef(z) || profile_dim==2, \"Do not specify z with 3d profiles\")\n  assert(profile_dim==3 || len(z)==len(profiles),\"Length of z does not match length of profiles.\")\n  let(\n    // Adjoin Z coordinates to 2d profiles\n    profiles = profile_dim==3 ? profiles :\n               [for(i=idx(profiles)) path3d(profiles[i], z[i])],\n    // True length (not counting repeated vertices) of profiles after refinement\n    refined_len = [for(i=idx(profiles)) refine[i]*len(profiles[i])],\n    // Define this to be 1 if a profile is used on either side by a resampling method, zero otherwise.\n    profile_resampled = [for(i=idx(profiles))\n      1-(\n           i==0 ?  method_type[0] * (closed? last(method_type) : 1) :\n           i==len(profiles)-1 ? last(method_type) * (closed ? select(method_type,-2) : 1) :\n         method_type[i] * method_type[i-1])],\n    parts = search(1,[1,for(i=[0:1:len(profile_resampled)-2]) profile_resampled[i]!=profile_resampled[i+1] ? 1 : 0],0),\n    plen = [for(i=idx(parts)) (i== len(parts)-1? len(refined_len) : parts[i+1]) - parts[i]],\n    max_list = [for(i=idx(parts)) each repeat(max(select(refined_len, parts[i], parts[i]+plen[i]-1)), plen[i])],\n    transition_profiles = [for(i=[(closed?0:1):1:profcount-1]) if (select(method_type,i-1) != method_type[i]) i],\n    badind = [for(tranprof=transition_profiles) if (refined_len[tranprof] != max_list[tranprof]) tranprof]\n  )\n  assert(badind==[],str(\"Profile length mismatch at method transition at indices \",badind,\" in skin()\"))\n  let(\n    full_list =    // If there are no duplicators then use more efficient where the whole input is treated together\n      !in_list(DUPLICATOR,method_type) ?\n         let(\n             resampled = [for(i=idx(profiles)) subdivide_path(profiles[i], max_list[i], method=sampling)],\n             fixedprof = [for(i=idx(profiles))\n                             i==0 || method[i-1]==\"direct\" ? resampled[i]\n                                                         : reindex_polygon(resampled[i-1],resampled[i])],\n             sliced = slice_profiles(fixedprof, slices, closed)\n            )\n            [!closed ? sliced : concat(sliced,[sliced[0]])]\n      :  // There are duplicators, so use approach where each pair is treated separately\n      [for(i=[0:profcount-1])\n        let(\n          pair =\n            method[i]==\"distance\" ? _skin_distance_match(profiles[i],select(profiles,i+1)) :\n            method[i]==\"fast_distance\" ? _skin_aligned_distance_match(profiles[i], select(profiles,i+1)) :\n            method[i]==\"tangent\" ? _skin_tangent_match(profiles[i],select(profiles,i+1)) :\n            /*method[i]==\"reindex\" || method[i]==\"direct\" ?*/\n               let( p1 = subdivide_path(profiles[i],max_list[i], method=sampling),\n                    p2 = subdivide_path(select(profiles,i+1),max_list[i], method=sampling)\n               ) (method[i]==\"direct\" ? [p1,p2] : [p1, reindex_polygon(p1, p2)]),\n            nsamples =  method_type[i]==RESAMPLING ? len(pair[0]) :\n               assert(refine[i]==select(refine,i+1),str(\"Refine value mismatch at indices \",[i,(i+1)%len(refine)],\n                                                        \".  Method \",method[i],\" requires equal values\"))\n               refine[i] * len(pair[0])\n          )\n          subdivide_and_slice(pair,slices[i], nsamples, method=sampling)],\n      vnf=vnf_join(\n          [for(i=idx(full_list))\n              vnf_vertex_array(full_list[i], cap1=i==0 && fullcaps[0], cap2=i==len(full_list)-1 && fullcaps[1],\n                               col_wrap=true, style=style)])\n  )\n  reorient(anchor,spin,orient,vnf=vnf,p=vnf,extent=atype==\"hull\",cp=cp);\n\n\n\n// Function&Module: linear_sweep()\n// Synopsis: Create a linear extrusion from a path, with optional texturing. \n// SynTags: VNF, Geom\n// Topics: Extrusion, Textures, Sweep\n// See Also: rotate_sweep(), sweep(), spiral_sweep(), path_sweep(), offset_sweep()\n// Usage: As Module\n//   linear_sweep(region, [height], [center=], [slices=], [twist=], [scale=], [style=], [caps=], [convexity=]) [ATTACHMENTS];\n// Usage: With Texturing\n//   linear_sweep(region, [height], [center=], texture=, [tex_size=]|[tex_reps=], [tex_depth=], [style=], [tex_samples=], ...) [ATTACHMENTS];\n// Usage: As Function\n//   vnf = linear_sweep(region, [height], [center=], [slices=], [twist=], [scale=], [style=], [caps=]);\n//   vnf = linear_sweep(region, [height], [center=], texture=, [tex_size=]|[tex_reps=], [tex_depth=], [style=], [tex_samples=], ...);\n// Description:\n//   If called as a module, creates a polyhedron that is the linear extrusion of the given 2D region or polygon.\n//   If called as a function, returns a VNF that can be used to generate a polyhedron of the linear extrusion\n//   of the given 2D region or polygon.  The benefit of using this, over using `linear_extrude region(rgn)` is\n//   that it supports `anchor`, `spin`, `orient` and attachments.  You can also make more refined\n//   twisted extrusions by using `maxseg` to subsample flat faces.\n//   .\n//   Anchoring for linear_sweep is based on the anchors for the swept region rather than from the polyhedron that is created.  This can produce more\n//   predictable anchors for LEFT, RIGHT, FWD and BACK in many cases, but the anchors may only\n//   be aproximately correct for twisted objects, and corner anchors may point in unexpected directions in some cases.\n//   If you need anchors directly computed from the surface you can pass the vnf from linear_sweep\n//   to {{vnf_polyhedron()}}, which will compute anchors directly from the full VNF.  \n// Arguments:\n//   region = The 2D [Region](regions.scad) or polygon that is to be extruded.\n//   h / height / l / length = The height to extrude the region.  Default: 1\n//   center = If true, the created polyhedron will be vertically centered.  If false, it will be extruded upwards from the XY plane.  Default: `false`\n//   ---\n//   twist = The number of degrees to rotate the top of the shape, clockwise around the Z axis, relative to the bottom.  Default: 0\n//   scale = The amount to scale the top of the shape, in the X and Y directions, relative to the size of the bottom.  Default: 1\n//   shift = The amount to shift the top of the shape, in the X and Y directions, relative to the position of the bottom.  Default: [0,0]\n//   slices = The number of slices to divide the shape into along the Z axis, to allow refinement of detail, especially when working with a twist.  Default: `twist/5`\n//   maxseg = If given, then any long segments of the region will be subdivided to be shorter than this length.  This can refine twisting flat faces a lot.  Default: `undef` (no subsampling)\n//   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0), or a VNF tile that defines the texture to apply to vertical surfaces.  See {{texture()}} for what named textures are supported.\n//   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`\n//   tex_reps = If given instead of tex_size, a 2-vector giving the number of texture tile repetitions in the horizontal and vertical directions on the extrusion.\n//   tex_inset = If numeric, lowers the texture into the surface by the specified proportion, e.g. 0.5 would lower it half way into the surface.  If `true`, insets by exactly its full depth.  Default: `false`\n//   tex_rot = Rotate texture by specified angle, which must be a multiple of 90 degrees.  Default: 0\n//   tex_depth = Specify texture depth; if negative, invert the texture.  Default: 1.\n//   tex_samples = Minimum number of \"bend points\" to have in VNF texture tiles.  Default: 8\n//   style = The style to use when triangulating the surface of the object.  Valid values are `\"default\"`, `\"alt\"`, or `\"quincunx\"`.\n//   caps = If false do not create end caps.  Can be a boolean vector.  Default: true\n//   convexity = Max number of surfaces any single ray could pass through.  Module use only.\n//   cp = Centerpoint for determining intersection anchors or centering the shape.  Determines the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 3D point.  Default: `\"centroid\"`\n//   atype = Set to \"hull\" or \"intersect\" to select anchor type.  Default: \"hull\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `\"origin\"`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Anchor Types:\n//   \"hull\" = Anchors to the virtual convex hull of the shape.\n//   \"intersect\" = Anchors to the surface of the shape.\n//   \"bbox\" = Anchors to the bounding box of the extruded shape.\n// Extra Anchors:\n//   \"origin\" = Centers the extruded shape vertically only, but keeps the original path positions in the X and Y.  Oriented UP.\n//   \"original_base\" = Keeps the original path positions in the X and Y, but at the bottom of the extrusion.  Oriented UP.\n// Example: Extruding a Compound Region.\n//   rgn1 = [for (d=[10:10:60]) circle(d=d,$fn=8)];\n//   rgn2 = [square(30,center=false)];\n//   rgn3 = [for (size=[10:10:20]) move([15,15],p=square(size=size, center=true))];\n//   mrgn = union(rgn1,rgn2);\n//   orgn = difference(mrgn,rgn3);\n//   linear_sweep(orgn,height=20,convexity=16);\n// Example: With Twist, Scale, Shift, Slices and Maxseg.\n//   rgn1 = [for (d=[10:10:60]) circle(d=d,$fn=8)];\n//   rgn2 = [square(30,center=false)];\n//   rgn3 = [\n//       for (size=[10:10:20])\n//       apply(\n//          move([15,15]),\n//          square(size=size, center=true)\n//       )\n//   ];\n//   mrgn = union(rgn1,rgn2);\n//   orgn = difference(mrgn,rgn3);\n//   linear_sweep(\n//       orgn, height=50, maxseg=2, slices=40,\n//       twist=90, scale=0.5, shift=[10,5],\n//       convexity=16\n//   );\n// Example: Anchors on an Extruded Region\n//   rgn1 = [for (d=[10:10:60]) circle(d=d,$fn=8)];\n//   rgn2 = [square(30,center=false)];\n//   rgn3 = [\n//       for (size=[10:10:20])\n//       apply(\n//           move([15,15]),\n//           rect(size=size)\n//       )\n//   ];\n//   mrgn = union(rgn1,rgn2);\n//   orgn = difference(mrgn,rgn3);\n//   linear_sweep(orgn,height=20,convexity=16)\n//       show_anchors();\n// Example: \"diamonds\" texture.\n//   path = glued_circles(r=15, spread=40, tangent=45);\n//   linear_sweep(\n//       path, texture=\"diamonds\", tex_size=[5,10],\n//       h=40, style=\"concave\");\n// Example: \"pyramids\" texture.\n//   linear_sweep(\n//       rect(50), texture=\"pyramids\", tex_size=[10,10],\n//       h=40, style=\"convex\");\n// Example: \"bricks_vnf\" texture.\n//   path = glued_circles(r=15, spread=40, tangent=45);\n//   linear_sweep(\n//       path, texture=\"bricks_vnf\", tex_size=[10,10],\n//       tex_depth=0.25, h=40);\n// Example: User defined heightfield texture.\n//   path = ellipse(r=[20,10]);\n//   texture = [for (i=[0:9])\n//       [for (j=[0:9])\n//           1/max(0.5,norm([i,j]-[5,5])) ]];\n//   linear_sweep(\n//       path, texture=texture, tex_size=[5,5],\n//       h=40, style=\"min_edge\", anchor=BOT);\n// Example: User defined VNF tile texture.\n//   path = ellipse(r=[20,10]);\n//   tex = let(n=16,m=0.25) [\n//        [\n//            each resample_path(path3d(square(1)),n),\n//            each move([0.5,0.5],\n//                p=path3d(circle(d=0.5,$fn=n),m)),\n//            [1/2,1/2,0],\n//        ], [\n//            for (i=[0:1:n-1]) each [\n//                [i,(i+1)%n,(i+3)%n+n],\n//                [i,(i+3)%n+n,(i+2)%n+n],\n//                [2*n,n+i,n+(i+1)%n],\n//            ]\n//        ]\n//   ];\n//   linear_sweep(path, texture=tex, tex_size=[5,5], h=40);\n// Example: Textured with twist and scale.\n//   linear_sweep(regular_ngon(n=3, d=50),\n//       texture=\"rough\", h=100, tex_depth=2,\n//       tex_size=[20,20], style=\"min_edge\",\n//       convexity=10, scale=0.2, twist=120);\n// Example: As Function\n//   path = glued_circles(r=15, spread=40, tangent=45);\n//   vnf = linear_sweep(\n//       path, h=40, texture=\"trunc_pyramids\", tex_size=[5,5],\n//       tex_depth=1, style=\"convex\");\n//   vnf_polyhedron(vnf, convexity=10);\n// Example: VNF tile that has no top/bottom edges and produces a disconnected result\n//   shape = skin([rect(2/5),\n//                 rect(2/3),\n//                 rect(2/5)],\n//                z=[0,1/2,1],\n//                slices=0,\n//                caps=false);\n//   tile = move([0,1/2,2/3],yrot(90,shape));\n//   linear_sweep(circle(20), texture=tile,\n//                tex_size=[10,10],tex_depth=5,\n//                h=40,convexity=4);\n// Example: The same tile from above, turned 90 degrees, creates problems at the ends, because the end cap is not a connected polygon.  When the ends are disconnected you may find that some parts of the end cap are missing and spurious polygons included.  \n//  shape = skin([rect(2/5),\n//                rect(2/3),\n//                rect(2/5)],\n//               z=[0,1/2,1],\n//               slices=0,\n//               caps=false);\n//  tile = move([1/2,1,2/3],xrot(90,shape));\n//  linear_sweep(circle(20), texture=tile,\n//               tex_size=[30,20],tex_depth=15,\n//               h=40,convexity=4);\n// Example: This example shows some endcap polygons missing and a spurious triangle\n//   shape = skin([rect(2/5),\n//                 rect(2/3),\n//                 rect(2/5)],\n//                z=[0,1/2,1],\n//                slices=0,\n//                caps=false);\n//   tile = xscale(.5,move([1/2,1,2/3],xrot(90,shape)));\n//   doubletile = vnf_join([tile, right(.5,tile)]);\n//   linear_sweep(circle(20), texture=doubletile,\n//                tex_size=[45,45],tex_depth=15, h=40);\n// Example: You can fix ends for disconnected cases using {{top_half()}} and {{bottom_half()}}\n//   shape = skin([rect(2/5),\n//                 rect(2/3),\n//                 rect(2/5)],\n//                z=[0,1/2,1],\n//                slices=0,\n//                caps=false);\n//   tile = move([1/2,1,2/3],xrot(90,shape));\n//   vnf_polyhedron(\n//     top_half(\n//       bottom_half(\n//         linear_sweep(circle(20), texture=tile,\n//                     tex_size=[30,20],tex_depth=15,\n//                     h=40.2,caps=false),\n//       z=20),\n//     z=-20)); \n\nmodule linear_sweep(\n    region, height, center,\n    twist=0, scale=1, shift=[0,0],\n    slices, maxseg, style=\"default\", convexity, caps=true, \n    texture, tex_size=[5,5], tex_reps, tex_counts,\n    tex_inset=false, tex_rot=0,\n    tex_depth, tex_scale, tex_samples,\n    cp, atype=\"hull\", h,l,length,\n    anchor, spin=0, orient=UP\n) {\n    h = one_defined([h, height,l,length],\"h,height,l,length\",dflt=1);\n    region = force_region(region);\n    check = assert(is_region(region),\"Input is not a region\");\n    anchor = center==true? \"origin\" :\n        center == false? \"original_base\" :\n        default(anchor, \"original_base\");\n    vnf = linear_sweep(\n        region, height=h, style=style, caps=caps, \n        twist=twist, scale=scale, shift=shift,\n        texture=texture,\n        tex_size=tex_size,\n        tex_reps=tex_reps,\n        tex_counts=tex_counts,\n        tex_inset=tex_inset,\n        tex_rot=tex_rot,\n        tex_depth=tex_depth,\n        tex_samples=tex_samples,\n        slices=slices,\n        maxseg=maxseg,\n        anchor=\"origin\"\n    );\n    anchors = [\n        named_anchor(\"original_base\", [0,0,-h/2], UP)\n    ];\n    cp = default(cp, \"centroid\");\n    geom = atype==\"hull\"?  attach_geom(cp=cp, region=region, h=h, extent=true, shift=shift, scale=scale, twist=twist, anchors=anchors) :\n        atype==\"intersect\"?  attach_geom(cp=cp, region=region, h=h, extent=false, shift=shift, scale=scale, twist=twist, anchors=anchors) :\n        atype==\"bbox\"?\n            let(\n                bounds = pointlist_bounds(flatten(region)),\n                size = bounds[1] - bounds[0],\n                midpt = (bounds[0] + bounds[1])/2\n            )\n            attach_geom(cp=[0,0,0], size=point3d(size,h), offset=point3d(midpt), shift=shift, scale=scale, twist=twist, anchors=anchors) :\n        assert(in_list(atype, [\"hull\",\"intersect\",\"bbox\"]), \"Anchor type must be \\\"hull\\\", \\\"intersect\\\", or \\\"bbox\\\".\");\n    attachable(anchor,spin,orient, geom=geom) {\n        vnf_polyhedron(vnf, convexity=convexity);\n        children();\n    }\n}\n\n\nfunction linear_sweep(\n    region, height, center,\n    twist=0, scale=1, shift=[0,0],\n    slices, maxseg, style=\"default\", caps=true, \n    cp, atype=\"hull\", h,\n    texture, tex_size=[5,5], tex_reps, tex_counts,\n    tex_inset=false, tex_rot=0,\n    tex_scale, tex_depth, tex_samples, h, l, length, \n    anchor, spin=0, orient=UP\n) =\n    assert(num_defined([tex_reps,tex_counts])<2, \"In linear_sweep() the 'tex_counts' parameter has been replaced by 'tex_reps'.  You cannot give both.\")\n    assert(num_defined([tex_scale,tex_depth])<2, \"In linear_sweep() the 'tex_scale' parameter has been replaced by 'tex_depth'.  You cannot give both.\")\n    let(\n        region = force_region(region),\n        tex_reps = is_def(tex_counts)? echo(\"In linear_sweep() the 'tex_counts' parameter is deprecated and has been replaced by 'tex_reps'\")tex_counts\n                 : tex_reps,\n        tex_depth = is_def(tex_scale)? echo(\"In linear_sweep() the 'tex_scale' parameter is deprecated and has been replaced by 'tex_depth'\")tex_scale\n                  : default(tex_depth,1)\n    )\n    assert(is_region(region), \"Input is not a region or polygon.\")\n    assert(is_num(scale) || is_vector(scale))\n    assert(is_vector(shift, 2), str(shift))\n    assert(is_bool(caps) || is_bool_list(caps,2), \"caps must be boolean or a list of two booleans\")\n    let(\n        h = one_defined([h, height,l,length],\"h,height,l,length\",dflt=1)\n    )\n    !is_undef(texture)? _textured_linear_sweep(\n        region, h=h, caps=caps, \n        texture=texture, tex_size=tex_size,\n        counts=tex_reps, inset=tex_inset,\n        rot=tex_rot, tex_scale=tex_depth,\n        twist=twist, scale=scale, shift=shift,\n        style=style, samples=tex_samples,\n        anchor=anchor, spin=spin, orient=orient\n    ) :\n    let(\n        caps = is_bool(caps) ? [caps,caps] : caps, \n        anchor = center==true? \"origin\" :\n            center == false? \"original_base\" :\n            default(anchor, \"original_base\"),\n        regions = region_parts(region),\n        slices = default(slices, max(1,ceil(abs(twist)/5))),\n        scale = is_num(scale)? [scale,scale] : point2d(scale),\n        topmat = move(shift) * scale(scale) * rot(-twist),\n        trgns = [\n            for (rgn = regions) [\n                for (path = rgn) let(\n                    p = list_unwrap(path),\n                    path = is_undef(maxseg)? p : [\n                        for (seg = pair(p,true)) each\n                        let( steps = ceil(norm(seg.y - seg.x) / maxseg) )\n                        lerpn(seg.x, seg.y, steps, false)\n                    ]\n                ) apply(topmat, path)\n            ]\n        ],\n        vnf = vnf_join([\n            for (rgn = regions)\n            for (pathnum = idx(rgn)) let(\n                p = list_unwrap(rgn[pathnum]),\n                path = is_undef(maxseg)? p : [\n                    for (seg=pair(p,true)) each\n                    let(steps=ceil(norm(seg.y-seg.x)/maxseg))\n                    lerpn(seg.x, seg.y, steps, false)\n                ],\n                verts = [\n                    for (i=[0:1:slices]) let(\n                        u = i / slices,\n                        scl = lerp([1,1], scale, u),\n                        ang = lerp(0, -twist, u),\n                        off = lerp([0,0,-h/2], point3d(shift,h/2), u),\n                        m = move(off) * scale(scl) * rot(ang)\n                    ) apply(m, path3d(path))\n                ]\n            ) vnf_vertex_array(verts, caps=false, col_wrap=true, style=style),\n            if (caps[0]) for (rgn = regions) vnf_from_region(rgn, down(h/2), reverse=true),\n            if (caps[1]) for (rgn = trgns) vnf_from_region(rgn, up(h/2), reverse=false)\n        ]),\n        anchors = [\n            named_anchor(\"original_base\", [0,0,-h/2], UP)\n        ],\n        cp = default(cp, \"centroid\"),\n        geom = atype==\"hull\"?  attach_geom(cp=cp, region=region, h=h, extent=true, shift=shift, scale=scale, twist=twist, anchors=anchors) :\n            atype==\"intersect\"?  attach_geom(cp=cp, region=region, h=h, extent=false, shift=shift, scale=scale, twist=twist, anchors=anchors) :\n            atype==\"bbox\"?\n                let(\n                    bounds = pointlist_bounds(flatten(region)),\n                    size = bounds[1] - bounds[0],\n                    midpt = (bounds[0] + bounds[1])/2\n                )\n                attach_geom(cp=[0,0,0], size=point3d(size,h), offset=point3d(midpt), shift=shift, scale=scale, twist=twist, anchors=anchors) :\n            assert(in_list(atype, [\"hull\",\"intersect\",\"bbox\"]), \"Anchor type must be \\\"hull\\\", \\\"intersect\\\", or \\\"bbox\\\".\")\n    ) reorient(anchor,spin,orient, geom=geom, p=vnf);\n\n\n// Function&Module: rotate_sweep()\n// Synopsis: Create a surface of revolution from a path with optional texturing. \n// SynTags: VNF, Geom\n// Topics: Extrusion, Sweep, Revolution, Textures\n// See Also: linear_sweep(), sweep(), spiral_sweep(), path_sweep(), offset_sweep()\n// Usage: As Function\n//   vnf = rotate_sweep(shape, [angle], ...);\n// Usage: As Module\n//   rotate_sweep(shape, [angle], ...) [ATTACHMENTS];\n// Usage: With Texturing\n//   rotate_sweep(shape, texture=, [tex_size=]|[tex_reps=], [tex_depth=], [tex_samples=], [tex_rot=], [tex_inset=], ...) [ATTACHMENTS];\n// Description:\n//   Takes a polygon or [region](regions.scad) and sweeps it in a rotation around the Z axis, with optional texturing.\n//   When called as a function, returns a [VNF](vnf.scad).\n//   When called as a module, creates the sweep as geometry.\n// Arguments:\n//   shape = The polygon or [region](regions.scad) to sweep around the Z axis.\n//   angle = If given, specifies the number of degrees to sweep the shape around the Z axis, counterclockwise from the X+ axis.  Default: 360 (full rotation)\n//   ---\n//   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0), or a VNF tile that defines the texture to apply to vertical surfaces.  See {{texture()}} for what named textures are supported.\n//   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`\n//   tex_reps = If given instead of tex_size, a 2-vector giving the number of texture tile repetitions in the direction perpendicular to extrusion and in the direction parallel to extrusion.  \n//   tex_inset = If numeric, lowers the texture into the surface by the specified proportion, e.g. 0.5 would lower it half way into the surface.  If `true`, insets by exactly its full depth.  Default: `false`\n//   tex_rot = Rotate texture by specified angle, which must be a multiple of 90 degrees.  Default: 0\n//   tex_depth = Specify texture depth; if negative, invert the texture.  Default: 1.\n//   tex_samples = Minimum number of \"bend points\" to have in VNF texture tiles.  Default: 8\n//   style = {{vnf_vertex_array()}} style.  Default: \"min_edge\"\n//   closed = If false, and shape is given as a path, then the revolved path will be sealed to the axis of rotation with untextured caps.  Default: `true`\n//   convexity = (Module only) Convexity setting for use with polyhedron.  Default: 10\n//   cp = Centerpoint for determining \"intersect\" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 3D point.  Default: \"centroid\"\n//   atype = Select \"hull\" or \"intersect\" anchor types.  Default: \"hull\"\n//   anchor = Translate so anchor point is at the origin. Default: \"origin\"\n//   spin = Rotate this many degrees around Z axis after anchor. Default: 0\n//   orient = Vector to rotate top towards after spin  (module only)\n// Anchor Types:\n//   \"hull\" = Anchors to the virtual convex hull of the shape.\n//   \"intersect\" = Anchors to the surface of the shape.\n// Example:\n//   rgn = [\n//       for (a = [0, 120, 240]) let(\n//           cp = polar_to_xy(15, a) + [30,0]\n//       ) each [\n//           move(cp, p=circle(r=10)),\n//           move(cp, p=hexagon(d=15)),\n//       ]\n//   ];\n//   rotate_sweep(rgn, angle=240);\n// Example:\n//   rgn = right(30, p=union([for (a = [0, 90]) rot(a, p=rect([15,5]))]));\n//   rotate_sweep(rgn);\n// Example:\n//   path = right(50, p=circle(d=40));\n//   rotate_sweep(path, texture=\"bricks_vnf\", tex_size=[10,10], tex_depth=0.5, style=\"concave\");\n// Example:\n//   tex = [\n//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n//       [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n//       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],\n//       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],\n//       [0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1],\n//       [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1],\n//       [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1],\n//       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1],\n//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n//       [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n//       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n//   ];\n//   path = arc(cp=[0,0], r=40, start=60, angle=-120);\n//   rotate_sweep(\n//       path, closed=false,\n//       texture=tex, tex_size=[20,20],\n//       tex_depth=1, style=\"concave\");\n// Example:\n//   include <BOSL2/beziers.scad>\n//   bezpath = [\n//       [15, 30], [10,15],\n//       [10,  0], [20, 10], [30,12],\n//       [30,-12], [20,-10], [10, 0],\n//       [10,-15], [15,-30]\n//   ];\n//   path = bezpath_curve(bezpath, splinesteps=32);\n//   rotate_sweep(\n//       path, closed=false,\n//       texture=\"diamonds\", tex_size=[10,10],\n//       tex_depth=1, style=\"concave\");\n// Example:\n//   path = [\n//       [20, 30], [20, 20],\n//       each arc(r=20, corner=[[20,20],[10,0],[20,-20]]),\n//       [20,-20], [20,-30],\n//   ];\n//   vnf = rotate_sweep(\n//       path, closed=false,\n//       texture=\"trunc_pyramids\",\n//       tex_size=[5,5], tex_depth=1,\n//       style=\"convex\");\n//   vnf_polyhedron(vnf, convexity=10);\n// Example:\n//   rgn = [\n//       right(40, p=circle(d=50)),\n//       right(40, p=circle(d=40,$fn=6)),\n//   ];\n//   rotate_sweep(\n//       rgn, texture=\"diamonds\",\n//       tex_size=[10,10], tex_depth=1,\n//       angle=240, style=\"concave\");\n\nfunction rotate_sweep(\n    shape, angle=360,\n    texture, tex_size=[5,5], tex_counts, tex_reps, \n    tex_inset=false, tex_rot=0,\n    tex_scale, tex_depth, tex_samples,\n    tex_taper, shift=[0,0], closed=true,\n    style=\"min_edge\", cp=\"centroid\",\n    atype=\"hull\", anchor=\"origin\",\n    spin=0, orient=UP\n) =\n    assert(num_defined([tex_reps,tex_counts])<2, \"In rotate_sweep() the 'tex_counts' parameters has been replaced by 'tex_reps'.  You cannot give both.\")\n    assert(num_defined([tex_scale,tex_depth])<2, \"In linear_sweep() the 'tex_scale' parameter has been replaced by 'tex_depth'.  You cannot give both.\")\n    let( region = force_region(shape),\n         tex_reps = is_def(tex_counts)? echo(\"In rotate_sweep() the 'tex_counts' parameter is deprecated and has been replaced by 'tex_reps'\")tex_counts\n                  : tex_reps,\n        tex_depth = is_def(tex_scale)? echo(\"In rotate_sweep() the 'tex_scale' parameter is deprecated and has been replaced by 'tex_depth'\")tex_scale\n                  : default(tex_depth,1)\n    )\n    assert(is_region(region), \"Input is not a region or polygon.\")\n    let(\n        bounds = pointlist_bounds(flatten(region)),\n        min_x = bounds[0].x,\n        max_x = bounds[1].x,\n        min_y = bounds[0].y,\n        max_y = bounds[1].y,\n        h = max_y - min_y\n    )\n    assert(min_x>=0, \"Input region must exist entirely in the X+ half-plane.\")\n    !is_undef(texture)? _textured_revolution(\n        shape,\n        texture=texture,\n        tex_size=tex_size,\n        counts=tex_reps,\n        tex_scale=tex_depth,\n        inset=tex_inset,\n        rot=tex_rot,\n        samples=tex_samples,\n        taper=tex_taper,\n        shift=shift,\n        closed=closed,\n        angle=angle,\n        style=style\n    ) :\n    let(\n        steps = ceil(segs(max_x) * angle / 360) + (angle<360? 1 : 0),\n        skmat = down(min_y) * skew(sxz=shift.x/h, syz=shift.y/h) * up(min_y),\n        transforms = [\n            if (angle==360) for (i=[0:1:steps-1]) skmat * rot([90,0,360-i*360/steps]),\n            if (angle<360) for (i=[0:1:steps-1]) skmat * rot([90,0,angle-i*angle/(steps-1)]),\n        ],\n        vnf = sweep(\n            region, transforms,\n            closed=angle==360,\n            caps=angle!=360,\n            style=style, cp=cp,\n            atype=atype, anchor=anchor,\n            spin=spin, orient=orient\n        )\n    ) vnf;\n\n\nmodule rotate_sweep(\n    shape, angle=360,\n    texture, tex_size=[5,5], tex_counts, tex_reps,\n    tex_inset=false, tex_rot=0,\n    tex_scale, tex_depth, tex_samples,\n    tex_taper, shift=[0,0],\n    style=\"min_edge\",\n    closed=true,\n    cp=\"centroid\",\n    convexity=10,\n    atype=\"hull\",\n    anchor=\"origin\",\n    spin=0,\n    orient=UP\n) {\n    dummy =\n       assert(num_defined([tex_reps,tex_counts])<2, \"In rotate_sweep() the 'tex_counts' parameters has been replaced by 'tex_reps'.  You cannot give both.\")\n       assert(num_defined([tex_scale,tex_depth])<2, \"In rotate_sweep() the 'tex_scale' parameter has been replaced by 'tex_depth'.  You cannot give both.\");\n    tex_reps = is_def(tex_counts)? echo(\"In rotate_sweep() the 'tex_counts' parameter is deprecated and has been replaced by 'tex_reps'\")tex_counts\n             : tex_reps;\n    tex_depth = is_def(tex_scale)? echo(\"In rotate_sweep() the 'tex_scale' parameter is deprecated and has been replaced by 'tex_depth'\")tex_scale\n              : default(tex_depth,1);\n    region = force_region(shape);\n    check = assert(is_region(region), \"Input is not a region or polygon.\");\n    bounds = pointlist_bounds(flatten(region));\n    min_x = bounds[0].x;\n    max_x = bounds[1].x;\n    min_y = bounds[0].y;\n    max_y = bounds[1].y;\n    h = max_y - min_y;\n    check2 = assert(min_x>=0, \"Input region must exist entirely in the X+ half-plane.\");\n    if (!is_undef(texture)) {\n        _textured_revolution(\n            shape,\n            texture=texture,\n            tex_size=tex_size,\n            counts=tex_reps,\n            tex_scale=tex_depth,\n            inset=tex_inset,\n            rot=tex_rot,\n            samples=tex_samples,\n            taper=tex_taper,\n            shift=shift,\n            closed=closed,\n            angle=angle,\n            style=style,\n            atype=atype, anchor=anchor,\n            spin=spin, orient=orient\n        ) children();\n    } else {\n        steps = ceil(segs(max_x) * angle / 360) + (angle<360? 1 : 0);\n        skmat = down(min_y) * skew(sxz=shift.x/h, syz=shift.y/h) * up(min_y);\n        transforms = [\n            if (angle==360) for (i=[0:1:steps-1]) skmat * rot([90,0,360-i*360/steps]),\n            if (angle<360) for (i=[0:1:steps-1]) skmat * rot([90,0,angle-i*angle/(steps-1)]),\n        ];\n        sweep(\n            region, transforms,\n            closed=angle==360,\n            caps=angle!=360,\n            style=style, cp=cp,\n            convexity=convexity,\n            atype=atype, anchor=anchor,\n            spin=spin, orient=orient\n        ) children();\n    }\n}\n\n\n// Function&Module: spiral_sweep()\n// Synopsis: Sweep a path along a helix.\n// SynTags: VNF, Geom\n// Topics: Extrusion, Sweep, Spiral\n// See Also: thread_helix(), linear_sweep(), rotate_sweep(), sweep(), path_sweep(), offset_sweep()\n// Usage: As Module\n//   spiral_sweep(poly, h, r|d=, turns, [taper=], [center=], [taper1=], [taper2=], [internal=], ...)[ATTACHMENTS];\n//   spiral_sweep(poly, h, r1=|d1=, r2=|d2=, turns, [taper=], [center=], [taper1=], [taper2=], [internal=], ...)[ATTACHMENTS];\n// Usage: As Function\n//   vnf = spiral_sweep(poly, h, r|d=, turns, ...);\n//   vnf = spiral_sweep(poly, h, r1=|d1=, r1=|d2=, turns, ...);\n// Description:\n//   Takes a closed 2D polygon path, centered on the XY plane, and sweeps/extrudes it along a 3D spiral path\n//   of a given radius, height and degrees of rotation.  The origin in the profile traces out the helix of the specified radius.\n//   If turns is positive the path will be right-handed;  if turns is negative the path will be left-handed.\n//   Such an extrusion can be used to make screw threads.  \n//   .\n//   The lead_in options specify a lead-in section where the ends of the spiral scale down to avoid a sharp cut face at the ends.\n//   You can specify the length of this scaling directly with the lead_in parameters or as an angle using the lead_in_ang parameters.\n//   If you give a positive value, the extrusion is lengthenend by the specified distance or angle; if you give a negative\n//   value then the scaled end is included in the extrusion length specified by `turns`.  If the value is zero then no scaled ends\n//   are produced.  The shape of the scaled ends can be controlled with the lead_in_shape parameter.  Supported options are \"sqrt\", \"linear\"\n//   \"smooth\" and \"cut\".  \n//   .\n//   The inside argument changes how the extrusion lead-in sections are formed.  If it is true then they scale\n//   towards the outside, like would be needed for internal threading.  If internal is fale then the lead-in sections scale\n//   towards the inside, like would be appropriate for external threads.  \n// Arguments:\n//   poly = Array of points of a polygon path, to be extruded.\n//   h = height of the spiral extrusion path\n//   r = Radius of the spiral extrusion path\n//   turns = number of revolutions to include in the spiral\n//   ---\n//   d = Diameter of the spiral extrusion path.\n//   d1/r1 = Bottom inside diameter or radius of spiral to extrude along.\n//   d2/r2 = Top inside diameter or radius of spiral to extrude along.\n//   lead_in = Specify linear length of the lead-in scaled section of the spiral.  Default: 0\n//   lead_in1 = Specify linear length of the lead-in scaled section of the spiral at the bottom\n//   lead_in2 = Specify linear length of the lead-in scaled section of the spiral at the top\n//   lead_in_ang = Specify angular  length of the lead-in scaled section of the spiral\n//   lead_in_ang1 = Specify angular length of the lead-in scaled section of the spiral at the bottom\n//   lead_in_ang2 = Specify angular length of the lead-in scaled section of the spiral at the top\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"sqrt\"\n//   lead_in_shape1 = Specify the shape of the thread lead-in at the bottom by giving a text string or function.  \n//   lead_in_shape2 = Specify the shape of the thread lead-in at the top by giving a text string or function.\n//   lead_in_sample = Factor to increase sample rate in the lead-in section.  Default: 10\n//   internal = if true make internal threads.  The only effect this has is to change how the extrusion lead-in section are formed. When true, the extrusion scales towards the outside; when false, it scales towards the inside.  Default: false\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   poly = [[-10,0], [-3,-5], [3,-5], [10,0], [0,-30]];\n//   spiral_sweep(poly, h=200, r=50, turns=3, $fn=36);\n_leadin_ogive=function (x,L) \n     let( minscale = .05,\n          r=(L^2+(1-minscale^2))/2/(1-minscale),\n          scale = sqrt(r^2-(L*(1-x))^2) -(r-1)\n     )\n     x>1 ? [1,1]\n   : x<0 ? [lerp(minscale,1,.25),0] \n   : [lerp(scale,1,.25),scale];     \n\n_leadin_cut = function(x,L) x>0 ? [1,1] : [1,0];\n\n_leadin_sqrt = function(x,L)\n     let(end=0.05)   // Smallest scale at the end\n     x>1 ? [1,1]\n   : x<0 ? [lerp(end,1,.25),0]   \n   : let(  \n          s = sqrt(x + end^2 * (1-x))\n     )\n     [lerp(s,1,.25),s];    // thread width scale, thread height scale\n\n_leadin_linear = function(x,L)\n     let(minscale=.1)\n     x>1 ? [1,1]\n   : x<0 ? [lerp(minscale,1,.25),0]\n   : let(scale = lerp(minscale,1,x))\n     [lerp(scale,1,.25),scale];\n\n_lead_in_table = [\n     [\"default\", _leadin_sqrt],\n     [\"sqrt\", _leadin_sqrt],\n     [\"cut\", _leadin_cut],\n     [\"smooth\", _leadin_ogive],\n     [\"linear\", _leadin_linear]\n];\n\n      \nfunction _ss_polygon_r(N,theta) =\n        let( alpha = 360/N )\n        cos(alpha/2)/(cos(posmod(theta,alpha)-alpha/2));\nfunction spiral_sweep(poly, h, r, turns=1, taper, r1, r2, d, d1, d2, internal=false,\n                      lead_in_shape,lead_in_shape1, lead_in_shape2,\n                      lead_in, lead_in1, lead_in2,\n                      lead_in_ang, lead_in_ang1, lead_in_ang2,\n                      height,l,length,\n                      lead_in_sample = 10,\n                      anchor=CENTER, spin=0, orient=UP) =\n    assert(is_num(turns) && turns != 0, \"turns must be a nonzero number\")\n    assert(all_positive([h]), \"Spiral height must be a positive number\")\n    let(\n        dir = sign(turns),\n        r1 = get_radius(r1=r1, r=r, d1=d1, d=d),\n        r2 = get_radius(r1=r2, r=r, d1=d2, d=d),\n        bounds = pointlist_bounds(poly),\n        yctr = (bounds[0].y+bounds[1].y)/2,\n        xmin = bounds[0].x,\n        xmax = bounds[1].x,\n        poly = path3d(clockwise_polygon(poly)),\n        sides = segs(max(r1,r2)),\n        ang_step = 360/sides,\n        turns = abs(turns),\n        lead_in1 = first_defined([lead_in1, lead_in]),\n        lead_in2 = first_defined([lead_in1, lead_in]),        \n        lead_in_ang1 =\n                      let(\n                           user_ang = first_defined([lead_in_ang1,lead_in_ang])\n                      )\n                      assert(is_undef(user_ang) || is_undef(lead_in1), \"Cannot define lead_in/lead_in1 by both length and angle\")\n                      is_def(user_ang) ? user_ang : default(lead_in1,0)*360/(2*PI*r1),\n        lead_in_ang2 =\n                      let(\n                           user_ang = first_defined([lead_in_ang2,lead_in_ang])\n                      )\n                      assert(is_undef(user_ang) || is_undef(lead_in2), \"Cannot define lead_in/lead_in2 by both length and angle\")\n                      is_def(user_ang) ? user_ang : default(lead_in2,0)*360/(2*PI*r2),\n        minang = -max(0,lead_in_ang1),\n        maxang = 360*turns + max(0,lead_in_ang2),\n        cut_ang1 = minang+abs(lead_in_ang1),\n        cut_ang2 = maxang-abs(lead_in_ang1),        \n        lead_in_shape1 = first_defined([lead_in_shape1, lead_in_shape, \"default\"]),\n        lead_in_shape2 = first_defined([lead_in_shape2, lead_in_shape, \"default\"]),             \n        lead_in_func1 = is_func(lead_in_shape1) ? lead_in_shape1\n                      : assert(is_string(lead_in_shape1),\"lead_in_shape/lead_in_shape1 must be a function or string\")\n                        let(ind = search([lead_in_shape1], _lead_in_table,0)[0])\n                        assert(ind!=[],str(\"Unknown lead_in_shape, \\\"\",lead_in_shape1,\"\\\"\"))\n                        _lead_in_table[ind[0]][1],\n        lead_in_func2 = is_func(lead_in_shape2) ? lead_in_shape2\n                      : assert(is_string(lead_in_shape2),\"lead_in_shape/lead_in_shape2 must be a function or string\")\n                        let(ind = search([lead_in_shape2], _lead_in_table,0)[0])\n                        assert(ind!=[],str(\"Unknown lead_in_shape, \\\"\",lead_in_shape2,\"\\\"\"))\n                        _lead_in_table[ind[0]][1]\n    )\n    assert( cut_ang1<cut_ang2, \"Tapers are too long to fit\")\n    assert( all_positive([r1,r2]), \"Diameter/radius must be positive\")\n    let(\n  \n        // This complicated sampling scheme is designed to ensure that faceting always starts at angle zero\n        // for alignment with cylinders, and there is always a facet boundary at the $fn specified locations, \n        // regardless of what kind of subsampling occurs for tapers.\n        orig_anglist = [\n            if (minang<0) minang,\n            each reverse([for(ang = [-ang_step:-ang_step:minang+EPSILON]) ang]),\n            for(ang = [0:ang_step:maxang-EPSILON]) ang,\n            maxang\n        ],\n        anglist = [\n           for(a=orig_anglist) if (a<cut_ang1-EPSILON) a,\n           cut_ang1,\n           for(a=orig_anglist) if (a>cut_ang1+EPSILON && a<cut_ang2-EPSILON) a,\n           cut_ang2,\n           for(a=orig_anglist) if (a>cut_ang2+EPSILON) a\n        ],\n        interp_ang = [\n                      for(i=idx(anglist,e=-2)) \n                          each lerpn(anglist[i],anglist[i+1],\n                                         (lead_in_ang1!=0 && anglist[i+1]<=cut_ang1) || (lead_in_ang2!=0 && anglist[i]>=cut_ang2)\n                                            ? ceil((anglist[i+1]-anglist[i])/ang_step*lead_in_sample)\n                                            : 1,\n                                     endpoint=false),\n                      last(anglist)\n                     ],\n        skewmat = affine3d_skew_xz(xa=atan2(r2-r1,h)),\n        points = [\n            for (a = interp_ang) let (\n                hsc = a<cut_ang1 ? lead_in_func1((a-minang)/abs(lead_in_ang1),abs(lead_in_ang1)*2*PI*r1/360)\n                    : a>cut_ang2 ? lead_in_func2((maxang-a)/abs(lead_in_ang2),abs(lead_in_ang2)*2*PI*r2/360)\n                    : [1,1],\n                u = a/(360*turns), \n                r = lerp(r1,r2,u),\n                mat = affine3d_zrot(dir*a)\n                    * affine3d_translate([_ss_polygon_r(sides,dir*a)*r, 0, h * (u-0.5)])\n                    * affine3d_xrot(90)\n                    * skewmat\n                    * scale([hsc.y,hsc.x,1], cp=[internal ? xmax : xmin, yctr, 0]),\n                pts = apply(mat, poly)\n            ) pts\n        ],\n        vnf = vnf_vertex_array(\n            points, col_wrap=true, caps=true, reverse=dir>0,\n        //    style=higbee1>0 || higbee2>0 ? \"quincunx\" : \"alt\"\n            style=\"convex\"\n        ),\n        vnf2 = vnf_triangulate(vnf)\n    )\n    reorient(anchor,spin,orient, vnf=vnf2, r1=r1, r2=r2, l=h, p=vnf2);\n\n\n\nmodule spiral_sweep(poly, h, r, turns=1, taper, r1, r2, d, d1, d2, internal=false,\n                    lead_in_shape,lead_in_shape1, lead_in_shape2,\n                    lead_in, lead_in1, lead_in2,\n                    lead_in_ang, lead_in_ang1, lead_in_ang2,\n                    height,l,length,\n                    lead_in_sample=10,\n                    anchor=CENTER, spin=0, orient=UP)\n{\n    vnf = spiral_sweep(poly=poly, h=h, r=r, turns=turns, r1=r1, r2=r2, d=d, d1=d1, d2=d2, internal=internal,\n                       lead_in_shape=lead_in_shape,lead_in_shape1=lead_in_shape1, lead_in_shape2=lead_in_shape2,\n                       lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2,\n                       lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n                       height=height,l=length,length=length,\n                       lead_in_sample=lead_in_sample);\n    h = one_defined([h,height,length,l],\"h,height,length,l\");\n    r1 = get_radius(r1=r1, r=r, d1=d1, d=d);\n    r2 = get_radius(r1=r2, r=r, d1=d2, d=d);\n    lead_in1 = u_mul(first_defined([lead_in1,lead_in]),1/(2*PI*r1));\n    lead_in2 = u_mul(first_defined([lead_in2,lead_in]),1/(2*PI*r2));\n    lead_in_ang1 = first_defined([lead_in_ang1,lead_in_ang]);\n    lead_in_ang2 = first_defined([lead_in_ang2,lead_in_ang]);\n    extra_turns = max(0,first_defined([lead_in1,lead_in_ang1,0]))+max(0,first_defined([lead_in2,lead_in_ang2,0]));\n    attachable(anchor,spin,orient, r1=r1, r2=r2, l=h) {\n        vnf_polyhedron(vnf, convexity=ceil(2*(abs(turns)+extra_turns)));\n        children();\n    }\n}\n\n\n\n// Function&Module: path_sweep()\n// Synopsis: Sweep a 2d polygon path along a 2d or 3d path. \n// SynTags: VNF, Geom\n// Topics: Extrusion, Sweep, Paths\n// See Also: linear_sweep(), rotate_sweep(), sweep(), spiral_sweep(), path_sweep2d(), offset_sweep()\n// Usage: As module\n//   path_sweep(shape, path, [method], [normal=], [closed=], [twist=], [twist_by_length=], [symmetry=], [scale=], [scale_by_length=], [last_normal=], [tangent=], [uniform=], [relaxed=], [caps=], [style=], [convexity=], [anchor=], [cp=], [spin=], [orient=], [atype=]) [ATTACHMENTS];\n// Usage: As function\n//   vnf = path_sweep(shape, path, [method], [normal=], [closed=], [twist=], [twist_by_length=], [symmetry=], [scale=], [scale_by_length=], [last_normal=], [tangent=], [uniform=], [relaxed=], [caps=], [style=], [transforms=], [anchor=], [cp=], [spin=], [orient=], [atype=]);\n// Description:\n//   Takes as input `shape`, a 2D polygon path (list of points), and `path`, a 2d or 3d path (also a list of points)\n//   and constructs a polyhedron by sweeping the shape along the path. When run as a module returns the polyhedron geometry.\n//   When run as a function returns a VNF by default or if you set `transforms=true` then it returns a list of transformations suitable as input to `sweep`.\n//   .\n//   The sweeping process places one copy of the shape for each point in the path.  The origin in `shape` is translated to\n//   the point in `path`.  The normal vector of the shape, which points in the Z direction, is aligned with the tangent\n//   vector for the path, so this process is constructing a shape whose normal cross sections are equal to your specified shape.\n//   If you do not supply a list of tangent vectors then an approximate tangent vector is computed\n//   based on the path points you supply using {{path_tangents()}}.\n// Figure(3D,Big,VPR=[70,0,345],VPD=20,VPT=[5.5,10.8,-2.7],NoScales): This example shows how the shape, in this case the quadrilateral defined by `[[0, 0], [0, 1], [0.25, 1], [1, 0]]`, appears as the cross section of the swept polyhedron.  The blue line shows the path.  The normal vector to the shape is shown in black; it is based at the origin and points upwards in the Z direction.  The sweep aligns this normal vector with the blue path tangent, which in this case, flips the shape around.  Note that for a 2D path like this one, the Y direction in the shape is mapped to the Z direction in the sweep.\n//   tri= [[0, 0], [0, 1], [.25,1], [1, 0]];\n//   path = arc(r=5,n=81,angle=[-20,65]);\n//   % path_sweep(tri,path);\n//   T = path_sweep(tri,path,transforms=true);\n//   color(\"red\")for(i=[0:20:80]) stroke(apply(T[i],path3d(tri)),width=.1,closed=true);\n//   color(\"blue\")stroke(path3d(arc(r=5,n=101,angle=[-20,80])),width=.1,endcap2=\"arrow2\");\n//   color(\"red\")stroke([path3d(tri)],width=.1);\n//   stroke([CENTER,UP], width=.07,endcap2=\"arrow2\",color=\"black\");\n// Continues:\n//   In the figure you can see that the swept polyhedron, shown in transparent gray, has the quadrilateral as its cross\n//   section.  The quadrilateral is positioned perpendicular to the path, which is shown in blue, so that the normal\n//   vector for the quadrilateral is parallel to the tangent vector for the path.  The origin for the shape is the point\n//   which follows the path.  For a 2D path, the Y axis of the shape is mapped to the Z axis and in this case,\n//   pointing the quadrilateral's normal vector (in black) along the tangent line of\n//   the path, which is going in the direction of the blue arrow, requires that the quadrilateral be \"turned around\".  If we\n//   reverse the order of points in the path we get a different result:\n// Figure(3D,Big,VPR=[70,0,20],VPD=20,VPT=[1.25,9.25,-2.65],NoScales): The same sweep operation with the path traveling in the opposite direction.  Note that in order to line up the normal correctly, the shape is reversed compared to Figure 1, so the resulting sweep looks quite different.\n//   tri= [[0, 0], [0, 1], [.25,1], [1, 0]];\n//   path = reverse(arc(r=5,n=81,angle=[-20,65]));\n//   % path_sweep(tri,path);\n//   T = path_sweep(tri,path,transforms=true);\n//   color(\"red\")for(i=[0:20:80]) stroke(apply(T[i],path3d(tri)),width=.1,closed=true);\n//   color(\"blue\")stroke(reverse(path3d(arc(r=5,n=101,angle=[-20-15,65]))),width=.1,endcap2=\"arrow2\");\n//   color(\"red\")stroke([path3d(tri)],width=.1);\n//   stroke([CENTER,UP], width=.07,endcap2=\"arrow2\",color=\"black\");\n// Continues:\n//   If your shape is too large for the curves in the path you can create a situation where the shapes cross each\n//   other.  This results in an invalid polyhedron, which may appear OK when previewed or rendered alone, but will give rise\n//   to cryptic CGAL errors when rendered with a second object in your model.  You may be able to use {{path_sweep2d()}}\n//   to produce a valid model in cases like this.  You can debug models like this using the `profiles=true` option which will show all\n//   the cross sections in your polyhedron.  If any of them intersect, the polyhedron will be invalid.\n// Figure(3D,Big,VPR=[47,0,325],VPD=23,VPT=[6.8,4,-3.8],NoScales): We have scaled the path to an ellipse and show a large triangle as the shape.  The triangle is sometimes bigger than the local radius of the path, leading to an invalid polyhedron, which you can identify because the red lines cross in the middle.\n//   tri= scale([4.5,2.5],[[0, 0], [0, 1], [1, 0]]);\n//   path = xscale(1.5,arc(r=5,n=81,angle=[-70,70]));\n//   % path_sweep(tri,path);\n//   T = path_sweep(tri,path,transforms=true);\n//   color(\"red\")for(i=[0:20:80]) stroke(apply(T[i],path3d(tri)),width=.1,closed=true);\n//   color(\"blue\")stroke(path3d(xscale(1.5,arc(r=5,n=81,angle=[-70,80]))),width=.1,endcap2=\"arrow2\");\n// Continues:\n//   During the sweep operation the shape's normal vector aligns with the tangent vector of the path.  Note that\n//   this leaves an ambiguity about how the shape is rotated as it sweeps along the path.\n//   For 2D paths, this ambiguity is resolved by aligning the Y axis of the shape to the Z axis of the swept polyhedron.\n//   You can force the  shape to twist as it sweeps along the path using the `twist` parameter, which specifies the total\n//   number of degrees to twist along the whole swept polyhedron.  This produces a result like the one shown below.\n// Figure(3D,Big,VPR=[66,0,14],VPD=20,VPT=[3.4,4.5,-0.8]): The shape twists as we sweep.  Note that it still aligns the origin in the shape with the path, and still aligns the normal vector with the path tangent vector.\n//   tri= [[0, 0], [0, 1], [.25,1],[1, 0]];\n//   path = arc(r=5,n=81,angle=[-20,65]);\n//   % path_sweep(tri,path,twist=-60);\n//   T = path_sweep(tri,path,transforms=true,twist=-60);\n//   color(\"red\")for(i=[0:20:80]) stroke(apply(T[i],path3d(tri)),width=.1,closed=true);\n//   color(\"blue\")stroke(path3d(arc(r=5,n=101,angle=[-20,80])),width=.1,endcap2=\"arrow2\");\n// Continues:\n//   The `twist` argument adds the specified number of degrees of twist into the model, and it may be positive or\n//   negative.  When `closed=true` the starting shape and ending shape must match to avoid a sudden extreme twist at the\n//   joint.  By default `twist` is therefore required to be a multiple of 360.  However, if your shape has rotational\n//   symmetry, this requirement is overly strict.  You can specify the symmetry using the `symmetry` argument, and then\n//   you can choose smaller twists consistent with the specified symmetry.  The symmetry argument gives the number of\n//   rotations that map the shape exactly onto itself, so a pentagon has 5-fold symmetry.  This argument is only valid\n//   for closed sweeps.  When you specify symmetry, the twist must be a multiple of 360/symmetry.\n//   .\n//   The twist is normally spread uniformly along your shape based on the path length.  If you set `twist_by_length` to\n//   false then the twist will be uniform based on the point count of your path.  Twisted shapes will produce twisted\n//   faces, so if you want them to look good you should use lots of points on your path and also lots of points on the\n//   shape.  If your shape is a simple polygon, use {{subdivide_path()}} to increase\n//   the number of points.\n//   .\n//   As noted above, the sweep process has an ambiguity regarding the twist.  For 2D paths it is easy to resolve this\n//   ambiguity by aligning the Y axis in the shape to the Z axis in the swept polyhedron.  When the path is\n//   three-dimensional, things become more complex.  It is no longer possible to use a simple alignment rule like the\n//   one we use in 2D.  You may find that the shape rotates unexpectedly around its axis as it traverses the path.  The\n//   `method` parameter allows you to specify how the shapes are aligned, resulting in different twist in the resulting\n//   polyhedron.  You can choose from three different methods for selecting the rotation of your shape.  None of these\n//   methods will produce good, or even valid, results on all inputs, so it is important to select a suitable method.\n//   .\n//   The three methods you can choose using the `method` parameter are:\n//   .\n//   The \"incremental\" method (the default) works by adjusting the shape at each step by the minimal rotation that makes the shape normal to the tangent\n//   at the next point.  This method is robust in that it always produces a valid result for well-behaved paths with sufficiently high\n//   sampling.  Unfortunately, it can produce a large amount of undesirable twist.  When constructing a closed shape this algorithm in\n//   its basic form provides no guarantee that the start and end shapes match up.  To prevent a sudden twist at the last segment,\n//   the method calculates the required twist for a good match and distributes it over the whole model (as if you had specified a\n//   twist amount).  If you specify `symmetry` this may allow the algorithm to choose a smaller twist for this alignment.\n//   To start the algorithm, we need an initial condition.  This is supplied by\n//   using the `normal` argument to give a direction to align the Y axis of your shape.  By default the normal points UP if the path\n//   makes an angle of 45 deg or less with the xy plane and it points BACK if the path makes a higher angle with the XY plane.  You\n//   can also supply `last_normal` which provides an ending orientation constraint.  Be aware that the curve may still exhibit\n//   twisting in the middle.  This method is the default because it is the most robust, not because it generally produces the best result.\n//   .\n//   The \"natural\" method works by computing the Frenet frame at each point on the path.  This is defined by the tangent to the curve and\n//   the normal which lies in the plane defined by the curve at each point.  This normal points in the direction of curvature of the curve.\n//   The result is a very well behaved set of shape positions without any unexpected twisting&mdash;as long as the curvature never falls to zero.  At a\n//   point of zero curvature (a flat point), the curve does not define a plane and the natural normal is not defined.  Furthermore, even if\n//   you skip over this troublesome point so the normal is defined, it can change direction abruptly when the curvature is zero, leading to\n//   a nasty twist and an invalid model.  A simple example is a circular arc joined to another arc that curves the other direction.  Note\n//   that the X axis of the shape is aligned with the normal from the Frenet frame.\n//   .\n//   The \"manual\" method allows you to specify your desired normal either globally with a single vector, or locally with\n//   a list of normal vectors for every path point.  The normal you supply is projected to be orthogonal to the tangent to the\n//   path and the Y direction of your shape will be aligned with the projected normal.  (Note this is different from the \"natural\" method.)\n//   Careless choice of a normal may result in a twist in the shape, or an error if your normal is parallel to the path tangent.\n//   If you set `relax=true` then the condition that the cross sections are orthogonal to the path is relaxed and the swept object\n//   uses the actual specified normal.  In this case, the tangent is projected to be orthogonal to your supplied normal to define\n//   the cross section orientation.  Specifying a list of normal vectors gives you complete control over the orientation of your\n//   cross sections and can be useful if you want to position your model to be on the surface of some solid.\n//   .\n//   You can also apply scaling to the profile along the path.  You can give a list of scalar scale factors or a list of 2-vector scale. \n//   In the latter scale the x and y scales of the profile are scaled separately before the profile is placed onto the path.  For non-closed\n//   paths you can also give a single scale value or a 2-vector which is treated as the final scale.  The intermediate sections\n//   are then scaled by linear interpolation either relative to length (if scale_by_length is true) or by point count otherwise.  \n//   .\n//   You can use set `transforms` to true to return a list of transformation matrices instead of the swept shape.  In this case, you can\n//   often omit shape entirely.  The exception is when `closed=true` and you are using the \"incremental\" method.  In this case, `path_sweep`\n//   uses the shape to correct for twist when the shape closes on itself, so you must include a valid shape.\n// Arguments:\n//   shape = A 2D polygon path or region describing the shape to be swept.\n//   path = 2D or 3D path giving the path to sweep over\n//   method = one of \"incremental\", \"natural\" or \"manual\".  Default: \"incremental\"\n//   ---\n//   normal = normal vector for initializing the incremental method, or for setting normals with method=\"manual\".  Default: UP if the path makes an angle lower than 45 degrees to the xy plane, BACK otherwise.\n//   closed = path is a closed loop.  Default: false\n//   twist = amount of twist to add in degrees.  For closed sweeps must be a multiple of 360/symmetry.  Default: 0\n//   twist_by_length = if true then interpolate twist based on the path length of the path. If false interoplate based on point count.  Default: true\n//   symmetry = symmetry of the shape when closed=true.  Allows the shape to join with a 360/symmetry rotation instead of a full 360 rotation.  Default: 1\n//   scale = Amount to scale the profiles.  If you give a scalar the scale starts at 1 and ends at your specified value. The same is true for a 2-vector, but x and y are scaled separately.   You can also give a vector of values, one for each path point, and you can give a list of 2-vectors that give the x and y scales of your profile for every point on the path (a Nx2 matrix for a path of length N.  Default: 1 (no scaling)\n//   scale_by_length = if true then interpolate scale based on the path length of the path. If false interoplate based on point count.  Default: true\n//   last_normal = normal to last point in the path for the \"incremental\" method.  Constrains the orientation of the last cross section if you supply it.\n//   uniform = if set to false then compute tangents using the uniform=false argument, which may give better results when your path is non-uniformly sampled.  This argument is passed to {{path_tangents()}}.  Default: true\n//   tangent = a list of tangent vectors in case you need more accuracy (particularly at the end points of your curve)\n//   relaxed = set to true with the \"manual\" method to relax the orthogonality requirement of cross sections to the path tangent.  Default: false\n//   caps = Can be a boolean or vector of two booleans.  Set to false to disable caps at the two ends.  Default: true\n//   style = vnf_vertex_array style.  Default: \"min_edge\"\n//   profiles = if true then display all the cross section profiles instead of the solid shape.  Can help debug a sweep.  (module only) Default: false\n//   width = the width of lines used for profile display.  (module only) Default: 1\n//   transforms = set to true to return transforms instead of a VNF.  These transforms can be manipulated and passed to sweep().  (function only)  Default: false.\n//   convexity = convexity parameter for polyhedron().  (module only)  Default: 10\n//   anchor = Translate so anchor point is at the origin. Default: \"origin\"\n//   spin = Rotate this many degrees around Z axis after anchor. Default: 0\n//   orient = Vector to rotate top towards after spin\n//   atype  = Select \"hull\" or \"intersect\" anchor types.  Default: \"hull\"\n//   cp = Centerpoint for determining \"intersect\" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 3D point.  Default: \"centroid\"\n// Anchor Types:\n//   \"hull\" = Anchors to the virtual convex hull of the shape.\n//   \"intersect\" = Anchors to the surface of the shape.\n// Example(NoScales): A simple sweep of a square along a sine wave:\n//   path = [for(theta=[-180:5:180]) [theta/10, 10*sin(theta)]];\n//   sq = square(6,center=true);\n//   path_sweep(sq,path);\n// Example(NoScales): If the square is not centered, then we get a different result because the shape is in a different place relative to the origin:\n//   path = [for(theta=[-180:5:180]) [theta/10, 10*sin(theta)]];\n//   sq = square(6);\n//   path_sweep(sq,path);\n// Example(Med,VPR=[34,0,8],NoScales): It may not be obvious, but the polyhedron in the previous example is invalid.  It will eventually give CGAL errors when you combine it with other shapes.  To see this, set profiles to true and look at the left side.  The profiles cross each other and intersect.  Any time this happens, your polyhedron is invalid, even if it seems to be working at first.  Another observation from the profile display is that we have more profiles than needed over a lot of the shape, so if the model is slow, using fewer profiles in the flat portion of the curve might speed up the calculation.\n//   path = [for(theta=[-180:5:180]) [theta/10, 10*sin(theta)]];\n//   sq = square(6);\n//   path_sweep(sq,path,profiles=true,width=.1,$fn=8);\n// Example(2D): We'll use this shape in several examples\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   polygon(ushape);\n// Example(NoScales): Sweep along a clockwise elliptical arc, using default \"incremental\" method.\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[180,00], r=30));  // Clockwise\n//   path_sweep(ushape, path3d(elliptic_arc));\n// Example(NoScales): Sweep along a counter-clockwise elliptical arc.  Note that the orientation of the shape flips.\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=30));   // Counter-clockwise\n//   path_sweep(ushape, path3d(elliptic_arc));\n// Example(NoScales): Sweep along a clockwise elliptical arc, using \"natural\" method, which lines up the X axis of the shape with the direction of curvature.  This means the X axis will point inward, so a counterclockwise arc gives:\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=30));  // Counter-clockwise\n//   path_sweep(ushape, elliptic_arc, method=\"natural\");\n// Example(NoScales): Sweep along a clockwise elliptical arc, using \"natural\" method.  If the curve is clockwise then the shape flips upside-down to align the X axis.\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[180,0], r=30));  // Clockwise\n//   path_sweep(ushape, path3d(elliptic_arc), method=\"natural\");\n// Example(NoScales): Sweep along a clockwise elliptical arc, using \"manual\" method.  You can orient the shape in a direction you choose (subject to the constraint that the profiles remain normal to the path):\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[180,0], r=30));  // Clockwise\n//   path_sweep(ushape, path3d(elliptic_arc), method=\"manual\", normal=UP+RIGHT);\n// Example(NoScales): Here we changed the ellipse to be more pointy, and with the same results as above we get a shape with an irregularity in the middle where it maintains the specified direction around the point of the ellipse.  If the ellipse were more pointy, this would result in a bad polyhedron:\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   elliptic_arc = yscale(2, p=arc($fn=64,angle=[180,0], r=30));  // Clockwise\n//   path_sweep(ushape, path3d(elliptic_arc), method=\"manual\", normal=UP+RIGHT);\n// Example(NoScales): It is easy to produce an invalid shape when your path has a smaller radius of curvature than the width of your shape.  The exact threshold where the shape becomes invalid depends on the density of points on your path.  The error may not be immediately obvious, as the swept shape appears fine when alone in your model, but adding a cube to the model reveals the problem.  In this case the pentagon is turned so its longest direction points inward to create the singularity.\n//   qpath = [for(x=[-3:.01:3]) [x,x*x/1.8,0]];\n//   // Prints 0.9, but we use pentagon with radius of 1.0 > 0.9\n//   echo(radius_of_curvature = 1/max(path_curvature(qpath)));\n//   path_sweep(apply(rot(90),pentagon(r=1)), qpath, normal=BACK, method=\"manual\");\n//   cube(0.5);    // Adding a small cube forces a CGAL computation which reveals\n//                 // the error by displaying nothing or giving a cryptic message\n// Example(NoScales): Using the `relax` option we allow the profiles to deviate from orthogonality to the path.  This eliminates the crease that broke the previous example because the sections are all parallel to each other.\n//   qpath = [for(x=[-3:.01:3]) [x,x*x/1.8,0]];\n//   path_sweep(apply(rot(90),pentagon(r=1)), qpath, normal=BACK, method=\"manual\", relaxed=true);\n//   cube(0.5);    // Adding a small cube is not a problem with this valid model\n// Example(Med,VPR=[16,0,100],VPT=[0.05,0.6,0.6],VPD=25,NoScales): Using the `profiles=true` option can help debug bad polyhedra such as this one.  If any of the profiles intersect or cross each other, the polyhedron will be invalid.  In this case, you can see these intersections in the middle of the shape, which may give insight into how to fix your shape.   The profiles may also help you identify cases with a valid polyhedron where you have more profiles than needed to adequately define the shape.\n//   tri= scale([4.5,2.5],[[0, 0], [0, 1], [1, 0]]);\n//   path = left(4,xscale(1.5,arc(r=5,n=25,angle=[-70,70])));\n//   path_sweep(tri,path,profiles=true,width=.1);\n// Example(NoScales):  This 3d arc produces a result that twists to an undefined angle.  By default the incremental method sets the starting normal to UP, but the ending normal is unconstrained.\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   arc = yrot(37, p=path3d(arc($fn=64, r=30, angle=[0,180])));\n//   path_sweep(ushape, arc, method=\"incremental\");\n// Example(NoScales): You can constrain the last normal as well.  Here we point it right, which produces a nice result.\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   arc = yrot(37, p=path3d(arc($fn=64, r=30, angle=[0,180])));\n//   path_sweep(ushape, arc, method=\"incremental\", last_normal=RIGHT);\n// Example(NoScales): Here we constrain the last normal to UP.  Be aware that the behavior in the middle is unconstrained.\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   arc = yrot(37, p=path3d(arc($fn=64, r=30, angle=[0,180])));\n//   path_sweep(ushape, arc, method=\"incremental\", last_normal=UP);\n// Example(NoScales): The \"natural\" method produces a very different result\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   arc = yrot(37, p=path3d(arc($fn=64, r=30, angle=[0,180])));\n//   path_sweep(ushape, arc, method=\"natural\");\n// Example(NoScales): When the path starts at an angle of more that 45 deg to the xy plane the initial normal for \"incremental\" is BACK.  This produces the effect of the shape rising up out of the xy plane.  (Using UP for a vertical path is invalid, hence the need for a split in the defaults.)\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   arc = xrot(75, p=path3d(arc($fn=64, r=30, angle=[0,180])));\n//   path_sweep(ushape, arc, method=\"incremental\");\n// Example(NoScales): Adding twist\n//   // Counter-clockwise\n//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=3));\n//   path_sweep(pentagon(r=1), path3d(elliptic_arc), twist=72);\n// Example(NoScales): Closed shape\n//   ellipse = xscale(2, p=circle($fn=64, r=3));\n//   path_sweep(pentagon(r=1), path3d(ellipse), closed=true);\n// Example(NoScales): Closed shape with added twist\n//   ellipse = xscale(2, p=circle($fn=64, r=3));\n//   // Looks better with finer sampling\n//   pentagon = subdivide_path(pentagon(r=1), 30);\n//   path_sweep(pentagon, path3d(ellipse),\n//              closed=true, twist=360);\n// Example(NoScales): The last example was a lot of twist.  In order to use less twist you have to tell `path_sweep` that your shape has symmetry, in this case 5-fold.  Mobius strip with pentagon cross section:\n//   ellipse = xscale(2, p=circle($fn=64, r=3));\n//   // Looks better with finer sampling\n//   pentagon = subdivide_path(pentagon(r=1), 30);\n//   path_sweep(pentagon, path3d(ellipse), closed=true,\n//              symmetry = 5, twist=2*360/5);\n// Example(Med,NoScales): A helical path reveals the big problem with the \"incremental\" method: it can introduce unexpected and extreme twisting.  (Note helix example came from list-comprehension-demos)\n//   function helix(t) = [(t / 1.5 + 0.5) * 30 * cos(6 * 360 * t),\n//                        (t / 1.5 + 0.5) * 30 * sin(6 * 360 * t),\n//                         200 * (1 - t)];\n//   helix_steps = 200;\n//   helix = [for (i=[0:helix_steps]) helix(i/helix_steps)];\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   path_sweep(ushape, helix);\n// Example(Med,NoScales): You can constrain both ends, but still the twist remains:\n//   function helix(t) = [(t / 1.5 + 0.5) * 30 * cos(6 * 360 * t),\n//                        (t / 1.5 + 0.5) * 30 * sin(6 * 360 * t),\n//                         200 * (1 - t)];\n//   helix_steps = 200;\n//   helix = [for (i=[0:helix_steps]) helix(i/helix_steps)];\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   path_sweep(ushape, helix, normal=UP, last_normal=UP);\n// Example(Med,NoScales): Even if you manually guess the amount of twist and remove it, the result twists one way and then the other:\n//   function helix(t) = [(t / 1.5 + 0.5) * 30 * cos(6 * 360 * t),\n//                        (t / 1.5 + 0.5) * 30 * sin(6 * 360 * t),\n//                         200 * (1 - t)];\n//   helix_steps = 200;\n//   helix = [for (i=[0:helix_steps]) helix(i/helix_steps)];\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   path_sweep(ushape, helix, normal=UP, last_normal=UP, twist=360);\n// Example(Med,NoScales): To get a good result you must use a different method.\n//   function helix(t) = [(t / 1.5 + 0.5) * 30 * cos(6 * 360 * t),\n//                        (t / 1.5 + 0.5) * 30 * sin(6 * 360 * t),\n//                         200 * (1 - t)];\n//   helix_steps = 200;\n//   helix = [for (i=[0:helix_steps]) helix(i/helix_steps)];\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   path_sweep(ushape, helix, method=\"natural\");\n// Example(Med,NoScales): Note that it may look like the shape above is flat, but the profiles are very slightly tilted due to the nonzero torsion of the curve.  If you want as flat as possible, specify it so with the \"manual\" method:\n//   function helix(t) = [(t / 1.5 + 0.5) * 30 * cos(6 * 360 * t),\n//                        (t / 1.5 + 0.5) * 30 * sin(6 * 360 * t),\n//                         200 * (1 - t)];\n//   helix_steps = 200;\n//   helix = [for (i=[0:helix_steps]) helix(i/helix_steps)];\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   path_sweep(ushape, helix, method=\"manual\", normal=UP);\n// Example(Med,NoScales): What if you want to angle the shape inward?  This requires a different normal at every point in the path:\n//   function helix(t) = [(t / 1.5 + 0.5) * 30 * cos(6 * 360 * t),\n//                        (t / 1.5 + 0.5) * 30 * sin(6 * 360 * t),\n//                         200 * (1 - t)];\n//   helix_steps = 200;\n//   helix = [for (i=[0:helix_steps]) helix(i/helix_steps)];\n//   normals = [for(i=[0:helix_steps]) [-cos(6*360*i/helix_steps), -sin(6*360*i/helix_steps), 2.5]];\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   path_sweep(ushape, helix, method=\"manual\", normal=normals);\n// Example(NoScales): When using \"manual\" it is important to choose a normal that works for the whole path, producing a consistent result.  Here we have specified an upward normal, and indeed the shape is pointed up everywhere, but two abrupt transitional twists render the model invalid.\n//   yzcircle = yrot(90,p=path3d(circle($fn=64, r=30)));\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   path_sweep(ushape, yzcircle, method=\"manual\", normal=UP, closed=true);\n// Example(NoScales): The \"natural\" method will introduce twists when the curvature changes direction.  A warning is displayed.\n//   arc1 = path3d(arc(angle=90, r=30));\n//   arc2 = xrot(-90, cp=[0,30],p=path3d(arc(angle=[90,180], r=30)));\n//   two_arcs = path_merge_collinear(concat(arc1,arc2));\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   path_sweep(ushape, two_arcs, method=\"natural\");\n// Example(NoScales): The only simple way to get a good result is the \"incremental\" method:\n//   arc1 = path3d(arc(angle=90, r=30));\n//   arc2 = xrot(-90, cp=[0,30],p=path3d(arc(angle=[90,180], r=30)));\n//   arc3 = apply( translate([-30,60,30])*yrot(90), path3d(arc(angle=[270,180], r=30)));\n//   three_arcs = path_merge_collinear(concat(arc1,arc2,arc3));\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   path_sweep(ushape, three_arcs, method=\"incremental\");\n// Example(Med,NoScales): knot example from list-comprehension-demos, \"incremental\" method\n//   function knot(a,b,t) =   // rolling knot\n//        [ a * cos (3 * t) / (1 - b* sin (2 *t)),\n//          a * sin( 3 * t) / (1 - b* sin (2 *t)),\n//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))];\n//   a = 0.8; b = sqrt (1 - a * a);\n//   ksteps = 400;\n//   knot_path = [for (i=[0:ksteps-1]) 50 * knot(a,b,(i/ksteps)*360)];\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   path_sweep(ushape, knot_path, closed=true, method=\"incremental\");\n// Example(Med,NoScales): knot example from list-comprehension-demos, \"natural\" method.  Which one do you like better?\n//   function knot(a,b,t) =   // rolling knot\n//        [ a * cos (3 * t) / (1 - b* sin (2 *t)),\n//          a * sin( 3 * t) / (1 - b* sin (2 *t)),\n//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))];\n//   a = 0.8; b = sqrt (1 - a * a);\n//   ksteps = 400;\n//   knot_path = [for (i=[0:ksteps-1]) 50 * knot(a,b,(i/ksteps)*360)];\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   path_sweep(ushape, knot_path, closed=true, method=\"natural\");\n// Example(Med,NoScales): knot with twist.  Note if you twist it the other direction the center section untwists because of the natural twist there.  Also compare to the \"incremental\" method which has less twist in the center.\n//   function knot(a,b,t) =   // rolling knot\n//        [ a * cos (3 * t) / (1 - b* sin (2 *t)),\n//          a * sin( 3 * t) / (1 - b* sin (2 *t)),\n//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))];\n//   a = 0.8; b = sqrt (1 - a * a);\n//   ksteps = 400;\n//   knot_path = [for (i=[0:ksteps-1]) 50 * knot(a,b,(i/ksteps)*360)];\n//   path_sweep(subdivide_path(pentagon(r=12),30), knot_path, closed=true,\n//              twist=-360*8, symmetry=5, method=\"natural\");\n// Example(Med,NoScales): twisted knot with twist distributed by path sample points instead of by length using `twist_by_length=false`\n//   function knot(a,b,t) =   // rolling knot\n//           [ a * cos (3 * t) / (1 - b* sin (2 *t)),\n//             a * sin( 3 * t) / (1 - b* sin (2 *t)),\n//           1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))];\n//   a = 0.8; b = sqrt (1 - a * a);\n//   ksteps = 400;\n//   knot_path = [for (i=[0:ksteps-1]) 50 * knot(a,b,(i/ksteps)*360)];\n//   path_sweep(subdivide_path(pentagon(r=12),30), knot_path, closed=true,\n//              twist=-360*8, symmetry=5, method=\"natural\", twist_by_length=false);\n// Example(Big,NoScales): This torus knot example comes from list-comprehension-demos.  The knot lies on the surface of a torus.  When we use the \"natural\" method the swept figure is angled compared to the surface of the torus because the curve doesn't follow geodesics of the torus.\n//   function knot(phi,R,r,p,q) =\n//       [ (r * cos(q * phi) + R) * cos(p * phi),\n//         (r * cos(q * phi) + R) * sin(p * phi),\n//          r * sin(q * phi) ];\n//   ushape = 3*[[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   points = 50;       // points per loop\n//   R = 400; r = 150;  // Torus size\n//   p = 2;  q = 5;     // Knot parameters\n//   %torus(r_maj=R,r_min=r);\n//   k = max(p,q) / gcd(p,q) * points;\n//   knot_path   = [ for (i=[0:k-1]) knot(360*i/k/gcd(p,q),R,r,p,q) ];\n//   path_sweep(rot(90,p=ushape),knot_path,  method=\"natural\", closed=true);\n// Example(Big,NoScales): By computing the normal to the torus at the path we can orient the path to lie on the surface of the torus:\n//   function knot(phi,R,r,p,q) =\n//       [ (r * cos(q * phi) + R) * cos(p * phi),\n//         (r * cos(q * phi) + R) * sin(p * phi),\n//          r * sin(q * phi) ];\n//   function knot_normal(phi,R,r,p,q) =\n//       knot(phi,R,r,p,q)\n//           - R*unit(knot(phi,R,r,p,q)\n//               - [0,0, knot(phi,R,r,p,q)[2]]) ;\n//   ushape = 3*[[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   points = 50;       // points per loop\n//   R = 400; r = 150;  // Torus size\n//   p = 2;  q = 5;     // Knot parameters\n//   %torus(r_maj=R,r_min=r);\n//   k = max(p,q) / gcd(p,q) * points;\n//   knot_path   = [ for (i=[0:k-1]) knot(360*i/k/gcd(p,q),R,r,p,q) ];\n//   normals = [ for (i=[0:k-1]) knot_normal(360*i/k/gcd(p,q),R,r,p,q) ];\n//   path_sweep(ushape,knot_path,normal=normals, method=\"manual\", closed=true);\n// Example(NoScales): You can request the transformations and manipulate them before passing them on to sweep.  Here we construct a tube that changes scale by first generating the transforms and then applying the scale factor and connecting the inside and outside.  Note that the wall thickness varies because it is produced by scaling.\n//   shape = star(n=5, r=10, ir=5);\n//   rpath = arc(25, points=[[29,6,-4], [3,4,6], [1,1,7]]);\n//   trans = path_sweep(shape, rpath, transforms=true);\n//   outside = [for(i=[0:len(trans)-1]) trans[i]*scale(lerp(1,1.5,i/(len(trans)-1)))];\n//   inside = [for(i=[len(trans)-1:-1:0]) trans[i]*scale(lerp(1.1,1.4,i/(len(trans)-1)))];\n//   sweep(shape, concat(outside,inside),closed=true);\n// Example(NoScales): An easier way to scale your model is to use the scale parameter.\n//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=3));\n//   path_sweep(pentagon(r=1), path3d(elliptic_arc), scale=2);\n// Example(NoScales): Scaling only in the y direction of the profile (z direction in the model in this case)\n//   elliptic_arc = xscale(2, p=arc($fn=64,angle=[0,180], r=3));\n//   path_sweep(rect(2), path3d(elliptic_arc), scale=[1,2]);\n// Example(NoScales): Specifying scale at every point for a closed path\n//   N=64;\n//   path = circle(r=5, $fn=64);\n//   theta = lerpn(0,360,N,endpoint=false);\n//   scale = [for(t=theta) sin(6*t)/5+1];\n//   path_sweep(rect(2), path3d(path), closed=true, scale=scale);\n// Example(Med,NoScales): Using path_sweep on a region\n//   rgn1 = [for (d=[10:10:60]) circle(d=d,$fn=8)];\n//   rgn2 = [square(30,center=false)];\n//   rgn3 = [for (size=[10:10:20]) move([15,15],p=square(size=size, center=true))];\n//   mrgn = union(rgn1,rgn2);\n//   orgn = difference(mrgn,rgn3);\n//   path_sweep(orgn,arc(r=40,angle=180));\n// Example(Med,NoScales): A region with a twist\n//   region = [for(i=pentagon(5)) move(i,p=circle(r=2,$fn=25))];\n//   path_sweep(region,\n//              circle(r=16,$fn=75),closed=true,\n//              twist=360/5*2,symmetry=5);\n// Example(Med,NoScales): Cutting a cylinder with a curved path.  Note that in this case, the incremental method produces just a slight twist but the natural method produces an extreme twist.  But manual specification produces no twist, as desired:\n//   $fn=90;\n//   r=8;\n//   thickness=1;\n//   len=21;\n//   curve = [for(theta=[0:4:359])\n//              [r*cos(theta), r*sin(theta), 10+sin(6*theta)]];\n//   difference(){\n//     cylinder(r=r, h=len);\n//     down(.5)cylinder(r=r-thickness, h=len+1);\n//     path_sweep(left(.05,square([1.1,1])), curve, closed=true,\n//                method=\"manual\", normal=UP);\n//   }\n\nmodule path_sweep(shape, path, method=\"incremental\", normal, closed, twist=0, twist_by_length=true, scale=1, scale_by_length=true,\n                    symmetry=1, last_normal, tangent, uniform=true, relaxed=false, caps, style=\"min_edge\", convexity=10,\n                    anchor=\"origin\",cp=\"centroid\",spin=0, orient=UP, atype=\"hull\",profiles=false,width=1)\n{\n    dummy = assert(is_region(shape) || is_path(shape,2), \"shape must be a 2D path or region\");\n    vnf = path_sweep(shape, path, method, normal, closed, twist, twist_by_length, scale, scale_by_length,\n                    symmetry, last_normal, tangent, uniform, relaxed, caps, style);\n\n    if (profiles){\n        assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\");\n        tran = path_sweep(shape, path, method, normal, closed, twist, twist_by_length, scale, scale_by_length, \n                          symmetry, last_normal, tangent, uniform, relaxed,transforms=true);\n        rshape = is_path(shape) ? [path3d(shape)]\n                                : [for(s=shape) path3d(s)];\n        attachable(anchor,spin,orient, vnf=vnf, extent=atype==\"hull\", cp=cp) {\n            for(T=tran) stroke([for(part=rshape)apply(T,part)],width=width);\n            children();\n        }\n    }\n    else\n      vnf_polyhedron(vnf,convexity=convexity,anchor=anchor, spin=spin, orient=orient, atype=atype, cp=cp)\n          children();\n}\n\n\nfunction path_sweep(shape, path, method=\"incremental\", normal, closed, twist=0, twist_by_length=true, scale=1, scale_by_length=true, \n                    symmetry=1, last_normal, tangent, uniform=true, relaxed=false, caps, style=\"min_edge\", transforms=false,\n                    anchor=\"origin\",cp=\"centroid\",spin=0, orient=UP, atype=\"hull\") =\n  is_1region(path) ? path_sweep(shape=shape,path=path[0], method=method, normal=normal, closed=default(closed,true), \n                                twist=twist, scale=scale, scale_by_length=scale_by_length, twist_by_length=twist_by_length, symmetry=symmetry, last_normal=last_normal,\n                                tangent=tangent, uniform=uniform, relaxed=relaxed, caps=caps, style=style, transforms=transforms,\n                                anchor=anchor, cp=cp, spin=spin, orient=orient, atype=atype) :\n  let(closed=default(closed,false))\n  assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\")\n  assert(!closed || twist % (360/symmetry)==0, str(\"For a closed sweep, twist must be a multiple of 360/symmetry = \",360/symmetry))\n  assert(closed || symmetry==1, \"symmetry must be 1 when closed is false\")\n  assert(is_integer(symmetry) && symmetry>0, \"symmetry must be a positive integer\")\n  let(path = force_path(path))\n  assert(is_path(path,[2,3]), \"input path is not a 2D or 3D path\")\n  assert(!closed || !approx(path[0],last(path)), \"Closed path includes start point at the end\")\n  assert((is_region(shape) || is_path(shape,2)) || (transforms && !(closed && method==\"incremental\")),\"shape must be a 2d path or region\")\n  let(\n    path = path3d(path),\n    caps = is_def(caps) ? caps :\n           closed ? false : true,\n    capsOK = is_bool(caps) || is_bool_list(caps,2),\n    fullcaps = is_bool(caps) ? [caps,caps] : caps,\n    normalOK = is_undef(normal) || (method!=\"natural\" && is_vector(normal,3))\n                                || (method==\"manual\" && same_shape(normal,path)),\n    scaleOK = scale==1 || ((is_num(scale) || is_vector(scale,2)) && !closed) || is_vector(scale,len(path)) || is_matrix(scale,len(path),2)\n    \n  )\n  assert(normalOK,  method==\"natural\" ? \"Cannot specify normal with the \\\"natural\\\" method\"\n                  : method==\"incremental\" ? \"Normal with \\\"incremental\\\" method must be a 3-vector\"\n                  : str(\"Incompatible normal given.  Must be a 3-vector or a list of \",len(path),\" 3-vectors\"))\n  assert(capsOK, \"caps must be boolean or a list of two booleans\")\n  assert(!closed || !caps, \"Cannot make closed shape with caps\")\n  assert(is_undef(normal) || (is_vector(normal) && len(normal)==3) || (is_path(normal) && len(normal)==len(path) && len(normal[0])==3), \"Invalid normal specified\")\n  assert(is_undef(tangent) || (is_path(tangent) && len(tangent)==len(path) && len(tangent[0])==3), \"Invalid tangent specified\")\n  assert(scaleOK,str(\"Incompatible or invalid scale\",closed?\" for closed path\":\"\",\": must be \", closed?\"\":\"a scalar, a 2-vector, \",\n                     \"a vector of length \",len(path),\" or a \",len(path),\"x2 matrix of scales\"))\n  let(\n    scale = !(is_num(scale) || is_vector(scale,2)) ? scale\n          : let(s=is_num(scale) ? [scale,scale] : scale)\n            !scale_by_length ? lerpn([1,1],s,len(path))\n          : lerp([1,1],s, path_length_fractions(path,false)),\n    scale_list = [for(s=scale) scale(s),if (closed) scale(scale[0])],\n    tangents = is_undef(tangent) ? path_tangents(path,uniform=uniform,closed=closed) : [for(t=tangent) unit(t)],\n    normal = is_path(normal) ? [for(n=normal) unit(n)] :\n             is_def(normal) ? unit(normal) :\n             method ==\"incremental\" && abs(tangents[0].z) > 1/sqrt(2) ? BACK : UP,\n    normals = is_path(normal) ? normal : repeat(normal,len(path)),\n    tpathfrac = twist_by_length ? path_length_fractions(path, closed) : [for(i=[0:1:len(path)]) i / (len(path)-(closed?0:1))],\n    spathfrac = scale_by_length ? path_length_fractions(path, closed) : [for(i=[0:1:len(path)]) i / (len(path)-(closed?0:1))],    \n    L = len(path),\n    unscaled_transform_list =\n        method==\"old_incremental\" ?\n          let(rotations =\n                 [for( i  = 0,\n                       ynormal = normal - (normal * tangents[0])*tangents[0],\n                       rotation = frame_map(y=ynormal, z=tangents[0])\n                         ;\n                       i < len(tangents) + (closed?1:0)\n                         ;\n                       rotation = i<len(tangents)-1+(closed?1:0)? rot(from=tangents[i],to=tangents[(i+1)%L])*rotation : undef,\n                       i=i+1\n                      )\n                   rotation],\n              // The mismatch is the inverse of the last transform times the first one for the closed case, or the inverse of the\n              // desired final transform times the realized final transform in the open case.  Note that when closed==true the last transform\n              // is a actually looped around and applies to the first point position, so if we got back exactly where we started\n              // then it will be the identity, but we might have accumulated some twist which will show up as a rotation around the\n              // X axis.  Similarly, in the closed==false case the desired and actual transformations can only differ in the twist,\n              // so we can need to calculate the twist angle so we can apply a correction, which we distribute uniformly over the whole path.\n              reference_rot = closed ? rotations[0] :\n                           is_undef(last_normal) ? last(rotations) :\n                             let(\n                                 last_tangent = last(tangents),\n                                 lastynormal = last_normal - (last_normal * last_tangent) * last_tangent\n                             )\n                           frame_map(y=lastynormal, z=last_tangent),\n              mismatch = transpose(last(rotations)) * reference_rot,\n              correction_twist = atan2(mismatch[1][0], mismatch[0][0]),\n              // Spread out this extra twist over the whole sweep so that it doesn't occur\n              // abruptly as an artifact at the last step.\n              twistfix = correction_twist%(360/symmetry),\n              adjusted_final = !closed ? undef :\n                            translate(path[0]) * rotations[0] * zrot(-correction_twist+correction_twist%(360/symmetry)-twist)\n          )  [for(i=idx(path)) translate(path[i]) * rotations[i] * zrot((twistfix-twist)*tpathfrac[i]), if(closed) adjusted_final] \n      : method==\"incremental\" ?   // Implements Rotation Minimizing Frame from \"Computation of Rotation Minimizing Frames\"\n                                  // by Wenping Yang, Bert B\u00fcttler, Dayue Zheng, Yang Liu, 2008\n                                  // http://doi.acm.org/10.1145/1330511.1330513\n          let(rotations =         // https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/Computation-of-rotation-minimizing-frames.pdf\n                 [for( i  = 0,\n                       ynormal = normal - (normal * tangents[0])*tangents[0],\n                       rotation = frame_map(y=ynormal, z=tangents[0]),\n                       r=ynormal\n                         ;\n                       i < len(tangents) + (closed?1:0)\n                         ;\n                       v1 = path[(i+1)%L]-path[i%L],\n                       c1 = v1*v1,\n                       rL = r - 2*(v1*r)/c1 * v1,\n                       tL = tangents[i%L] - 2*(v1*tangents[i%L])/c1 * v1,\n                       v2 = tangents[(i+1)%L]-tL,\n                       c2 = v2*v2,\n                       r = rL - (2/c2)*(v2*rL)*v2,\n                       rotation = i<len(tangents)-1+(closed?1:0)? frame_map(y=r,z=tangents[(i+1)%L]) : undef,\n                       i=i+1\n                      )\n                   rotation],\n              // The mismatch is the inverse of the last transform times the first one for the closed case, or the inverse of the\n              // desired final transform times the realized final transform in the open case.  Note that when closed==true the last transform\n              // is a actually looped around and applies to the first point position, so if we got back exactly where we started\n              // then it will be the identity, but we might have accumulated some twist which will show up as a rotation around the\n              // X axis.  Similarly, in the closed==false case the desired and actual transformations can only differ in the twist,\n              // so we can need to calculate the twist angle so we can apply a correction, which we distribute uniformly over the whole path.\n              reference_rot = closed ? rotations[0] :\n                           is_undef(last_normal) ? last(rotations) :\n                             let(\n                                 last_tangent = last(tangents),\n                                 lastynormal = last_normal - (last_normal * last_tangent) * last_tangent\n                             )\n                           frame_map(y=lastynormal, z=last_tangent),\n              mismatch = transpose(last(rotations)) * reference_rot,\n              correction_twist = atan2(mismatch[1][0], mismatch[0][0]),\n              // Spread out this extra twist over the whole sweep so that it doesn't occur\n              // abruptly as an artifact at the last step.\n              twistfix = correction_twist%(360/symmetry),\n              adjusted_final = !closed ? undef :\n                            translate(path[0]) * rotations[0] * zrot(-correction_twist+correction_twist%(360/symmetry)-twist)\n          )  [for(i=idx(path)) translate(path[i]) * rotations[i] * zrot((twistfix-twist)*tpathfrac[i]), if(closed) adjusted_final] \n      : method==\"manual\" ?\n              [for(i=[0:L-(closed?0:1)]) let(\n                       ynormal = relaxed ? normals[i%L] : normals[i%L] - (normals[i%L] * tangents[i%L])*tangents[i%L],\n                       znormal = relaxed ? tangents[i%L] - (normals[i%L] * tangents[i%L])*normals[i%L] : tangents[i%L],\n                       rotation = frame_map(y=ynormal, z=znormal)\n                   )\n                   assert(approx(ynormal*znormal,0),str(\"Supplied normal is parallel to the path tangent at point \",i))\n                   translate(path[i%L])*rotation*zrot(-twist*tpathfrac[i])\n              ]\n      : method==\"natural\" ?   // map x axis of shape to the path normal, which points in direction of curvature\n              let (pathnormal = path_normals(path, tangents, closed))\n              assert(all_defined(pathnormal),\"Natural normal vanishes on your curve, select a different method\")\n              let( testnormals = [for(i=[0:len(pathnormal)-1-(closed?1:2)]) pathnormal[i]*select(pathnormal,i+2)],\n                   a=[for(i=idx(testnormals)) testnormals[i]<.5 ? echo(str(\"Big change at index \",i,\" pn=\",pathnormal[i],\" pn2= \",select(pathnormal,i+2))):0],\n                   dummy = min(testnormals) < .5 ? echo(\"WARNING: ***** Abrupt change in normal direction.  Consider a different method in path_sweep() *****\") :0\n                 )\n              [for(i=[0:L-(closed?0:1)]) let(\n                       rotation = frame_map(x=pathnormal[i%L], z=tangents[i%L])\n                   )\n                   translate(path[i%L])*rotation*zrot(-twist*tpathfrac[i])\n                 ] \n      : assert(false,\"Unknown method or no method given\"), // unknown method\n    transform_list = v_mul(unscaled_transform_list, scale_list),\n    ends_match = !closed ? true\n                 : let( rshape = is_path(shape) ? [path3d(shape)]\n                                                : [for(s=shape) path3d(s)]\n                   )\n                   are_regions_equal(apply(transform_list[0], rshape),\n                                     apply(transform_list[L], rshape)),\n    dummy = ends_match ? 0 : echo(\"WARNING: ***** The points do not match when closing the model in path_sweep() *****\")\n  )\n  transforms ? transform_list\n             : sweep(is_path(shape)?clockwise_polygon(shape):shape, transform_list, closed=false, caps=fullcaps,style=style,\n                       anchor=anchor,cp=cp,spin=spin,orient=orient,atype=atype);\n\n\n// Function&Module: path_sweep2d()\n// Synopsis: Sweep a 2d polygon path along a 2d path allowing self-intersection. \n// SynTags: VNF, Geom\n// Topics: Extrusion, Sweep, Paths\n// See Also: linear_sweep(), rotate_sweep(), sweep(), spiral_sweep(), path_sweep(), offset_sweep()\n// Usage: as module\n//   path_sweep2d(shape, path, [closed], [caps], [quality], [style], [convexity=], [anchor=], [spin=], [orient=], [atype=], [cp=]) [ATTACHMENTS];\n// Usage: as function\n//   vnf = path_sweep2d(shape, path, [closed], [caps], [quality], [style], [anchor=], [spin=], [orient=], [atype=], [cp=]);\n// Description:\n//   Takes an input 2D polygon (the shape) and a 2d path, and constructs a polyhedron by sweeping the shape along the path.\n//   When run as a module returns the polyhedron geometry.  When run as a function returns a VNF.\n//   .\n//   See {{path_sweep()}} for more details on how the sweep operation works and for introductory examples.\n//   This 2d version is different because local self-intersections (creases in the output) are allowed and do not produce CGAL errors.\n//   This is accomplished by using offset() calculations, which are more expensive than simply copying the shape along\n//   the path, so if you do not have local self-intersections, use {{path_sweep()}} instead.  If xmax is the largest x value (in absolute value)\n//   of the shape, then path_sweep2d() will work as long as the offset of `path` exists at `delta=xmax`.  If the offset vanishes, as in the\n//   case of a circle offset by more than its radius, then you will get an error about a degenerate offset.\n//   Note that global self-intersections will still give rise to CGAL errors.  You should be able to handle these by partitioning your model.  The y axis of the\n//   shape is mapped to the z axis in the swept polyhedron, and no twisting can occur.\n//   The quality parameter is passed to offset to determine the offset quality.\n// Arguments:\n//   shape = a 2D polygon describing the shape to be swept\n//   path = a 2D path giving the path to sweep over\n//   closed = path is a closed loop.  Default: false\n//   caps = true to create endcap faces when closed is false.  Can be a length 2 boolean array.  Default is true if closed is false.\n//   quality = quality of offset used in calculation.  Default: 1\n//   style = vnf_vertex_array style.  Default: \"min_edge\"\n//   ---\n//   convexity = convexity parameter for polyhedron (module only)  Default: 10\n//   anchor = Translate so anchor point is at the origin.  Default: \"origin\"\n//   spin = Rotate this many degrees around Z axis after anchor.  Default: 0\n//   orient = Vector to rotate top towards after spin\n//   atype = Select \"hull\" or \"intersect\" anchor types.  Default: \"hull\"\n//   cp = Centerpoint for determining \"intersect\" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 3D point.  Default: \"centroid\"\n// Anchor Types:\n//   \"hull\" = Anchors to the virtual convex hull of the shape.\n//   \"intersect\" = Anchors to the surface of the shape.\n// Example: Sine wave example with self-intersections at each peak.  This would fail with path_sweep().\n//   sinewave = [for(i=[-30:10:360*2+30]) [i/40,3*sin(i)]];\n//   path_sweep2d(circle(r=3,$fn=15), sinewave);\n// Example: The ends can look weird if they are in a place where self intersection occurs.  This is a natural result of how offset behaves at ends of a path.\n//   coswave = [for(i=[0:10:360*1.5]) [i/40,3*cos(i)]];\n//   zrot(-20)\n//     path_sweep2d( circle(r=3,$fn=15), coswave);\n// Example: This closed path example works ok as long as the hole in the center remains open.\n//   ellipse = yscale(3,p=circle(r=3,$fn=120));\n//   path_sweep2d(circle(r=2.5,$fn=32), reverse(ellipse), closed=true);\n// Example: When the hole is closed a global intersection renders the model invalid.  You can fix this by taking the union of the two (valid) halves.\n//   ellipse = yscale(3,p=circle(r=3,$fn=120));\n//   L = len(ellipse);\n//   path_sweep2d(circle(r=3.25, $fn=32), select(ellipse,floor(L*.2),ceil(L*.8)),closed=false);\n//   path_sweep2d(circle(r=3.25, $fn=32), select(ellipse,floor(L*.7),ceil(L*.3)),closed=false);\n\nfunction path_sweep2d(shape, path, closed=false, caps, quality=1, style=\"min_edge\",\n                      anchor=\"origin\",cp=\"centroid\",spin=0, orient=UP, atype=\"hull\") =\n   let(\n        caps = is_def(caps) ? caps\n             : closed ? false : true,\n        capsOK = is_bool(caps) || is_bool_list(caps,2),\n        fullcaps = is_bool(caps) ? [caps,caps] : caps,\n        shape = force_path(shape,\"shape\"),\n        path = force_path(path)\n   )\n   assert(is_path(shape,2), \"shape must be a 2D path\")\n   assert(is_path(path,2), \"path must be a 2D path\")\n   assert(capsOK, \"caps must be boolean or a list of two booleans\")\n   assert(!closed || !caps, \"Cannot make closed shape with caps\")\n   let(\n        profile = ccw_polygon(shape),\n        flip = closed && is_polygon_clockwise(path) ? -1 : 1,\n        path = flip ? reverse(path) : path,\n        proflist= transpose(\n                     [for(pt = profile)\n                        let(\n                            ofs = offset(path, delta=-flip*pt.x, return_faces=true,closed=closed, quality=quality),\n                            map = column(_ofs_vmap(ofs,closed=closed),1)\n                        )\n                        select(path3d(ofs[0],pt.y),map)\n                      ]\n                  ),\n        vnf = vnf_vertex_array([\n                         each proflist,\n                         if (closed) proflist[0]\n                        ],cap1=fullcaps[0],cap2=fullcaps[1],col_wrap=true,style=style)\n   )\n   reorient(anchor,spin,orient,vnf=vnf,p=vnf,extent=atype==\"hull\",cp=cp);\n\n\nmodule path_sweep2d(profile, path, closed=false, caps, quality=1, style=\"min_edge\", convexity=10,\n                    anchor=\"origin\", cp=\"centroid\", spin=0, orient=UP, atype=\"hull\")\n{\n   vnf = path_sweep2d(profile, path, closed, caps, quality, style);\n   vnf_polyhedron(vnf,convexity=convexity,anchor=anchor, spin=spin, orient=orient, atype=atype, cp=cp)\n        children();\n}\n\n// Extract vertex mapping from offset face list.  The output of this function\n// is a list of pairs [i,j] where i is an index into the parent curve and j is\n// an index into the offset curve.  It would probably make sense to rewrite\n// offset() to return this instead of the face list and have offset_sweep\n// use this input to assemble the faces it needs.\n\nfunction _ofs_vmap(ofs,closed=false) =\n    let(   // Caclulate length of the first (parent) curve\n        firstlen = max(flatten(ofs[1]))+1-len(ofs[0])\n    )\n    [\n     for(entry=ofs[1]) _ofs_face_edge(entry,firstlen),\n     if (!closed) _ofs_face_edge(last(ofs[1]),firstlen,second=true)\n    ];\n\n\n// Extract first (default) or second edge that connects the parent curve to its offset.  The first input\n// face is a list of 3 or 4 vertices as indices into the two curves where the parent curve vertices are\n// numbered from 0 to firstlen-1 and the offset from firstlen and up.  The firstlen pararameter is used\n// to determine which curve the vertices belong to and to remove the offset so that the return gives\n// the index into each curve with a 0 base.\nfunction _ofs_face_edge(face,firstlen,second=false) =\n   let(\n       itry = min_index(face),\n       i = select(face,itry-1)<firstlen ? itry-1:itry,\n       edge1 = select(face,[i,i-1]),\n       edge2 = select(face,i+1)<firstlen ? select(face,[i+1,i+2])\n                                         : select(face,[i,i+1])\n   )\n   (second ? edge2 : edge1)-[0,firstlen];\n\n\n\n// Function&Module: sweep()\n// Synopsis: Construct a 3d object from arbitrary transformations of a 2d polygon path.\n// SynTags: VNF, Geom\n// Topics: Extrusion, Sweep, Paths\n// See Also: linear_sweep(), rotate_sweep(), spiral_sweep(), path_sweep(), path_sweep2d(), offset_sweep()\n// Usage: As Module\n//   sweep(shape, transforms, [closed], [caps], [style], [convexity=], [anchor=], [spin=], [orient=], [atype=]) [ATTACHMENTS];\n// Usage: As Function\n//   vnf = sweep(shape, transforms, [closed], [caps], [style], [anchor=], [spin=], [orient=], [atype=]);\n// Description:\n//   The input `shape` must be a non-self-intersecting 2D polygon or region, and `transforms`\n//   is a list of 4x4 transformation matrices.  The sweep algorithm applies each transformation in sequence\n//   to the shape input and links the resulting polygons together to form a polyhedron.\n//   If `closed=true` then the first and last transformation are linked together.\n//   The `caps` parameter controls whether the ends of the shape are closed.\n//   As a function, returns the VNF for the polyhedron.  As a module, computes the polyhedron.\n//   .\n//   Note that this is a very powerful, general framework for producing polyhedra.  It is important\n//   to ensure that your resulting polyhedron does not include any self-intersections, or it will\n//   be invalid and will generate CGAL errors.  If you get such errors, most likely you have an\n//   overlooked self-intersection.  Note also that the errors will not occur when your shape is alone\n//   in your model, but will arise if you add a second object to the model.  This may mislead you into\n//   thinking the second object caused a problem.  Even adding a simple cube to the model will reveal the problem.\n// Arguments:\n//   shape = 2d path or region, describing the shape to be swept.\n//   transforms = list of 4x4 matrices to apply\n//   closed = set to true to form a closed (torus) model.  Default: false\n//   caps = true to create endcap faces when closed is false.  Can be a singe boolean to specify endcaps at both ends, or a length 2 boolean array.  Default is true if closed is false.\n//   style = vnf_vertex_array style.  Default: \"min_edge\"\n//   ---\n//   convexity = convexity setting for use with polyhedron.  (module only) Default: 10\n//   cp = Centerpoint for determining \"intersect\" anchors or centering the shape.  Determintes the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 3D point.  Default: \"centroid\"\n//   atype = Select \"hull\" or \"intersect\" anchor types.  Default: \"hull\"\n//   anchor = Translate so anchor point is at the origin. Default: \"origin\"\n//   spin = Rotate this many degrees around Z axis after anchor. Default: 0\n//   orient = Vector to rotate top towards after spin  (module only)\n// Anchor Types:\n//   \"hull\" = Anchors to the virtual convex hull of the shape.\n//   \"intersect\" = Anchors to the surface of the shape.\n// Example(VPR=[45,0,74],VPD=175,VPT=[-3.8,12.4,19]): A bent object that also changes shape along its length.\n//   radius = 75;\n//   angle = 40;\n//   shape = circle(r=5,$fn=32);\n//   T = [for(i=[0:25]) xrot(-angle*i/25,cp=[0,radius,0])*scale([1+i/25, 2-i/25,1])];\n//   sweep(shape,T);\n// Example: This is the \"sweep-drop\" example from list-comprehension-demos.\n//   function drop(t) = 100 * 0.5 * (1 - cos(180 * t)) * sin(180 * t) + 1;\n//   function path(t) = [0, 0, 80 + 80 * cos(180 * t)];\n//   function rotate(t) = 180 * pow((1 - t), 3);\n//   step = 0.01;\n//   path_transforms = [for (t=[0:step:1-step]) translate(path(t)) * zrot(rotate(t)) * scale([drop(t), drop(t), 1])];\n//   sweep(circle(1, $fn=12), path_transforms);\n// Example: Another example from list-comprehension-demos\n//   function f(x) = 3 - 2.5 * x;\n//   function r(x) = 2 * 180 * x * x * x;\n//   pathstep = 1;\n//   height = 100;\n//   shape_points = subdivide_path(square(10),40,closed=true);\n//   path_transforms = [for (i=[0:pathstep:height]) let(t=i/height) up(i) * scale([f(t),f(t),i]) * zrot(r(t))];\n//   sweep(shape_points, path_transforms);\n// Example: Twisted container.  Note that this technique doesn't create a fixed container wall thickness.\n//   shape = subdivide_path(square(30,center=true), 40, closed=true);\n//   outside = [for(i=[0:24]) up(i)*rot(i)*scale(1.25*i/24+1)];\n//   inside = [for(i=[24:-1:2]) up(i)*rot(i)*scale(1.2*i/24+1)];\n//   sweep(shape, concat(outside,inside));\n\nfunction sweep(shape, transforms, closed=false, caps, style=\"min_edge\",\n               anchor=\"origin\", cp=\"centroid\", spin=0, orient=UP, atype=\"hull\") =\n    assert(is_consistent(transforms, ident(4)), \"Input transforms must be a list of numeric 4x4 matrices in sweep\")\n    assert(is_path(shape,2) || is_region(shape), \"Input shape must be a 2d path or a region.\")\n    let(\n        caps = is_def(caps) ? caps :\n            closed ? false : true,\n        capsOK = is_bool(caps) || is_bool_list(caps,2),\n        fullcaps = is_bool(caps) ? [caps,caps] : caps\n    )\n    assert(len(transforms)>=2, \"transformation must be length 2 or more\")\n    assert(capsOK, \"caps must be boolean or a list of two booleans\")\n    assert(!closed || !caps, \"Cannot make closed shape with caps\")\n    is_region(shape)? let(\n        regions = region_parts(shape),\n        rtrans = reverse(transforms),\n        vnfs = [\n            for (rgn=regions) each [\n                for (path=rgn)\n                    sweep(path, transforms, closed=closed, caps=false, style=style),\n                if (fullcaps[0]) vnf_from_region(rgn, transform=transforms[0], reverse=true),\n                if (fullcaps[1]) vnf_from_region(rgn, transform=last(transforms)),\n            ],\n        ],\n        vnf = vnf_join(vnfs)\n    ) vnf :\n    assert(len(shape)>=3, \"shape must be a path of at least 3 non-colinear points\")\n    vnf_vertex_array([for(i=[0:len(transforms)-(closed?0:1)]) apply(transforms[i%len(transforms)],path3d(shape))],\n                     cap1=fullcaps[0],cap2=fullcaps[1],col_wrap=true,style=style);\n\n\nmodule sweep(shape, transforms, closed=false, caps, style=\"min_edge\", convexity=10,\n             anchor=\"origin\",cp=\"centroid\",spin=0, orient=UP, atype=\"hull\")\n{\n    vnf = sweep(shape, transforms, closed, caps, style);\n    vnf_polyhedron(vnf, convexity=convexity, anchor=anchor, spin=spin, orient=orient, atype=atype, cp=cp)\n        children();\n}\n\n\n\n// Section: Functions for resampling and slicing profile lists\n\n// Function: subdivide_and_slice()\n// Synopsis: Resample list of paths to have the same point count and interpolate additional paths. \n// SynTags: PathList\n// Topics: Paths, Path Subdivision\n// See Also: slice_profiles()\n// Usage:\n//   newprof = subdivide_and_slice(profiles, slices, [numpoints], [method], [closed]);\n// Description:\n//   Subdivides the input profiles to have length `numpoints` where `numpoints` must be at least as\n//   big as the largest input profile.  By default `numpoints` is set equal to the length of the\n//   largest profile.  You can set `numpoints=\"lcm\"` to sample to the least common multiple of all\n//   curves, which will avoid sampling artifacts but may produce a huge output.  After subdivision,\n//   profiles are sliced.\n// Arguments:\n//   profiles = profiles to operate on\n//   slices = number of slices to insert between each pair of profiles.  May be a vector\n//   numpoints = number of points after sampling.\n//   method = method used for calling {{subdivide_path()}}, either `\"length\"` or `\"segment\"`.  Default: `\"length\"`\n//   closed = the first and last profile are connected.  Default: false\nfunction subdivide_and_slice(profiles, slices, numpoints, method=\"length\", closed=false) =\n  let(\n    maxsize = max_length(profiles),\n    numpoints = is_undef(numpoints) ? maxsize :\n                numpoints == \"lcm\" ? lcmlist([for(p=profiles) len(p)]) :\n                is_num(numpoints) ? round(numpoints) : undef\n  )\n  assert(is_def(numpoints), \"Parameter numpoints must be \\\"max\\\", \\\"lcm\\\" or a positive number\")\n  assert(numpoints>=maxsize, \"Number of points requested is smaller than largest profile\")\n  let(fixpoly = [for(poly=profiles) subdivide_path(poly, numpoints,method=method)])\n  slice_profiles(fixpoly, slices, closed);\n\n\n\n// Function: slice_profiles()\n// Synopsis: Linearly interpolates between path profiles.\n// SynTags: PathList\n// Topics: Paths, Path Subdivision\n// See Also: subdivide_and_slice()\n// Usage:\n//   profs = slice_profiles(profiles, slices, [closed]);\n// Description:\n//   Given an input list of profiles, linearly interpolate between each pair to produce a\n//   more finely sampled list.  The parameters `slices` specifies the number of slices to\n//   be inserted between each pair of profiles and can be a number or a list.\n// Arguments:\n//   profiles = list of paths to operate on.  They must be lists of the same shape and length.\n//   slices = number of slices to insert between each pair, or a list to vary the number inserted.\n//   closed = set to true if last profile connects to first one.  Default: false\nfunction slice_profiles(profiles,slices,closed=false) =\n  assert(is_num(slices) || is_list(slices))\n  let(listok = !is_list(slices) || len(slices)==len(profiles)-(closed?0:1))\n  assert(listok, \"Input slices to slice_profiles is a list with the wrong length\")\n  let(\n    count = is_num(slices) ? repeat(slices,len(profiles)-(closed?0:1)) : slices,\n    slicelist = [for (i=[0:len(profiles)-(closed?1:2)])\n      each lerpn(profiles[i], select(profiles,i+1), count[i]+1, false)\n    ]\n  )\n  concat(slicelist, closed?[]:[profiles[len(profiles)-1]]);\n\n\n\nfunction _closest_angle(alpha,beta) =\n    is_vector(beta) ? [for(entry=beta) _closest_angle(alpha,entry)]\n  : beta-alpha > 180 ? beta - ceil((beta-alpha-180)/360) * 360\n  : beta-alpha < -180 ? beta + ceil((alpha-beta-180)/360) * 360\n  : beta;\n\n\n// Smooth data with N point moving average.  If angle=true handles data as angles.\n// If closed=true assumes last point is adjacent to the first one.\n// If closed=false pads data with left/right value (probably wrong behavior...should do linear interp)\nfunction _smooth(data,len,closed=false,angle=false) =\n  let(  halfwidth = floor(len/2),\n        result = closed ? [for(i=idx(data))\n                           let(\n                             window = angle ? _closest_angle(data[i],select(data,i-halfwidth,i+halfwidth))\n                                            : select(data,i-halfwidth,i+halfwidth)\n                           )\n                           mean(window)]\n               : [for(i=idx(data))\n                   let(\n                       window = select(data,max(i-halfwidth,0),min(i+halfwidth,len(data)-1)),\n                       left = i-halfwidth<0,\n                       pad = left ? data[0] : last(data)\n                   )\n                   sum(window)+pad*(len-len(window))] / len\n   )\n   result;\n\n\n// Function: rot_resample()\n// Synopsis: Resample a list of rotation operators. \n// SynTags: MatList\n// Topics: Matrices, Interpolation, Rotation\n// See Also: subdivide_and_slice(), slice_profiles()\n// Usage:\n//   rlist = rot_resample(rotlist, n, [method=], [twist=], [scale=], [smoothlen=], [long=], [turns=], [closed=])\n// Description:\n//   Takes as input a list of rotation matrices in 3d.  Produces as output a resampled\n//   list of rotation operators (4x4 matrixes) suitable for use with sweep().  You can optionally apply twist to\n//   the output with the twist parameter, which is either a scalar to apply a uniform\n//   overall twist, or a vector to apply twist non-uniformly.  Similarly you can apply\n//   scaling either overall or with a vector.  The smoothlen parameter applies smoothing\n//   to the twist and scaling to prevent abrupt changes.  This is done by a moving average\n//   of the smoothing or scaling values.  The default of 1 means no smoothing.  The long parameter causes\n//   the interpolation to be done the \"long\" way around the rotation instead of the short way.\n//   Note that the rotation matrix cannot distinguish which way you rotate, only the place you\n//   end after rotation.  Another ambiguity arises if your rotation is more than 360 degrees.\n//   You can add turns with the turns parameter, so giving turns=1 will add 360 degrees to the\n//   rotation so it completes one full turn plus the additional rotation given my the transform.\n//   You can give long as a scalar or as a vector.  Finally if closed is true then the\n//   resampling will connect back to the beginning.\n//   .\n//   The default is to resample based on the length of the arc defined by each rotation operator.  This produces\n//   uniform sampling over all of the transformations.  It requires that each rotation has nonzero length.\n//   In this case n specifies the total number of samples.  If you set method to \"count\" then you get\n//   n samples for each transform.  You can set n to a vector to vary the samples at each step.\n// Arguments:\n//   rotlist = list of rotation operators in 3d to resample\n//   n = Number of rotations to produce as output when method is \"length\" or number for each transformation if method is \"count\".  Can be a vector when method is \"count\"\n//   ---\n//   method = sampling method, either \"length\" or \"count\"\n//   twist = scalar or vector giving twist to add overall or at each rotation.  Default: none\n//   scale = scalar or vector giving scale factor to add overall or at each rotation.  Default: none\n//   smoothlen = amount of smoothing to apply to scaling and twist.  Should be an odd integer.  Default: 1\n//   long = resample the \"long way\" around the rotation, a boolean or list of booleans.  Default: false\n//   turns = add extra turns.  If a scalar adds the turns to every rotation, or give a vector.  Default: 0\n//   closed = if true then the rotation list is treated as closed.  Default: false\n// Example(3D): Resampling the arc from a compound rotation with translations thrown in.\n//   tran = rot_resample([ident(4), back(5)*up(4)*xrot(-10)*zrot(-20)*yrot(117,cp=[10,0,0])], n=25);\n//   sweep(circle(r=1,$fn=3), tran);\n// Example(3D): Applying a scale factor\n//   tran = rot_resample([ident(4), back(5)*up(4)*xrot(-10)*zrot(-20)*yrot(117,cp=[10,0,0])], n=25, scale=2);\n//   sweep(circle(r=1,$fn=3), tran);\n// Example(3D): Applying twist\n//   tran = rot_resample([ident(4), back(5)*up(4)*xrot(-10)*zrot(-20)*yrot(117,cp=[10,0,0])], n=25, twist=60);\n//   sweep(circle(r=1,$fn=3), tran);\n// Example(3D): Going the long way\n//   tran = rot_resample([ident(4), back(5)*up(4)*xrot(-10)*zrot(-20)*yrot(117,cp=[10,0,0])], n=25, long=true);\n//   sweep(circle(r=1,$fn=3), tran);\n// Example(3D): Getting transformations from turtle3d\n//   include<BOSL2/turtle3d.scad>\n//   tran=turtle3d([\"arcsteps\",1,\"up\", 10, \"arczrot\", 10,170],transforms=true);\n//   sweep(circle(r=1,$fn=3),rot_resample(tran, n=40));\n// Example(3D): If you specify a larger angle in turtle you need to use the long argument\n//   include<BOSL2/turtle3d.scad>\n//   tran=turtle3d([\"arcsteps\",1,\"up\", 10, \"arczrot\", 10,270],transforms=true);\n//   sweep(circle(r=1,$fn=3),rot_resample(tran, n=40,long=true));\n// Example(3D): And if the angle is over 360 you need to add turns to get the right result.  Note long is false when the remaining angle after subtracting full turns is below 180:\n//   include<BOSL2/turtle3d.scad>\n//   tran=turtle3d([\"arcsteps\",1,\"up\", 10, \"arczrot\", 10,90+360],transforms=true);\n//   sweep(circle(r=1,$fn=3),rot_resample(tran, n=40,long=false,turns=1));\n// Example(3D): Here the remaining angle is 270, so long must be set to true\n//   include<BOSL2/turtle3d.scad>\n//   tran=turtle3d([\"arcsteps\",1,\"up\", 10, \"arczrot\", 10,270+360],transforms=true);\n//   sweep(circle(r=1,$fn=3),rot_resample(tran, n=40,long=true,turns=1));\n// Example(3D): Note the visible line at the scale transition\n//   include<BOSL2/turtle3d.scad>\n//   tran = turtle3d([\"arcsteps\",1,\"arcup\", 10, 90, \"arcdown\", 10, 90], transforms=true);\n//   rtran = rot_resample(tran,200,scale=[1,6]);\n//   sweep(circle(1,$fn=32),rtran);\n// Example(3D): Observe how using a large smoothlen value eases that transition\n//   include<BOSL2/turtle3d.scad>\n//   tran = turtle3d([\"arcsteps\",1,\"arcup\", 10, 90, \"arcdown\", 10, 90], transforms=true);\n//   rtran = rot_resample(tran,200,scale=[1,6],smoothlen=17);\n//   sweep(circle(1,$fn=32),rtran);\n// Example(3D): A similar issues can arise with twist, where a \"line\" is visible at the transition\n//   include<BOSL2/turtle3d.scad>\n//   tran = turtle3d([\"arcsteps\", 1, \"arcup\", 10, 90, \"move\", 10], transforms=true,state=[1,-.5,0]);\n//   rtran = rot_resample(tran,100,twist=[0,60],smoothlen=1);\n//   sweep(subdivide_path(rect([3,3]),40),rtran);\n// Example(3D): Here's the smoothed twist transition\n//   include<BOSL2/turtle3d.scad>\n//   tran = turtle3d([\"arcsteps\", 1, \"arcup\", 10, 90, \"move\", 10], transforms=true,state=[1,-.5,0]);\n//   rtran = rot_resample(tran,100,twist=[0,60],smoothlen=17);\n//   sweep(subdivide_path(rect([3,3]),40),rtran);\n// Example(3D): Toothed belt based on a list-comprehension-demos example.  This version has a smoothed twist transition.  Try changing smoothlen to 1 to see the more abrupt transition that occurs without smoothing.\n//   include<BOSL2/turtle3d.scad>\n//   r_small = 19;       // radius of small curve\n//   r_large = 46;       // radius of large curve\n//   flat_length = 100;  // length of flat belt section\n//   teeth=42;           // number of teeth\n//   belt_width = 12;\n//   tooth_height = 9;\n//   belt_thickness = 3;\n//   angle = 180 - 2*atan((r_large-r_small)/flat_length);\n//   beltprofile = path3d(subdivide_path(\n//                   square([belt_width, belt_thickness],anchor=FWD),\n//                   20));\n//   beltrots =\n//     turtle3d([\"arcsteps\",1,\n//               \"move\", flat_length,\n//               \"arcleft\", r_small, angle,\n//               \"move\", flat_length,\n//     // Closing path will be interpolated\n//     //        \"arcleft\", r_large, 360-angle\n//              ],transforms=true);\n//   beltpath = rot_resample(beltrots,teeth*4,\n//                           twist=[180,0,-180,0],\n//                           long=[false,false,false,true],\n//                           smoothlen=15,closed=true);\n//   belt = [for(i=idx(beltpath))\n//             let(tooth = floor((i+$t*4)/2)%2)\n//             apply(beltpath[i]*\n//                     yscale(tooth\n//                            ? tooth_height/belt_thickness\n//                            : 1),\n//                   beltprofile)\n//          ];\n//   skin(belt,slices=0,closed=true);\nfunction rot_resample(rotlist,n,twist,scale,smoothlen=1,long=false,turns=0,closed=false,method=\"length\") =\n    assert(is_int(smoothlen) && smoothlen>0 && smoothlen%2==1, \"smoothlen must be a positive odd integer\")\n    assert(method==\"length\" || method==\"count\")\n    let(tcount = len(rotlist) + (closed?0:-1))\n    assert(method==\"count\" || is_int(n), \"n must be an integer when method is \\\"length\\\"\")\n    assert(is_int(n) || is_vector(n,tcount), str(\"n must be scalar or vector with length \",tcount))\n    let(\n          count = method==\"length\" ? (closed ? n+1 : n)\n                                   : (is_vector(n) ? sum(n) : tcount*n)+1  //(closed?0:1)\n    )\n    assert(is_bool(long) || len(long)==tcount,str(\"Input long must be a scalar or have length \",tcount))\n    let(\n        long = force_list(long,tcount),\n        turns = force_list(turns,tcount),\n        T = [for(i=[0:1:tcount-1]) rot_inverse(rotlist[i])*select(rotlist,i+1)],\n        parms = [for(i=idx(T))\n                    let(tparm = rot_decode(T[i],long[i]))\n                    [tparm[0]+turns[i]*360,tparm[1],tparm[2],tparm[3]]\n                ],\n        radius = [for(i=idx(parms)) norm(parms[i][2])],\n        length = [for(i=idx(parms)) norm([norm(parms[i][3]), parms[i][0]/360*2*PI*radius[i]])]\n    )\n    assert(method==\"count\" || all_positive(length),\n           \"Rotation list includes a repeated entry or a rotation around the origin, not allowed when method=\\\"length\\\"\")\n    let(\n        cumlen = [0, each cumsum(length)],\n        totlen = last(cumlen),\n        stepsize = totlen/(count-1),\n        samples = method==\"count\"\n                  ? let( n = force_list(n,tcount))\n                    [for(N=n) lerpn(0,1,N,endpoint=false)]\n                  :[for(i=idx(parms))\n                    let(\n                        remainder = cumlen[i] % stepsize,\n                        offset = remainder==0 ? 0\n                                              : stepsize-remainder,\n                        num = ceil((length[i]-offset)/stepsize)\n                    )\n                    count(num,offset,stepsize)/length[i]],\n         twist = first_defined([twist,0]),\n         scale = first_defined([scale,1]),\n         needlast = !approx(last(last(samples)),1),\n         sampletwist = is_num(twist) ? lerpn(0,twist,count)\n                     : let(\n                          cumtwist = [0,each cumsum(twist)]\n                      )\n                      [for(i=idx(parms)) each lerp(cumtwist[i],cumtwist[i+1],samples[i]),\n                      if (needlast) last(cumtwist)\n                      ],\n         samplescale = is_num(scale) ? lerp(1,scale,lerpn(0,1,count))\n                     : let(\n                          cumscale = [1,each cumprod(scale)]\n                      )\n                      [for(i=idx(parms)) each lerp(cumscale[i],cumscale[i+1],samples[i]),\n                       if (needlast) last(cumscale)],\n         smoothtwist = _smooth(closed?select(sampletwist,0,-2):sampletwist,smoothlen,closed=closed,angle=true),\n         smoothscale = _smooth(samplescale,smoothlen,closed=closed),\n         interpolated = [\n           for(i=idx(parms))\n             each [for(u=samples[i]) rotlist[i] * move(u*parms[i][3]) * rot(a=u*parms[i][0],v=parms[i][1],cp=parms[i][2])],\n           if (needlast) last(rotlist)\n         ]\n     )\n     [for(i=idx(interpolated,e=closed?-2:-1)) interpolated[i]*zrot(smoothtwist[i])*scale(smoothscale[i])];\n\n\n\n\n\n//////////////////////////////////////////////////////////////////\n//\n// Minimum Distance Mapping using Dynamic Programming\n//\n// Given inputs of a two polygons, computes a mapping between their vertices that minimizes the sum the sum of\n// the distances between every matched pair of vertices.  The algorithm uses dynamic programming to calculate\n// the optimal mapping under the assumption that poly1[0] <-> poly2[0].  We then rotate through all the\n// possible indexings of the longer polygon.  The theoretical run time is quadratic in the longer polygon and\n// linear in the shorter one.\n//\n// The top level function, _skin_distance_match(), cycles through all the of the indexings of the larger\n// polygon, computes the optimal value for each indexing, and chooses the overall best result.  It uses\n// _dp_extract_map() to thread back through the dynamic programming array to determine the actual mapping, and\n// then converts the result to an index repetition count list, which is passed to repeat_entries().\n//\n// The function _dp_distance_array builds up the rows of the dynamic programming matrix with reference\n// to the previous rows, where `tdist` holds the total distance for a given mapping, and `map`\n// holds the information about which path was optimal for each position.\n//\n// The function _dp_distance_row constructs each row of the dynamic programming matrix in the usual\n// way where entries fill in based on the three entries above and to the left.  Note that we duplicate\n// entry zero so account for wrap-around at the ends, and we initialize the distance to zero to avoid\n// double counting the length of the 0-0 pair.\n//\n// This function builds up the dynamic programming distance array where each entry in the\n// array gives the optimal distance for aligning the corresponding subparts of the two inputs.\n// When the array is fully populated, the bottom right corner gives the minimum distance\n// for matching the full input lists.  The `map` array contains a the three key values for the three\n// directions, where _MAP_DIAG means you map the next vertex of `big` to the next vertex of `small`,\n// _MAP_LEFT means you map the next vertex of `big` to the current vertex of `small`, and _MAP_UP\n// means you map the next vertex of `small` to the current vertex of `big`.\n//\n// Return value is [min_distance, map], where map is the array that is used to extract the actual\n// vertex map.\n\n_MAP_DIAG = 0;\n_MAP_LEFT = 1;\n_MAP_UP = 2;\n\n/*\nfunction _dp_distance_array(small, big, abort_thresh=1/0, small_ind=0, tdist=[], map=[]) =\n   small_ind == len(small)+1 ? [tdist[len(tdist)-1][len(big)-1], map] :\n   let( newrow = _dp_distance_row(small, big, small_ind, tdist) )\n   min(newrow[0]) > abort_thresh ? [tdist[len(tdist)-1][len(big)-1],map] :\n   _dp_distance_array(small, big, abort_thresh, small_ind+1, concat(tdist, [newrow[0]]), concat(map, [newrow[1]]));\n*/\n\n\nfunction _dp_distance_array(small, big, abort_thresh=1/0) =\n   [for(\n        small_ind = 0,\n        tdist = [],\n        map = []\n           ;\n        small_ind<=len(small)+1\n           ;\n        newrow =small_ind==len(small)+1 ? [0,0,0] :  // dummy end case\n                           _dp_distance_row(small,big,small_ind,tdist),\n        tdist = concat(tdist, [newrow[0]]),\n        map = concat(map, [newrow[1]]),\n        small_ind = min(newrow[0])>abort_thresh ? len(small)+1 : small_ind+1\n       )\n     if (small_ind==len(small)+1) each [tdist[len(tdist)-1][len(big)], map]];\n                                     //[tdist,map]];\n\n\nfunction _dp_distance_row(small, big, small_ind, tdist) =\n                    // Top left corner is zero because it gets counted at the end in bottom right corner\n   small_ind == 0 ? [cumsum([0,for(i=[1:len(big)]) norm(big[i%len(big)]-small[0])]), repeat(_MAP_LEFT,len(big)+1)] :\n   [for(big_ind=1,\n       newrow=[ norm(big[0] - small[small_ind%len(small)]) + tdist[small_ind-1][0] ],\n       newmap = [_MAP_UP]\n         ;\n       big_ind<=len(big)+1\n         ;\n       costs = big_ind == len(big)+1 ? [0] :    // handle extra iteration\n                             [tdist[small_ind-1][big_ind-1],  // diag\n                              newrow[big_ind-1],              // left\n                              tdist[small_ind-1][big_ind]],   // up\n       newrow = concat(newrow, [min(costs)+norm(big[big_ind%len(big)]-small[small_ind%len(small)])]),\n       newmap = concat(newmap, [min_index(costs)]),\n       big_ind = big_ind+1\n   ) if (big_ind==len(big)+1) each [newrow,newmap]];\n\n\nfunction _dp_extract_map(map) =\n      [for(\n           i=len(map)-1,\n           j=len(map[0])-1,\n           smallmap=[],\n           bigmap = []\n              ;\n           j >= 0\n              ;\n           advance_i = map[i][j]==_MAP_UP || map[i][j]==_MAP_DIAG,\n           advance_j = map[i][j]==_MAP_LEFT || map[i][j]==_MAP_DIAG,\n           i = i - (advance_i ? 1 : 0),\n           j = j - (advance_j ? 1 : 0),\n           bigmap = concat( [j%(len(map[0])-1)] ,  bigmap),\n           smallmap = concat( [i%(len(map)-1)]  , smallmap)\n          )\n        if (i==0 && j==0) each [smallmap,bigmap]];\n\n\n/// Internal Function: _skin_distance_match(poly1,poly2)\n/// Usage:\n///   polys = _skin_distance_match(poly1,poly2);\n/// Description:\n///   Find a way of associating the vertices of poly1 and vertices of poly2\n///   that minimizes the sum of the length of the edges that connect the two polygons.\n///   Polygons can be in 2d or 3d.  The algorithm has cubic run time, so it can be\n///   slow if you pass large polygons.  The output is a pair of polygons with vertices\n///   duplicated as appropriate to be used as input to `skin()`.\n/// Arguments:\n///   poly1 = first polygon to match\n///   poly2 = second polygon to match\nfunction _skin_distance_match(poly1,poly2) =\n   let(\n      swap = len(poly1)>len(poly2),\n      big = swap ? poly1 : poly2,\n      small = swap ? poly2 : poly1,\n      map_poly = [ for(\n              i=0,\n              bestcost = 1/0,\n              bestmap = -1,\n              bestpoly = -1\n              ;\n              i<=len(big)\n              ;\n              shifted = list_rotate(big,i),\n              result =_dp_distance_array(small, shifted, abort_thresh = bestcost),\n              bestmap = result[0]<bestcost ? result[1] : bestmap,\n              bestpoly = result[0]<bestcost ? shifted : bestpoly,\n              best_i = result[0]<bestcost ? i : best_i,\n              bestcost = min(result[0], bestcost),\n              i=i+1\n              )\n              if (i==len(big)) each [bestmap,bestpoly,best_i]],\n      map = _dp_extract_map(map_poly[0]),\n      smallmap = map[0],\n      bigmap = map[1],\n      // These shifts are needed to handle the case when points from both ends of one curve map to a single point on the other\n      bigshift =  len(bigmap) - max(max_index(bigmap,all=true))-1,\n      smallshift = len(smallmap) - max(max_index(smallmap,all=true))-1,\n      newsmall = list_rotate(repeat_entries(small,unique_count(smallmap)[1]),smallshift),\n      newbig = list_rotate(repeat_entries(map_poly[1],unique_count(bigmap)[1]),bigshift)\n      )\n      swap ? [newbig, newsmall] : [newsmall,newbig];\n\n\n// This function associates vertices but with the assumption that index 0 is associated between the\n// two inputs.  This gives only quadratic run time.  As above, output is pair of polygons with\n// vertices duplicated as suited to use as input to skin().\n\nfunction _skin_aligned_distance_match(poly1, poly2) =\n    let(\n      result = _dp_distance_array(poly1, poly2, abort_thresh=1/0),\n      map = _dp_extract_map(result[1]),\n      shift0 = len(map[0]) - max(max_index(map[0],all=true))-1,\n      shift1 = len(map[1]) - max(max_index(map[1],all=true))-1,\n      new0 = list_rotate(repeat_entries(poly1,unique_count(map[0])[1]),shift0),\n      new1 = list_rotate(repeat_entries(poly2,unique_count(map[1])[1]),shift1)\n  )\n  [new0,new1];\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// Internal Function: _skin_tangent_match()\n/// Usage:\n///   x = _skin_tangent_match(poly1, poly2)\n/// Description:\n///   Finds a mapping of the vertices of the larger polygon onto the smaller one.  Whichever input is the\n///   shorter path is the polygon, and the longer input is the curve.  For every edge of the polygon, the algorithm seeks a plane that contains that\n///   edge and is tangent to the curve.  There will be more than one such point.  To choose one, the algorithm centers the polygon and curve on their centroids\n///   and chooses the closer tangent point.  The algorithm works its way around the polygon, computing a series of tangent points and then maps all of the\n///   points on the curve between two tangent points into one vertex of the polygon.  This algorithm can fail if the curve has too few points or if it is concave.\n/// Arguments:\n///   poly1 = input polygon\n///   poly2 = input polygon\nfunction _skin_tangent_match(poly1, poly2) =\n    let(\n        swap = len(poly1)>len(poly2),\n        big = swap ? poly1 : poly2,\n        small = swap ? poly2 : poly1,\n        curve_offset = centroid(small)-centroid(big),\n        cutpts = [for(i=[0:len(small)-1]) _find_one_tangent(big, select(small,i,i+1),curve_offset=curve_offset)],\n        shift = last(cutpts)+1,\n        newbig = list_rotate(big, shift),\n        repeat_counts = [for(i=[0:len(small)-1]) posmod(cutpts[i]-select(cutpts,i-1),len(big))],\n        newsmall = repeat_entries(small,repeat_counts)\n    )\n    assert(len(newsmall)==len(newbig), \"Tangent alignment failed, probably because of insufficient points or a concave curve\")\n    swap ? [newbig, newsmall] : [newsmall, newbig];\n\n\nfunction _find_one_tangent(curve, edge, curve_offset=[0,0,0], closed=true) =\n    let(\n        angles = [\n            for (i = [0:len(curve)-(closed?1:2)])\n            let(\n                plane = plane3pt( edge[0], edge[1], curve[i]),\n                tangent = [curve[i], select(curve,i+1)]\n            ) plane_line_angle(plane,tangent)\n        ],\n        zero_cross = [\n            for (i = [0:len(curve)-(closed?1:2)])\n            if (sign(angles[i]) != sign(select(angles,i+1)))\n            i\n        ],\n        d = [\n            for (i = zero_cross)\n            point_line_distance(curve[i]+curve_offset, edge)\n        ]\n    ) zero_cross[min_index(d)];\n\n\n// Function: associate_vertices()\n// Synopsis: Create vertex association to control how {{skin()}} links vertices. \n// SynTags: PathList\n// Topics: Extrusion, Skinning, Paths\n// See Also: skin()\n// Usage:\n//   newpoly = associate_vertices(polygons, split);\n// Description:\n//   Takes as input a list of polygons and duplicates specified vertices in each polygon in the list through the series so\n//   that the input can be passed to `skin()`.  This allows you to decide how the vertices are linked up rather than accepting\n//   the automatically computed minimal distance linkage.  However, the number of vertices in the polygons must not decrease in the list.\n//   The output is a list of polygons that all have the same number of vertices with some duplicates.  You specify the vertex splitting\n//   using the `split` which is a list where each entry corresponds to a polygon: split[i] is a value or list specifying which vertices in polygon i to split.\n//   Give the empty list if you don't want a split for a particular polygon.  If you list a vertex once then it will be split and mapped to\n//   two vertices in the next polygon.  If you list it N times then N copies will be created to map to N+1 vertices in the next polygon.\n//   You must ensure that each mapping produces the correct number of vertices to exactly map onto every vertex of the next polygon.\n//   Note that if you split (only) vertex i of a polygon that means it will map to vertices i and i+1 of the next polygon.  Vertex 0 will always\n//   map to vertex 0 and the last vertices will always map to each other, so if you want something different than that you'll need to reindex\n//   your polygons.\n// Arguments:\n//   polygons = list of polygons to split\n//   split = list of lists of split vertices\n// Example(FlatSpin,VPD=17,VPT=[0,0,2]):  If you skin together a square and hexagon using the optimal distance method you get two triangular faces on opposite sides:\n//   sq = regular_ngon(4,side=2);\n//   hex = apply(rot(15),hexagon(side=2));\n//   skin([sq,hex], slices=10, refine=10, method=\"distance\", z=[0,4]);\n// Example(FlatSpin,VPD=17,VPT=[0,0,2]):  Using associate_vertices you can change the location of the triangular faces.  Here they are connect to two adjacent vertices of the square:\n//   sq = regular_ngon(4,side=2);\n//   hex = apply(rot(15),hexagon(side=2));\n//   skin(associate_vertices([sq,hex],[[1,2]]), slices=10, refine=10, sampling=\"segment\", z=[0,4]);\n// Example(FlatSpin,VPD=17,VPT=[0,0,2]): Here the two triangular faces connect to a single vertex on the square.  Note that we had to rotate the hexagon to line them up because the vertices match counting forward, so in this case vertex 0 of the square matches to vertices 0, 1, and 2 of the hexagon.\n//   sq = regular_ngon(4,side=2);\n//   hex = apply(rot(60),hexagon(side=2));\n//   skin(associate_vertices([sq,hex],[[0,0]]), slices=10, refine=10, sampling=\"segment\", z=[0,4]);\n// Example(3D): This example shows several polygons, with only a single vertex split at each step:\n//   sq = regular_ngon(4,side=2);\n//   pent = pentagon(side=2);\n//   hex = hexagon(side=2);\n//   sep = regular_ngon(7,side=2);\n//   profiles = associate_vertices([sq,pent,hex,sep], [1,3,4]);\n//   skin(profiles ,slices=10, refine=10, method=\"distance\", z=[0,2,4,6]);\n// Example(3D): The polygons cannot shrink, so if you want to have decreasing polygons you'll need to concatenate multiple results.  Note that it is perfectly ok to duplicate a profile as shown here, where the pentagon is duplicated:\n//   sq = regular_ngon(4,side=2);\n//   pent = pentagon(side=2);\n//   grow = associate_vertices([sq,pent], [1]);\n//   shrink = associate_vertices([sq,pent], [2]);\n//   skin(concat(grow, reverse(shrink)), slices=10, refine=10, method=\"distance\", z=[0,2,2,4]);\nfunction associate_vertices(polygons, split, curpoly=0) =\n   curpoly==len(polygons)-1 ? polygons :\n   let(\n      polylen = len(polygons[curpoly]),\n      cursplit = force_list(split[curpoly])\n   )\n    assert(len(split)==len(polygons)-1,str(split,\"Split list length mismatch: it has length \", len(split),\" but must have length \",len(polygons)-1))\n    assert(polylen<=len(polygons[curpoly+1]),str(\"Polygon \",curpoly,\" has more vertices than the next one.\"))\n    assert(len(cursplit)+polylen == len(polygons[curpoly+1]),\n           str(\"Polygon \", curpoly, \" has \", polylen, \" vertices.  Next polygon has \", len(polygons[curpoly+1]),\n                  \" vertices.  Split list has length \", len(cursplit), \" but must have length \", len(polygons[curpoly+1])-polylen))\n    assert(len(cursplit) == 0 || max(cursplit)<polylen && min(curpoly)>=0,\n           str(\"Split \",cursplit,\" at polygon \",curpoly,\" has invalid vertices.  Must be in [0:\",polylen-1,\"]\"))\n    len(cursplit)==0 ? associate_vertices(polygons,split,curpoly+1) :\n    let(\n      splitindex = sort(concat(count(polylen), cursplit)),\n      newpoly = [for(i=[0:len(polygons)-1]) i<=curpoly ? select(polygons[i],splitindex) : polygons[i]]\n    )\n   associate_vertices(newpoly, split, curpoly+1);\n\n\n\n// DefineHeader(Table;Headers=Texture\u00a0Name|Type|Description): Texture Values\n\n// Section: Texturing\n//   Some operations are able to add texture to the objects they create.  A texture can be any regularly repeated variation in the height of the surface.\n//   To define a texture you need to specify how the height should vary over a rectangular block that will be repeated to tile the object.  Because textures\n//   are based on rectangular tiling, this means adding textures to curved shapes may result in distortion of the basic texture unit.  For example, if you\n//   texture a cone, the scale of the texture will be larger at the wide end of the cone and smaller at the narrower end of the cone.\n//   .\n//   You can specify a texture using to method: a height field or a VNF.  For each method you also must specify the scale of the texture, which\n//   gives the size of the rectangular unit in your object that will correspond to one texture tile.  Note that this scale does not preserve\n//   aspect ratio: you can stretch the texture as desired.  \n// Subsection: Height Field Texture Maps\n//   The simplest way to specify a texture map is to give a 2d array of\n//   height values which specify the height of the texture on a grid.\n//   Values in the height field should range from 0 to 1.  A zero height\n//   in the height field corresponds to the height of the surface and 1\n//   the highest point in the texture above the surface being textured.\n// Figure(2D,Big,NoScales,VPT=[6.21418,0.242814,0],VPD=28.8248,VPR=[0,0,0]): Here is a 2d texture described by a \"grid\" that just contains a single row.  Such a texture can be used to create ribbing. The texture is `[[0, 1, 1, 0]]`, and the fixture shows three repetitions of the basic texture unit.\n//   ftex1 = [0,1,1,0,0];\n//   stroke( transpose([count(5),ftex1]), dots=true, dots_width=3,width=.05);\n//   right(4)stroke( transpose([count(5),ftex1]), dots=true, width=.05,dots_color=\"red\",color=\"blue\",dots_width=3);\n//   right(8)stroke( transpose([count(5),ftex1]), dots=true, dots_width=3,width=.05);\n//   stroke([[4,-.3],[8,-.3]],width=.05,endcaps=\"arrow2\",color=\"black\");\n//   move([6,-.4])color(\"black\")text(\"Texture Size\", size=0.3,anchor=BACK);\n// Continues:\n//   Line segments connect the dots within the texture and also the dots between adjacent texture tiles.\n//   The size of the texture (specified with `tex_size`) includes the segment that connects the tile to the next one.\n//   Note that the grid is always uniformly spaced.\n//   By default textures are created with unit depth, meaning that the top surface\n//   of the texture is 1 unit above the surface being textured, assuming that the texture\n//   is correctly designed to span the range from 0 to 1.  The `tex_depth` parameter can adjust\n//   this dimension of a texture without changing anything else, and setting `tex_depth` negative\n//   will invert a texture.\n// Figure(2D,Big,NoScales,VPR=[0,0,0],VPT=[6.86022,-1.91238,0],VPD=28.8248):\n//   ftex1 = [0,1,1,0,0];\n//   left(0)color(.6*[1,1,1])rect([12,1],anchor=BACK+LEFT);\n//   stroke( transpose([count(5),ftex1]), dots=true, dots_width=3,width=.05);\n//   polygon( transpose([count(5),ftex1]));\n//   right(4){stroke( transpose([count(5),ftex1]), dots=true, width=.05,dots_width=3);\n//        polygon( transpose([count(5),ftex1]));\n//        }\n//   right(8){stroke( transpose([count(5),ftex1]), dots=true, dots_width=3,width=.05);\n//             polygon( transpose([count(5),ftex1]));\n//        }\n//   stroke([[12.25,0],[12.25,1]],width=.05,endcaps=\"arrow2\",color=\"black\");\n//   move([12.35,.5])color(\"black\")text(\"Depth=1\", size=0.3,anchor=LEFT);\n//   fwd(4){\n//   left(0)color(.6*[1,1,1])rect([12,1],anchor=BACK+LEFT);\n//   stroke( transpose([count(5),2*ftex1]), dots=true, dots_width=3,width=.05);\n//   polygon( transpose([count(5),2*ftex1]));\n//   right(4){stroke( transpose([count(5),2*ftex1]), dots=true, width=.05,dots_width=3);\n//        polygon( transpose([count(5),2*ftex1]));\n//        }\n//   right(8){stroke( transpose([count(5),2*ftex1]), dots=true, dots_width=3,width=.05);\n//             polygon( transpose([count(5),2*ftex1]));\n//        }\n//   stroke([[12.25,0],[12.25,2]],width=.05,endcaps=\"arrow2\",color=\"black\");\n//   move([12.35,1])color(\"black\")text(\"Depth=2\", size=0.3,anchor=LEFT);\n//   }\n// Continues:\n//   If you want to keep the texture the same size but make the slope\n//   steeper you need to add more points to make the uniform grid fine enough\n//   to represent the slope you want.  This means that creating sharp edges\n//   can require a large number of points, resulting in longer run times.\n//   When using the built-in textures you can control the number of points\n//   using the `n=` argument to {{texture()}}.  \n// Figure(2D,Big,NoScales,VPT=[6.21418,0.242814,0],VPD=28.8248,VPR=[0,0,0]):  \n//   ftex2 = xscale(4/11,transpose([count(12),[0,1,1,1,1,1,1,1,1,1,0,0]]));\n//   stroke( ftex2, dots=true, dots_width=3,width=.05);\n//   right(4)stroke( ftex2, dots=true, width=.05,dots_color=\"red\",color=\"blue\",dots_width=3);\n//   right(8)stroke( ftex2, dots=true, dots_width=3,width=.05);\n//   stroke([[4,-.3],[8,-.3]],width=.05,endcaps=\"arrow2\",color=\"black\");\n//   move([6,-.4])color(\"black\")text(\"Texture Size\", size=0.3,anchor=BACK);\n// Continues:\n//   A more serious limitation of height field textures is that some shapes, such as hexagons or circles, cannot be accurately represented because\n//   their points don't fall on any grid.  Trying to create such shapes is difficult and will require many points to approximate the\n//   true point positions for the desired shape.  This will make the texture slow to compute.  \n//   Another serious limitation is more subtle.  In the 2D examples above, it is obvious how to connect the\n//   dots together.  But in 3D example we need to triangulate the points on a grid, and this triangulation is not unique.\n//   The `style` argument lets you specify how the points are triangulated using the styles supported by {{vnf_vertex_array()}}.\n//   In the example below we have expanded the 2D example into 3D:\n//   ```openscad\n//       [[0,0,0,0],\n//        [0,1,1,0],\n//        [0,1,1,0],\n//        [0,0,0,0]]\n//   ```\n//   and we show the 3D triangulations produced by the different styles:\n// Figure(3D,Big,NoAxes,VPR=[45.5,0,18.2],VPT=[2.3442,-6.25815,3.91529],VPD=35.5861):\n//   tex = [\n//          [0,0,0,0,0],\n//          [0,1,1,0,0],\n//          [0,1,1,0,0],\n//          [0,0,0,0,0],\n//          [0,0,0,0,0]       \n//         ];\n//   hm = [for(i=[0:4]) [for(j=[0:4]) [i,-j,tex[i][j]]]];      \n//   types = [\"quincunx\", \"convex\", \"concave\",\"min_area\", \"default\",\"alt\",\"min_edge\"]; \n//   grid_copies(spacing=5, n=[4,2]){\n//     let(s = types[$row*4+$col]){\n//       if (is_def(s)){\n//       vnf_polyhedron(vnf_vertex_array(hm,style=s));\n//       if ($row==1)\n//         back(.8)right(2)rotate($vpr)color(\"black\")text(s,size=.5,anchor=CENTER);\n//       else\n//         fwd(4.7)right(2)rotate($vpr)color(\"black\")text(s,size=.5,anchor=CENTER);\n//       }\n//     }\n//   }  \n// Continues:\n//   Note that of the seven available styles, five produce a different result.  There may exist some concave shape where none of the styles\n//   produce the right result everywhere on the shape.  If this happens it would be another limitation of height field textures.  (If you have an\n//   example of such a texture and shape please let us know!)\n// Subsection: VNF Textures\n//   VNF textures overcome all of the limitations of height field textures, but with two costs.  They can be more difficult to construct than\n//   a simple array of height values, and they are significantly slower to compute for a tile with the same number of points.  Note, however, for\n//   textures that don't neatly lie on a grid, a VNF tile will be more efficient than a finely sampled height field.  With VNF textures you can create\n//   textures that have disconnected components, or concavities that cannot be expressed with a single valued height map.  However, you can also\n//   create invalid textures that fail to close at the ends, so care is required to ensure that your resulting shape is valid.  \n//   .\n//   A VNF texture is defined by defining the texture tile with a VNF whose projection onto the XY plane is contained in the unit square [0,1] x [0,1] so\n//   that the VNF can be tiled.   The VNF is tiled without a gap, matching the edges, so the vertices along corresponding edges must match to make a\n//   consistent triangulation possible.  The VNF cannot have any X or Y values outside the interval [0,1].  If you want a valid polyhedron\n//   that OpenSCAD will render then you need to take care with edges of the tiles that correspond to endcap faces in the textured object.\n//   So for example, in a linear sweep, the top and bottom edges of tiles end abruptly to form the end cap of the object.  You can make a valid object\n//   in two ways.  One way is to create a tile with a single, complete edge along Y=0, and of course a corresponding edges along Y=1.  The second way\n//   to make a valid object is to have no points at all on the Y=0 line, and of course none on Y=1.  In this case, the resulting texture produces\n//   a collection of disconnected objects.  Note that the Z coordinates of your tile can be anything, but for the dimensional settings on textures\n//   to work intuitively, you should construct your tile so that Z ranges from 0 to 1.\n// Figure(3D): This is the \"hexgrid\" VNF tile, which creates a hexagonal grid texture, something which doesn't work well with a height field because the edges of the hexagon don't align with the grid.  Note how the tile ranges between 0 and 1 in both X, Y and Z.  In fact, to get a proper aspect ratio in your final texture you need to use the `tex_size` parameter to introduct a sqrt(3) scale factor.  \n//   tex = texture(\"hex_grid\");\n//   vnf_polyhedron(tex);\n// Figure(3D): This is an example of a tile that has no edges at the top or bottom, so it creates disconnected rings.  See {{linear_sweep()}} for examples showing this tile in use.\n//   shape = skin([\n//                 rect(2/5),\n//                 rect(2/3),\n//                 rect(2/5)\n//                ],\n//                z=[0,1/2,1],\n//                slices=0,\n//                caps=false);\n//   tile = move([0,1/2,2/3],yrot(90,shape));\n//   vnf_polyhedron(tile);\n// Continues:\n//   A VNF texture provides a flat structure.  In order to apply this structure to a cylinder or other curved object, the VNF must be sliced\n//   and \"folded\" so it can follow the curve.  This folding is controlled by the `tex_samples` parameter to {{cyl()}}, {{linear_sweep()}},\n//   and {{rotate_sweep()}}.  Note that you specify it when you **use** the texture, not when you create it.  This differs from height\n//   fields, where the analogous parameter is the `n=` parameter of the {{texture()}} function.  When `tex_samples` is too small, only the\n//   points given in the VNF will follow the surface, resulting in a blocky look and geometrical artifacts.  \n// Figure(3D,Med,NoAxes): On the left the `tex_samples` value is small and the texture is blocky.  On the right, the default value of 8 allows a reasonable fit to the cylinder. \n//   xdistribute(spacing=5){\n//      cyl(d=10/PI, h=5, chamfer=0,\n//         texture=texture(\"bricks_vnf\"), tex_samples=1, tex_reps=[6,3], tex_depth=.2);\n//      cyl(d=10/PI, h=5, chamfer=0,\n//         texture=texture(\"bricks_vnf\"), tex_samples=8, tex_reps=[6,3], tex_depth=.2);\n//   }\n// Continues:\n//   Note that when the VNF is sliced,\n//   extra points can be introduced in the interior of faces leading to unexpected irregularities in the textures, which appear\n//   as extra triangles.  These artifacts can be minimized by making the VNF texture's faces as large as possible rather than using\n//   a triangulated VNF, but depending on the specific VNF texture, it may be impossible to entirely eliminate them.\n// Figure(3D,Big,NoAxes,VPR=[140.9,0,345.7],VPT=[9.48289,-0.88709,5.7837],VPD=39.5401): The left shows a normal bricks_vnf texture.  The right shows a texture that was first passed through {{vnf_triangulate()}}.  Note the extra triangle artifacts visible across the brick faces.\n//   tex = texture(\"bricks_vnf\");\n//   cyl(d=10,h=15,texture=tex, tex_reps=[4,2],tex_samples=5);\n//   up(7)fwd(-3)right(15)cyl(d=10,h=15,texture=vnf_triangulate(tex), tex_reps=[4,2],tex_samples=5);\n\n\n// Function: texture()\n// Topics: Textures, Knurling\n// Synopsis: Produce a standard texture. \n// Topics: Extrusion, Textures\n// See Also: linear_sweep(), rotate_sweep(), heightfield(), cylindrical_heightfield()\n// Usage:\n//   tx = texture(tex, [n=], [inset=], [gap=], [roughness=]);\n// Description:\n//   Given a texture name, returns a texture.  Textures can come in two varieties:\n//   - Heightfield textures which are 2D arrays of scalars.  These are usually faster to render, but can be less precise and prone to triangulation errors.  The table below gives the recommended style for the best triangulation.  If results are still incorrect, switch to the similar VNF tile by adding the \"_vnf\" suffix.\n//   - VNF Tile textures, which are VNFs that cover the unit square [0,0] x [1,1].  These tend to be slower to render, but allow greater flexibility and precision for shapes that don't align with a grid.\n//   .\n//   In the descriptions below, imagine the textures positioned on the XY plane, so \"horizontal\" refers to the \"sideways\" dimensions of the texture and\n//   \"up\" and \"down\" refer to the depth dimension, perpendicular to the surface being textured.  If a texture is placed on a cylinder the \"depth\" will become the radial direction and the \"horizontal\"\n//   direction will be the vertical and tangential directions on the cylindrical surface.  All horizontal dimensions for VNF textures are relative to the unit square\n//   on which the textures are defined, so a value of 0.25 for a gap or border will refer to 1/4 of the texture's full length and/or width.  All supported textures appear below in the examples.  \n// Arguments:\n//   tex = The name of the texture to get.\n//   ---\n//   n = The number of samples to use for defining a heightfield texture.  Depending on the texture, result will be either n x n or 1 x n.  Not allowed for VNF textures.  See the `tex_samples` argument to {{cyl()}}, {{linear_sweep()}} and {{rotate_sweep()}} for controlling the sampling of VNF textures.\n//   border = The size of a border region on some VNF tile textures.  Generally between 0 and 0.5.\n//   gap = The gap between logically distinct parts of some VNF tiles.  (ie: gap between bricks, gap between truncated ribs, etc.)\n//   roughness = The amount of roughness used on the surface of some heightfield textures.  Generally between 0 and 0.5.\n// Example(3D): **\"bricks\"** (Heightfield) = A brick-wall pattern.  Giving `n=` sets the number of heightfield samples to `n x n`.  Default: 24.  Giving `roughness=` adds a level of height randomization to add roughness to the texture.  Default: 0.05.  Use `style=\"convex\"`.\n//   tex = texture(\"bricks\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): **\"bricks_vnf\"** (VNF) = VNF version of \"bricks\".  Giving `gap=` sets the \"mortar\" gap between adjacent bricks, default 0.05.  Giving `border=` specifies that the top face of the brick is smaller than the bottom of the brick by `border` on each of the four sides.  If `gap` is zero then a `border` value close to 0.5 will cause bricks to come to a sharp pointed edge, with just a tiny flat top surface.  Note that `gap+border` must be strictly smaller than 0.5.   Default is `border=0.05`.  \n//   tex = texture(\"bricks_vnf\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): \"bricks_vnf\" texture with large border. \n//   tex = texture(\"bricks_vnf\",border=0.25);\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D,VPR=[84.4,0,4.7],VPT=[2.44496,6.53317,14.6135],VPD = 126): **\"checkers\"** (VNF) = A pattern of alternating checkerboard squares.  Giving `border=` specifies that the top face of the checker surface is smaller than the bottom by `border` on each of the four sides.  As `border` approaches 0.5 the tops come to sharp corners.  You must set `border` strictly between 0 and 0.5.  Default: 0.05.\n//   tex = texture(\"checkers\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D,VPR=[84.4,0,4.7],VPT=[2.44496,6.53317,14.6135],VPD = 126): \"checkers\" texture with large border.  \n//   tex = texture(\"checkers\",border=0.25);\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): **\"cones\"** (VNF) = Raised conical spikes.  Specify `$fn` to set the number of segments on the cone (will be rounded to a multiple of 4).  The default is `$fn=16`.  Note that `$fa` and `$fs` are ignored, since the scale of the texture is unknown at the time of definition.  Giving `border=` specifies the horizontal border width between the edge of the tile and the base of the cone.  The `border` value must be nonnegative and smaller than 0.5.  Default: 0.\n//   tex = texture(\"cones\", $fn=16);\n//   linear_sweep(\n//       rect(30), texture=tex, h=30, tex_depth=3,\n//       tex_size=[10,10]\n//   );\n// Example(3D): **\"cubes\"** (VNF) = Corner-cubes texture.  This texture needs to be scaled in vertically by sqrt(3) to have its correct aspect\n//   tex = texture(\"cubes\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): \"cubes\" texture at the correct scale.  \n//   tex = texture(\"cubes\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=20*sqrt(3), tex_depth=3,\n//       tex_size=[10,10*sqrt(3)]\n//   );\n// Example(3D): **\"diamonds\"** (Heightfield) = Four-sided pyramid with the corners of the base aligned with the axes.  Compare to \"pyramids\".  Useful for knurling.  Giving `n=` sets the number of heightfield samples to `n x n`. Default: 2.  Use `style=\"concave\"` for pointed bumps, or `style=\"default\"` or `style=\"alt\"` for a diagonal ribs.  \n//   tex = texture(\"diamonds\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10], style=\"concave\"\n//   );\n// Example(3D): \"diamonds\" texture can give diagonal ribbing with \"default\" style. \n//   tex = texture(\"diamonds\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10], style=\"default\"\n//   );\n// Example(3D): \"diamonds\" texture gives diagonal ribbing the other direction with \"alt\" style.  \n//   tex = texture(\"diamonds\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10], style=\"alt\"\n//   );\n// Example(3D): **\"diamonds_vnf\"** (VNF) = VNF version of \"diamonds\".\n//   tex = texture(\"diamonds_vnf\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): **\"dimples\"** (VNF) = Round divots.  Specify `$fn` to set the number of segments on the dimples (will be rounded to a multiple of 4).  The default is `$fn=16`.  Note that `$fa` and `$fs` are ignored, since the scale of the texture is unknown at the time of definition.  Giving `border=` specifies the horizontal width of the flat border region between the tile edges and the edge of the dimple.  Must be nonnegative and strictly less than 0.5.  Default: 0.05.  \n//   tex = texture(\"dimples\", $fn=16);\n//   linear_sweep(\n//       rect(30), texture=tex, h=30, \n//       tex_size=[10,10]\n//   );\n// Example(3D): **\"dots\"** (VNF) = Raised round bumps.  Specify `$fn` to set the number of segments on the dots (will be rounded to a multiple of 4).  The default is `$fn=16`.  Note that `$fa` and `$fs` are ignored, since the scale of the texture is unknown at the time of definition.  Giving `border=` specifies the horizontal width of the flat border region between the tile edge and the edge of the dots.  Must be nonnegative and strictly less than 0.5.  Default: 0.05.\n//   tex = texture(\"dots\", $fn=16);\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): **\"hex_grid\"** (VNF) = A hexagonal grid defined by V-grove borders.  Giving `border=` specifies that the top face of the hexagon is smaller than the bottom by `border` on the left and right sides.  This means the V-groove top width for grooves running parallel to the Y axis will be double the border value.  If the texture is scaled in the Y direction by sqrt(3) then the groove will be uniform on all six sides of the hexagon.  Border must be strictly between 0 and 0.5, default: 0.1.\n//   tex = texture(\"hex_grid\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): \"hex_grid\" texture with large border\n//   tex = texture(\"hex_grid\", border=0.4);\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): \"hex_grid\" scaled in Y by sqrt(3) so hexagons are regular and grooves are all the same width.  Note height of cube is also scaled so tile fits without being automatically adjusted to fit, ruining our choice of scale.\n//   tex = texture(\"hex_grid\",border=.07);\n//   linear_sweep(\n//       rect(30), texture=tex, h=quantup(30,10*sqrt(3)),\n//       tex_size=[10,10*sqrt(3)], tex_depth=3\n//   );\n// Example(3D): \"hex_grid\" texture, with approximate scaling because 17 is close to sqrt(3) times 10.\n//   tex = texture(\"hex_grid\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=34,\n//       tex_size=[10,17]\n//   );\n// Example(3D): **\"hills\"** (Heightfield) = Wavy sine-wave hills and valleys,  Giving `n=` sets the number of heightfield samples to `n` x `n`.  Default: 12.  Set `style=\"quincunx\"`.\n//   tex = texture(\"hills\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10], style=\"quincunx\"\n//   );\n// Example(3D): **\"pyramids\"** (Heightfield) = Four-sided pyramid with the edges of the base aligned with the axess.  Compare to \"diamonds\". Useful for knurling.  Giving `n=` sets the number of heightfield samples to `n` by `n`. Default: 2. Set style to \"convex\".  Note that style=\"concave\" or style=\"min_edge\" produce mini-diamonds with flat squares in between.\n//   tex = texture(\"pyramids\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10], style=\"convex\"\n//   );\n// Example(3D): \"pyramids\" texture, with \"concave\" produces a mini-diamond texture.  Note that \"min_edge\" also gives this result.\n//   tex = texture(\"pyramids\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10], style=\"concave\"\n//   );\n// Example(3D): **\"pyramids_vnf\"** (VNF) = VNF version of \"pyramids\".\n//   tex = texture(\"pyramids_vnf\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): **\"ribs\"** (Heightfield) = Vertically aligned triangular ribs.  Giving `n=` sets the number of heightfield samples to `n` by 1.  Default: 2.  The choice of style does not matter.\n//   tex = texture(\"ribs\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30, tex_depth=3,\n//       tex_size=[10,10], style=\"concave\"\n//   );\n// Example(3D): **\"rough\"** (Heightfield) = A pseudo-randomized rough texture.  Giving `n=` sets the number of heightfield samples to `n` by `n`.  Default: 32.  The `roughness=` parameter specifies the height of the random texture.  Default: 0.2.\n//   tex = texture(\"rough\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10], style=\"min_edge\"\n//   );\n// Example(3D): **\"tri_grid\"** (VNF) = A triangular grid defined by V-groove borders  Giving `border=` specifies that the top face of the triangular surface is smaller than the bottom by `border` along the horizontal edges (parallel to the X axis).  This means the V-groove top width of the grooves parallel to the X axis will be double the border value.  (The other grooves are wider.) If the tile is scaled in the Y direction by sqrt(3) then the groove will be uniform on the three sides of the triangle.  The border must be strictly between 0 and 1/6, default: 0.05.\n//   tex = texture(\"tri_grid\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): \"tri_grid\" texture with large border.  (Max border for tri_grid is 1/6.)  \n//   tex = texture(\"tri_grid\",border=.12);\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): \"tri_grid\" texture scaled in Y by sqrt(3) so triangles are equilateral and grooves are all the same width.  Note we have to ensure the height evenly fits the scaled texture tiles.\n//   tex = texture(\"tri_grid\",border=.04);\n//   linear_sweep(\n//       rect(30), texture=tex, h=quantup(30,10*sqrt(3)),\n//       tex_size=[10,10*sqrt(3)], tex_depth=3\n//   );\n// Example(3D): \"tri_grid\" texture.  Here scale makes Y approximately sqrt(3) larger than X so triangles are close to equilateral.\n//   tex = texture(\"tri_grid\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=34,\n//       tex_size=[10,17]\n//   );\n// Example(3D): **\"trunc_diamonds\"** (VNF) = Truncated diamonds, four-sided pyramids with the base corners aligned with the axes and the top cut off.  Or you can interpret it as V-groove lines at 45\u00ba angles.  Giving `border=` specifies that the width and height of the top surface of the diamond are smaller by `border` at the left, right, top and bottom.  The border is measured in the **horizontal** direction.  This means the V-groove width will be sqrt(2) times the border value.  The border must be strictly between 0 and sqrt(2)/4, which is about 0.35.  Default: 0.1.\n//   tex = texture(\"trunc_diamonds\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): \"trunc_diamonds\" texture with large border. \n//   tex = texture(\"trunc_diamonds\",border=.25);\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): **\"trunc_pyramids\"** (Heightfield) = Truncated pyramids, four sided pyramids with the base edges aligned to the axes and the top cut off.  Giving `n=` sets the number of heightfield samples to `n` by `n`.  Default: 6.  Set `style=\"convex\"`.\n//   tex = texture(\"trunc_pyramids\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10], style=\"convex\"\n//   );\n// Example(3D): **\"trunc_pyramids_vnf\"** (VNF) = Truncated pyramids, four sided pyramids with the base edges aligned to the axes and the top cut off.  You can also regard this as a grid of V-grooves.  Giving `border=` specifies that the top face is smaller than the top by `border` on all four sides.  This means the V-groove top width will be double the border value.  The border must be strictly between 0 and 0.5.  Default: 0.1.\n//   tex = texture(\"trunc_pyramids_vnf\");\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): \"trunc_pyramids_vnf\" texture with large border\n//   tex = texture(\"trunc_pyramids_vnf\", border=.4);\n//   linear_sweep(\n//       rect(30), texture=tex, h=30,\n//       tex_size=[10,10]\n//   );\n// Example(3D): **\"trunc_ribs\"** (Heightfield) = Truncated ribs.  Vertically aligned triangular ribs with the tops cut off, and with rib separation equal to the width of the flat tops.  Giving `n=` sets the number of heightfield samples to `n` by `1`.  Default: 4.  The style does not matter.\n//   tex = texture(\"trunc_ribs\");\n//   linear_sweep(\n//       rect(30), h=30, texture=tex,\n//       tex_depth=3, tex_size=[10,10],\n//       style=\"concave\"\n//   );\n// Example(3D): **\"trunc_ribs_vnf\"** (VNF) = Vertically aligned triangular ribs with the tops cut off.  Giving `gap=` sets the bottom gap between ribs.  Giving `border=` specifies that the top rib face is smaller than its base by `border` on both the left and right sides.  The gap measures the flat part between ribs and the border the width of the sloping portion. In order to fit, gap+2*border must be less than 1.  (This is because the gap is counted once but the border counts on both sides.)  Defaults: gap=1/4, border=1/4.\n//   tex = texture(\"trunc_ribs_vnf\", gap=0.25, border=1/6);\n//   linear_sweep(\n//       rect(30), h=30, texture=tex,\n//       tex_depth=3, tex_size=[10,10]\n//   );\n// Example(3D): **\"wave_ribs\"** (Heightfield) = Vertically aligned wavy ribs.  Giving `n=` sets the number of heightfield samples to `n` by `1`.  Default: 8.  The style does not matter.  \n//   tex = texture(\"wave_ribs\");\n//   linear_sweep(\n//       rect(30), h=30, texture=tex, \n//       tex_size=[10,10], tex_depth=3, style=\"concave\"\n//   );\n\n\nfunction _tex_fn_default() = 16;\n\n__vnf_no_n_mesg=\" texture is a VNF so it does not accept n.  Set sample rate for VNF textures using the tex_samples parameter to cyl(), linear_sweep() or rotate_sweep().\";\n\nfunction texture(tex, n, border, gap, roughness, inset) =\n    assert(num_defined([border,inset])<2, \"In texture() the 'inset' parameter has been replaced by 'border'.  You cannot give both parameters.\")\n    let(\n        border = is_def(inset)?echo(\"In texture() the argument 'inset' has been deprecated and will be removed.  Use 'border' instead\")\n                               inset\n                              :border\n    )\n    assert(is_undef(n) || all_positive([n]), \"n must be a positive value if given\")\n    assert(is_undef(border) || is_finite(border), \"border must be a number if given\")\n    assert(is_undef(gap) || is_finite(gap), \"gap must be a number if given\")\n    assert(is_undef(roughness) || all_nonnegative([roughness]), \"roughness must be a nonnegative value if given\")  \n    tex==\"ribs\"?\n        assert(num_defined([gap, border, roughness])==0, \"ribs texture does not accept gap, border or roughness\")\n\n        let(\n            n = quantup(default(n,2),2)\n        ) [[\n            each lerpn(1,0,n/2,endpoint=false),\n            each lerpn(0,1,n/2,endpoint=false),\n        ]] :\n    tex==\"trunc_ribs\"?\n        assert(num_defined([gap, border, roughness])==0, \"trunc_ribs texture does not accept gap, border or roughness\")\n        let(\n            n = quantup(default(n,4),4)\n        ) [[\n            each repeat(0,n/4),\n            each lerpn(0,1,n/4,endpoint=false),\n            each repeat(1,n/4),\n            each lerpn(1,0,n/4,endpoint=false),\n        ]] :\n    tex==\"trunc_ribs_vnf\"?\n        assert(is_undef(n), str(tex,__vnf_no_n_mesg))\n        let(\n            border = default(border,1/4)*2,\n            gap = default(gap,1/4),\n            f=echo(gap, border, gap+border, gap+2*border)\n        )\n        assert(all_nonnegative([border,gap]), \"trunc_ribs_vnf texture requires gap>=0 and border>=0\")\n        assert(gap+border <= 1, \"trunc_ribs_vnf texture requires that gap+2*border<=1\")\n        [\n            [\n               each move([0.5,0.5], p=path3d(rect([1-gap,1]),0)),\n               each move([0.5,0.5], p=path3d(rect([1-gap-border,1]),1)),\n               each path3d(square(1)),\n            ], [\n                [4,7,3,0], [1,2,6,5],\n                if (gap+border < 1-EPSILON) [4,5,6,7],\n                if (gap > EPSILON) each [[1,9,10,2], [0,3,11,8]],\n            ]\n        ] :\n    tex==\"wave_ribs\"?\n        assert(num_defined([gap, border, roughness])==0, \"wave_ribs texture does not accept gap, border or roughness\")  \n        let(\n            n = max(6,default(n,8))\n        ) [[\n            for(a=[0:360/n:360-EPSILON])\n            (cos(a)+1)/2\n        ]] :\n    tex==\"diamonds\"?\n        assert(num_defined([gap, border, roughness])==0, \"diamonds texture does not accept gap, border or roughness\")  \n        let(\n            n = quantup(default(n,2),2)\n        ) [\n            let(\n                path = [\n                    each lerpn(0,1,n/2,endpoint=false),\n                    each lerpn(1,0,n/2,endpoint=false),\n                ]\n            )\n            for (i=[0:1:n-1]) [\n                for (j=[0:1:n-1]) min(\n                    select(path,i+j),\n                    select(path,i-j)\n                )\n            ],\n        ] :\n    tex==\"diamonds_vnf\"?\n        assert(is_undef(n), str(tex,__vnf_no_n_mesg))\n        assert(num_defined([gap, border, roughness])==0, \"diamonds_vnf texture does not accept gap, border or roughness\")\n        [\n            [\n                [0,   1, 1], [1/2,   1, 0], [1,   1, 1],\n                [0, 1/2, 0], [1/2, 1/2, 1], [1, 1/2, 0],\n                [0,   0, 1], [1/2,   0, 0], [1,   0, 1],\n            ], [\n                [0,1,3], [2,5,1], [8,7,5], [6,3,7],\n                [1,5,4], [5,7,4], [7,3,4], [4,3,1],\n            ]\n        ] :\n    tex==\"pyramids\"?\n        assert(num_defined([gap, border, roughness])==0, \"pyramids texture does not accept gap, border or roughness\")\n        let(\n            n = quantup(default(n,2),2)\n        ) [\n            for (i = [0:1:n-1]) [\n                for (j = [0:1:n-1])\n                1 - (max(abs(i-n/2), abs(j-n/2)) / (n/2))\n            ]\n        ] :\n    tex==\"pyramids_vnf\"?\n        assert(is_undef(n), str(tex,__vnf_no_n_mesg))\n        assert(num_defined([gap, border, roughness])==0, \"pyramids_vnf texture does not accept gap, border or roughness\")  \n        [\n            [ [0,1,0], [1,1,0], [1/2,1/2,1], [0,0,0], [1,0,0] ],\n            [ [2,0,1], [2,1,4], [2,4,3], [2,3,0] ]\n        ] :\n    tex==\"trunc_pyramids\"?\n        assert(num_defined([gap, border, roughness])==0, \"trunc_pyramids texture does not accept gap, border or roughness\")  \n        let(\n            n = quantup(default(n,6),3)\n        ) [\n            for (i = [0:1:n-1]) [\n                for (j = [0:1:n-1])\n                (1 - (max(n/6, abs(i-n/2), abs(j-n/2)) / (n/2))) * 1.5\n            ]\n        ] :\n    tex==\"trunc_pyramids_vnf\"?\n        assert(is_undef(n), str(tex,__vnf_no_n_mesg))\n        assert(num_defined([gap, roughness])==0, \"trunc_pyramids_vnf texture does not accept gap, or roughness\")\n        let(\n            border = default(border,0.1)\n        )\n        assert(border>0 && border<.5, \"trunc_pyramids_vnf texture requires border in (0,0.5)\")\n        [\n            [\n                each path3d(square(1)),\n                each move([1/2,1/2,1], p=path3d(rect(1-2*border))),\n            ], [\n                for (i=[0:3])\n                    [i, (i+1)%4, (i+1)%4+4,i+4],\n                [4,5,6,7]\n            ]\n        ] :\n    tex==\"hills\"?\n        assert(num_defined([gap, border, roughness])==0, \"hills texture does not accept gap, border or roughness\")  \n        let(\n            n = default(n,12)\n        ) [\n            for (a=[0:360/n:359.999]) [\n                for (b=[0:360/n:359.999])\n                (cos(a)*cos(b)+1)/2\n            ]\n        ] :\n    tex==\"bricks\"?\n        assert(num_defined([gap,border])==0, \"bricks texture does not accept gap or border\")  \n        let(\n            n = quantup(default(n,24),2),\n            rough = default(roughness,0.05)\n        ) [\n            for (y = [0:1:n-1])\n            rands(-rough/2, rough/2, n, seed=12345+y*678) + [\n                for (x = [0:1:n-1])\n                (y%(n/2) <= max(1,n/16))? 0 :\n                let( even = floor(y/(n/2))%2? n/2 : 0 )\n                (x+even) % n <= max(1,n/16)? 0 : 0.5\n            ]\n        ] :\n    tex==\"bricks_vnf\"?\n        assert(is_undef(n), str(tex,__vnf_no_n_mesg))\n        assert(num_defined([roughness])==0, \"bricks_vnf texture does not accept roughness\")\n        let(\n            border = default(border,0.05),\n            gap = default(gap,0.05)\n        )\n        assert(border>=0,\"bricks_vnf texture requires nonnegative border\")\n        assert(gap>0, \"bricks_vnf requires gap greater than 0\")\n        assert(gap+border<0.5, \"bricks_vnf requires gap+border<0.5\")\n          [\n            [\n                each path3d(square(1)),\n                each move([gap/2, gap/2, 0], p=path3d(square([1-gap, 0.5-gap]))),\n                each move([gap/2+border/2, gap/2+border/2, 1], p=path3d(square([1-gap-border, 0.5-gap-border]))),\n                each move([0, 0.5+gap/2, 0], p=path3d(square([0.5-gap/2, 0.5-gap]))),\n                each move([0, 0.5+gap/2+border/2, 1], p=path3d(square([0.5-gap/2-border/2, 0.5-gap-border]))),\n                each move([0.5+gap/2, 0.5+gap/2, 0], p=path3d(square([0.5-gap/2, 0.5-gap]))),\n                each move([0.5+gap/2+border/2, 0.5+gap/2+border/2, 1], p=path3d(square([0.5-gap/2-border/2, 0.5-gap-border]))),\n            ], [\n                [0,4,7,20], [4,8,11,7], [9,8,4,5], [4,0,1,5], [10,9,5,6],\n                [20,7,6,13,12,21] ,[2,3,23,22,15,14], [15,19,18,14], [22,23,27,26], [16,19,15,12],[13,6,5,1],\n                [26,25,21,22], [8,9,10,11],[7,11,10,6],[17,16,12,13],[22,21,12,15],[16,17,18,19],[24,25,26,27],[25,24,20,21]\n            ]\n        ] :\n    tex==\"checkers\"?\n        assert(is_undef(n), str(tex,__vnf_no_n_mesg))\n        assert(num_defined([gap, roughness])==0, \"checkers texture does not accept gap, or roughness\")\n        let(\n            border = default(border,0.05)\n        )\n        assert(border>0 && border<.5, \"checkers texture requires border in (0,0.5)\")\n          [\n            [\n                each move([0,0], p=path3d(square(0.5-border),1)),\n                each move([0,0.5], p=path3d(square(0.5-border))),\n                each move([0.5,0], p=path3d(square(0.5-border))),\n                each move([0.5,0.5], p=path3d(square(0.5-border),1)),\n                [1/2-border/2,1/2-border/2,1/2], [0,1,1], [1/2-border,1,1],\n                [1/2,1,0], [1-border,1,0], [1,0,1], [1,1/2-border,1],\n                [1,1/2,0], [1,1-border,0], [1,1,1], [1/2-border/2,1-border/2,1/2],\n                [1-border/2,1-border/2,1/2], [1-border/2,1/2-border/2,1/2],\n            ], [\n                for (i=[0:4:12]) each [[i,i+1,i+2,i+3]],\n                [10,16,13,12,28,11],[9,0,3,16,10], [11,28,22,21,8],\n                [4,7,26,14,13,16], [7,6,17,18,26], [5,4,16,3,2],\n                [19,20,27,15,14,26], [20,25,27], [19,26,18],\n                [23,28,12,15,27,24], [23,22,28], [24,27,25]\n            ]\n        ] :\n    tex==\"cones\"?\n        assert(is_undef(n),str(\"To set number of segments on cones use $fn. \", tex,__vnf_no_n_mesg))\n        assert(num_defined([gap,roughness])==0, \"cones texture does not accept gap or roughness\")  \n        let(\n            border = default(border,0),\n            n = $fn > 0 ? quantup($fn,4) : _tex_fn_default()\n        )\n        assert(border>=0 && border<0.5)\n        [\n            [\n                each move([1/2,1/2], p=path3d(circle(d=1-2*border,$fn=n))),\n                [1/2,1/2,1],\n                each border>0 ? path3d(subdivide_path(square(1),refine=2,closed=true))\n                              : path3d(square(1))\n            ], [\n                for (i=[0:1:n-1]) [i, (i+1)%n, n],\n                if (border>0) for (i=[0:3]) [for(j=[(i+1)*n/4:-1:i*n/4]) j%n,\n                                            (2*i+7)%8+n+1,(2*i)%8+n+1, (2*i+1)%8+n+1],\n                if (border==0) for (i=[0:3]) [for(j=[(i+1)*n/4:-1:i*n/4]) j%n, i+n+1]\n            ]\n        ] :\n    tex==\"cubes\"?\n        assert(is_undef(n), str(tex,__vnf_no_n_mesg))\n        assert(num_defined([gap, border, roughness])==0, \"cubes texture does not accept gap, border or roughness\")  \n        [\n            [\n                [0,1,1/2], [1,1,1/2], [1/2,5/6,1], [0,4/6,0], [1,4/6,0],\n                [1/2,3/6,1/2], [0,2/6,1], [1,2/6,1], [1/2,1/6,0], [0,0,1/2],\n                [1,0,1/2],\n            ], [\n                [0,1,2], [0,2,3], [1,4,2], [2,5,3], [2,4,5],\n                [6,3,5], [4,7,5], [7,8,5], [6,5,8], [10,8,7],\n                [9,6,8], [10,9,8],\n            ]\n        ] :\n    tex==\"trunc_diamonds\"?\n        assert(is_undef(n), str(tex,__vnf_no_n_mesg))  \n        assert(num_defined([gap, roughness])==0, \"trunc_diamonds texture does not accept gap or roughness\")\n        let(\n            border = default(border,0.1)/sqrt(2)*2\n        )\n        assert(border>0 && border<0.5)\n        [\n            [\n                each move([1/2,1/2,0], p=path3d(circle(d=1,$fn=4))),\n                each move([1/2,1/2,1], p=path3d(circle(d=1-border*2,$fn=4))),\n                for (a=[0:90:359]) each move([1/2,1/2], p=zrot(-a, p=[[1/2,border,1], [border,1/2,1], [1/2,1/2,1]]))\n            ], [\n                for (i=[0:3]) each let(j=i*3+8) [\n                    [i,(i+1)%4,(i+1)%4+4,i+4],\n                    [j,j+1,j+2], [i, (i+3)%4,j+1, j], \n                ],\n                [4,5,6,7],\n            ]\n        ] :\n    tex==\"dimples\" || tex==\"dots\" ?\n        assert(is_undef(n),str(\"To set number of segments on \",tex,\" use $fn. \", tex,__vnf_no_n_mesg))\n        assert(num_defined([gap,roughness])==0, str(tex,\" texture does not accept gap or roughness\"))\n        let(\n            border = default(border,0.05),\n            n = $fn > 0 ? quantup($fn,4) : _tex_fn_default()\n        )\n        assert(border>=0 && border < 0.5)\n        let(\n            rows=ceil(n/4),\n            r=adj_ang_to_hyp(1/2-border,45),\n            dots = tex==\"dots\",\n            cp = [1/2, 1/2, r*sin(45)*(dots?-1:1)],\n            sc = 1 / (r - abs(cp.z)),\n            uverts = [\n                for (p=[0:1:rows-1], t=[0:360/n:359.999])\n                    cp + (\n                        dots? spherical_to_xyz(r, -t, 45-45*p/rows) :\n                        spherical_to_xyz(r, -t, 135+45*p/rows)\n                    ),\n                cp + r * (dots?UP:DOWN),\n                each border>0 ? path3d(subdivide_path(square(1),refine=2,closed=true))\n                              : path3d(square(1)),\n                      \n            ],\n            verts = zscale(sc, p=uverts),\n            faces = [\n                for (i=[0:1:rows-2], j=[0:1:n-1]) each [\n                    [i*n+j, i*n+(j+1)%n, (i+1)*n+(j+1)%n,(i+1)*n+j],\n                ],\n                for (i=[0:1:n-1]) [(rows-1)*n+i, (rows-1)*n+(i+1)%n, rows*n],\n                if (border>0) for (i=[0:3]) [for(j=[(i+1)*n/4:-1:i*n/4]) j%n,\n                                            (2*i+7)%8+rows*n+1,(2*i)%8+rows*n+1, (2*i+1)%8+rows*n+1],\n                if (border==0) for (i=[0:3]) [for(j=[(i+1)*n/4:-1:i*n/4]) j%n, i+rows*n+1]\n            ]\n        ) [verts, faces] :\n    tex==\"tri_grid\"?\n        assert(is_undef(n), str(tex,__vnf_no_n_mesg))  \n        assert(num_defined([gap, roughness])==0, str(tex,\" texture does not accept gap or roughness\"))  \n        let(\n            border = default(border,0.05)*sqrt(3)\n        )\n        assert(border>0 && border<sqrt(3)/6, \"tri_grid texture requires border in (0,1/6)\")\n        let(\n            adj = opp_ang_to_adj(border, 30),\n            y1 = border / adj_ang_to_opp(1,60),     // i/sqrt(3)\n            y2 = 2*y1,            // 2*i/sqrt(3)\n            y3 = 0.5 - y1,\n            y4 = 0.5 + y1,\n            y5 = 1 - y2,\n            y6 = 1 - y1\n        )\n        [\n            [\n                [0,0,0], [1,0,0],\n                [adj,y1,1], [1-adj,y1,1],\n                [0,y2,1], [1,y2,1],\n                [0.5,0.5-y2,1],\n                [0,y3,1], [0.5-adj,y3,1], [0.5+adj,y3,1], [1,y3,1],\n                [0,0.5,0], [0.5,0.5,0], [1,0.5,0],\n                [0,y4,1], [0.5-adj,y4,1], [0.5+adj,y4,1], [1,y4,1],\n                [0.5,0.5+y2,1],\n                [0,y5,1], [1,y5,1],\n                [adj,y6,1], [1-adj,y6,1],\n                [0,1,0], [1,1,0],\n            ], [\n               [0,2,3,1],\n               [21,23,24,22],\n               [2,6,3], [0,12,6,2], [1,3,6,12],\n               [0,4,8,12], [4,7,8], [8,7,11,12],\n               [1,12,9,5], [5,9,10], [10,9,12,13], \n               [11,14,15,12], [19,15,14], [19,23,12,15],\n               [16,17,13,12], [16,20,17], [12,24,20,16], \n               [21,22,18], [12,23,21,18],\n               [12,18,22,24],\n            ]\n        ] :\n    tex==\"hex_grid\"?\n        assert(is_undef(n), str(tex,__vnf_no_n_mesg))  \n        assert(num_defined([gap, roughness])==0, str(tex,\" texture does not accept gap or roughness\"))\n        let(\n            border=default(border,0.1)\n        )\n        assert(border>0 && border<0.5)\n        let(\n            diag=opp_ang_to_hyp(border,60),\n            side=adj_ang_to_opp(1,30),\n            hyp=adj_ang_to_hyp(0.5,30),\n            sc = 1/3/hyp,\n            hex=[ [1,2/6,0], [1/2,1/6,0], [0,2/6,0], [0,4/6,0], [1/2,5/6,0], [1,4/6,0] ]\n        ) [\n            [\n                each hex,\n                each move([0.5,0.5], p=yscale(sc, p=path3d(ellipse(d=1-2*border, circum=true, spin=-30,$fn=6),1))),\n                hex[0]-[0,diag*sc,-1],\n                for (ang=[270+60,270-60]) hex[1]+yscale(sc, p=cylindrical_to_xyz(diag,ang,1)),\n                hex[2]-[0,diag*sc,-1],\n                [0,0,1], [0.5-border,0,1], [0.5,0,0], [0.5+border,0,1], [1,0,1],\n                hex[3]+[0,diag*sc,1],\n                for (ang=[90+60,90-60]) hex[4]+yscale(sc, p=cylindrical_to_xyz(diag,ang,1)),\n                hex[5]+[0,diag*sc,1],\n                [0,1,1], [0.5-border,1,1], [0.5,1,0], [0.5+border,1,1], [1,1,1],\n            ], [\n                count(6,s=6),\n                for (i=[0:1:5]) [i,(i+1)%6, (i+1)%6+6, i+6],\n                [20,19,13,12], [17,16,15,14],\n                [21,25,26,22], [23,28,29,24],\n                [0,12,13,1], [1,14,15,2],\n                [3,21,22,4], [4,23,24,5],\n                [1,13,19,18], [1,18,17,14], \n                [4,22,26,27], [4,27,28,23],\n            ]\n        ] :\n    tex==\"rough\"?\n        assert(num_defined([gap,border])==0, str(tex,\" texture does not accept gap or border\"))\n        let(\n            n = default(n,32),\n            rough = default(roughness, 0.2)\n        ) [\n            for (y = [0:1:n-1])\n            rands(0, rough, n, seed=123456+29*y)\n        ] :\n    assert(false, str(\"Unrecognized texture name: \", tex));\n\n\n/// Function&Module: _textured_linear_sweep()\n/// Usage: As Function\n///   vnf = _textured_linear_sweep(region, texture, tex_size, h, ...);\n///   vnf = _textured_linear_sweep(region, texture, counts=, h=, ...);\n/// Usage: As Module\n///   _textured_linear_sweep(region, texture, tex_size, h, ...) [ATTACHMENTS];\n///   _textured_linear_sweep(region, texture, counts=, h=, ...) [ATTACHMENTS];\n/// Topics: Sweep, Extrusion, Textures, Knurling\n/// See Also: heightfield(), cylindrical_heightfield(), texture()\n/// Description:\n///   Given a [[Region|regions.scad]], creates a linear extrusion of it vertically, optionally twisted, scaled, and/or shifted,\n///   with a given texture tiled evenly over the side surfaces.  The texture can be given in one of three ways:\n///   - As a texture name string. (See {{texture()}} for supported named textures.)\n///   - As a 2D array of evenly spread height values. (AKA a heightfield.)\n///   - As a VNF texture tile.  A VNF tile exactly defines a surface from `[0,0]` to `[1,1]`, with the Z coordinates\n///     being the height of the texture point from the surface.  VNF tiles MUST be able to tile in both X and Y\n///     directions with no gaps, with the front and back edges aligned exactly, and the left and right edges as well.\n///   . \n///   One script to convert a grayscale image to a texture heightfield array in a .scad file can be found at:\n///   https://raw.githubusercontent.com/BelfrySCAD/BOSL2/master/scripts/img2scad.py\n/// Arguments:\n///   region = The [[Region|regions.scad]] to sweep/extrude.\n///   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0), or a VNF tile that defines the texture to apply to vertical surfaces.  See {{texture()}} for what named textures are supported.\n///   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`\n///   h / l = The height to extrude/sweep the path.\n///   ---\n///   counts = If given instead of tex_size, gives the tile repetition counts for textures over the surface length and height.\n///   inset = If numeric, lowers the texture into the surface by that amount, before the tex_scale multiplier is applied.  If `true`, insets by exactly `1`.  Default: `false`\n///   rot = If true, rotates the texture 90\u00ba.\n///   tex_scale = Scaling multiplier for the texture depth.\n///   twist = Degrees of twist for the top of the extrustion/sweep, compared to the bottom.  Default: 0\n///   scale = Scaling multiplier for the top of the extrustion/sweep, compared to the bottom.  Default: 1\n///   shift = [X,Y] amount to translate the top, relative to the bottom.  Default: [0,0]\n///   style = The triangulation style used.  See {{vnf_vertex_array()}} for valid styles.  Used only with heightfield type textures. Default: `\"min_edge\"`\n///   samples = Minimum number of \"bend points\" to have in VNF texture tiles.  Default: 8\n///   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n///   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n///   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n/// Extra Anchors:\n///   centroid_top = The centroid of the top of the shape, oriented UP.\n///   centroid = The centroid of the center of the shape, oriented UP.\n///   centroid_bot = The centroid of the bottom of the shape, oriented DOWN.\n\nfunction _get_vnf_tile_edges(texture) =\n    let(\n        verts = texture[0],\n        faces = texture[1],\n        everts = [for (v = verts) (v.x==0 || v.y==0 || v.x==1 || v.y==1)],\n        uc = unique_count([\n            for (face = faces, i = idx(face))\n            let(edge = select(face,i,i+1), i1 = min(edge), i2 = max(edge))\n            if (everts[i1] && everts[i2])\n            [i1, i2]\n        ]),\n        edges = uc[0], counts = uc[1],\n        uedges = [for (i = idx(edges)) if (counts[i] == 1) edges[i] ]\n    ) uedges;\n\n\nfunction _validate_texture(texture) =\n    is_vnf(texture)\n      ? let( // Validate VNF tile texture\n            bounds = pointlist_bounds(texture[0]),\n            min_xy = point2d(bounds[0]),\n            max_xy = point2d(bounds[1])\n        )\n        //assert(min_xy==[0,0] && max_xy==[1,1],\"VNF tiles must span exactly from [0,0] to [1,1] in the X and Y components.\"))\n        assert(all_nonnegative(concat(min_xy,[1,1]-max_xy)), \"VNF tile X and Y components must be between 0 and 1.\")\n        let(\n            verts = texture[0],\n            uedges = _get_vnf_tile_edges(texture),\n            edge_verts = [for (i = unique(flatten(uedges))) verts[i] ],\n            hverts = [for(v = edge_verts) if(v.x==0 || v.x==1) v],\n            vverts = [for(v = edge_verts) if(v.y==0 || v.y==1) v],\n            allgoodx = all(hverts, function(v) any(hverts, function(w) approx(w,[1-v.x, v.y, v.z]))),\n            allgoody = all(vverts, function(v) any(vverts, function(w) approx(w,[v.x, 1-v.y, v.z])))\n        )\n        assert(allgoodx && allgoody, \"All VNF tile edge vertices must line up with a vertex on the opposite side of the tile.\")\n        true\n      : // Validate heightfield texture.\n        assert(is_matrix(texture), \"Malformed texture.\")\n        let( tex_dim = list_shape(texture) )\n        assert(len(tex_dim) == 2, \"Heightfield texture must be a 2D square array of scalar heights.\")\n        assert(all_defined(tex_dim), \"Heightfield texture must be a 2D square array of scalar heights.\")\n        true;\n\n\nfunction _textured_linear_sweep(\n    region, texture, tex_size=[5,5],\n    h, counts, inset=false, rot=0,\n    tex_scale=1, twist, scale, shift,\n    style=\"min_edge\", l, caps=true, \n    height, length, samples,\n    anchor=CENTER, spin=0, orient=UP\n) =\n    assert(is_path(region,[2]) || is_region(region))\n    assert(is_undef(samples) || is_int(samples))\n    assert(counts==undef || is_vector(counts,2))\n    assert(tex_size==undef || is_vector(tex_size,2))\n    assert(is_bool(rot) || in_list(rot,[0,90,180,270]))\n    assert(is_bool(caps) || is_bool_list(caps,2))\n    let(\n        caps = is_bool(caps) ? [caps,caps] : caps,\n        regions = is_path(region,2)? [[region]] : region_parts(region),\n        tex = is_string(texture)? texture(texture,$fn=_tex_fn_default()) : texture,\n        dummy = assert(is_undef(samples) || is_vnf(tex), \"You gave the tex_samples argument with a heightfield texture, which is not permitted.  Use the n= argument to texture() instead\"),\n        dummy2=is_bool(rot)?echo(\"boolean value for tex_rot is deprecated.  Use a numerical angle, one of 0, 90, 180, or 270.\")0:0,\n        texture = !rot? tex :\n            is_vnf(tex)? zrot(is_num(rot)?rot:90, cp=[1/2,1/2], p=tex) :\n            rot==180? reverse([for (row=tex) reverse(row)]) :\n            rot==270? [for (row=transpose(tex)) reverse(row)] :\n            reverse(transpose(tex)),\n        h = first_defined([h, l, height, length, 1]),\n        inset = is_num(inset)? inset : inset? 1 : 0,\n        twist = default(twist, 0),\n        shift = default(shift, [0,0]),\n        scale = scale==undef? [1,1,1] :\n            is_num(scale)? [scale,scale,1] : scale,\n        samples = !is_vnf(texture)? len(texture[0]) :\n            is_num(samples)? samples : 8,\n        check_tex = _validate_texture(texture),\n        sorted_tile =\n            !is_vnf(texture)? texture :\n            let(\n                s = 1 / max(1, samples),\n                vnf = samples<=1? texture :\n                    let(\n                        vnft = vnf_slice(texture, \"X\", list([s:s:1-s/2])),\n                        zvnf = [\n                            [\n                                for (p=vnft[0]) [\n                                    approx(p.x,0)? 0 : approx(p.x,1)? 1 : p.x,\n                                    approx(p.y,0)? 0 : approx(p.y,1)? 1 : p.y,\n                                    p.z\n                                ]\n                            ],\n                            vnft[1]\n                        ]\n                    ) zvnf\n            ) _vnf_sort_vertices(vnf, idx=[1,0]),\n        vertzs = !is_vnf(sorted_tile)? undef :\n            group_sort(sorted_tile[0], idx=1),\n        tpath = is_vnf(sorted_tile)\n            ? _find_vnf_tile_edge_path(sorted_tile,0)\n            : let(\n                  row = sorted_tile[0],\n                  rlen = len(row)\n              ) [for (i = [0:1:rlen]) [i/rlen, row[i%rlen]]],\n        tmat = scale(scale) * zrot(twist) * up(h/2),\n        pre_skew_vnf = vnf_join([\n            for (rgn = regions) let(\n                walls_vnf = vnf_join([\n                    for (path = rgn) let(\n                        path = reverse(path),\n                        plen = path_length(path, closed=true),\n                        counts = is_vector(counts,2)? counts :\n                            is_vector(tex_size,2)\n                              ? [round(plen/tex_size.x), max(1,round(h/tex_size.y)), ]\n                              : [ceil(6*plen/h), 6],\n                        obases = resample_path(path, n=counts.x * samples, closed=true),\n                        onorms = path_normals(obases, closed=true),\n                        bases = list_wrap(obases),\n                        norms = list_wrap(onorms),\n                        vnf = is_vnf(texture)\n                          ? let( // VNF tile texture\n                                row_vnf = vnf_join([\n                                    for (j = [0:1:counts.x-1]) [\n                                        [\n                                            for (group = vertzs)\n                                            each [\n                                                for (vert = group) let(\n                                                    u = floor((j + vert.x) * samples),\n                                                    uu = ((j + vert.x) * samples) - u,\n                                                    texh = tex_scale<0 ? -(1-vert.z - inset) * tex_scale\n                                                                       : (vert.z - inset) * tex_scale,\n                                                    base = lerp(bases[u], select(bases,u+1), uu),\n                                                    norm = unit(lerp(norms[u], select(norms,u+1), uu)),\n                                                    xy = base + norm * texh\n                                                ) point3d(xy,vert.y)\n                                            ]\n                                        ],\n                                        sorted_tile[1]\n                                    ]\n                                ]),\n                                sorted_row = _vnf_sort_vertices(row_vnf, idx=[1,0]),\n                                rvertzs = group_sort(sorted_row[0], idx=1),\n                                vnf1 = vnf_join([\n                                    for (i = [0:1:counts.y-1]) [\n                                        [\n                                            for (group = rvertzs) let(\n                                                v = (i + group[0].z) / counts.y,\n                                                sc = lerp([1,1,1], scale, v),\n                                                mat = scale(sc) *\n                                                    zrot(twist*v) *\n                                                    up(((i/counts.y)-0.5)*h) *\n                                                    zscale(h/counts.y)\n                                            ) each apply(mat, group)\n                                        ],\n                                        sorted_row[1]\n                                    ]\n                                ])\n                            ) vnf1\n                          : let( // Heightfield texture\n                                texcnt = [len(texture[0]), len(texture)],\n                                tile_rows = [\n                                    for (ti = [0:1:texcnt.y-1])\n                                    path3d([\n                                        for (j = [0:1:counts.x])\n                                        for (tj = [0:1:texcnt.x-1])\n                                        if (j != counts.x || tj == 0)\n                                        let(\n                                            part = (j + (tj/texcnt.x)) * samples,\n                                            u = floor(part),\n                                            uu = part - u,\n                                            texh = tex_scale<0 ? -(1-texture[ti][tj] - inset) * tex_scale\n                                                               : (texture[ti][tj] - inset) * tex_scale,\n                                            base = lerp(bases[u], select(bases,u+1), uu),\n                                            norm = unit(lerp(norms[u], select(norms,u+1), uu)),\n                                            xy = base + norm * texh\n                                        ) xy\n                                    ])\n                                ],\n                                tiles = [\n                                    for (i = [0:1:counts.y], ti = [0:1:texcnt.y-1])\n                                    if (i != counts.y || ti == 0)\n                                    let(\n                                        v = (i + (ti/texcnt.y)) / counts.y,\n                                        sc = lerp([1, 1, 1], scale, v),\n                                        mat = up((v-0.5)*h) *\n                                              scale(sc) *\n                                              zrot(twist*v)\n                                    ) apply(mat, tile_rows[(texcnt.y-ti)%texcnt.y])\n                                ]\n                            ) vnf_vertex_array(\n                                tiles, caps=false, style=style,\n                                col_wrap=true, row_wrap=false,\n                                reverse=true\n                            )\n                    ) vnf\n                ]),\n                brgn = [\n                    for (path = rgn) let(\n                        path = reverse(path),\n                        plen = path_length(path, closed=true),\n                        counts = is_vector(counts,2)? counts :\n                            is_vector(tex_size,2)\n                              ? [round(plen/tex_size.x), max(1,round(h/tex_size.y)), ]\n                              : [ceil(6*plen/h), 6],\n                        obases = resample_path(path, n=counts.x * samples, closed=true),\n                        onorms = path_normals(obases, closed=true),\n                        bases = list_wrap(obases),\n                        norms = list_wrap(onorms),\n                        nupath = [\n                            for (j = [0:1:counts.x-1], vert = tpath) let(\n                                part = (j + vert.x) * samples,\n                                u = floor(part),\n                                uu = part - u,\n                                texh = tex_scale<0 ? -(1-vert.y - inset) * tex_scale\n                                                   : (vert.y - inset) * tex_scale,\n                                base = lerp(bases[u], select(bases,u+1), uu),\n                                norm = unit(lerp(norms[u], select(norms,u+1), uu)),\n                                xy = base + norm * texh\n                            ) xy\n                        ]\n                    ) nupath\n                ],\n                bot_vnf = !caps[0] || brgn==[[]] ? EMPTY_VNF\n                    : vnf_from_region(brgn, down(h/2), reverse=true),\n                top_vnf = !caps[1] || brgn==[[]] ? EMPTY_VNF\n                    : vnf_from_region(brgn, tmat, reverse=false)\n            ) vnf_join([walls_vnf, bot_vnf, top_vnf])\n        ]),\n        skmat = down(h/2) * skew(sxz=shift.x/h, syz=shift.y/h) * up(h/2),\n        final_vnf = apply(skmat, pre_skew_vnf),\n        cent = centroid(region),\n        anchors = [\n            named_anchor(\"centroid_top\", point3d(cent, h/2), UP),\n            named_anchor(\"centroid\",     point3d(cent),      UP),\n            named_anchor(\"centroid_bot\", point3d(cent,-h/2), DOWN)\n        ]\n    ) reorient(anchor,spin,orient, vnf=final_vnf, extent=true, anchors=anchors, p=final_vnf);\n\n\n\nfunction _find_vnf_tile_edge_path(vnf, val) =\n    let(\n        verts = vnf[0],\n        fragments = [\n            for(edge = _get_vnf_tile_edges(vnf))\n            let(v0 = verts[edge[0]], v1 = verts[edge[1]])\n            if (approx(v0.y, val) && approx(v1.y, val))\n            v0.x <= v1.x? [[v0.x,v0.z], [v1.x,v1.z]] :\n            [[v1.x,v1.z], [v0.x,v0.z]]\n        ],\n        sfrags = sort(fragments, idx=[0,1]),\n        rpath = _assemble_a_path_from_fragments(sfrags)[0],\n        opath = rpath==[]? []\n              : rpath[0].x > last(rpath).x ? reverse(rpath)\n              : rpath\n    ) opath;\n\n\n/// Function&Module: _textured_revolution()\n/// Usage: As Function\n///   vnf = _textured_revolution(shape, texture, tex_size, [tex_scale=], ...);\n///   vnf = _textured_revolution(shape, texture, counts=, [tex_scale=], ...);\n/// Usage: As Module\n///   _textured_revolution(shape, texture, tex_size, [tex_scale=], ...) [ATTACHMENTS];\n///   _textured_revolution(shape, texture, counts=, [tex_scale=], ...) [ATTACHMENTS];\n/// Topics: Sweep, Extrusion, Textures, Knurling\n/// See Also: heightfield(), cylindrical_heightfield(), texture()\n/// Description:\n///   Given a 2D region or path, fully in the X+ half-plane, revolves that shape around the Z axis (after rotating its Y+ to Z+).\n///   This creates a solid from that surface of revolution, possibly capped top and bottom, with the sides covered in a given tiled texture.\n///   The texture can be given in one of three ways:\n///   - As a texture name string. (See {{texture()}} for supported named textures.)\n///   - As a 2D array of evenly spread height values. (AKA a heightfield.)\n///   - As a VNF texture tile.  A VNF tile exactly defines a surface from `[0,0]` to `[1,1]`, with the Z coordinates\n///     being the height of the texture point from the surface.  VNF tiles MUST be able to tile in both X and Y\n///     directions with no gaps, with the front and back edges aligned exactly, and the left and right edges as well.\n///   .\n///   One script to convert a grayscale image to a texture heightfield array in a .scad file can be found at:\n///   https://raw.githubusercontent.com/BelfrySCAD/BOSL2/master/scripts/img2scad.py\n/// Arguments:\n///   shape = The path or region to sweep/extrude.\n///   texture = A texture name string, or a rectangular array of scalar height values (0.0 to 1.0), or a VNF tile that defines the texture to apply to the revolution surface.  See {{texture()}} for what named textures are supported.\n///   tex_size = An optional 2D target size for the textures.  Actual texture sizes will be scaled somewhat to evenly fit the available surface. Default: `[5,5]`\n///   tex_scale = Scaling multiplier for the texture depth.\n///   ---\n///   inset = If numeric, lowers the texture into the surface by that amount, before the tex_scale multiplier is applied.  If `true`, insets by exactly `1`.  Default: `false`\n///   rot = If true, rotates the texture 90\u00ba.\n///   shift = [X,Y] amount to translate the top, relative to the bottom.  Default: [0,0]\n///   closed = If false, and shape is given as a path, then the revolved path will be sealed to the axis of rotation with untextured caps.  Default: `true`\n///   taper = If given, and `closed=false`, tapers the texture height to zero over the first and last given percentage of the path.  If given as a lookup table with indices between 0 and 100, uses the percentage lookup table to ramp the texture heights.  Default: `undef` (no taper)\n///   angle = The number of degrees counter-clockwise from X+ to revolve around the Z axis.  Default: `360`\n///   style = The triangulation style used.  See {{vnf_vertex_array()}} for valid styles.  Used only with heightfield type textures. Default: `\"min_edge\"`\n///   counts = If given instead of tex_size, gives the tile repetition counts for textures over the surface length and height.\n///   samples = Minimum number of \"bend points\" to have in VNF texture tiles.  Default: 8\n///   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n///   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n///   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n/// Anchor Types:\n///   \"hull\" = Anchors to the virtual convex hull of the shape.\n///   \"intersect\" = Anchors to the surface of the shape.\n\nfunction _textured_revolution(\n    shape, texture, tex_size, tex_scale=1,\n    inset=false, rot=false, shift=[0,0],\n    taper, closed=true, angle=360,\n    counts, samples,\n    style=\"min_edge\", atype=\"intersect\",\n    anchor=CENTER, spin=0, orient=UP\n) = \n    assert(angle>0 && angle<=360)\n    assert(is_path(shape,[2]) || is_region(shape))\n    assert(is_undef(samples) || is_int(samples))\n    assert(is_bool(closed))\n    assert(counts==undef || is_vector(counts,2))\n    assert(tex_size==undef || is_vector(tex_size,2))\n    assert(is_bool(rot) || in_list(rot,[0,90,180,270]))\n    let( taper_is_ok = is_undef(taper) || (is_finite(taper) && taper>=0 && taper<50) || is_path(taper,2) )\n    assert(taper_is_ok, \"Bad taper= value.\")\n    assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\")\n    let(\n        regions = !is_path(shape,2)? region_parts(shape) :\n            closed? region_parts([shape]) :\n            let(\n                clpoly = [[0,shape[0].y], each shape, [0,last(shape).y]],\n                dpoly = deduplicate(clpoly),\n                cwpoly = is_polygon_clockwise(dpoly) ? dpoly : reverse(dpoly)\n            )\n            [[ select(cwpoly,1,-2) ]],\n        checks = [\n            for (rgn=regions, path=rgn)\n            assert(all(path, function(pt) pt.x>=0))\n        ]\n    )\n    assert(closed || is_path(shape,2))\n    let(\n        tex = is_string(texture)? texture(texture,$fn=_tex_fn_default()) : texture,\n        dummy = assert(is_undef(samples) || is_vnf(tex), \"You gave the tex_samples argument with a heightfield texture, which is not permitted.  Use the n= argument to texture() instead\"),\n        dummy2=is_bool(rot)?echo(\"boolean value for tex_rot is deprecated.  Use a numerical angle, one of 0, 90, 180, or 270.\")0:0,        \n        texture = !rot? tex :\n            is_vnf(tex)? zrot(is_num(rot)?rot:90, cp=[1/2,1/2], p=tex) :\n            rot==180? reverse([for (row=tex) reverse(row)]) :\n            rot==270? [for (row=transpose(tex)) reverse(row)] :\n            reverse(transpose(tex)),\n        check_tex = _validate_texture(texture),\n        inset = is_num(inset)? inset : inset? 1 : 0,\n        samples = !is_vnf(texture)? len(texture) :\n            is_num(samples)? samples : 8,\n        bounds = pointlist_bounds(flatten(flatten(regions))),\n        maxx = bounds[1].x,\n        miny = bounds[0].y,\n        maxy = bounds[1].y,\n        h = maxy - miny,\n        circumf = 2 * PI * maxx,\n        tile = !is_vnf(texture)? texture :\n            let(\n                utex = samples<=1? texture :\n                    let(\n                        s = 1 / samples,\n                        slices = list([s : s : 1-s/2]),\n                        vnfx = vnf_slice(texture, \"X\", slices),\n                        vnfy = vnf_slice(vnfx, \"Y\", slices),\n                        vnft = vnf_triangulate(vnfy),\n                        zvnf = [\n                            [\n                                for (p=vnft[0]) [\n                                    approx(p.x,0)? 0 : approx(p.x,1)? 1 : p.x,\n                                    approx(p.y,0)? 0 : approx(p.y,1)? 1 : p.y,\n                                    p.z\n                                ]\n                            ],\n                            vnft[1]\n                        ]\n                    ) zvnf\n            ) _vnf_sort_vertices(utex, idx=[0,1]),\n        vertzs = is_vnf(texture)? group_sort(tile[0], idx=0) : undef,\n        bpath = is_vnf(tile)\n            ? _find_vnf_tile_edge_path(tile,1)\n            : let(\n                  row = tile[0],\n                  rlen = len(row)\n              ) [for (i = [0:1:rlen]) [i/rlen, row[i%rlen]]],\n        counts_x = is_vector(counts,2)? counts.x :\n            is_vector(tex_size,2)\n              ? max(1,round(angle/360*circumf/tex_size.x))\n              : ceil(6*angle/360*circumf/h),\n        taper_lup = closed || is_undef(taper)? [[-1,1],[2,1]] :\n            is_num(taper)? [[-1,0], [0,0], [taper/100+EPSILON,1], [1-taper/100-EPSILON,1], [1,0], [2,0]] :\n            is_path(taper,2)? let(\n                retaper = [\n                    for (t=taper)\n                    assert(t[0]>=0 && t[0]<=100, \"taper lookup indices must be between 0 and 100 inclusive.\")\n                    [t[0]/100, t[1]]\n                ],\n                taperout = [[-1,retaper[0][1]], each retaper, [2,last(retaper)[1]]]\n            ) taperout :\n            assert(false, \"Bad taper= argument value.\"),\n        full_vnf = vnf_join([\n            for (rgn = regions) let(\n                rgn_wall_vnf = vnf_join([\n                    for (path = rgn) let(\n                        plen = path_length(path, closed=closed),\n                        counts_y = is_vector(counts,2)? counts.y :\n                            is_vector(tex_size,2)? max(1,round(plen/tex_size.y)) : 6,\n                        obases = resample_path(path, n=counts_y * samples + (closed?0:1), closed=closed),\n                        onorms = path_normals(obases, closed=closed),\n                        rbases = closed? list_wrap(obases) : obases,\n                        rnorms = closed? list_wrap(onorms) : onorms,\n                        bases = xrot(90, p=path3d(rbases)),\n                        norms = xrot(90, p=path3d(rnorms)),\n                        vnf = is_vnf(texture)\n                          ? vnf_join([ // VNF tile texture\n                                for (j = [0:1:counts_y-1])\n                                [\n                                    [\n                                        for (group = vertzs) each [\n                                            for (vert = group) let(\n                                                part = (j + (1-vert.y)) * samples,\n                                                u = floor(part),\n                                                uu = part - u,\n                                                base = lerp(select(bases,u), select(bases,u+1), uu),\n                                                norm = unit(lerp(select(norms,u), select(norms,u+1), uu)),\n                                                tex_scale = tex_scale * lookup(part/samples/counts_y, taper_lup),\n                                                texh = tex_scale<0 ? -(1-vert.z - inset) * tex_scale * (base.x / maxx)\n                                                                   : (vert.z - inset) * tex_scale * (base.x / maxx),\n                                                xyz = base - norm * texh\n                                            ) zrot(vert.x*angle/counts_x, p=xyz)\n                                        ]\n                                    ],\n                                    tile[1]\n                                ]\n                            ])\n                          : let( // Heightfield texture\n                                texcnt = [len(texture[0]), len(texture)],\n                                tiles = transpose([\n                                    for (j = [0,1], tj = [0:1:texcnt.x-1])\n                                    if (j == 0 || tj == 0)\n                                    let(\n                                        v = (j + (tj/texcnt.x)) / counts_x,\n                                        mat = zrot(v*angle)\n                                    ) apply(mat, [\n                                        for (i = [0:1:counts_y-(closed?1:0)], ti = [0:1:texcnt.y-1])\n                                        if (i != counts_y || ti == 0)\n                                        let(\n                                            part = (i + (ti/texcnt.y)) * samples,\n                                            u = floor(part),\n                                            uu = part - u,\n                                            base = lerp(bases[u], select(bases,u+1), uu),\n                                            norm = unit(lerp(norms[u], select(norms,u+1), uu)),\n                                            tex_scale = tex_scale * lookup(part/samples/counts_y, taper_lup),\n                                            texh = tex_scale<0 ? -(1-texture[ti][tj] - inset) * tex_scale * (base.x / maxx)\n                                                               : (texture[ti][tj] - inset) * tex_scale * (base.x / maxx),\n                                            xyz = base - norm * texh\n                                        ) xyz\n                                    ])\n                                ])\n                            ) vnf_vertex_array(\n                                tiles, caps=false, style=style,\n                                col_wrap=false, row_wrap=closed\n                            )\n                    ) vnf\n                ]),\n                walls_vnf = vnf_join([\n                    for (i = [0:1:counts_x-1])\n                    zrot(i*angle/counts_x, rgn_wall_vnf)\n                ]),\n                endcap_vnf = angle == 360? EMPTY_VNF :\n                    let(\n                        cap_rgn = [\n                            for (path = rgn) let(\n                                plen = path_length(path, closed=closed),\n                                counts_y = is_vector(counts,2)? counts.y :\n                                    is_vector(tex_size,2)? max(1,round(plen/tex_size.y)) : 6,\n                                obases = resample_path(path, n=counts_y * samples + (closed?0:1), closed=closed),\n                                onorms = path_normals(obases, closed=closed),\n                                bases = closed? list_wrap(obases) : obases,\n                                norms = closed? list_wrap(onorms) : onorms,\n                                ppath = is_vnf(texture)\n                                  ? [ // VNF tile texture\n                                        for (j = [0:1:counts_y-1])\n                                        for (group = vertzs, vert = reverse(group))\n                                        if (approx(vert.x, 0)) let(\n                                            part = (j + (1 - vert.y)) * samples,\n                                            u = floor(part),\n                                            uu = part - u,\n                                            base = lerp(select(bases,u), select(bases,u+1), uu),\n                                            norm = unit(lerp(select(norms,u), select(norms,u+1), uu)),\n                                            tex_scale = tex_scale * lookup(part/samples/counts_y, taper_lup),\n                                            texh = tex_scale<0 ? -(1-vert.z - inset) * tex_scale * (base.x / maxx)\n                                                               : (vert.z - inset) * tex_scale * (base.x / maxx),\n                                            xyz = base - norm * texh\n                                        ) xyz\n                                    ]\n                                  : let( // Heightfield texture\n                                        texcnt = [len(texture[0]), len(texture)]\n                                    ) [\n                                        for (i = [0:1:counts_y-(closed?1:0)], ti = [0:1:texcnt.y-1])\n                                        if (i != counts_y || ti == 0)\n                                        let(\n                                            part = (i + (ti/texcnt.y)) * samples,\n                                            u = floor(part),\n                                            uu = part - u,\n                                            base = lerp(bases[u], select(bases,u+1), uu),\n                                            norm = unit(lerp(norms[u], select(norms,u+1), uu)),\n                                            tex_scale = tex_scale * lookup(part/samples/counts_y, taper_lup),\n                                            texh = tex_scale<0 ? -(1-texture[ti][0] - inset) * tex_scale * (base.x / maxx)\n                                                               : (texture[ti][0] - inset) * tex_scale * (base.x / maxx),\n                                            xyz = base - norm * texh\n                                        ) xyz\n                                    ],\n                                path = closed? ppath : [\n                                    [0, ppath[0].y],\n                                    each ppath,\n                                    [0, last(ppath).y],\n                                ]\n                            ) deduplicate(path, closed=closed)\n                        ],\n                        vnf2 = vnf_from_region(cap_rgn, xrot(90), reverse=false),\n                        vnf3 = vnf_from_region(cap_rgn, rot([90,0,angle]), reverse=true)\n                    ) vnf_join([vnf2, vnf3]),\n                allcaps_vnf = closed? EMPTY_VNF :\n                    let(\n                        plen = path_length(rgn[0], closed=closed),\n                        counts_y = is_vector(counts,2)? counts.y :\n                            is_vector(tex_size,2)? max(1,round(plen/tex_size.y)) : 6,\n                        obases = resample_path(rgn[0], n=counts_y * samples + (closed?0:1), closed=closed),\n                        onorms = path_normals(obases, closed=closed),\n                        rbases = closed? list_wrap(obases) : obases,\n                        rnorms = closed? list_wrap(onorms) : onorms,\n                        bases = xrot(90, p=path3d(rbases)),\n                        norms = xrot(90, p=path3d(rnorms)),\n                        caps_vnf = vnf_join([\n                            for (j = [-1,0]) let(\n                                base = select(bases,j),\n                                norm = unit(select(norms,j)),\n                                ppath = [\n                                    for (vert = bpath) let(\n                                        uang = vert.x / counts_x,\n                                        tex_scale = tex_scale * lookup([0,1][j+1], taper_lup),\n                                        texh = tex_scale<0 ? -(1-vert.y - inset) * tex_scale * (base.x / maxx)\n                                                           : (vert.y - inset) * tex_scale * (base.x / maxx),\n                                        xyz = base - norm * texh\n                                    ) zrot(angle*uang, p=xyz)\n                                ],\n                                pplen = len(ppath),\n                                zed = j<0? max(column(ppath,2)) :\n                                    min(column(ppath,2)),\n                                slice_vnf = [\n                                    [\n                                        each ppath,\n                                        [0, 0, zed],\n                                    ], [\n                                        for (i = [0:1:pplen-2])\n                                            j<0? [pplen, i, (i+1)%pplen] :\n                                            [pplen, (i+1)%pplen, i]\n                                    ]\n                                ],\n                                cap_vnf = vnf_join([\n                                    for (i = [0:1:counts_x-1])\n                                        zrot(i*angle/counts_x, p=slice_vnf)\n                                ])\n                            ) cap_vnf\n                        ])\n                    ) caps_vnf\n            ) vnf_join([walls_vnf, endcap_vnf, allcaps_vnf])\n        ]),\n        skmat = down(-miny) * skew(sxz=shift.x/h, syz=shift.y/h) * up(-miny),\n        skvnf = apply(skmat, full_vnf),\n        geom = atype==\"intersect\"\n              ? attach_geom(vnf=skvnf, extent=false)\n              : attach_geom(vnf=skvnf, extent=true)\n    ) reorient(anchor,spin,orient, geom=geom, p=skvnf);\n\n\nmodule _textured_revolution(\n    shape, texture, tex_size, tex_scale=1,\n    inset=false, rot=false, shift=[0,0],\n    taper, closed=true, angle=360,\n    style=\"min_edge\", atype=\"intersect\",\n    convexity=10, counts, samples,\n    anchor=CENTER, spin=0, orient=UP\n) {\n    dummy = assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\");\n    vnf = _textured_revolution(\n        shape, texture, tex_size=tex_size,\n        tex_scale=tex_scale, inset=inset, rot=rot,\n        taper=taper, closed=closed, style=style,\n        shift=shift, angle=angle,\n        samples=samples, counts=counts\n    );\n    geom = atype==\"intersect\"\n          ? attach_geom(vnf=vnf, extent=false)\n          : attach_geom(vnf=vnf, extent=true);\n    attachable(anchor,spin,orient, geom=geom) {\n        vnf_polyhedron(vnf, convexity=convexity);\n        children();\n    }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-39", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: sliders.scad\n//   Simple V-groove based sliders and rails.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/sliders.scad>\n// FileGroup: Parts\n// FileSummary: Simple sliders and rails.\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Modules\n\n\n// Module: slider()\n// Synopsis: Creates a V-groove slider.\n// SynTags: Geom\n// Topics: Parts, Sliders\n// See Also: rail()\n// Usage:\n//   slider(l, w, h, [base=], [wall=], [ang=], [$slop=]) [ATTACHMENTS];\n// Description:\n//   Creates a slider to match a V-groove rail.\n// Arguments:\n//   l = Length (long axis) of slider.\n//   w = Width of slider.\n//   h = Height of slider.\n//   ---\n//   base = Height of slider base.\n//   wall = Width of wall behind each side of the slider.\n//   ang = Overhang angle for slider, to facilitate supportless printig.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value to make parts fit just right.\n// Example:\n//   slider(l=30, base=10, wall=4, $slop=0.2, spin=90);\nfunction slider(l=30, w=10, h=10, base=10, wall=5, ang=30, anchor=BOTTOM, spin=0, orient=UP) = no_function(\"slider\");\nmodule slider(l=30, w=10, h=10, base=10, wall=5, ang=30, anchor=BOTTOM, spin=0, orient=UP)\n{\n    full_width = w + 2*wall;\n    full_height = h + base;\n\n    attachable(anchor,spin,orient, size=[full_width, l, h+2*base]) {\n        zrot(90)\n        down(base+h/2) {\n            // Base\n            cuboid([full_width, l, base-get_slop()], chamfer=2, edges=[FRONT,BACK], except_edges=BOT, anchor=BOTTOM);\n\n            // Wall\n            xflip_copy(offset=w/2+get_slop()) {\n                cuboid([wall, l, full_height], chamfer=2, edges=RIGHT, except_edges=BOT, anchor=BOTTOM+LEFT);\n            }\n\n            // Sliders\n            up(base+h/2) {\n                xflip_copy(offset=w/2+get_slop()+0.02) {\n                    bev_h = h/2*tan(ang);\n                    prismoid([h, l], [0, l-w], h=bev_h+0.01, orient=LEFT, anchor=BOT);\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n\n// Module: rail()\n// Synopsis: Creates a V-groove rail.\n// SynTags: Geom\n// Topics: Parts, Sliders\n// See Also: slider()\n// Usage:\n//   rail(l, w, h, [chamfer=], [ang=]) [ATTACHMENTS];\n// Description:\n//   Creates a V-groove rail.\n// Arguments:\n//   l = Length (long axis) of slider.\n//   w = Width of slider.\n//   h = Height of slider.\n//   chamfer = Size of chamfer at end of rail.\n//   ang = Overhang angle for slider, to facilitate supportless printing.\n//   ---\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `BOTTOM`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example:\n//   rail(l=100, w=10, h=10);\nfunction rail(l=30, w=10, h=10, chamfer=1.0, ang=30, anchor=BOTTOM, spin=0, orient=UP) = no_function(\"rail\");\nmodule rail(l=30, w=10, h=10, chamfer=1.0, ang=30, anchor=BOTTOM, spin=0, orient=UP)\n{\n    attack_ang = 30;\n    attack_len = 2;\n\n    fudge = 1.177;\n    chamf = sqrt(2) * chamfer;\n    cosa = cos(ang*fudge);\n    sina = sin(ang*fudge);\n\n    z1 = h/2;\n    z2 = z1 - chamf * cosa;\n    z3 = z1 - attack_len * sin(attack_ang);\n    z4 = 0;\n\n    x1 = w/2;\n    x2 = x1 - chamf * sina;\n    x3 = x1 - chamf;\n    x4 = x1 - attack_len * sin(attack_ang);\n    x5 = x2 - attack_len * sin(attack_ang);\n    x6 = x1 - z1 * sina;\n    x7 = x4 - z1 * sina;\n\n    y1 = l/2;\n    y2 = y1 - attack_len * cos(attack_ang);\n\n    attachable(anchor,spin,orient, size=[w, l, h]) {\n        polyhedron(\n            convexity=4,\n            points=[\n                [-x5, -y1,  z3],\n                [ x5, -y1,  z3],\n                [ x7, -y1,  z4],\n                [ x4, -y1, -z1-0.05],\n                [-x4, -y1, -z1-0.05],\n                [-x7, -y1,  z4],\n\n                [-x3, -y2,  z1],\n                [ x3, -y2,  z1],\n                [ x2, -y2,  z2],\n                [ x6, -y2,  z4],\n                [ x1, -y2, -z1-0.05],\n                [-x1, -y2, -z1-0.05],\n                [-x6, -y2,  z4],\n                [-x2, -y2,  z2],\n\n                [ x5,  y1,  z3],\n                [-x5,  y1,  z3],\n                [-x7,  y1,  z4],\n                [-x4,  y1, -z1-0.05],\n                [ x4,  y1, -z1-0.05],\n                [ x7,  y1,  z4],\n\n                [ x3,  y2,  z1],\n                [-x3,  y2,  z1],\n                [-x2,  y2,  z2],\n                [-x6,  y2,  z4],\n                [-x1,  y2, -z1-0.05],\n                [ x1,  y2, -z1-0.05],\n                [ x6,  y2,  z4],\n                [ x2,  y2,  z2],\n            ],\n            faces=[\n                [0, 1, 2],\n                [0, 2, 5],\n                [2, 3, 4],\n                [2, 4, 5],\n\n                [0, 13, 6],\n                [0, 6, 7],\n                [0, 7, 1],\n                [1, 7, 8],\n                [1, 8, 9],\n                [1, 9, 2],\n                [2, 9, 10],\n                [2, 10, 3],\n                [3, 10, 11],\n                [3, 11, 4],\n                [4, 11, 12],\n                [4, 12, 5],\n                [5, 12, 13],\n                [5, 13, 0],\n\n                [14, 15, 16],\n                [14, 16, 19],\n                [16, 17, 18],\n                [16, 18, 19],\n\n                [14, 27, 20],\n                [14, 20, 21],\n                [14, 21, 15],\n                [15, 21, 22],\n                [15, 22, 23],\n                [15, 23, 16],\n                [16, 23, 24],\n                [16, 24, 17],\n                [17, 24, 25],\n                [17, 25, 18],\n                [18, 25, 26],\n                [18, 26, 19],\n                [19, 26, 27],\n                [19, 27, 14],\n\n                [6, 21, 20],\n                [6, 20, 7],\n                [7, 20, 27],\n                [7, 27, 8],\n                [8, 27, 26],\n                [8, 26, 9],\n                [9, 26, 25],\n                [9, 25, 10],\n                [10, 25, 24],\n                [10, 24, 11],\n                [11, 24, 23],\n                [11, 23, 12],\n                [12, 23, 22],\n                [12, 22, 13],\n                [13, 22, 21],\n                [13, 21, 6],\n            ]\n        );\n        children();\n    }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-40", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: std.scad\n//   File that includes the standard BOSL include files.\n// Includes:\n//   include <BOSL2/std.scad>\n//////////////////////////////////////////////////////////////////////\n\nassert(version_num()>=20190500, \"BOSL2 requires OpenSCAD version 2019.05 or later.\");\n\ninclude <version.scad>\n\ninclude <constants.scad>\ninclude <transforms.scad>\ninclude <distributors.scad>\ninclude <mutators.scad>\ninclude <color.scad>\ninclude <attachments.scad>\ninclude <shapes3d.scad>\ninclude <shapes2d.scad>\ninclude <drawing.scad>\ninclude <masks3d.scad>\ninclude <masks2d.scad>\ninclude <math.scad>\ninclude <paths.scad>\ninclude <lists.scad>\ninclude <comparisons.scad>\ninclude <linalg.scad>\ninclude <trigonometry.scad>\ninclude <vectors.scad>\ninclude <affine.scad>\ninclude <coords.scad>\ninclude <geometry.scad>\ninclude <regions.scad>\ninclude <strings.scad>\ninclude <skin.scad>\ninclude <vnf.scad>\ninclude <utility.scad>\ninclude <partitions.scad>\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-41", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: strings.scad\n//   String manipulation and formatting functions.\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Data Management\n// FileSummary: String manipulation functions.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Extracting substrings\n\n// Function: substr()\n// Synopsis: Returns a substring from a string.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip()\n// Usage:\n//   newstr = substr(str, [pos], [len]);\n// Description:\n//   Returns a substring from a string start at position `pos` with length `len`, or\n//   if `len` isn't given, the rest of the string.\n// Arguments:\n//   str = string to operate on\n//   pos = starting index of substring, or vector of first and last position.  Default: 0\n//   len = length of substring, or omit it to get the rest of the string.  If len is zero or less then the emptry string is returned.\n// Example:\n//   substr(\"abcdefg\",3,3);     // Returns \"def\"\n//   substr(\"abcdefg\",2);       // Returns \"cdefg\"\n//   substr(\"abcdefg\",len=3);   // Returns \"abc\"\n//   substr(\"abcdefg\",[2,4]);   // Returns \"cde\"\n//   substr(\"abcdefg\",len=-2);  // Returns \"\"\nfunction substr(str, pos=0, len=undef) =\n    is_list(pos) ? _substr(str, pos[0], pos[1]-pos[0]+1) :\n    len == undef ? _substr(str, pos, len(str)-pos) :\n    _substr(str,pos,len);\n\nfunction _substr(str,pos,len,substr=\"\") =\n    len <= 0 || pos>=len(str) ? substr :\n    _substr(str, pos+1, len-1, str(substr, str[pos]));\n\n\n// Function: suffix()\n// Synopsis: Returns the last few characters of a string.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip()\n// Usage:\n//   newstr = suffix(str,len);\n// Description:\n//   Returns the last `len` characters from the input string `str`.\n//   If `len` is longer than the length of `str`, then the entirety of `str` is returned.\n// Arguments:\n//   str = The string to get the suffix of.\n//   len = The number of characters of suffix to get.\nfunction suffix(str,len) =\n    len>=len(str)? str : substr(str, len(str)-len,len);\n\n\n\n// Section: String Searching\n\n\n// Function: str_find()\n// Synopsis: Finds a substring in a string.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip()\n// Usage:\n//   ind = str_find(str,pattern,[last=],[all=],[start=]);\n// Description:\n//   Searches input string `str` for the string `pattern` and returns the index or indices of the matches in `str`.\n//   By default `str_find()` returns the index of the first match in `str`.  If `last` is true then it returns the index of the last match.\n//   If the pattern is the empty string the first match is at zero and the last match is the last character of the `str`.\n//   If `start` is set then the search begins at index start, working either forward and backward from that position.  If you set `start`\n//   and `last` is true then the search will find the pattern if it begins at index `start`.  If no match exists, returns `undef`.\n//   If you set `all` to true then `str_find()` returns all of the matches in a list, or an empty list if there are no matches.\n// Arguments:\n//   str = String to search.\n//   pattern = string pattern to search for\n//   ---\n//   last = set to true to return the last match. Default: false\n//   all = set to true to return all matches as a list.  Overrides last.  Default: false\n//   start = index where the search starts\n// Example:\n//   str_find(\"abc123def123abc\",\"123\");   // Returns 3\n//   str_find(\"abc123def123abc\",\"b\");     // Returns 1\n//   str_find(\"abc123def123abc\",\"1234\");  // Returns undef\n//   str_find(\"abc\",\"\");                  // Returns 0\n//   str_find(\"abc123def123\", \"123\", start=4);     // Returns 9\n//   str_find(\"abc123def123abc\",\"123\",last=true);  // Returns 9\n//   str_find(\"abc123def123abc\",\"b\",last=true);    // Returns 13\n//   str_find(\"abc123def123abc\",\"1234\",last=true); // Returns undef\n//   str_find(\"abc\",\"\",last=true);                 // Returns 3\n//   str_find(\"abc123def123\", \"123\", start=8, last=true));  // Returns 3\n//   str_find(\"abc123def123abc\",\"123\",all=true);   // Returns [3,9]\n//   str_find(\"abc123def123abc\",\"b\",all=true);     // Returns [1,13]\n//   str_find(\"abc123def123abc\",\"1234\",all=true);  // Returns []\n//   str_find(\"abc\",\"\",all=true);                  // Returns [0,1,2]\nfunction str_find(str,pattern,start=undef,last=false,all=false) =\n    all? _str_find_all(str,pattern) :\n    let( start = first_defined([start,last?len(str)-len(pattern):0]) )\n    pattern==\"\"? start :\n    last? _str_find_last(str,pattern,start) :\n    _str_find_first(str,pattern,len(str)-len(pattern),start);\n\nfunction _str_find_first(str,pattern,max_sindex,sindex) =\n    sindex<=max_sindex && !substr_match(str,sindex, pattern)?\n        _str_find_first(str,pattern,max_sindex,sindex+1) :\n        (sindex <= max_sindex ? sindex : undef);\n\nfunction _str_find_last(str,pattern,sindex) =\n    sindex>=0 && !substr_match(str,sindex, pattern)?\n        _str_find_last(str,pattern,sindex-1) :\n        (sindex >=0 ? sindex : undef);\n\nfunction _str_find_all(str,pattern) =\n    pattern == \"\" ? count(len(str)) :\n    [for(i=[0:1:len(str)-len(pattern)]) if (substr_match(str,i,pattern)) i];\n\n// Function: substr_match()\n// Synopsis: Returns true if the string `pattern` matches the string `str`.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip()\n// Usage\n//   bool = substr_match(str,start,pattern);\n// Description:\n//   Returns true if the string `pattern` matches the string `str` starting\n//   at `str[start]`.  If the string is too short for the pattern, or\n//   `start` is out of bounds \u2013 either negative or beyond the end of the\n//   string \u2013 then substr_match returns false.\n// Arguments:\n//   str = String to search\n//   start = Starting index for search in str\n//   pattern = String pattern to search for\n// Examples:\n//   substr_match(\"abcde\",2,\"cd\");   // Returns true\n//   substr_match(\"abcde\",2,\"cx\");   // Returns false\n//   substr_match(\"abcde\",2,\"cdef\"); // Returns false\n//   substr_match(\"abcde\",-2,\"cd\");  // Returns false\n//   substr_match(\"abcde\",19,\"cd\");  // Returns false\n//   substr_match(\"abc\",1,\"\");       // Returns true\n\n//\n//    This is carefully optimized for speed.  Precomputing the length\n//    cuts run time in half when the string is long.  Two other string\n//    comparison methods were slower.\nfunction substr_match(str,start,pattern) =\n     len(str)-start <len(pattern)? false\n   : _substr_match_recurse(str,start,pattern,len(pattern));\n\nfunction _substr_match_recurse(str,sindex,pattern,plen,pindex=0,) =\n    pindex < plen && pattern[pindex]==str[sindex]\n       ? _substr_match_recurse(str,sindex+1,pattern,plen,pindex+1)\n       : (pindex==plen);\n\n\n// Function: starts_with()\n// Synopsis: Returns true if the string starts with a given substring.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip()\n// Usage:\n//    bool = starts_with(str,pattern);\n// Description:\n//    Returns true if the input string `str` starts with the specified string pattern, `pattern`.\n//    Otherwise returns false.\n// Arguments:\n//   str = String to search.\n//   pattern = String pattern to search for.\n// Example:\n//   starts_with(\"abcdef\",\"abc\");  // Returns true\n//   starts_with(\"abcdef\",\"def\");  // Returns false\n//   starts_with(\"abcdef\",\"\");     // Returns true\nfunction starts_with(str,pattern) = substr_match(str,0,pattern);\n\n\n// Function: ends_with()\n// Synopsis: Returns true if the string ends with a given substring.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip()\n// Usage:\n//    bool = ends_with(str,pattern);\n// Description:\n//    Returns true if the input string `str` ends with the specified string pattern, `pattern`.\n//    Otherwise returns false.\n// Arguments:\n//   str = String to search.\n//   pattern = String pattern to search for.\n// Example:\n//   ends_with(\"abcdef\",\"def\");  // Returns true\n//   ends_with(\"abcdef\",\"de\");   // Returns false\n//   ends_with(\"abcdef\",\"\");     // Returns true\nfunction ends_with(str,pattern) = substr_match(str,len(str)-len(pattern),pattern);\n\n\n\n// Function: str_split()\n// Synopsis: Splits a longer string wherever a given substring occurs.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip()\n// Usage:\n//   string_list = str_split(str, sep, [keep_nulls]);\n// Description:\n//   Breaks an input string into substrings using a separator or list of separators.  If keep_nulls is true\n//   then two sequential separator characters produce an empty string in the output list.  If keep_nulls is false\n//   then no empty strings are included in the output list.\n//   .\n//   If sep is a single string then each character in sep is treated as a delimiting character and the input string is\n//   split at every delimiting character.  Empty strings can occur whenever two delimiting characters are sequential.\n//   If sep is a list of strings then the input string is split sequentially using each string from the list in order.\n//   If keep_nulls is true then the output will have length equal to `len(sep)+1`, possibly with trailing null strings\n//   if the string runs out before the separator list.\n// Arguments:\n//   str = String to split.\n//   sep = a string or list of strings to use for the separator\n//   keep_nulls = boolean value indicating whether to keep null strings in the output list.  Default: true\n// Example:\n//   str_split(\"abc+def-qrs*iop\",\"*-+\");     // Returns [\"abc\", \"def\", \"qrs\", \"iop\"]\n//   str_split(\"abc+*def---qrs**iop+\",\"*-+\");// Returns [\"abc\", \"\", \"def\", \"\", \"\", \"qrs\", \"\", \"iop\", \"\"]\n//   str_split(\"abc      def\",\" \");          // Returns [\"abc\", \"\", \"\", \"\", \"\", \"\", \"def\"]\n//   str_split(\"abc      def\",\" \",keep_nulls=false);  // Returns [\"abc\", \"def\"]\n//   str_split(\"abc+def-qrs*iop\",[\"+\",\"-\",\"*\"]);     // Returns [\"abc\", \"def\", \"qrs\", \"iop\"]\n//   str_split(\"abc+def-qrs*iop\",[\"-\",\"+\",\"*\"]);     // Returns [\"abc+def\", \"qrs*iop\", \"\", \"\"]\nfunction str_split(str,sep,keep_nulls=true) =\n    !keep_nulls ? _remove_empty_strs(str_split(str,sep,keep_nulls=true)) :\n    is_list(sep) ? _str_split_recurse(str,sep,i=0,result=[]) :\n    let( cutpts = concat([-1],sort(flatten(search(sep, str,0))),[len(str)]))\n    [for(i=[0:len(cutpts)-2]) substr(str,cutpts[i]+1,cutpts[i+1]-cutpts[i]-1)];\n\nfunction _str_split_recurse(str,sep,i,result) =\n    i == len(sep) ? concat(result,[str]) :\n    let(\n        pos = search(sep[i], str),\n        end = pos==[] ? len(str) : pos[0]\n    )\n    _str_split_recurse(\n        substr(str,end+1),\n        sep, i+1,\n        concat(result, [substr(str,0,end)])\n    );\n\nfunction _remove_empty_strs(list) =\n    list_remove(list, search([\"\"], list,0)[0]);\n\n\n\n// Section: String modification\n\n\n// Function: str_join()\n// Synopsis: Joints a list of strings into a single string.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip()\n// Usage:\n//   str = str_join(list, [sep]);\n// Description:\n//   Returns the concatenation of a list of strings, optionally with a\n//   separator string inserted between each string on the list.\n// Arguments:\n//   list = list of strings to concatenate\n//   sep = separator string to insert.  Default: \"\"\n// Example:\n//   str_join([\"abc\",\"def\",\"ghi\"]);        // Returns \"abcdefghi\"\n//   str_join([\"abc\",\"def\",\"ghi\"], \" + \");  // Returns \"abc + def + ghi\"\nfunction str_join(list,sep=\"\",_i=0, _result=\"\") =\n    _i >= len(list)-1 ? (_i==len(list) ? _result : str(_result,list[_i])) :\n    str_join(list,sep,_i+1,str(_result,list[_i],sep));\n\n\n\n\n// Function: str_strip()\n// Synopsis: Strips given leading and trailing characters from a string.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip()\n// Usage:\n//   str = str_strip(s,c,[start],[end]);\n// Description:\n//   Takes a string `s` and strips off all leading and/or trailing characters that exist in string `c`.\n//   By default strips both leading and trailing characters.  If you set start or end to true then\n//   it will strip only the leading or trailing characters respectively.  If you set start\n//   or end to false then it will strip only lthe trailing or leading characters.\n// Arguments:\n//   s = The string to strip leading or trailing characters from.\n//   c = The string of characters to strip.\n//   start = if true then strip leading characters\n//   end = if true then strip trailing characters\n// Example:\n//   str_strip(\"--##--123--##--\",\"#-\");  // Returns: \"123\"\n//   str_strip(\"--##--123--##--\",\"-\");   // Returns: \"##--123--##\"\n//   str_strip(\"--##--123--##--\",\"#\");   // Returns: \"--##--123--##--\"\n//   str_strip(\"--##--123--##--\",\"#-\",end=true);  // Returns: \"--##--123\"\n//   str_strip(\"--##--123--##--\",\"-\",end=true);   // Returns: \"--##--123--##\"\n//   str_strip(\"--##--123--##--\",\"#\",end=true);   // Returns: \"--##--123--##--\"\n//   str_strip(\"--##--123--##--\",\"#-\",start=true); // Returns: \"123--##--\"\n//   str_strip(\"--##--123--##--\",\"-\",start=true);  // Returns: \"##--123--##--\"\n//   str_strip(\"--##--123--##--\",\"#\",start=true);  // Returns: \"--##--123--##--\"\n\nfunction _str_count_leading(s,c,_i=0) =\n    (_i>=len(s)||!in_list(s[_i],[each c]))? _i :\n    _str_count_leading(s,c,_i=_i+1);\n\nfunction _str_count_trailing(s,c,_i=0) =\n    (_i>=len(s)||!in_list(s[len(s)-1-_i],[each c]))? _i :\n    _str_count_trailing(s,c,_i=_i+1);\n\nfunction str_strip(s,c,start,end) =\n  let(\n      nstart = (is_undef(start) && !end) ? true : start,\n      nend = (is_undef(end) && !start) ? true : end,\n      startind = nstart ? _str_count_leading(s,c) : 0,\n      endind = len(s) - (nend ? _str_count_trailing(s,c) : 0)\n  )\n  substr(s,startind, endind-startind);\n\n\n\n// Function: str_pad()\n// Synopsis: Pads a string to a given length.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip()\n// Usage:\n//   padded = str_pad(str, length, char, [left]);\n// Description:\n//   Pad the given string `str` with to length `length` with the specified character,\n//   which must be a length 1 string.  If left is true then pad on the left, otherwise\n//   pad on the right.  If the string is longer than the specified length the full string\n//   is returned unchanged.\n// Arguments:\n//   str = string to pad\n//   length = length to pad to\n//   char = character to pad with.  Default: \" \" (space)\n//   left = if true, pad on the left side.  Default: false\nfunction str_pad(str,length,char=\" \",left=false) =\n  assert(is_str(str))\n  assert(is_str(char) && len(char)==1, \"char must be a single character string\")\n  assert(is_bool(left))\n  let(\n    padding = str_join(repeat(char,length-len(str)))\n  )\n  left ? str(padding,str) : str(str,padding);\n\n\n\n// Function: str_replace_char()\n// Synopsis: Replace given chars in a string with another substring.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip()\n// Usage:\n//   newstr = str_replace_char(str, char, replace);\n// Description:\n//   Replace every occurence of `char` in the input string with the string `replace` which\n//   can be any string.\nfunction str_replace_char(str,char,replace) =\n   assert(is_str(str))\n   assert(is_str(char) && len(char)==1, \"Search pattern 'char' must be a single character string\")\n   assert(is_str(replace))\n   str_join([for(c=str) c==char ? replace : c]);\n\n\n// Function: downcase()\n// Synopsis: Lowercases all characters in a string.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip(), upcase(), downcase()\n// Usage:\n//   newstr = downcase(str);\n// Description:\n//   Returns the string with the standard ASCII upper case letters A-Z replaced\n//   by their lower case versions.\n// Arguments:\n//   str = String to convert.\n// Example:\n//   downcase(\"ABCdef\");   // Returns \"abcdef\"\nfunction downcase(str) =\n    str_join([for(char=str) let(code=ord(char)) code>=65 && code<=90 ? chr(code+32) : char]);\n\n\n// Function: upcase()\n// Synopsis: Uppercases all characters in a string.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip(), upcase(), downcase()\n// Usage:\n//   newstr = upcase(str);\n// Description:\n//   Returns the string with the standard ASCII lower case letters a-z replaced\n//   by their upper case versions.\n// Arguments:\n//   str = String to convert.\n// Example:\n//   upcase(\"ABCdef\");   // Returns \"ABCDEF\"\nfunction upcase(str) =\n    str_join([for(char=str) let(code=ord(char)) code>=97 && code<=122 ? chr(code-32) : char]);\n\n\n// Section: Random strings\n\n// Function: rand_str()\n// Synopsis: Create a randomized string.\n// Topics: Strings\n// See Also: suffix(), str_find(), substr_match(), starts_with(), ends_with(), str_split(), str_join(), str_strip(), upcase(), downcase()\n// Usage:\n//    str = rand_str(n, [charset], [seed]);\n// Description:\n//    Produce a random string of length `n`.  If you give a string `charset` then the\n//    characters of the random string are drawn from that list, weighted by the number\n//    of times each character appears in the list.  If you do not give a character set\n//    then the string is generated with characters ranging from 0 to z (based on\n//    character code).\nfunction rand_str(n, charset, seed) =\n  is_undef(charset)? str_join([for(c=rand_int(48,122,n,seed)) chr(c)])\n                   : str_join([for(i=rand_int(0,len(charset)-1,n,seed)) charset[i]]);\n\n\n\n// Section: Parsing strings into numbers\n\n// Function: parse_int()\n// Synopsis: Parse an integer from a string.\n// Topics: Strings\n// See Also: parse_int(), parse_float(), parse_frac(), parse_num()\n// Usage:\n//   num = parse_int(str, [base])\n// Description:\n//   Converts a string into an integer with any base up to 16.  Returns NaN if\n//   conversion fails.  Digits above 9 are represented using letters A-F in either\n//   upper case or lower case.\n// Arguments:\n//   str = String to convert.\n//   base = Base for conversion, from 2-16.  Default: 10\n// Example:\n//   parse_int(\"349\");        // Returns 349\n//   parse_int(\"-37\");        // Returns -37\n//   parse_int(\"+97\");        // Returns 97\n//   parse_int(\"43.9\");       // Returns nan\n//   parse_int(\"1011010\",2);  // Returns 90\n//   parse_int(\"13\",2);       // Returns nan\n//   parse_int(\"dead\",16);    // Returns 57005\n//   parse_int(\"CEDE\", 16);   // Returns 52958\n//   parse_int(\"\");           // Returns 0\nfunction parse_int(str,base=10) =\n    str==undef ? undef :\n    len(str)==0 ? 0 :\n    let(str=downcase(str))\n    str[0] == \"-\" ? -_parse_int_recurse(substr(str,1),base,len(str)-2) :\n    str[0] == \"+\" ?  _parse_int_recurse(substr(str,1),base,len(str)-2) :\n    _parse_int_recurse(str,base,len(str)-1);\n\nfunction _parse_int_recurse(str,base,i) =\n    let(\n        digit = search(str[i],\"0123456789abcdef\"),\n        last_digit = digit == [] || digit[0] >= base ? (0/0) : digit[0]\n    ) i==0 ? last_digit :\n    _parse_int_recurse(str,base,i-1)*base + last_digit;\n\n\n// Function: parse_float()\n// Synopsis: Parse a float from a string.\n// Topics: Strings\n// See Also: parse_int(), parse_float(), parse_frac(), parse_num()\n// Usage:\n//   num = parse_float(str);\n// Description:\n//   Converts a string to a floating point number.  Returns NaN if the\n//   conversion fails.\n// Arguments:\n//   str = String to convert.\n// Example:\n//   parse_float(\"44\");       // Returns 44\n//   parse_float(\"3.4\");      // Returns 3.4\n//   parse_float(\"-99.3332\"); // Returns -99.3332\n//   parse_float(\"3.483e2\");  // Returns 348.3\n//   parse_float(\"-44.9E2\");  // Returns -4490\n//   parse_float(\"7.342e-4\"); // Returns 0.0007342\n//   parse_float(\"\");         // Returns 0\nfunction parse_float(str) =\n    str==undef ? undef :\n    len(str) == 0 ? 0 :\n    in_list(str[1], [\"+\",\"-\"]) ? (0/0) : // Don't allow --3, or +-3\n    str[0]==\"-\" ? -parse_float(substr(str,1)) :\n    str[0]==\"+\" ?  parse_float(substr(str,1)) :\n    let(esplit = str_split(str,\"eE\") )\n    len(esplit)==2 ? parse_float(esplit[0]) * pow(10,parse_int(esplit[1])) :\n    let( dsplit = str_split(str,[\".\"]))\n    parse_int(dsplit[0])+parse_int(dsplit[1])/pow(10,len(dsplit[1]));\n\n\n// Function: parse_frac()\n// Synopsis: Parse a float from a fraction string.\n// Topics: Strings\n// See Also: parse_int(), parse_float(), parse_frac(), parse_num()\n// Usage:\n//   num = parse_frac(str,[mixed=],[improper=],[signed=]);\n// Description:\n//   Converts a string fraction to a floating point number.  A string fraction has the form `[-][# ][#/#]` where each `#` is one or more of the\n//   digits 0-9, and there is an optional sign character at the beginning.\n//   The full form is a sign character and an integer, followed by exactly one space, followed by two more\n//   integers separated by a \"/\" character.  The leading integer and\n//   space can be omitted or the trailing fractional part can be omitted.  If you set `mixed` to false then the leading integer part is not\n//   accepted and the input must include a slash.  If you set `improper` to false then the fractional part must be a proper fraction, where\n//   the numerator is smaller than the denominator.  If you set `signed` to false then the leading sign character is not permitted.\n//   The empty string evaluates to zero.  Any invalid string evaluates to NaN.\n// Arguments:\n//   str = String to convert.\n//   ---\n//   mixed = set to true to accept mixed fractions, false to reject them.  Default: true\n//   improper = set to true to accept improper fractions, false to reject them.  Default: true\n//   signed = set to true to accept a leading sign character, false to reject.  Default: true\n// Example:\n//   parse_frac(\"3/4\");     // Returns 0.75\n//   parse_frac(\"-77/9\");   // Returns -8.55556\n//   parse_frac(\"+1/3\");    // Returns 0.33333\n//   parse_frac(\"19\");      // Returns 19\n//   parse_frac(\"2 3/4\");   // Returns 2.75\n//   parse_frac(\"-2 12/4\"); // Returns -5\n//   parse_frac(\"\");        // Returns 0\n//   parse_frac(\"3/0\");     // Returns inf\n//   parse_frac(\"0/0\");     // Returns nan\n//   parse_frac(\"-77/9\",improper=false);   // Returns nan\n//   parse_frac(\"-2 12/4\",improper=false); // Returns nan\n//   parse_frac(\"-2 12/4\",signed=false);   // Returns nan\n//   parse_frac(\"-2 12/4\",mixed=false);    // Returns nan\n//   parse_frac(\"2 1/4\",mixed=false);      // Returns nan\nfunction parse_frac(str,mixed=true,improper=true,signed=true) =\n    str == undef ? undef\n  : len(str)==0 ? 0\n  : str[0]==\" \" ? NAN\n  : signed && str[0]==\"-\" ? -parse_frac(substr(str,1),mixed=mixed,improper=improper,signed=false)\n  : signed && str[0]==\"+\" ?  parse_frac(substr(str,1),mixed=mixed,improper=improper,signed=false)\n  : mixed && (str_find(str,\" \")!=undef || str_find(str,\"/\")==undef)?   // Mixed allowed and there is a space or no slash\n        let(whole = str_split(str,[\" \"]))\n        _parse_int_recurse(whole[0],10,len(whole[0])-1) + parse_frac(whole[1], mixed=false, improper=improper, signed=false)\n  : let(split = str_split(str,\"/\"))\n    len(split)!=2 ? NAN\n  : let(\n        numerator =  _parse_int_recurse(split[0],10,len(split[0])-1),\n        denominator = _parse_int_recurse(split[1],10,len(split[1])-1)\n    )\n    !improper && numerator>=denominator? NAN\n  : denominator<0 ? NAN\n  : numerator/denominator;\n\n\n// Function: parse_num()\n// Synopsis: Parse a float from a decimal or fraction string.\n// Topics: Strings\n// See Also: parse_int(), parse_float(), parse_frac(), parse_num()\n// Usage:\n//   num = parse_num(str);\n// Description:\n//   Converts a string to a number.  The string can be either a fraction (two integers separated by a \"/\") or a floating point number.\n//   Returns NaN if the conversion fails.\n// Example:\n//   parse_num(\"3/4\");    // Returns 0.75\n//   parse_num(\"3.4e-2\"); // Returns 0.034\nfunction parse_num(str) =\n    str == undef ? undef :\n    let( val = parse_frac(str) )\n    val == val ? val :\n    parse_float(str);\n\n\n\n\n// Section: Formatting numbers into strings\n\n// Function: format_int()\n// Synopsis: Formats an integer into a string, with possible leading zeros.\n// Topics: Strings\n// See Also: format_int(), format_fixed(), format_float(), format()\n// Usage:\n//   str = format_int(i, [mindigits]);\n// Description:\n//   Formats an integer number into a string.  This can handle larger numbers than `str()`.\n// Arguments:\n//   i = The integer to make a string of.\n//   mindigits = If the number has fewer than this many digits, pad the front with zeros until it does.  Default: 1.\n// Example:\n//   str(123456789012345);  // Returns \"1.23457e+14\"\n//   format_int(123456789012345);  // Returns \"123456789012345\"\n//   format_int(-123456789012345);  // Returns \"-123456789012345\"\nfunction format_int(i,mindigits=1) =\n    i<0? str(\"-\", format_int(-i,mindigits)) :\n    let(i=floor(i), e=floor(log(i)))\n    i==0? str_join([for (j=[0:1:mindigits-1]) \"0\"]) :\n    str_join(\n        concat(\n            [for (j=[0:1:mindigits-e-2]) \"0\"],\n            [for (j=[e:-1:0]) str(floor(i/pow(10,j)%10))]\n        )\n    );\n\n\n// Function: format_fixed()\n// Synopsis: Formats a float into a string with a fixed number of decimal places.\n// Topics: Strings\n// See Also: format_int(), format_fixed(), format_float(), format()\n// Usage:\n//   s = format_fixed(f, [digits]);\n// Description:\n//   Given a floating point number, formats it into a string with the given number of digits after the decimal point.\n// Arguments:\n//   f = The floating point number to format.\n//   digits = The number of digits after the decimal to show.  Default: 6\nfunction format_fixed(f,digits=6) =\n    assert(is_int(digits))\n    assert(digits>0)\n    is_list(f)? str(\"[\",str_join(sep=\", \", [for (g=f) format_fixed(g,digits=digits)]),\"]\") :\n    str(f)==\"nan\"? \"nan\" :\n    str(f)==\"inf\"? \"inf\" :\n    f<0? str(\"-\",format_fixed(-f,digits=digits)) :\n    assert(is_num(f))\n    let(\n        sc = pow(10,digits),\n        scaled = floor(f * sc + 0.5),\n        whole = floor(scaled/sc),\n        part = floor(scaled-(whole*sc))\n    ) str(format_int(whole),\".\",format_int(part,digits));\n\n\n// Function: format_float()\n// Synopsis: Formats a float into a string with a given number of significant digits.\n// Topics: Strings\n// See Also: format_int(), format_fixed(), format_float(), format()\n// Usage:\n//   str = format_float(f,[sig]);\n// Description:\n//   Formats the given floating point number `f` into a string with `sig` significant digits.\n//   Strips trailing `0`s after the decimal point.  Strips trailing decimal point.\n//   If the number can be represented in `sig` significant digits without a mantissa, it will be.\n//   If given a list of numbers, recursively prints each item in the list, returning a string like `[3,4,5]`\n// Arguments:\n//   f = The floating point number to format.\n//   sig = The number of significant digits to display.  Default: 12\n// Example:\n//   format_float(PI,12);  // Returns: \"3.14159265359\"\n//   format_float([PI,-16.75],12);  // Returns: \"[3.14159265359, -16.75]\"\nfunction format_float(f,sig=12) =\n    assert(is_int(sig))\n    assert(sig>0)\n    is_list(f)? str(\"[\",str_join(sep=\", \", [for (g=f) format_float(g,sig=sig)]),\"]\") :\n    f==0? \"0\" :\n    str(f)==\"nan\"? \"nan\" :\n    str(f)==\"inf\"? \"inf\" :\n    f<0? str(\"-\",format_float(-f,sig=sig)) :\n    assert(is_num(f))\n    let(\n        e = floor(log(f)),\n        mv = sig - e - 1\n    ) mv == 0? format_int(floor(f + 0.5)) :\n    (e<-sig/2||mv<0)? str(format_float(f*pow(10,-e),sig=sig),\"e\",e) :\n    let(\n        ff = f + pow(10,-mv)*0.5,\n        whole = floor(ff),\n        part = floor((ff-whole) * pow(10,mv))\n    )\n    str_join([\n        str(whole),\n        str_strip(end=true,\n            str_join([\n                \".\",\n                format_int(part, mindigits=mv)\n            ]),\n            \"0.\"\n        )\n    ]);\n\n\n/// Function: _format_matrix()\n/// Usage:\n///   _format_matrix(M, [sig], [sep], [eps])\n/// Description:\n///   Convert a numerical matrix into a matrix of strings where every column\n///   is the same width so it will display in neat columns when printed.\n///   Values below eps will display as zero.  The matrix can include nans, infs\n///   or undefs and the rows can be different lengths.\n/// Arguments:\n///   M = numerical matrix to convert\n///   sig = significant digits to display.  Default: 4\n//    sep = number of spaces between columns or a text string to separate columns.  Default: 1\n///   eps = values smaller than this are shown as zero.  Default: 1e-9\nfunction _format_matrix(M, sig=4, sep=1, eps=1e-9) =\n   let(\n       figure_dash = chr(8210),\n       space_punc = chr(8200),\n       space_figure = chr(8199),\n       sep = is_num(sep) && sep>=0 ? str_join(repeat(space_figure,sep))\n           : is_string(sep) ? sep\n           : assert(false,\"Invalid separator: must be a string or positive integer giving number of spaces\"),\n       strarr=\n         [for(row=M)\n             [for(entry=row)\n                 let(\n                     text = is_undef(entry) ? \"und\"\n                          : !is_num(entry) ? str_join(repeat(figure_dash,2))\n                          : abs(entry) < eps ? \"0\"             // Replace hyphens with figure dashes\n                          : str_replace_char(format_float(entry, sig),\"-\",figure_dash),\n                     have_dot = is_def(str_find(text, \".\"))\n                 )\n                 // If the text lacks a dot we add a space the same width as a dot to\n                 // maintain alignment\n                 str(have_dot ? \"\" : space_punc, text)\n             ]\n         ],\n       maxwidth = max([for(row=M) len(row)]),\n       // Find maximum length for each column.  Some entries in a column may be missing.\n       maxlen = [for(i=[0:1:maxwidth-1])\n                    max(\n                         [for(j=idx(M)) i>=len(M[j]) ? 0 : len(strarr[j][i])])\n                ],\n       padded =\n         [for(row=strarr)\n            str_join([for(i=idx(row))\n                            let(\n                                extra = ends_with(row[i],\"inf\") ? 1 : 0\n                            )\n                            str_pad(row[i],maxlen[i]+extra,space_figure,left=true)],sep=sep)]\n    )\n    padded;\n\n\n\n// Function: format()\n// Synopsis: Formats multiple values into a string with a given format.\n// Topics: Strings\n// See Also: format_int(), format_fixed(), format_float(), format()\n// Usage:\n//   s = format(fmt, vals);\n// Description:\n//   Given a format string and a list of values, inserts the values into the placeholders in the format string and returns it.\n//   Formatting placeholders have the following syntax:\n//   - A leading `{` character to show the start of the placeholder.\n//   - An integer index into the `vals` list to specify which value should be formatted at that place. If not given, the first placeholder will use index `0`, the second will use index `1`, etc.\n//   - An optional `:` separator to indicate that what follows if a formatting specifier.  If not given, no formatting info follows.\n//   - An optional `-` character to indicate that the value should be left justified if the value needs field width padding.  If not given, right justification is used.\n//   - An optional `0` character to indicate that the field should be padded with `0`s.  If not given, spaces will be used for padding.\n//   - An optional integer field width, which the value should be padded to.  If not given, no padding will be performed.\n//   - An optional `.` followed by an integer precision length, for specifying how many digits to display in numeric formats.  If not give, 6 digits is assumed.\n//   - An optional letter to indicate the formatting style to use.  If not given, `s` is assumed, which will do it's generic best to format any data type.\n//   - A trailing `}` character to show the end of the placeholder.\n//   .\n//   Formatting styles, and their effects are as follows:\n//   - `s`: Converts the value to a string with `str()` to display.  This is very generic.\n//   - `i` or `d`: Formats numeric values as integers.\n//   - `f`: Formats numeric values with the precision number of digits after the decimal point.  NaN and Inf are shown as `nan` and `inf`.\n//   - `F`: Formats numeric values with the precision number of digits after the decimal point.  NaN and Inf are shown as `NAN` and `INF`.\n//   - `g`: Formats numeric values with the precision number of total significant digits.  NaN and Inf are shown as `nan` and `inf`.  Mantissas are demarked by `e`.\n//   - `G`: Formats numeric values with the precision number of total significant digits.  NaN and Inf are shown as `NAN` and `INF`.  Mantissas are demarked by `E`.\n//   - `b`: If the value logically evaluates as true, it shows as `true`, otherwise `false`.\n//   - `B`: If the value logically evaluates as true, it shows as `TRUE`, otherwise `FALSE`.\n// Arguments:\n//   fmt = The formatting string, with placeholders to format the values into.\n//   vals = The list of values to format.\n// Example(NORENDER):\n//   format(\"The value of {} is {:.14f}.\", [\"pi\", PI]);  // Returns: \"The value of pi is 3.14159265358979.\"\n//   format(\"The value {1:f} is known as {0}.\", [\"pi\", PI]);  // Returns: \"The value 3.141593 is known as pi.\"\n//   format(\"We use a very small value {1:.6g} as {0}.\", [\"EPSILON\", EPSILON]);  // Returns: \"We use a very small value 1e-9 as EPSILON.\"\n//   format(\"{:-5s}{:i}{:b}\", [\"foo\", 12e3, 5]);  // Returns: \"foo  12000true\"\n//   format(\"{:-10s}{:.3f}\", [\"plecostamus\",27.43982]);  // Returns: \"plecostamus27.440\"\n//   format(\"{:-10.9s}{:.3f}\", [\"plecostamus\",27.43982]);  // Returns: \"plecostam 27.440\"\nfunction format(fmt, vals) =\n    let(\n        parts = str_split(fmt,\"{\")\n    ) str_join([\n        for(i = idx(parts))\n        let(\n            found_brace = i==0 || [for (c=parts[i]) if(c==\"}\") c] != [],\n            err = assert(found_brace, \"Unbalanced { in format string.\"),\n            p = i==0? [undef,parts[i]] : str_split(parts[i],\"}\"),\n            fmta = p[0],\n            raw = p[1]\n        ) each [\n            assert(i<99)\n            is_undef(fmta)? \"\" : let(\n                fmtb = str_split(fmta,\":\"),\n                num = is_digit(fmtb[0])? parse_int(fmtb[0]) : (i-1),\n                left = fmtb[1][0] == \"-\",\n                fmtb1 = default(fmtb[1],\"\"),\n                fmtc = left? substr(fmtb1,1) : fmtb1,\n                zero = fmtc[0] == \"0\",\n                lch = fmtc==\"\"? \"\" : fmtc[len(fmtc)-1],\n                hastyp = is_letter(lch),\n                typ = hastyp? lch : \"s\",\n                fmtd = hastyp? substr(fmtc,0,len(fmtc)-1) : fmtc,\n                fmte = str_split((zero? substr(fmtd,1) : fmtd), \".\"),\n                wid = parse_int(fmte[0]),\n                prec = parse_int(fmte[1]),\n                val = assert(num>=0&&num<len(vals)) vals[num],\n                unpad = typ==\"s\"? (\n                        let( sval = str(val) )\n                        is_undef(prec)? sval :\n                        substr(sval, 0, min(len(sval)-1, prec))\n                    ) :\n                    (typ==\"d\" || typ==\"i\")? format_int(val) :\n                    typ==\"b\"? (val? \"true\" : \"false\") :\n                    typ==\"B\"? (val? \"TRUE\" : \"FALSE\") :\n                    typ==\"f\"? downcase(format_fixed(val,default(prec,6))) :\n                    typ==\"F\"? upcase(format_fixed(val,default(prec,6))) :\n                    typ==\"g\"? downcase(format_float(val,default(prec,6))) :\n                    typ==\"G\"? upcase(format_float(val,default(prec,6))) :\n                    assert(false,str(\"Unknown format type: \",typ)),\n                padlen = max(0,wid-len(unpad)),\n                padfill = str_join([for (i=[0:1:padlen-1]) zero? \"0\" : \" \"]),\n                out = left? str(unpad, padfill) : str(padfill, unpad)\n            )\n            out, raw\n        ]\n    ]);\n\n\n\n// Section: Checking character class\n\n// Function: is_lower()\n// Synopsis: Returns true if all characters in the string are lowercase.\n// Topics: Strings\n// See Also: is_lower(), is_upper(), is_digit(), is_hexdigit(), is_letter()\n// Usage:\n//   x = is_lower(s);\n// Description:\n//   Returns true if all the characters in the given string are lowercase letters. (a-z)\nfunction is_lower(s) =\n    assert(is_string(s))\n    s==\"\"? false :\n    len(s)>1? all([for (v=s) is_lower(v)]) :\n    let(v = ord(s[0])) (v>=ord(\"a\") && v<=ord(\"z\"));\n\n\n// Function: is_upper()\n// Synopsis: Returns true if all characters in the string are uppercase.\n// Topics: Strings\n// See Also: is_lower(), is_upper(), is_digit(), is_hexdigit(), is_letter()\n// Usage:\n//   x = is_upper(s);\n// Description:\n//   Returns true if all the characters in the given string are uppercase letters. (A-Z)\nfunction is_upper(s) =\n    assert(is_string(s))\n    s==\"\"? false :\n    len(s)>1? all([for (v=s) is_upper(v)]) :\n    let(v = ord(s[0])) (v>=ord(\"A\") && v<=ord(\"Z\"));\n\n\n// Function: is_digit()\n// Synopsis: Returns true if all characters in the string are decimal digits.\n// Topics: Strings\n// See Also: is_lower(), is_upper(), is_digit(), is_hexdigit(), is_letter()\n// Usage:\n//   x = is_digit(s);\n// Description:\n//   Returns true if all the characters in the given string are digits. (0-9)\nfunction is_digit(s) =\n    assert(is_string(s))\n    s==\"\"? false :\n    len(s)>1? all([for (v=s) is_digit(v)]) :\n    let(v = ord(s[0])) (v>=ord(\"0\") && v<=ord(\"9\"));\n\n\n// Function: is_hexdigit()\n// Synopsis: Returns true if all characters in the string are hexidecimal digits.\n// Topics: Strings\n// See Also: is_lower(), is_upper(), is_digit(), is_hexdigit(), is_letter()\n// Usage:\n//   x = is_hexdigit(s);\n// Description:\n//   Returns true if all the characters in the given string are valid hexadecimal digits. (0-9 or a-f or A-F))\nfunction is_hexdigit(s) =\n    assert(is_string(s))\n    s==\"\"? false :\n    len(s)>1? all([for (v=s) is_hexdigit(v)]) :\n    let(v = ord(s[0]))\n    (v>=ord(\"0\") && v<=ord(\"9\")) ||\n    (v>=ord(\"A\") && v<=ord(\"F\")) ||\n    (v>=ord(\"a\") && v<=ord(\"f\"));\n\n\n// Function: is_letter()\n// Synopsis: Returns true if all characters in the string are letters.\n// Topics: Strings\n// See Also: is_lower(), is_upper(), is_digit(), is_hexdigit(), is_letter()\n// Usage:\n//   x = is_letter(s);\n// Description:\n//   Returns true if all the characters in the given string are standard ASCII letters. (A-Z or a-z)\nfunction is_letter(s) =\n    assert(is_string(s))\n    s==\"\"? false :\n    all([for (v=s) is_lower(v) || is_upper(v)]);\n\n\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-42", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: structs.scad\n//   This file provides manipulation of \"structs\".  A \"struct\" is a data structure that\n//   associates arbitrary keys with values and allows you to get and set values\n//   by key.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/structs.scad>\n// FileGroup: Data Management\n// FileSummary: Structure/Dictionary Manipulation\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: struct operations\n//\n// A struct is a data structure that associates arbitrary keys (of any type) with values (of any type).\n// Structures are implemented as lists of [key, value] pairs.\n//\n// An empty list `[]` is an empty structure and can be used wherever a structure input is required.\n\n// Function: struct_set()\n// Synopsis: Sets one or more key-value pairs in a struct.\n// Topics: Data Structures, Dictionaries\n// See Also: struct_set(), struct_remove(), struct_val(), struct_keys(), echo_struct(), is_struct()\n// Usage:\n//   struct2 = struct_set(struct, key, value, [grow=]);\n//   struct2 = struct_set(struct, [key1, value1, key2, value2, ...], [grow=]);\n// Description:\n//   Sets the key(s) in the structure to the specified value(s), returning a new updated structure.  If a\n//   key exists its value is changed, otherwise the key is added to the structure.  If `grow=false` then\n//   it is an error to set a key not already defined in the structure.  If you specify the same key twice\n//   that is also an error.  Note that key order will change when you change a key's value.\n// Arguments:\n//   struct = input structure.\n//   key = key to set or list of key,value pairs to set\n//   value = value to set the key to (when giving a single key and value)\n//   ---\n//   grow = Set to true to allow structure to grow, or false for new keys to generate an error.  Default: true\n// Example: Create a struct containing just one key-value pair\n//   some_struct = struct_set([], \"answer\", 42);\n//   // 'some_struct' now contains a single value, 42, under one key, \"answer\".\n// Example: Create a struct containing more than one key-value pair. Note that keys and values need not be the same type.\n//   some_struct = struct_set([], [\"answer\", 42, 2, \"two\", \"quote\", \"What a nice day\"]);\n//   // 'some struct' now contains these key-value pairs:\n//   // answer: 42\n//   // 2: two\n//   // quote: What a nice day\nfunction struct_set(struct, key, value, grow=true) =\n  is_def(value) ? struct_set(struct,[key,value],grow=grow)\n  :\n  assert(is_list(key) && len(key)%2==0, \"[key,value] pair list is not a list or has an odd length\")\n  let(\n      new_entries = [for(i=[0:1:len(key)/2-1]) [key[2*i], key[2*i+1]]],\n      newkeys = column(new_entries,0),\n      indlist = search(newkeys, struct,0,0),\n      badkeys = grow ? (search([undef],new_entries,1,0)[0] != [] ? [undef] : [])\n                     : [for(i=idx(indlist)) if (is_undef(newkeys[i]) || len(indlist[i])==0) newkeys[i]],\n      ind = flatten(indlist),\n      dupfind = search(newkeys, new_entries,0,0),\n      dupkeys = [for(i=idx(dupfind)) if (len(dupfind[i])>1) newkeys[i]]\n  )\n  assert(badkeys==[], str(\"Unknown or bad key \",_format_key(badkeys[0]),\" in struct_set\"))\n  assert(dupkeys==[], str(\"Duplicate key \",_format_key(dupkeys[0]),\" for struct\"))\n  concat(list_remove(struct,ind), new_entries);\n\nfunction _format_key(key) = is_string(key) ? str(\"\\\"\",key,\"\\\"\"): key;\n\n// Function: struct_remove()\n// Synopsis: Removes one or more keys from a struct.\n// Topics: Data Structures, Dictionaries\n// See Also: struct_set(), struct_remove(), struct_val(), struct_keys(), echo_struct(), is_struct()\n// Usage:\n//   struct2 = struct_remove(struct, key);\n// Description:\n//   Remove key or list of keys from a structure.  If you want to remove a single key which is a list\n//   you must pass it as a singleton list, or struct_remove will attempt to remove the listed items as keys.\n//   If you list the same item multiple times for removal it will be removed without error.\n// Arguments:\n//   struct = input structure\n//   key = a single key or list of keys to remove.\nfunction struct_remove(struct, key) =\n   !is_list(key) ? struct_remove(struct, [key]) :\n    let(ind = search(key, struct))\n    list_remove(struct, [for(i=ind) if (i!=[]) i]);\n\n\n// Function: struct_val()\n// Synopsis: Returns the value for an key in a struct.\n// Topics: Data Structures, Dictionaries\n// See Also: struct_set(), struct_remove(), struct_val(), struct_keys(), echo_struct(), is_struct()\n// Usage:\n//   val = struct_val(struct, key, default);\n// Description:\n//   Returns the value for the specified key in the structure, or default value if the key is not present\n// Arguments:\n//   struct = input structure\n//   key = key whose value to return\n//   default = default value to return if key is not present.  Default: undef\nfunction struct_val(struct, key, default=undef) =\n    assert(is_def(key),\"key is missing\")\n    let(ind = search([key],struct)[0])\n    ind == [] ? default : struct[ind][1];\n\n\n// Function: struct_keys()\n// Synopsis: Returns a list of keys for a struct.\n// Topics: Data Structures, Dictionaries\n// See Also: struct_set(), struct_remove(), struct_val(), struct_keys(), echo_struct(), is_struct()\n// Usage:\n//   keys = struct_keys(struct);\n// Description:\n//   Returns a list of the keys in a structure\n// Arguments:\n//   struct = input structure\nfunction struct_keys(struct) = column(struct,0);\n\n\n// Function&Module: echo_struct()\n// Synopsis: Echoes the struct to the console in a formatted manner.\n// Topics: Data Structures, Dictionaries\n// See Also: struct_set(), struct_remove(), struct_val(), struct_keys(), echo_struct(), is_struct()\n// Usage:\n//   echo_struct(struct, [name]);\n//   foo = echo_struct(struct, [name]);\n// Description:\n//   Displays a list of structure keys and values, one pair per line, for easier reading.\n// Arguments:\n//   struct = input structure\n//   name = optional structure name to list at the top of the output.  Default: \"\"\nfunction echo_struct(struct,name=\"\") =\n    let( keylist = [for(entry=struct) str(\"  \",entry[0],\": \",entry[1],\"\\n\")])\n    echo(str(\"\\nStructure \",name,\"\\n\",str_join(keylist)))\n    undef;\n\nmodule echo_struct(struct,name=\"\") {\n    no_children($children);\n    dummy = echo_struct(struct,name);\n}\n\n\n// Function: is_struct()\n// Synopsis: Returns true if the value is a struct.\n// Topics: Data Structures, Dictionaries\n// See Also: struct_set(), struct_remove(), struct_val(), struct_keys(), echo_struct(), is_struct()\n// Usage:\n//   bool = is_struct(struct);\n// Description:\n//   Returns true if the input is a list of pairs, false otherwise.\nfunction is_struct(x) =\n    is_list(x) && [for (xx=x) if(!(is_list(xx) && len(xx)==2)) 1] == [];\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-43", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: threading.scad\n//   Provides generic threading support and specialized support for standard triangular (UTS/ISO) threading,\n//   trapezoidal threading (ACME), pipe threading, buttress threading, square threading and ball screws.  \n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/threading.scad>\n// FileGroup: Threaded Parts\n// FileSummary: Various types of threaded rods and nuts.\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Thread Ends and Options\n//   A standard process for making machine screws is to begin with round stock that has\n//   beveled ends.  This stock is then rolled between flat, grooved plates to form the threads.\n//   The result is a bolt that looks like this at the end:\n// Figure(3D,Med,NoAxes,VPR=[83.7,0,115.5],VPT=[1.37344,1.26411,-0.299415],VPD=35.5861): \n//   threaded_rod(d=13,pitch=2,l=10,blunt_start=false,$fn=80);\n// Figure(2D,Med,NoAxes): A properly mated screw and bolt with beveled ends\n//   $fn=32;\n//   projection(cut=true)\n//   xrot(-90){\n//   down(2.5)difference(){\n//     cuboid([20,20,5]);\n//     zrot(20)\n//     threaded_rod(d=13.2, pitch=2,l=5.1,blunt_start=false,internal=true);\n//   }\n//   up(2.85-2)threaded_rod(d=13, pitch=2, l=10, blunt_start=false);\n//   \n//   }\n// Continues:\n//   Cross threading occurs when the bolt is misaligned with the threads in the nut.\n//   It can destroy the threads, or cause the nut to jam.  The standard beveled end process\n//   makes cross threading a possibility because the beveled partial threads can pass\n//   each other when the screw enters the nut.\n// Figure(2D,Med,NoAxes):\n//   $fn=32;\n//   projection(cut=true)\n//   xrot(-90){\n//   down(2.5)difference(){\n//     cuboid([20,20,5]);\n//     zrot(20)\n//     threaded_rod(d=13.2, pitch=2,l=5.1,blunt_start=false,internal=true);\n//   }\n//   left(.6)up(2.99)yrot(-atan(2/13)-1)rot(180+30)threaded_rod(d=13, pitch=2, l=10, blunt_start=false);\n//   }\n// Continues:\n//   In addition, those partial screw threads may be weak, and easily broken.  They do\n//   not contribute to the strength of the assembly.  \n//   In 1891 Clinton A. Higbee received a patent for a modification to screw threads\n//   https://patents.google.com/patent/US447775A meant to address these limitations.\n//   Instead of beveling the end of the screw, Higbee said to remove the partial thread.\n//   The resulting screw might look like this:\n// Figure(3D,Med,NoAxes,VPR=[72,0,294],VPT=[0,0,0],VPD=44):\n//   $fn=48;\n//   threaded_rod(d=13,pitch=2,l=10,blunt_start=true,lead_in_shape=\"cut\",end_len=.2);\n// Continues:\n//   Because the threads are complete everywhere, cross threading is unlikely to occur.\n//   This type of threading has been called \"Higbee threads\", but in recent machinist\n//   handbooks it is called \"blunt start\" threading.  \n//   This style of thread is not commonly used in metal fasteners because it requires\n//   machining the threads, which is much more costly than the rolling procedure described\n//   above.  However, plastic threads usually have some sort of gradual thread end.\n//   For models that will be 3D printed, there is no reason to choose the standard\n//   bevel end bolt, so in this library the blunt start threads are the default.\n//   If you need standard bevel-end threads, you can choose them with the `blunt_start` options.\n//   Note that blunt start threads are more efficient.\n//   .\n//   Various options exist for controlling the ends of threads. You can specify bevels on threaded rods.\n//   In conventional threading, bevels are needed on the ends to remove sharp, thin edges, and\n//   the bevel is sized to the full outer diameter of the threaded rod.  \n//   With blunt start threading, the bevel appears on the unthreaded part of the rod.\n//   On a threaded rod, a bevel value of `true` or a positive bevel value cut off the corner.\n// Figure(3D,Med,NoAxes,VPR=[72,0,54],VPT=[0,0,0],VPD=44):\n//   threaded_rod(d=13,pitch=2,l=10,blunt_start=true,bevel=true,$fn=80);\n// Continues:\n//   A negative bevel value produces a flaring bevel, that might be useful if the rod needs to mate with another part.\n//   You can also set `bevel=\"reverse\"` to get a flaring bevel of the default size.\n// Figure(3D,Med,NoAxes,VPR=[72,0,54],VPT=[0,0,0],VPD=44): Negative bevel on a regular threaded rod.\n//   threaded_rod(d=13,pitch=2,l=10,blunt_start=true,bevel=-2,$fn=80);\n// Continues:\n//   If you set `internal=true` to create a mask for a threaded hole, then bevels are reversed: positive bevels flare outward so that when you subtract\n//   the threaded rod it gives a beveled edge to the hole.  In this case, negative bevels go inward, which might be useful to\n//   create a bevel at the bottom of a threaded hole.\n// Figure(3D,Med,NoAxes,VPR=[72,0,54],VPT=[0,0,0],VPD=44): Threaded rod mask produced using `internal=true` with regular bevel at the top and reversed bevel at the bottom.  \n//   threaded_rod(d=13,pitch=2,l=10,blunt_start=true,bevel2=true,bevel1=\"reverse\",internal=true,$fn=80);\n// Continues:\n//   You can also extend the unthreaded section using the `end_len` parameters.  A long unthreaded section will make\n//   it impossible to tilt the bolt and produce misaligned threads, so it could make assembly easier.  \n// Figure(3D,Med,NoAxes,VPR=[72,0,54],VPT=[0,0,0],VPD=48): Negative bevel on a regular threaded rod.\n//   threaded_rod(d=13,pitch=2,l=15,end_len2=5,blunt_start=true,bevel=true,$fn=80);\n// Continues:\n//   It is also possible to adjust the length of the lead-in section of threads, or the\n//   shape of that lead-in section.  The lead-in length can be set using the `lead_in` arguments\n//   to specify a length or the `lead_in_ang` arguments to specify an angle.  For general\n//   threading applications, making the lead in long creates a smaller thread that could\n//   be more fragile and more prone to cross threading.  \n// Figure(3D,Med,NoAxes,VPR=[52,0,300],VPT=[0,0,4],VPD=35.5861):\n//   threaded_rod(d=13,pitch=2,l=10,lead_in=6,blunt_start=true,bevel=false,$fn=80);\n// Continues:\n//   To change the form of the thread end you use the `lead_in_shape` argument.\n//   You can specify \"sqrt\", \"cut\" or \"smooth\" shapes.  The \"sqrt\" shape is the historical\n//   shape used in the library.  The \"cut\" shape is available to model Higbee pattern threads, but\n//   is not as good as the others in practice, because the flat faces on the threads can hit each other.\n//   The lead-in shape is produced by applying a scale factor to the thread cross section that varies along the lead-in length. \n//   You can also specify a custom shape\n//   by giving a function literal, `f(x,L)` where `L` will be the total linear\n//   length of the lead-in section and `x` will be a value between 0 and 1 giving\n//   the position in the lead in, with 0 being the tip and 1 being the full height thread.\n//   The return value must be a 2-vector giving the thread width scale and thread height\n//   scale at that location.  If `x<0` the function must return a thread height scale\n//   of zero, but it is usually best if the thread width scale does not go to zero,\n//   because that will give a sharply pointed thread end.  If `x>1` the function must\n//   return `[1,1]`.  \n// Figure(3D,Med,NoAxes,VPR=[75,0,338],VPT=[-2,0,3.3],VPD=25): The standard lead in shapes\n//   left_half()zrot(0){\n//   up(2)   threaded_rod(d=13,pitch=2,l=2,blunt_start=true,bevel=false,$fn=128,anchor=BOT);\n//   up(4)   threaded_rod(d=13,pitch=2,l=2.5,blunt_start=true,bevel=false,$fn=128,lead_in_shape=\"cut\",end_len2=.5,anchor=BOT);\n//      threaded_rod(d=13,pitch=2,l=2,blunt_start=true,bevel=false,$fn=128,lead_in_shape=\"smooth\",anchor=BOT);\n//   }\n//   $fn=64;\n//   s=.85;\n//   color(\"black\")\n//   up(3.5)left(4.5)fwd(6)rot($vpr){\n//      back(1.9)text3d(\"cut\",size=s);\n//      text3d(\"sqrt\",size=s);\n//      fwd(1.9)text3d(\"smooth\",size=s);\n//   }   \n\n\n// Section: Standard (UTS/ISO) Threading\n\n// Module: threaded_rod()\n// Synopsis: Creates an UTS/ISO triangular threaded rod.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: threaded_nut()\n// Usage:\n//   threaded_rod(d, l|length, pitch, [internal=], ...) [ATTACHMENTS];\n// Description:\n//   Constructs a standard ISO (metric) or UTS (English) threaded rod.  These threads are close to triangular,\n//   with a 60 degree thread angle.  You can give diameter value which specifies the outer diameter and will produce\n//   the \"basic form\" or you can\n//   set d to a triplet [d_min, d_pitch, d_major] where are parameters determined by the ISO and UTS specifications\n//   that define clearance sizing for the threading.  See screws.scad for how to make screws\n//   using the specification parameters.  \n// Arguments:\n//   d = Outer diameter of threaded rod, or a triplet of [d_min, d_pitch, d_major]. \n//   l / length / h / height = length of threaded rod.\n//   pitch = Length between threads.\n//   ---\n//   left_handed = if true, create left-handed threads.  Default = false\n//   starts = The number of lead starts.  Default: 1\n//   bevel = if true, bevel the thread ends.  Default: false\n//   bevel1 = if true bevel the bottom end.\n//   bevel2 = if true bevel the top end.\n//   internal = If true, make this a mask for making internal threads.\n//   d1 = Bottom outside diameter of threads.\n//   d2 = Top outside diameter of threads.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   teardrop = If true, adds a teardrop profile to the back (Y+) side of the threaded rod, for 3d printability of horizontal holes. If numeric, specifies the proportional extra distance of the teardrop flat top from the screw center, or set to \"max\" for a pointed teardrop. Default: false\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Example(2D):\n//   projection(cut=true)\n//       threaded_rod(d=10, l=15, pitch=1.5, orient=BACK);\n// Examples(Med):\n//   threaded_rod(d=25, height=20, pitch=2, $fa=1, $fs=1);\n//   threaded_rod(d=10, l=20, pitch=1.25, left_handed=true, $fa=1, $fs=1);\n//   threaded_rod(d=25, l=20, pitch=2, $fa=1, $fs=1, end_len=1.5, bevel=true);\n//   threaded_rod(d=25, l=20, pitch=2, $fa=1, $fs=1, blunt_start=false);\n// Example(Med;VPR=[100,0,5];VPD=220): Masking a Horizontal Threaded Hole\n//   difference() {\n//     cuboid(50);\n//     threaded_rod(\n//         d=25, l=51, pitch=4, $fn=36,\n//         internal=true, bevel=true,\n//         blunt_start=false,\n//         teardrop=true, orient=FWD\n//     );\n//   }\n// Example(Big,NoAxes): Diamond threading where both left-handed and right-handed nuts travel (in the same direction) on the threaded rod:\n//   $fn=32;\n//   $slop = 0.075;\n//   d = 3/8*INCH;\n//   pitch = 1/16*INCH;\n//   starts=3;\n//   xdistribute(19){\n//       intersection(){\n//         threaded_rod(l=40, pitch=pitch, d=d,starts=starts,anchor=BOTTOM,end_len=.44);\n//         threaded_rod(l=40, pitch=pitch, d=d, left_handed=true,starts=starts,anchor=BOTTOM);\n//       }\n//       threaded_nut(nutwidth=4.5/8*INCH,id=d,h=3/8*INCH,pitch=pitch,starts=starts,anchor=BOTTOM);\n//       threaded_nut(nutwidth=4.5/8*INCH,id=d,h=3/8*INCH,pitch=pitch,starts=starts,left_handed=true,anchor=BOTTOM);\n//   }\nfunction threaded_rod(\n    d, l, pitch,\n    left_handed=false,\n    bevel,bevel1,bevel2,starts=1,\n    internal=false,\n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) = no_function(\"threaded_rod\");\n\nmodule threaded_rod(\n    d, l, pitch,\n    left_handed=false,\n    bevel,bevel1,bevel2,starts=1,\n    internal=false,\n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) {\n    dummy1=\n      assert(all_positive(pitch))\n      assert(all_positive(d) || (is_undef(d) && all_positive([d1,d2])));\n    basic = is_num(d) || is_undef(d) || is_def(d1) || is_def(d2);\n    dummy2 = assert(basic || is_vector(d,3));\n    depth = basic ? cos(30) * 5/8\n                  : (d[2] - d[0])/2/pitch;\n    crestwidth = basic ? 1/8 : 1/2 - (d[2]-d[1])/sqrt(3)/pitch;\n    profile =    [\n                  [-depth/sqrt(3)-crestwidth/2, -depth],\n                  [              -crestwidth/2,      0],\n                  [               crestwidth/2,      0],\n                  [ depth/sqrt(3)+crestwidth/2, -depth]\n                 ];\n    oprofile = internal? [\n        [-6/16, -depth],\n        [-1/16,  0],\n        [-1/32,  0.02],\n        [ 1/32,  0.02],\n        [ 1/16,  0],\n        [ 6/16, -depth]\n    ] : [\n        [-7/16, -depth*1.07],\n        [-6/16, -depth],\n        [-1/16,  0],\n        [ 1/16,  0],\n        [ 6/16, -depth],\n        [ 7/16, -depth*1.07]\n    ];\n    generic_threaded_rod(\n        d=basic ? d : d[2], d1=d1, d2=d2, l=l,\n        pitch=pitch,\n        profile=profile,starts=starts,\n        left_handed=left_handed,\n        bevel=bevel,bevel1=bevel1,bevel2=bevel2,\n        internal=internal, length=length, height=height, h=h,\n        blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n        lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n        lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n        end_len=end_len, end_len1=end_len1, end_len2=end_len2,\n        teardrop=teardrop,\n        anchor=anchor,\n        spin=spin,\n        orient=orient\n    ) children();\n}\n\n\n\n// Module: threaded_nut()\n// Synopsis: Creates an UTS/ISO triangular threaded nut.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: threaded_rod()\n// Usage:\n//   threaded_nut(nutwidth, id, h|height|thickness, pitch,...) [ATTACHMENTS];\n// Description:\n//   Constructs a hex nut or square nut for an ISO (metric) or UTS (English) threaded rod.\n//   The inner diameter is measured from the bottom of the threads.  \n// Arguments:\n//   nutwidth = flat to flat width of nut\n//   id = inner diameter of threaded hole, measured from bottom of threads\n//   h / height / l / length / thickness = height/thickness of nut.\n//   pitch = Distance between threads, or zero for no threads. \n//   ---\n//   shape = specifies shape of nut, either \"hex\" or \"square\".  Default: \"hex\"\n//   left_handed = if true, create left-handed threads.  Default = false\n//   starts = The number of lead starts.  Default: 1\n//   bevel = if true, bevel the outside of the nut.  Default: true for hex nuts, false for square nuts\n//   bevel1 = if true, bevel the outside of the nut bottom.\n//   bevel2 = if true, bevel the outside of the nut top. \n//   bevang = set the angle for the outside nut bevel.  Default: 30\n//   ibevel = if true, bevel the inside (the hole).   Default: true\n//   ibevel1 = if true bevel the inside, bottom end.\n//   ibevel2 = if true bevel the inside, top end.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Examples(Med):\n//   threaded_nut(nutwidth=16, id=8, h=8, pitch=1.25, $slop=0.05, $fa=1, $fs=1);\n//   threaded_nut(nutwidth=16, id=8, h=8, pitch=1.25, left_handed=true, bevel=false, $slop=0.1, $fa=1, $fs=1);\n//   threaded_nut(shape=\"square\", nutwidth=16, id=8, h=8, pitch=1.25, $slop=0.1, $fa=1, $fs=1);\n//   threaded_nut(shape=\"square\", nutwidth=16, id=8, h=8, pitch=1.25, bevel2=true, $slop=0.1, $fa=1, $fs=1);\n//   rot(90)threaded_nut(nutwidth=16, id=8, h=8, pitch=1.25,blunt_start=false, $slop=0.1, $fa=1, $fs=1);\nfunction threaded_nut(\n    nutwidth, id, h,\n    pitch, starts=1, shape=\"hex\", left_handed=false, bevel, bevel1, bevel2, id1,id2,\n    ibevel1, ibevel2, ibevel, bevang=30, thickness, height,\n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n)=no_function(\"threaded_nut\");\nmodule threaded_nut(\n    nutwidth, id, h,\n    pitch, starts=1, shape=\"hex\", left_handed=false, bevel, bevel1, bevel2, id1,id2,\n    ibevel1, ibevel2, ibevel, bevang=30, thickness, height,\n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n) {\n    dummy1=\n          assert(all_nonnegative(pitch), \"Nut pitch must be nonnegative\")\n          assert(all_positive(id), \"Nut inner diameter must be positive\")\n          assert(all_positive(h),\"Nut thickness must be positive\");\n    basic = is_num(id) || is_undef(id) || is_def(id1) || is_def(id2);\n    dummy2 = assert(basic || is_vector(id,3));\n    depth = basic ? cos(30) * 5/8\n                  : (id[2] - id[0])/2/pitch;\n    crestwidth = basic ? 1/8 : 1/2 - (id[2]-id[1])/sqrt(3)/pitch;\n    profile =    [\n                  [-depth/sqrt(3)-crestwidth/2, -depth],\n                  [              -crestwidth/2,      0],\n                  [               crestwidth/2,      0],\n                  [ depth/sqrt(3)+crestwidth/2, -depth]\n                 ];\n    oprofile = [\n        [-6/16, -depth/pitch],\n        [-1/16,  0],\n        [-1/32,  0.02],\n        [ 1/32,  0.02],\n        [ 1/16,  0],\n        [ 6/16, -depth/pitch]\n    ];\n    generic_threaded_nut(\n        nutwidth=nutwidth,\n        id=basic ? id : id[2], id1=id1, id2=id2,\n        h=h,\n        pitch=pitch,\n        profile=profile,starts=starts,shape=shape, \n        left_handed=left_handed,\n        bevel=bevel,bevel1=bevel1,bevel2=bevel2,\n        ibevel1=ibevel1, ibevel2=ibevel2, ibevel=ibevel,\n        blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n        lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n        lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n        end_len=end_len, end_len1=end_len1, end_len2=end_len2,\n        l=l,length=length,\n        anchor=anchor, spin=spin,\n        orient=orient\n    ) children();\n}\n\n// Section: Trapezoidal Threading\n\n\n// Module: trapezoidal_threaded_rod()\n// Synopsis: Creates a trapezoidal threaded rod.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: trapezoidal_threaded_nut()\n// Usage:\n//   trapezoidal_threaded_rod(d, l|length, pitch, [thread_angle=|flank_angle=], [thread_depth=], [internal=], ...) [ATTACHMENTS];\n// Description:\n//   Constructs a threaded rod with a symmetric trapezoidal thread.  Trapezoidal threads are used for lead screws because\n//   they are one of the strongest symmetric profiles.  This tooth shape is stronger than a similarly\n//   sized square thread becuase of its wider base.  However, it does place a radial load on the nut, unlike the square thread.\n//   For loads in only one direction the asymmetric buttress thread profile can bear greater loads.  \n//   .\n//   By default produces the nominal dimensions\n//   for metric trapezoidal threads: a thread angle of 30 degrees and a depth set to half the pitch.\n//   You can also specify your own trapezoid parameters.  For ACME threads see acme_threaded_rod().\n// Figure(2D,Med,NoAxes):\n//   pa_delta = tan(15)/4;\n//   rr1 = -1/2;\n//   z1 = 1/4-pa_delta;\n//   z2 = 1/4+pa_delta;\n//   profile = [\n//               [-z2, rr1],\n//               [-z1,  0],\n//               [ z1,  0],\n//               [ z2, rr1],\n//             ];\n//   fullprofile = 50*left(1/2,p=concat(profile, right(1, p=profile)));\n//   stroke(fullprofile,width=1);\n//   dir = fullprofile[2]-fullprofile[3];\n//   dir2 = fullprofile[5]-fullprofile[4];\n//   curve = arc(32,angle=[75,105],r=67.5);\n//   avgpt = mean([fullprofile[5]+.1*dir2, fullprofile[5]+.4*dir2]);\n//   color(\"red\"){\n//    stroke([fullprofile[2]+.1*dir, fullprofile[2]+.4*dir], width=1);\n//    stroke([fullprofile[5]+.1*dir2, fullprofile[5]+.4*dir2], width=1);\n//    stroke(move(-curve[0]+avgpt,p=curve), width=1,endcaps=\"arrow2\");\n//    back(10)text(\"thread\",size=4,halign=\"center\");\n//    back(3)text(\"angle\",size=4,halign=\"center\");\n//   }\n// Figure(2D,Med,NoAxes):\n//   pa_delta = tan(15)/4;\n//      rr1 = -1/2;\n//      z1 = 1/4-pa_delta;\n//      z2 = 1/4+pa_delta;\n//      profile = [\n//                  [-z2, rr1],\n//                  [-z1,  0],\n//                  [ z1,  0],\n//                  [ z2, rr1],\n//                ];\n//      fullprofile = 50*left(1/2,p=concat(profile, right(1, p=profile)));\n//      stroke(fullprofile,width=1);\n//      dir = fullprofile[2]-fullprofile[3];\n//      dir2 = fullprofile[5]-fullprofile[4];\n//      curve = arc(15,angle=[75,87],r=40 /*67.5*/);\n//      avgpt = mean([fullprofile[5]+.1*dir2, fullprofile[5]+.4*dir2]);\n//      color(\"red\"){\n//       stroke([fullprofile[4]+[0,1], fullprofile[4]+[0,37]], width=1);\n//       stroke([fullprofile[5]+.1*dir2, fullprofile[5]+.4*dir2], width=1);\n//       stroke(move(-curve[0]+avgpt,p=curve), width=0.71,endcaps=\"arrow2\");\n//       right(14)back(19)text(\"flank\",size=4,halign=\"center\");\n//       right(14)back(14)text(\"angle\",size=4,halign=\"center\");\n//      }\n// Arguments:\n//   d = Outer diameter of threaded rod.\n//   l / length / h / height = Length of threaded rod.\n//   pitch = Thread spacing. \n//   ---\n//   thread_angle = Angle between two thread faces.  Default: 30\n//   thread_depth = Depth of threads.  Default: pitch/2\n//   flank_angle = Angle of thread faces to plane perpendicular to screw. \n//   left_handed = If true, create left-handed threads.  Default: false\n//   starts = The number of lead starts.  Default: 1\n//   bevel = if true, bevel the thread ends.  Default: false\n//   bevel1 = if true bevel the bottom end.\n//   bevel2 = if true bevel the top end. \n//   internal = If true, make this a mask for making internal threads.  Default: false\n//   d1 = Bottom outside diameter of threads.\n//   d2 = Top outside diameter of threads.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   teardrop = If true, adds a teardrop profile to the back (Y+) side of the threaded rod, for 3d printability of horizontal holes. If numeric, specifies the proportional extra distance of the teardrop flat top from the screw center, or set to \"max\" for a pointed teardrop. Default: false\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Example(2D):\n//   projection(cut=true)\n//       trapezoidal_threaded_rod(d=10, l=15, pitch=2, orient=BACK);\n// Examples(Med): \n//   trapezoidal_threaded_rod(d=10, l=40, pitch=2, $fn=32);  // Standard metric threading\n//   rot(-65)trapezoidal_threaded_rod(d=10, l=17, pitch=2, blunt_start=false, $fn=32);  // Standard metric threading\n//   trapezoidal_threaded_rod(d=10, l=17, pitch=2, bevel=true, $fn=32);  // Standard metric threading\n//   trapezoidal_threaded_rod(d=10, h=30, pitch=2, left_handed=true, $fa=1, $fs=1);  // Standard metric threading\n//   trapezoidal_threaded_rod(d=10, l=40, pitch=3, left_handed=true, starts=3, $fn=36);\n//   trapezoidal_threaded_rod(l=25, d=10, pitch=2, starts=3, $fa=1, $fs=1, bevel=true, orient=RIGHT, anchor=BOTTOM);\n//   trapezoidal_threaded_rod(d=60, l=16, pitch=8, thread_depth=3, thread_angle=90, blunt_start=false, $fa=2, $fs=2);\n//   trapezoidal_threaded_rod(d=60, l=16, pitch=8, thread_depth=3, thread_angle=90, end_len=0, $fa=2, $fs=2);   \n//   trapezoidal_threaded_rod(d=60, l=16, pitch=8, thread_depth=3, thread_angle=90, left_handed=true, starts=4, $fa=2, $fs=2,end_len=0);\n//   trapezoidal_threaded_rod(d=16, l=40, pitch=2, thread_angle=60);\n//   trapezoidal_threaded_rod(d=25, l=40, pitch=10, thread_depth=8/3, thread_angle=100, starts=4, anchor=BOT, $fa=2, $fs=2,end_len=-2);\n//   trapezoidal_threaded_rod(d=50, l=35, pitch=8, thread_angle=60, starts=11, lead_in=3, $fn=120);\n//   trapezoidal_threaded_rod(d=10, l=40, end_len2=10, pitch=2, $fn=32);  // Unthreaded top end section\n// Example(Med): Using as a Mask to Make Internal Threads\n//   bottom_half() difference() {\n//       cube(50, center=true);\n//       trapezoidal_threaded_rod(d=40, l=51, pitch=5, thread_angle=30, internal=true, bevel=true, orient=RIGHT, $fn=36);\n//   }\n// Example(Med;VPR=[100,0,5];VPD=220): Masking a Horizontal Threaded Hole\n//   difference() {\n//     cuboid(50);\n//     trapezoidal_threaded_rod(\n//         d=25, l=51, pitch=4, $fn=36,\n//         thread_angle=30,\n//         internal=true, bevel=true,\n//         blunt_start=false,\n//         teardrop=true, orient=FWD\n//     );\n//   }\nfunction trapezoidal_threaded_rod(\n    d, l, pitch,\n    thread_angle,\n    thread_depth,\n    flank_angle,\n    left_handed=false,\n    bevel,bevel1,bevel2,\n    starts=1, \n    internal=false,\n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) = no_function(\"trapezoidal_threaded_rod\");\nmodule trapezoidal_threaded_rod(\n    d, l, pitch,\n    thread_angle,\n    thread_depth,\n    flank_angle,\n    left_handed=false,\n    bevel,bevel1,bevel2,\n    starts=1, \n    internal=false,\n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) {\n    dummy0 = assert(num_defined([thread_angle,flank_angle])<=1, \"Cannot define both flank angle and thread angle\");\n    thread_angle = first_defined([thread_angle, u_mul(2,flank_angle), 30]);\n    dummy1 = assert(all_nonnegative(pitch),\"Must give a positive pitch value\")\n             assert(thread_angle>=0 && thread_angle<180, \"Invalid thread angle or flank angle\")\n             assert(thread_angle<=90 || all_positive([thread_depth]),\n                   \"Thread angle (2*flank_angle) must be smaller than 90 degrees with default thread depth of pitch/2\");\n    depth = first_defined([thread_depth,pitch/2]);\n    pa_delta = 0.5*depth*tan(thread_angle/2) / pitch;\n    dummy2 = assert(pa_delta<=1/4, \"Specified thread geometry is impossible\");\n    rr1 = -depth/pitch;\n    z1 = 1/4-pa_delta;\n    z2 = 1/4+pa_delta;\n    profile = [\n               [-z2, rr1],\n               [-z1,  0],\n               [ z1,  0],\n               [ z2, rr1],\n              ];\n    generic_threaded_rod(d=d,l=l,pitch=pitch,profile=profile,\n                         left_handed=left_handed,bevel=bevel,bevel1=bevel1,bevel2=bevel2,starts=starts,d1=d1,d2=d2,\n                         internal=internal, length=length, height=height, h=h,\n                         blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n                         lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n                         lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n                         end_len=end_len, end_len1=end_len1, end_len2=end_len2,\n                         teardrop=teardrop, anchor=anchor,spin=spin,orient=orient)\n      children();\n}\n\n\n// Module: trapezoidal_threaded_nut()\n// Synopsis: Creates a trapezoidal threaded nut.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: trapezoidal_threaded_rod()\n// Usage:\n//   trapezoidal_threaded_nut(nutwidth, id, h|height|thickness, pitch, [thread_angle=|flank_angle=], [thread_depth], ...) [ATTACHMENTS];\n// Description:\n//   Constructs a hex nut or square nut for a symmetric trapzoidal threaded rod.  By default produces\n//   the nominal dimensions for metric trapezoidal threads: a thread angle of 30 degrees and a depth\n//   set to half the pitch.  You can also specify your own trapezoid parameters.  For ACME threads see\n//   acme_threaded_nut().\n// Arguments:\n//   nutwidth = flat to flat width of nut\n//   id = inner diameter of threaded hole, measured from bottom of threads\n//   h / height / l / length / thickness = height/thickness of nut.\n//   pitch = Thread spacing.\n//   ---\n//   thread_angle = Angle between two thread faces.  Default: 30\n//   thread_depth = Depth of the threads.  Default: pitch/2\n//   flank_angle = Angle of thread faces to plane perpendicular to screw. \n//   shape = specifies shape of nut, either \"hex\" or \"square\".  Default: \"hex\"\n//   left_handed = if true, create left-handed threads.  Default = false\n//   starts = The number of lead starts.  Default = 1\n//   bevel = if true, bevel the outside of the nut.  Default: true for hex nuts, false for square nuts\n//   bevel1 = if true, bevel the outside of the nut bottom.\n//   bevel2 = if true, bevel the outside of the nut top. \n//   bevang = set the angle for the outside nut bevel.  Default: 30\n//   ibevel = if true, bevel the inside (the hole).   Default: true\n//   ibevel1 = if true bevel the inside, bottom end.\n//   ibevel2 = if true bevel the inside, top end.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Examples(Med):\n//   trapezoidal_threaded_nut(nutwidth=16, id=8, h=8, pitch=2, $slop=0.1, anchor=UP);\n//   trapezoidal_threaded_nut(nutwidth=16, id=8, h=8, pitch=2, bevel=false, $slop=0.05, anchor=UP);\n//   trapezoidal_threaded_nut(nutwidth=17.4, id=10, h=10, pitch=2, $slop=0.1, left_handed=true);\n//   trapezoidal_threaded_nut(nutwidth=17.4, id=10, h=10, pitch=2, starts=3, $fa=1, $fs=1, $slop=0.15);\n//   trapezoidal_threaded_nut(nutwidth=17.4, id=10, h=10, pitch=2, starts=3, $fa=1, $fs=1, $slop=0.15, blunt_start=false);\n//   trapezoidal_threaded_nut(nutwidth=17.4, id=10, h=10, pitch=0, $slop=0.2);   // No threads\nfunction trapezoidal_threaded_nut(\n    nutwidth,\n    id,\n    h,\n    pitch,\n    thread_angle,\n    thread_depth, shape=\"hex\",\n    flank_angle,\n    left_handed=false,\n    starts=1,\n    bevel,bevel1,bevel2,bevang=30,\n    ibevel1,ibevel2,ibevel,\n    thickness,height,\n    id1,id2,\n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n) = no_function(\"trapezoidal_threaded_nut\");\nmodule trapezoidal_threaded_nut(\n    nutwidth,\n    id,\n    h,\n    pitch,\n    thread_angle,\n    thread_depth, shape=\"hex\",\n    flank_angle,\n    left_handed=false,\n    starts=1,\n    bevel,bevel1,bevel2,bevang=30,\n    ibevel1,ibevel2,ibevel,\n    thickness,height,\n    id1,id2,\n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n) {\n    dummy0 = assert(num_defined([thread_angle,flank_angle])<=1, \"Cannot define both flank angle and thread angle\");\n    thread_angle = first_defined([thread_angle, u_mul(2,flank_angle), 30]);\n    dummy1 = assert(all_nonnegative(pitch),\"Must give a positive pitch value\")\n             assert(thread_angle>=0 && thread_angle<180, \"Invalid thread angle or flank angle\")\n             assert(thread_angle<=90 || all_positive([thread_depth]),\n                   \"Thread angle (2*flank_angle) must be smaller than 90 degrees with default thread depth of pitch/2\");\n    depth = first_defined([thread_depth,pitch/2]);\n    pa_delta = 0.5*depth*tan(thread_angle/2) / pitch;\n    dummy2 = assert(pitch==0 || pa_delta<1/4, \"Specified thread geometry is impossible\");\n    rr1 = -depth/pitch;\n    z1 = 1/4-pa_delta;\n    z2 = 1/4+pa_delta;\n    profile = [\n               [-z2, rr1],\n               [-z1,  0],\n               [ z1,  0],\n               [ z2, rr1],\n              ];\n    generic_threaded_nut(nutwidth=nutwidth,id=id,h=h,pitch=pitch,profile=profile,id1=id1,id2=id2,\n                         shape=shape,left_handed=left_handed,bevel=bevel,bevel1=bevel1,bevel2=bevel2,starts=starts,\n                         ibevel=ibevel,ibevel1=ibevel1,ibevel2=ibevel2,bevang=bevang,height=height,thickness=thickness,\n                         blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n                         lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n                         lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n                         end_len=end_len, end_len1=end_len1, end_len2=end_len2,\n                         l=l,length=length,\n                         anchor=anchor,spin=spin,orient=orient)\n      children();\n}\n\n\n// Module: acme_threaded_rod()\n// Synopsis: Creates an ACME threaded rod.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: acme_threaded_nut()\n// Usage:\n//   acme_threaded_rod(d, l|length, tpi|pitch=, [internal=], ...) [ATTACHMENTS];\n// Description:\n//   Constructs an ACME trapezoidal threaded screw rod.  This form has a 29 degree thread angle with a\n//   symmetric trapezoidal thread.  \n// Arguments:\n//   d = Outer diameter of threaded rod.\n//   l / length / h / height = Length of threaded rod.\n//   tpi = threads per inch.\n//   ---\n//   pitch = thread spacing (alternative to tpi)\n//   starts = The number of lead starts.  Default = 1\n//   left_handed = if true, create left-handed threads.  Default = false\n//   bevel = if true, bevel the thread ends.  Default: false\n//   bevel1 = if true bevel the bottom end.\n//   bevel2 = if true bevel the top end. \n//   internal = If true, this is a mask for making internal threads.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   teardrop = If true, adds a teardrop profile to the back (Y+) side of the threaded rod, for 3d printability of horizontal holes. If numeric, specifies the proportional extra distance of the teardrop flat top from the screw center, or set to \"max\" for a pointed teardrop. Default: false\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Example(2D):\n//   projection(cut=true)\n//       acme_threaded_rod(d=10, l=15, pitch=2, orient=BACK);\n// Examples(Med):\n//   acme_threaded_rod(d=3/8*INCH, l=20, pitch=1/8*INCH, $fn=32);\n//   acme_threaded_rod(d=10, l=30, pitch=2, starts=3, $fa=1, $fs=1);\n// Example(Med;VPR=[100,0,5];VPD=220): Masking a Horizontal Threaded Hole\n//   difference() {\n//     cuboid(50);\n//     acme_threaded_rod(\n//         d=25, l=51, pitch=4, $fn=36,\n//         internal=true, bevel=true,\n//         blunt_start=false,\n//         teardrop=true, orient=FWD\n//     );\n//   }\nfunction acme_threaded_rod(\n    d, l, tpi, pitch,\n    starts=1,\n    left_handed=false,\n    bevel,bevel1,bevel2,\n    internal=false, \n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) = no_function(\"acme_threaded_rod\");\nmodule acme_threaded_rod(\n    d, l, tpi, pitch,\n    starts=1,\n    left_handed=false,\n    bevel,bevel1,bevel2,\n    internal=false, \n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) {\n    dummy = assert(num_defined([pitch,tpi])==1,\"Must give exactly one of pitch and tpi\");\n    pitch = is_undef(pitch) ? INCH/tpi : pitch;\n    trapezoidal_threaded_rod(\n        d=d, l=l, pitch=pitch,\n        thread_angle=29,\n        thread_depth=pitch/2,\n        starts=starts,\n        left_handed=left_handed,\n        bevel=bevel,bevel1=bevel1,bevel2=bevel2,\n        internal=internal, length=length, height=height, h=h,\n        blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n        lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n        lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n        end_len=end_len, end_len1=end_len1, end_len2=end_len2,\n        teardrop=teardrop,\n        anchor=anchor,\n        spin=spin,\n        orient=orient\n    ) children();\n}\n\n\n\n// Module: acme_threaded_nut()\n// Synopsis: Creates an ACME threaded nut.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: acme_threaded_rod()\n// Usage:\n//   acme_threaded_nut(nutwidth, id, h|height|thickness, tpi|pitch=, [shape=], ...) [ATTACHMENTS];\n// Description:\n//   Constructs a hexagonal or square nut for an ACME threaded screw rod. \n// Arguments:\n//   nutwidth = flat to flat width of nut.\n//   id = inner diameter of threaded hole, measured from bottom of threads\n//   h / height / l / length / thickness = height/thickness of nut.\n//   tpi = threads per inch\n//   ---\n//   pitch = Thread spacing (alternative to tpi)\n//   shape = specifies shape of nut, either \"hex\" or \"square\".  Default: \"hex\"\n//   left_handed = if true, create left-handed threads.  Default = false\n//   starts = Number of lead starts.  Default: 1\n//   bevel = if true, bevel the outside of the nut.  Default: true for hex nuts, false for square nuts\n//   bevel1 = if true, bevel the outside of the nut bottom.\n//   bevel2 = if true, bevel the outside of the nut top. \n//   bevang = set the angle for the outside nut bevel.  Default: 30\n//   ibevel = if true, bevel the inside (the hole).   Default: true\n//   ibevel1 = if true bevel the inside, bottom end.\n//   ibevel2 = if true bevel the inside, top end.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Examples(Med):\n//   acme_threaded_nut(nutwidth=16, id=3/8*INCH, h=8, tpi=8, $slop=0.05);\n//   acme_threaded_nut(nutwidth=16, id=3/8*INCH, h=10, tpi=12, starts=3, $slop=0.1, $fa=1, $fs=1, ibevel=false);\n//   acme_threaded_nut(nutwidth=16, id=3/8*INCH, h=10, tpi=12, starts=3, $slop=0.1, $fa=1, $fs=1, blunt_start=false);\nfunction acme_threaded_nut(\n    nutwidth, id, h, tpi, pitch,\n    starts=1,\n    left_handed=false,shape=\"hex\",\n    bevel,bevel1,bevel2,bevang=30,\n    ibevel,ibevel1,ibevel2,\n    height,thickness,\n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n) = no_function(\"acme_threaded_nut\");\nmodule acme_threaded_nut(\n    nutwidth, id, h, tpi, pitch,\n    starts=1,\n    left_handed=false,shape=\"hex\",\n    bevel,bevel1,bevel2,bevang=30,\n    ibevel,ibevel1,ibevel2,\n    height,thickness,\n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n) {\n    dummy = assert(num_defined([pitch,tpi])==1,\"Must give exactly one of pitch and tpi\");\n    pitch = is_undef(pitch) ? INCH/tpi : pitch;\n    dummy2=assert(is_num(pitch) && pitch>=0);\n    trapezoidal_threaded_nut(\n        nutwidth=nutwidth, id=id, h=h, pitch=pitch,\n        thread_depth = pitch/2, \n        thread_angle=29,shape=shape, \n        left_handed=left_handed,\n        bevel=bevel,bevel1=bevel1,bevel2=bevel2,\n        ibevel=ibevel,ibevel1=ibevel1,ibevel2=ibevel2,\n        height=height,thickness=thickness,\n        blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n        lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n        lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n        end_len=end_len, end_len1=end_len1, end_len2=end_len2,\n        l=l,length=length,\n        starts=starts,\n        anchor=anchor,\n        spin=spin,\n        orient=orient\n    ) children();\n}\n\n\n\n\n// Section: Pipe Threading\n\n// Module: npt_threaded_rod()\n// Synopsis: Creates NPT pipe threading.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: acme_threaded_rod()\n// Usage:\n//   npt_threaded_rod(size, [internal=], ...) [ATTACHMENTS];\n// Description:\n//   Constructs a standard NPT pipe end threading. If `internal=true`, creates a mask for making\n//   internal pipe threads.  Tapers smaller upwards if `internal=false`.  Tapers smaller downwards\n//   if `internal=true`.  If `hollow=true` and `internal=false`, then the pipe threads will be\n//   hollowed out into a pipe with the apropriate internal diameter.\n// Arguments:\n//   size = NPT standard pipe size in inches.  1/16\", 1/8\", 1/4\", 3/8\", 1/2\", 3/4\", 1\", 1+1/4\", 1+1/2\", or 2\".  Default: 1/2\"\n//   ---\n//   left_handed = If true, create left-handed threads.  Default = false\n//   bevel = if true, bevel the thread ends.  Default: false\n//   bevel1 = if true bevel the bottom end.\n//   bevel2 = if true bevel the top end. \n//   hollow = If true, create a pipe with the correct internal diameter.\n//   internal = If true, make this a mask for making internal threads.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Example(2D): The straight gray rectangle reveals the tapered threads.  \n//   projection(cut=true) npt_threaded_rod(size=1/4, orient=BACK);\n//   right(.533*INCH/2) color(\"gray\") rect([2,0.5946*INCH],anchor=LEFT);\n// Examples(Med):\n//   npt_threaded_rod(size=3/8, $fn=72);\n//   npt_threaded_rod(size=1/2, $fn=72, bevel=true);\n//   npt_threaded_rod(size=1/2, left_handed=true, $fn=72);\n//   npt_threaded_rod(size=3/4, hollow=true, $fn=96);\n// Example:\n//   diff(\"remove\"){\n//      cuboid([40,40,40])\n//      tag(\"remove\"){\n//        up(.01)position(TOP)\n//            npt_threaded_rod(size=3/4, $fn=96, internal=true, $slop=0.1, anchor=TOP);\n//        cyl(d=3/4*INCH, l=42, $fn=32);\n//      }\n//   }\nfunction npt_threaded_rod(\n    size=1/2,\n    left_handed=false,\n    bevel,bevel1,bevel2,\n    hollow=false,\n    internal=false,\n    anchor, spin, orient\n)=no_function(\"npt_threaded_rod\");\nmodule npt_threaded_rod(\n    size=1/2,\n    left_handed=false,\n    bevel,bevel1,bevel2,\n    hollow=false,\n    internal=false,\n    anchor, spin, orient\n) {\n    assert(is_finite(size));\n    assert(is_bool(left_handed));\n    assert(is_undef(bevel) || is_bool(bevel));\n    assert(is_bool(hollow));\n    assert(is_bool(internal));\n    assert(!(internal&&hollow), \"Cannot created a hollow internal threads mask.\");\n    info_table = [\n        // Size    len      OD    TPI\n        [ 1/16,  [ 0.3896, 0.308, 27  ]],\n        [ 1/8,   [ 0.3924, 0.401, 27  ]],\n        [ 1/4,   [ 0.5946, 0.533, 18  ]],\n        [ 3/8,   [ 0.6006, 0.668, 18  ]],\n        [ 1/2,   [ 0.7815, 0.832, 14  ]],\n        [ 3/4,   [ 0.7935, 1.043, 14  ]],\n        [ 1,     [ 0.9845, 1.305, 11.5]],\n        [ 1+1/4, [ 1.0085, 1.649, 11.5]],\n        [ 1+1/2, [ 1.0252, 1.888, 11.5]],\n        [ 2,     [ 1.0582, 2.362, 11.5]],\n    ];\n    info = [for (data=info_table) if(approx(size,data[0])) data[1]][0];\n    dummy1 = assert(is_def(info), \"Unsupported NPT size.  Try one of 1/16, 1/8, 1/4, 3/8, 1/2, 3/4, 1, 1+1/4, 1+1/2, 2\");\n    l = INCH * info[0];\n    d = INCH * info[1];\n    pitch = INCH / info[2];\n    rr = d/2;\n    rr2 = rr - l/32;\n    r1 = internal? rr2 : rr;\n    r2 = internal? rr : rr2;\n    depth = pitch * cos(30) * 5/8;\n    profile = internal? [\n        [-6/16, -depth/pitch],\n        [-1/16,  0],\n        [-1/32,  0.02],\n        [ 1/32,  0.02],\n        [ 1/16,  0],\n        [ 6/16, -depth/pitch]\n    ] : [\n        [-7/16, -depth/pitch*1.07],\n        [-6/16, -depth/pitch],\n        [-1/16,  0],\n        [ 1/16,  0],\n        [ 6/16, -depth/pitch],\n        [ 7/16, -depth/pitch*1.07]\n    ];\n    attachable(anchor,spin,orient, l=l, r1=r1, r2=r2) {\n        difference() {\n            generic_threaded_rod(\n                d1=2*r1, d2=2*r2, l=l,\n                pitch=pitch,\n                profile=profile,\n                left_handed=left_handed,\n                bevel=bevel,bevel1=bevel1,bevel2=bevel2,\n                internal=internal,\n                blunt_start=true\n            );\n            if (hollow) cylinder(h=l+1, d=size*INCH, center=true);\n        }\n        children();\n    }\n}\n\n\n\n// Section: Buttress Threading\n\n// Module: buttress_threaded_rod()\n// Synopsis: Creates a buttress-threaded rod.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: buttress_threaded_nut()\n// Usage:\n//   buttress_threaded_rod(d, l|length, pitch, [internal=], ...) [ATTACHMENTS];\n// Description:\n//   Constructs a simple buttress threaded rod with a 45 degree angle.  The buttress thread or sawtooth thread has low friction and high loading\n//   in one direction at the cost of higher friction and inferior loading in the other direction.  Buttress threads are sometimes used on\n//   vises, which are loaded only in one direction.  \n// Arguments:\n//   d = Outer diameter of threaded rod.\n//   l / length / h / height = Length of threaded rod.\n//   pitch = Thread spacing.\n//   ---\n//   left_handed = if true, create left-handed threads.  Default = false\n//   starts = Number of lead starts.  Default: 1\n//   bevel = if true, bevel the thread ends.  Default: false\n//   bevel1 = if true bevel the bottom end.\n//   bevel2 = if true bevel the top end. \n//   internal = If true, this is a mask for making internal threads.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   teardrop = If true, adds a teardrop profile to the back (Y+) side of the threaded rod, for 3d printability of horizontal holes. If numeric, specifies the proportional extra distance of the teardrop flat top from the screw center, or set to \"max\" for a pointed teardrop. Default: false\n//   d1 = Bottom outside diameter of threads.\n//   d2 = Top outside diameter of threads.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Example(2D):\n//   projection(cut=true)\n//       buttress_threaded_rod(d=10, l=15, pitch=2, orient=BACK);\n// Examples(Med):\n//   buttress_threaded_rod(d=25, l=20, pitch=2, $fa=1, $fs=1,end_len=0);\n//   buttress_threaded_rod(d=10, l=20, pitch=1.25, left_handed=true, $fa=1, $fs=1);\n// Example(Med;VPR=[100,0,5];VPD=220): Masking a Horizontal Threaded Hole\n//   difference() {\n//     cuboid(50);\n//     buttress_threaded_rod(\n//         d=25, l=51, pitch=4, $fn=36,\n//         internal=true, bevel=true,\n//         blunt_start=false,\n//         teardrop=true, orient=FWD\n//     );\n//   }\nfunction buttress_threaded_rod(\n    d, l, pitch,\n    left_handed=false, starts=1,\n    bevel,bevel1,bevel2,\n    internal=false,\n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) = no_function(\"buttress_threaded_rod\");\nmodule buttress_threaded_rod(\n    d, l, pitch,\n    left_handed=false, starts=1,\n    bevel,bevel1,bevel2,\n    internal=false,\n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) {\n    depth = pitch * 3/4;\n    profile = [\n        [  -1/2, -0.77],\n        [ -7/16, -0.75],\n        [  5/16,  0],\n        [  7/16,  0],\n        [  7/16, -0.75],\n        [   1/2, -0.77],\n    ];\n    generic_threaded_rod(\n        d=d, l=l, pitch=pitch,\n        profile=profile, \n        left_handed=left_handed,\n        bevel=bevel,bevel1=bevel1,bevel2=bevel2,\n        internal=internal, length=length, height=height, h=h,\n        blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n        lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n        lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n        end_len=end_len, end_len1=end_len1, end_len2=end_len2,\n        d1=d1,d2=d2,\n        teardrop=teardrop,\n        anchor=anchor,\n        spin=spin,starts=starts,\n        orient=orient\n    ) children();\n}\n\n\n\n// Module: buttress_threaded_nut()\n// Synopsis: Creates a buttress-threaded nut.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: buttress_threaded_rod()\n// Usage:\n//   buttress_threaded_nut(nutwidth, id, h|height|thickness, pitch, ...) [ATTACHMENTS];\n// Description:\n//   Constructs a hexagonal or square nut for a simple buttress threaded screw rod.  \n// Arguments:\n//   nutwidth = diameter of the nut.\n//   id = inner diameter of threaded hole, measured from bottom of threads\n//   h / height / l / length / thickness = height/thickness of nut.\n//   pitch = Thread spacing. \n//   ---\n//   shape = specifies shape of nut, either \"hex\" or \"square\".  Default: \"hex\"\n//   left_handed = if true, create left-handed threads.  Default = false\n//   starts = The number of lead starts.  Default: 1\n//   bevel = if true, bevel the outside of the nut.  Default: true for hex nuts, false for square nuts\n//   bevel1 = if true, bevel the outside of the nut bottom.\n//   bevel2 = if true, bevel the outside of the nut top. \n//   bevang = set the angle for the outside nut bevel.  Default: 30\n//   ibevel = if true, bevel the inside (the hole).   Default: true\n//   ibevel1 = if true bevel the inside, bottom end.\n//   ibevel2 = if true bevel the inside, top end.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Examples(Med):\n//   buttress_threaded_nut(nutwidth=16, id=8, h=8, pitch=1.25, left_handed=true, $slop=0.05, $fa=1, $fs=1);\nfunction buttress_threaded_nut(\n    nutwidth, id, h,\n    pitch, shape=\"hex\", left_handed=false,\n    bevel,bevel1,bevel2,bevang=30,starts=1,\n    ibevel,ibevel1,ibevel2,height,thickness,\n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n) = no_function(\"buttress_threaded_nut\");\nmodule buttress_threaded_nut(\n    nutwidth, id, h,\n    pitch, shape=\"hex\", left_handed=false,\n    bevel,bevel1,bevel2,bevang=30,starts=1,\n    ibevel,ibevel1,ibevel2,height,thickness,\n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n) {\n    depth = pitch * 3/4;\n    profile = [\n        [  -1/2, -0.77],\n        [ -7/16, -0.75],\n        [  5/16,  0],\n        [  7/16,  0],\n        [  7/16, -0.75],\n        [  1/ 2, -0.77],\n    ];\n    generic_threaded_nut(\n        nutwidth=nutwidth, id=id, h=h,\n        pitch=pitch,\n        profile=profile,\n        shape=shape,\n        left_handed=left_handed,starts=starts,\n        bevel=bevel,bevel1=bevel1,bevel2=bevel2,bevang=bevang,\n        ibevel=ibevel,ibevel1=ibevel1,ibevel2=ibevel2,\n        blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n        lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n        lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n        end_len=end_len, end_len1=end_len1, end_len2=end_len2,\n        l=l,length=length,\n        anchor=anchor, spin=spin, height=height, thickness=thickness, \n        orient=orient\n    ) children();\n}\n\n\n\n// Section: Square Threading\n\n// Module: square_threaded_rod()\n// Synopsis: Creates a square-threaded rod.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: square_threaded_nut()\n// Usage:\n//   square_threaded_rod(d, l|length, pitch, [internal=], ...) [ATTACHMENTS];\n// Description:\n//   Constructs a square profile threaded screw rod.  The greatest advantage of square threads is\n//   that they have the least friction and a much higher intrinsic efficiency than trapezoidal threads.\n//   They produce no radial load on the nut.  However, square threads cannot carry as much load as trapezoidal threads. \n// Arguments:\n//   d = Outer diameter of threaded rod.\n//   l / length / h / height = Length of threaded rod.\n//   pitch = Thread spacing.\n//   ---\n//   left_handed = if true, create left-handed threads.  Default = false\n//   starts = The number of lead starts.  Default = 1\n//   bevel = if true, bevel the thread ends.  Default: false\n//   bevel1 = if true bevel the bottom end.\n//   bevel2 = if true bevel the top end. \n//   internal = If true, this is a mask for making internal threads.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   teardrop = If true, adds a teardrop profile to the back (Y+) side of the threaded rod, for 3d printability of horizontal holes. If numeric, specifies the proportional extra distance of the teardrop flat top from the screw center, or set to \"max\" for a pointed teardrop. Default: false\n//   d1 = Bottom outside diameter of threads.\n//   d2 = Top outside diameter of threads.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Example(2D):\n//   projection(cut=true)\n//       square_threaded_rod(d=10, l=15, pitch=2, orient=BACK);\n// Examples(Med):\n//   square_threaded_rod(d=10, l=20, pitch=2, starts=2, $fn=32);\n// Example(Med;VPR=[100,0,5];VPD=220): Masking a Horizontal Threaded Hole\n//   difference() {\n//     cuboid(50);\n//     square_threaded_rod(\n//         d=25, l=51, pitch=4, $fn=36,\n//         internal=true, bevel=true,\n//         blunt_start=false,\n//         teardrop=true, orient=FWD\n//     );\n//   }\nfunction square_threaded_rod(\n    d, l, pitch,\n    left_handed=false,\n    bevel,bevel1,bevel2,\n    starts=1,\n    internal=false,\n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) = no_function(\"square_threaded_rod\");\nmodule square_threaded_rod(\n    d, l, pitch,\n    left_handed=false,\n    bevel,bevel1,bevel2,\n    starts=1,\n    internal=false,\n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) {\n    trapezoidal_threaded_rod(\n        d=d, l=l, pitch=pitch,\n        thread_angle=0.1,\n        left_handed=left_handed,\n        bevel=bevel,bevel1=bevel1,bevel2=bevel2,\n        starts=starts,\n        internal=internal, length=length, height=height, h=h,\n        blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n        lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n        lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n        end_len=end_len, end_len1=end_len1, end_len2=end_len2,\n        teardrop=teardrop,\n        d1=d1, d2=d2,\n        anchor=anchor,\n        spin=spin,\n        orient=orient\n    ) children();\n}\n\n\n\n// Module: square_threaded_nut()\n// Synopsis: Creates a square-threaded nut.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: square_threaded_rod()\n// Usage:\n//   square_threaded_nut(nutwidth, id, h|height|thickness, pitch, ...) [ATTACHMENTS];\n// Description:\n//   Constructs a hexagonal or square nut for a square profile threaded screw rod.  \n// Arguments:\n//   nutwidth = diameter of the nut.\n//   id = inner diameter of threaded hole, measured from bottom of threads\n//   h / height / l / length / thickness = height/thickness of nut.\n//   pitch = Length between threads.\n//   ---\n//   shape = specifies shape of nut, either \"hex\" or \"square\".  Default: \"hex\"\n//   left_handed = if true, create left-handed threads.  Default = false\n//   starts = The number of lead starts.  Default = 1\n//   bevel = if true, bevel the outside of the nut.  Default: true for hex nuts, false for square nuts\n//   bevel1 = if true, bevel the outside of the nut bottom.\n//   bevel2 = if true, bevel the outside of the nut top. \n//   bevang = set the angle for the outside nut bevel.  Default: 30\n//   ibevel = if true, bevel the inside (the hole).   Default: true\n//   ibevel1 = if true bevel the inside, bottom end.\n//   ibevel2 = if true bevel the inside, top end.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Examples(Med):\n//   square_threaded_nut(nutwidth=16, id=10, h=10, pitch=2, starts=2, $slop=0.1, $fn=32);\nfunction square_threaded_nut(\n    nutwidth, id, h,\n    pitch,\n    left_handed=false,\n    bevel,bevel1,bevel2,bevang=30,\n    ibevel,ibevel1,ibevel2,\n    height,thickness,    \n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    starts=1,\n    anchor, spin, orient\n) = no_function(\"square_threaded_nut\");\nmodule square_threaded_nut(\n    nutwidth, id, h,\n    pitch,\n    left_handed=false,\n    bevel,bevel1,bevel2,bevang=30,\n    ibevel,ibevel1,ibevel2,\n    height,thickness,    \n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    starts=1,\n    anchor, spin, orient\n) {\n    assert(is_num(pitch) && pitch>=0)\n    trapezoidal_threaded_nut(\n        nutwidth=nutwidth, id=id, h=h, pitch=pitch,\n        thread_angle=0,\n        left_handed=left_handed,\n        bevel=bevel,bevel1=bevel1,bevel2=bevel2, bevang=bevang,\n        ibevel=ibevel, ibevel1=ibevel1, ibevel2=ibevel2,\n        height=height,thickness=thickness,\n        starts=starts,\n        blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n        lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n        lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n        end_len=end_len, end_len1=end_len1, end_len2=end_len2,\n        l=l,length=length,\n        anchor=anchor,\n        spin=spin,\n        orient=orient\n    ) children();\n}\n\n\n// Section: Ball Screws\n\n// Module: ball_screw_rod()\n// Synopsis: Creates a ball screw rod.\n// SynTags: Geom\n// Topics: Threading, Screws\n// Usage:\n//   ball_screw_rod(d, l|length, pitch, [ball_diam], [ball_arc], [internal=], ...) [ATTACHMENTS];\n// Description:\n//   Constructs a ball screw rod.  This type of rod is used with ball bearings.  \n// Arguments:\n//   d = Outer diameter of threaded rod.\n//   l / length / h / height = Length of threaded rod.\n//   pitch = Thread spacing. Also, the diameter of the ball bearings used.\n//   ball_diam = The diameter of the ball bearings to use with this ball screw.\n//   ball_arc = The arc portion that should touch the ball bearings. Default: 120 degrees.\n//   ---\n//   left_handed = if true, create left-handed threads.  Default = false\n//   starts = The number of lead starts.  Default = 1\n//   bevel = if true, bevel the thread ends.  Default: false\n//   bevel1 = if true bevel the bottom end.\n//   bevel2 = if true bevel the top end. \n//   internal = If true, make this a mask for making internal threads.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Example(2D): Thread Profile, ball_diam=4, ball_arc=100\n//   projection(cut=true) ball_screw_rod(d=10, l=15, pitch=5, ball_diam=4, ball_arc=100, orient=BACK, $fn=24, blunt_start=false);\n// Example(2D): Thread Profile, ball_diam=4, ball_arc=120\n//   projection(cut=true) ball_screw_rod(d=10, l=15, pitch=5, ball_diam=4, ball_arc=120, orient=BACK, $fn=24, blunt_start=false);\n// Example(2D): Thread Profile, ball_diam=3, ball_arc=120\n//   projection(cut=true) ball_screw_rod(d=10, l=15, pitch=5, ball_diam=3, ball_arc=120, orient=BACK, $fn=24, blunt_start=false);\n// Examples(Med):\n//   ball_screw_rod(d=15, l=20, pitch=8, ball_diam=5, ball_arc=120, $fa=1, $fs=0.5, blunt_start=false);\n//   ball_screw_rod(d=15, l=20, pitch=5, ball_diam=4, ball_arc=120, $fa=1, $fs=0.5, blunt_start=false);\n//   ball_screw_rod(d=15, l=20, pitch=5, ball_diam=4, ball_arc=120, left_handed=true, $fa=1, $fs=0.5, blunt_start=false);\nfunction ball_screw_rod(\n    d, l, pitch, \n    ball_diam=5, ball_arc=100,\n    starts=1,\n    left_handed=false,\n    internal=false,\n    length, h, height,\n    bevel, bevel1, bevel2,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n) = no_function(\"ball_screw_rod\");\nmodule ball_screw_rod(\n    d, l, pitch, \n    ball_diam=5, ball_arc=100,\n    starts=1,\n    left_handed=false,\n    internal=false,\n    length, h, height,\n    bevel, bevel1, bevel2,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n) {\n    n = max(3,ceil(segs(ball_diam/2)*ball_arc/2/360));\n    depth = ball_diam * (1-cos(ball_arc/2))/2;\n    cpy = ball_diam/2/pitch*cos(ball_arc/2);\n    profile = [\n        each arc(n=n, d=ball_diam/pitch, cp=[-0.5,cpy], start=270, angle=ball_arc/2),\n        each arc(n=n, d=ball_diam/pitch, cp=[+0.5,cpy], start=270-ball_arc/2, angle=ball_arc/2)\n    ];\n    generic_threaded_rod(\n        d=d, l=l, pitch=pitch,\n        profile=profile,\n        left_handed=left_handed,\n        starts=starts,\n        bevel=bevel,bevel1=bevel1,bevel2=bevel2,\n        internal=internal, length=length, height=height, h=h,\n        blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n        lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n        lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n        end_len=end_len, end_len1=end_len1, end_len2=end_len2,\n        anchor=anchor,\n        spin=spin,\n        orient=orient\n    ) children();\n}\n\n\n// Section: Generic Threading\n\n// Module: generic_threaded_rod()\n// Synopsis: Creates a generic threaded rod.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: generic_threaded_nut()\n// Usage:\n//   generic_threaded_rod(d, l|length, pitch, profile, [internal=], ...) [ATTACHMENTS];\n// Description:\n//   Constructs a generic threaded rod using an arbitrary thread profile that you supply.  The rod can be tapered\n//   (e.g. for pipe threads).  For specific thread types use other modules that supply the appropriate profile.\n//   .\n//   You give the profile as a 2D path that will be scaled by the pitch to produce the final thread shape.  The profile\n//   X values must be between -1/2 and 1/2.  The Y=0 point will align with the specified rod diameter, so generally you\n//   want a Y value of zero at the peak (which makes your specified diameter the outer diameter of the threads).  The\n//   value in the valleys of the thread should then be `-depth/pitch` due to the scaling by the thread pitch.  The first\n//   and last points should generally have the same Y value, but it is not necessary to give values at X=1/2 or X=-1/2\n//   if unless the Y values differ from the interior points in the profile.  Generally you should center the profile\n//   horizontally in the interval [-1/2, 1/2].\n//   .\n//   If internal is true then produce a thread mask to difference from an object.  When internal is true the rod\n//   diameter is enlarged to correct for the polygonal nature of circles to ensure that the internal diameter is the\n//   specified size.  The diameter is also increased by `4 * $slop` to create clearance for threading by allowing a `2 *\n//   $slop` gap on each side.  If bevel is set to true and internal is false then the ends of the rod will be beveled.\n//   When bevel is true and internal is true the ends of the rod will be filled in so that the rod mask will create a\n//   bevel when subtracted from an object.  The bevel is at 45 deg and is the depth of the threads.\n//   .\n//   Blunt start threading, which is the default, specifies that the thread ends abruptly at its full width instead of\n//   running off the end of the shaft and leaving a sharp edged partial thread at the end of the screw.  This makes\n//   screws easier to start and prevents cross threading.  Blunt start threads should always be superior, and they are\n//   faster to model, but if you really need standard threads that run off the end you can set `blunt_start=false`.\n//   .\n//   The teardrop option cuts off the threads with a teardrop for 3d printability of horizontal holes.  By default,\n//   if the screw outer radius is r then the flat top will be at distance 1.05r from the center, adding a 5% space.  \n//   You can set teardrop to a numerical value to adjust that percentage, e.g. a value of 0.1 would give a 10% space.\n//   You can set teardrop to \"max\" to create a pointy-top teardrop with no flat section.  \n// Arguments:\n//   d = Outer diameter of threaded rod.\n//   l / length / h / height = Length of threaded rod.\n//   pitch = Thread spacing.\n//   profile = A 2D path giving the shape of a thread\n//   ---\n//   left_handed = If true, create left-handed threads.  Default: false\n//   starts = The number of lead starts.  Default: 1\n//   internal = If true, make this a mask for making internal threads.  Default: false\n//   d1 = Bottom outside diameter of threads.\n//   d2 = Top outside diameter of threads.\n//   bevel = set to true to bevel both ends, a number to specify a bevel size, false for no bevel, and \"reverse\" for an inverted bevel\n//   bevel1 = set bevel for bottom end. \n//   bevel2 = set bevel for top end.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   teardrop = If true, adds a teardrop profile to the back (Y+) side of the threaded rod, for 3d printability of horizontal holes. If numeric, specifies the proportional extra distance of the teardrop flat top from the screw center, or set to \"max\" for a pointed teardrop (see above). Default: false\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\n// Example(2DMed): Example Tooth Profile\n//   pitch = 2;\n//   depth = pitch * cos(30) * 5/8;\n//   profile = [\n//       [-7/16, -depth/pitch*1.07],\n//       [-6/16, -depth/pitch],\n//       [-1/16,  0],\n//       [ 1/16,  0],\n//       [ 6/16, -depth/pitch],\n//       [ 7/16, -depth/pitch*1.07]\n//   ];\n//   stroke(profile, width=0.02);\n// Example:\n//   pitch = 2;\n//   depth = pitch * cos(30) * 5/8;\n//   profile = [\n//       [-7/16, -depth/pitch*1.07],\n//       [-6/16, -depth/pitch],\n//       [-1/16,  0],\n//       [ 1/16,  0],\n//       [ 6/16, -depth/pitch],\n//       [ 7/16, -depth/pitch*1.07]\n//   ];\n//   generic_threaded_rod(d=10, l=40, pitch=2, profile=profile);\n\nfunction generic_threaded_rod(\n    d, l, pitch, profile,\n    left_handed=false, internal=false,\n    bevel, bevel1, bevel2, \n    starts=1,\n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) = no_function(\"generic_threaded_rod\");\nmodule generic_threaded_rod(\n    d, l, pitch, profile,\n    left_handed=false, internal=false,\n    bevel, bevel1, bevel2, \n    starts=1,\n    d1, d2, length, h, height,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    teardrop=false,\n    anchor, spin, orient\n) {\n    len = one_defined([l,length,h,height],\"l,length,h,height\");\n    bevel1 = first_defined([bevel1,bevel]);\n    bevel2 = first_defined([bevel2,bevel]);\n    blunt_start1 = first_defined([blunt_start1, blunt_start, true]);\n    blunt_start2 = first_defined([blunt_start2, blunt_start, true]);                           \n    r1 = get_radius(d1=d1, d=d);\n    r2 = get_radius(d1=d2, d=d);\n    lead_in1 = first_defined([lead_in1, lead_in]);\n    lead_in2 = first_defined([lead_in2, lead_in]);\n    lead_in_func = is_func(lead_in_shape) ? lead_in_shape\n                 : assert(is_string(lead_in_shape),\"lead_in_shape must be a function or string\")\n                   let(ind = search([lead_in_shape], _lead_in_table,0)[0])\n                   assert(ind!=[],str(\"Unknown lead_in_shape, \\\"\",lead_in_shape,\"\\\"\"))\n                   _lead_in_table[ind[0]][1];\n    dummy0 = \n      assert(all_positive([pitch]),\"Thread pitch must be a positive value\")\n      assert(all_positive([len]),\"Length must be a postive value\")\n      assert(is_path(profile),\"Profile must be a path\")\n      assert(is_bool(blunt_start1), \"blunt_start1/blunt_start must be boolean\")\n      assert(is_bool(blunt_start2), \"blunt_start2/blunt_start must be boolean\")\n      assert(is_bool(left_handed))\n      assert(all_positive([r1,r2]), \"Must give d or both d1 and d2 as positive values\")\n      assert(is_undef(bevel1) || is_num(bevel1) || is_bool(bevel1) || bevel1==\"reverse\", \"bevel1/bevel must be a number, boolean or \\\"reverse\\\"\")\n      assert(is_undef(bevel2) || is_num(bevel2) || is_bool(bevel2) || bevel2==\"reverse\", \"bevel2/bevel must be a number, boolean or \\\"reverse\\\"\");\n    sides = quantup(segs(max(r1,r2)), starts);\n    rsc = internal? (1/cos(180/sides)) : 1;    // Internal radius adjusted for faceting\n    islop = internal? 2*get_slop() : 0;\n    r1adj = r1 * rsc + islop;\n    r2adj = r2 * rsc + islop;\n\n    extreme = internal? max(column(profile,1)) : min(column(profile,1));\n    profile = !internal ? profile\n            : let(\n                 maxidx = [for(i=idx(profile)) if (profile[i].y==extreme) i],\n                 cutpt = len(maxidx)==1 ? profile(maxidx[0]).x\n                       : mean([profile[maxidx[0]].x, profile[maxidx[1]].x])\n              )\n              [\n                 for(entry=profile) if (entry.x>=cutpt) [entry.x-cutpt-1/2,entry.y], \n                 for(entry=profile) if (entry.x<cutpt) [entry.x-cutpt+1/2,entry.y]\n              ];\n    profmin = pitch * min(column(profile,1));\n    pmax = pitch * max(column(profile,1));\n    rmax = max(r1adj,r2adj)+pmax;\n\n    // These parameters give the size of the bevel, negative for an outward bevel (e.g. on internal thread mask)  \n    bev1 = (bevel1==\"reverse\"?-1:1)*(internal?-1:1) *\n               ( is_num(bevel1)? bevel1\n               : bevel1==false? 0\n               : blunt_start1? (bevel1==undef?0\n                               :internal ? r1/6\n                               :(r1+profmin)/6)\n               : pmax-profmin);\n    bev2 = (bevel2==\"reverse\"?-1:1)*(internal?-1:1) *\n               ( is_num(bevel2)? bevel2\n               : bevel2==false? 0\n               : blunt_start2? (bevel2==undef?0\n                               :internal ? r2/6\n                               :(r2+profmin)/6)\n               : pmax-profmin);\n    // This is the bevel size used for constructing the polyhedron.  The bevel is integrated when blunt start is on, but\n    // applied later via difference/union if blunt start is off, so set bevel to zero in the latter case.  \n    bevel_size1 = blunt_start1?bev1:0;\n    bevel_size2 = blunt_start2?bev2:0;\n    // This is the bevel size for clipping, which is only done when blunt start is off\n    clip_bev1 = blunt_start1?0:bev1;\n    clip_bev2 = blunt_start2?0:bev2;\n    end_len1_base = !blunt_start1? 0 : first_defined([end_len1,end_len, 0]);\n    end_len2_base = !blunt_start2? 0 : first_defined([end_len2,end_len, 0]);    \n    // Enlarge end lengths to give sufficient room for requested bevel\n    end_len1 = abs(bevel_size1)>0 ? max(end_len1_base, abs(bevel_size1)) : end_len1_base;\n    end_len2 = abs(bevel_size2)>0 ? max(end_len2_base, abs(bevel_size2)) : end_len2_base;\n    // length to create below/above z=0, with an extra revolution in non-blunt-start case so\n    // the threads can continue to the specified length and we can clip off the blunt start                       \n    len1 = -len/2 - (blunt_start1?0:pitch);   \n    len2 =  len/2 + (blunt_start2?0:pitch);\n\n    // Thread turns below and above z=0, with extra to ensure we go beyond the length needed\n    turns1 = len1/pitch-1;\n    turns2 = len2/pitch+1;\n    dir = left_handed? -1 : 1;\n    dummy2=\n        assert(abs(bevel_size1)+abs(bevel_size2)<len, \"Combined bevel size exceeds length of screw\")\n        assert(r1adj+extreme*pitch-bevel_size1>0, \"bevel1 is too large to fit screw diameter\")\n        assert(r2adj+extreme*pitch-bevel_size2>0, \"bevel2 is too large to fit screw diameter\");\n         \n    margin1 = profile[0].y==extreme ? profile[0].x : -1/2;\n    margin2 = last(profile).y==extreme? last(profile).x : 1/2;\n    lead_in_default = pmax-profmin;//2*pitch;\n        // 0*360/10;// /4/32*360; higlen_default;//0*4/32*360; //2/32*360;//360*max(pitch/2, pmax-depth)/(2*PI*r2adj);\n    // lead_in length needs to be quantized to match the samples\n    lead_in_ang1 = !blunt_start1? 0 :\n         let(\n             user_ang = first_defined([lead_in_ang1,lead_in_ang])\n         )\n         assert(is_undef(user_ang) || is_undef(lead_in1), \"Cannot define lead_in/lead_in1 by both length and angle\")\n         quantup(\n                 is_def(user_ang) ? user_ang : default(lead_in1, lead_in_default)*360/(2*PI*r1adj)\n                 , 360/sides);\n    lead_in_ang2 = !blunt_start2? 0 :\n         let(\n             user_ang = first_defined([lead_in_ang2,lead_in_ang])\n         )\n         assert(is_undef(user_ang) || is_undef(lead_in2), \"Cannot define lead_in/lead_in2 by both length and angle\")\n         quantup(\n                 is_def(user_ang) ? user_ang : default(lead_in2, lead_in_default)*360/(2*PI*r2adj)\n                 , 360/sides);\n    // cut_ang also need to be quantized, but the comparison is offset by 36*turns1/starts, so we need to pull that factor out\n    // of the quantization.  (The loop over angle starts at 360*turns1/starts, not at a multiple of 360/sides.)  \n//    cut_ang1 = 360 * (len1/pitch-margin1+end_len1/pitch) / starts + lead_in_ang1;\n//    cut_ang2 = 360 * (len2/pitch-margin2-end_len2/pitch) / starts - lead_in_ang2;\n    cut_ang1 = quantup(360 * (len1/pitch-margin1+end_len1/pitch) / starts + lead_in_ang1-360*turns1/starts,360/sides)+360*turns1/starts;\n    cut_ang2 = quantdn(360 * (len2/pitch-margin2-end_len2/pitch) / starts - lead_in_ang2-360*turns1/starts,360/sides)+360*turns1/starts;\n    dummy1 =\n      assert(cut_ang1<cut_ang2, \"lead in length are too long for the amount of thread: they overlap\")\n      assert(is_num(lead_in_ang1), \"lead_in1/lead_in must be a number\")\n      assert(r1adj+profmin>0 && r2adj+profmin>0, \"Screw profile deeper than rod radius\");\n    map_threads = right((r1adj + r2adj) / 2)                   // Shift profile out to thread radius\n                * affine3d_skew(sxz=(r2adj-r1adj)/len)         // Skew correction for tapered threads\n                * frame_map(x=[0,0,1], y=[1,0,0])          // Map profile to 3d, parallel to z axis\n                * scale(pitch);                            // scale profile by pitch\n    start_steps = sides / starts;\n\n    // This is the location for clipping the polyhedron, below the bevel, if one is present, or at length otherwise\n    // Clipping is done before scaling to pitch, so we need to divide by the pitch\n    rod_clip1 = (len1+abs(bevel_size1))/pitch;\n    rod_clip2 = (len2-abs(bevel_size2))/pitch;\n    prof3d=path3d(profile,1);\n    thread_verts = [\n        // Outer loop constructs a vertical column of the screw at each angle\n        // covering 360/starts degrees of the cylinder.  \n        for (step = [0:1:start_steps])\n            let(\n                ang = 360 * step/sides,\n                dz = step / start_steps,    // z offset for threads at this angle\n                rot_prof = zrot(ang*dir)*map_threads,   // Rotate profile to correct angular location\n                full_profile =  [   // profile for the entire rod\n                    for (turns = [turns1:1:turns2]) \n                        let(\n                            tang = turns/starts * 360 + ang,\n                            // EPSILON offset prevents funny looking extensions of the thread from its very tip\n                            // by forcing values near the tip to evaluate as less than zero = beyond the tip end\n                            hsc = tang < cut_ang1 ? lead_in_func(-EPSILON+1-(cut_ang1-tang)/lead_in_ang1,PI*2*r1adj*lead_in_ang1/360 )\n                                : tang > cut_ang2 ? lead_in_func(-EPSILON+1-(tang-cut_ang2)/lead_in_ang2,PI*2*r2adj*lead_in_ang2/360 )\n                                : [1,1],\n                            shift_and_scale = [[hsc.x, 0], [0,hsc.y], [dz+turns,(1-hsc.y)*extreme]]\n                        )\n                        // This is equivalent to apply(right(dz+turns)*higscale, profile)\n                        //\n                        // The right movement finds the position of the thread along\n                        // what will be the z axis after the profile is mapped to 3d,\n                        // and higscale creates a taper and the end of the threads.  \n                        each prof3d*shift_and_scale\n                ],\n                // Clip profile at the ends of the rod and add a z coordinate\n                full_profile_clipped = [\n                    for(pts=full_profile) [max(rod_clip1,min(rod_clip2,pts.x)), pts.y, 0]\n                ]\n            )\n            [\n              [0,0,len1],\n              //if (true) apply(rot_prof, [len1/pitch,extreme+2/pitch ,0]), \n              if (bevel_size1) apply(rot_prof, [len1/pitch,extreme-bevel_size1/pitch ,0]), \n              each apply(rot_prof, full_profile_clipped),\n              if (bevel_size2) apply(rot_prof, [len2/pitch,extreme-bevel_size2/pitch ,0]), \n              //if (true) apply(rot_prof, [len2/pitch,extreme+2/pitch ,0]), \n              [0, 0, len2]\n            ]\n    ];\n    style=internal?\"concave\":\"convex\";\n    thread_vnf = vnf_join([\n                           for (i=[0:1:starts-1])\n                             zrot(i*360/starts, p=vnf_vertex_array(thread_verts, reverse=left_handed, style=style,col_wrap=false)),\n                          ]);\n    slope = (r1adj-r2adj)/len;\n    dummy3 = \n      assert(r1adj+pmax-clip_bev1>0, \"bevel1 is too large to fit screw diameter\")\n      assert(r2adj+pmax-clip_bev2>0, \"bevel2 is too large to fit screw diameter\")\n      assert(abs(clip_bev1)+abs(clip_bev2)<len, \"Combined bevel size exceeds length of screw\");\n    attachable(anchor,spin,orient, r1=r1adj, r2=r2adj, l=len) {\n        union(){\n          difference() {\n              vnf_polyhedron(thread_vnf,convexity=10);              \n              if (clip_bev1>0)\n                  rotate_extrude()\n                      polygon([[                         0,-len/2],\n                               [r1adj+pmax-clip_bev1      ,-len/2],\n                               [r1adj+pmax-slope*clip_bev1,-len/2+clip_bev1],\n                               [                    rmax+1,-len/2+clip_bev1],\n                               [                    rmax+1, len1-1],\n                               [                         0, len1-1]]);\n              if (clip_bev2>0)\n                  rotate_extrude()\n                      polygon([[                         0, len/2],\n                               [r2adj+pmax-clip_bev2      , len/2],\n                               [r2adj+pmax+slope*clip_bev2, len/2-clip_bev2],\n                               [                    rmax+1, len/2-clip_bev2],\n                               [                    rmax+1, len2+1],\n                               [                         0, len2+1]]);\n              if (!blunt_start1 && clip_bev1<=0)\n                  down(len/2) cuboid([2*rmax+1,2*rmax+1, -len1+1], anchor=TOP);                     \n              if (!blunt_start2 && clip_bev2<=0)\n                  up(len/2) cuboid([2*rmax+1,2*rmax+1, len2+1], anchor=BOTTOM);\n          }\n\n          // Add bevel for internal thread mask\n          if (clip_bev1<0) \n              down(len/2+.001)cyl(l=-clip_bev1, r2=r1adj+profmin, r1=r1adj+profmin+slope*clip_bev1-clip_bev1,anchor=BOTTOM);\n          if (clip_bev2<0) \n              up(len/2+.001)cyl(l=-clip_bev2, r1=r2adj+profmin, r2=r2adj+profmin+slope*clip_bev1-clip_bev2,anchor=TOP);\n\n          // Add teardrop profile\n          if (teardrop!=false) {\n              fact = is_num(teardrop) ? assert(teardrop>=0,\"teardrop value cannot be negative\")1-1/sqrt(2)+teardrop\n                   : is_bool(teardrop) ? 1-1/sqrt(2)+0.05\n                   : teardrop==\"max\" ? 1/sqrt(2)\n                   : assert(false,\"invalid teardrop value\");\n              dummy = assert(fact<=1/sqrt(2), \"teardrop value too large\");\n              pdepth = pmax-profmin;              \n              trap1 = back((r1adj+pmax)/sqrt(2),path3d(list_rotate(trapezoid(ang=45,w1 = (r1adj+pmax)*sqrt(2), h = (r1adj+pmax)*fact,anchor=FWD),1),-l/2));\n              trap2 = back((r2adj+pmax)/sqrt(2),path3d(list_rotate(trapezoid(ang=45,w1 = (r2adj+pmax)*sqrt(2), h = (r2adj+pmax)*fact,anchor=FWD),1), l/2));\n              yproj = [[1,0,0],[0,0,0],[0,0,1]];\n              p1a=trap1[0]+unit([0,0,-l/2]-trap1[0])*pdepth*3/4;\n              p1b=last(trap1)+unit([0,0,-l/2]-last(trap1))*pdepth*3/4;\n              p2a=trap2[0]+unit([0,0,l/2]-trap2[0])*pdepth*3/4;\n              p2b=last(trap2)+  unit([0,0,l/2]-last(trap2))*pdepth*3/4     ;\n              cut1 = reverse([p1a, p1a*yproj, p1b*yproj, p1b]);\n              cut2 = reverse([p2a, p2a*yproj, p2b*yproj, p2b]);\n              vert = [\n                      [each cut1, each trap1],\n                      [each cut2, each trap2]\n              ];\n              vnf_polyhedron(vnf_vertex_array(vert,caps=true,col_wrap=true));\n              //     Old code creates an internal teardrop which unfortunately doesn't print well\n              //ang = min(45,opp_hyp_to_ang(rmax+profmin, rmax+pmax));\n              //xrot(-90) teardrop(l=l, r1=r1adj+profmin, r2=r2adj+profmin, ang=ang, cap_h1=r1adj+pmax, cap_h2=r2adj+pmax);\n          }\n        }\n        children();\n    }\n}\n\n\n\n// Module: generic_threaded_nut()\n// Synopsis: Creates a generic threaded nut.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: generic_threaded_rod()\n// Usage:\n//   generic_threaded_nut(nutwidth, id, h|height|thickness, pitch, profile, [$slop], ...) [ATTACHMENTS];\n// Description:\n//   Constructs a hexagonal or square nut for an generic threaded rod using a user-supplied thread profile.\n//   See {{generic_threaded_rod()}} for details on the profile specification.  \n// Arguments:\n//   nutwidth = outer dimension of nut from flat to flat.\n//   id = inner diameter of threaded hole, measured from bottom of threads\n//   h / height / thickness = height/thickness of nut.\n//   pitch = Thread spacing.\n//   profile = Thread profile.\n//   ---\n//   shape = specifies shape of nut, either \"hex\" or \"square\".  Default: \"hex\"\n//   left_handed = if true, create left-handed threads.  Default = false\n//   starts = The number of lead starts.  Default = 1\n//   id1 = inner diameter at the bottom\n//   id2 = inner diameter at the top\n//   bevel = if true, bevel the outside of the nut.  Default: true for hex nuts, false for square nuts\n//   bevel1 = if true, bevel the outside of the nut bottom.\n//   bevel2 = if true, bevel the outside of the nut top. \n//   bevang = set the angle for the outside nut bevel.  Default: 30\n//   ibevel = if true, bevel the inside (the hole).   Default: true\n//   ibevel1 = if true bevel the inside, bottom end.\n//   ibevel2 = if true bevel the inside, top end.\n//   blunt_start = If true apply truncated blunt start threads at both ends.  Default: true\n//   blunt_start1 = If true apply truncated blunt start threads bottom end.\n//   blunt_start2 = If true apply truncated blunt start threads top end.\n//   end_len = Specify the unthreaded length at the end after blunt start threads.  Default: 0\n//   end_len1 = Specify unthreaded length at the bottom\n//   end_len2 = Specify unthreaded length at the top\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"default\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   $slop = The printer-specific slop value, which adds clearance (`4*$slop`) to internal threads.\nfunction generic_threaded_nut(\n    nutwidth,\n    id,\n    h,\n    pitch,\n    profile,\n    shape=\"hex\",\n    left_handed=false,\n    starts=1,\n    bevel,bevel1,bevel2,bevang=30,\n    ibevel, ibevel1, ibevel2,\n    id1,id2, height, thickness, \n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n) = no_function(\"generic_threaded_nut\");\nmodule generic_threaded_nut(\n    nutwidth,\n    id,\n    h,\n    pitch,\n    profile,\n    shape=\"hex\",\n    left_handed=false,\n    starts=1,\n    bevel,bevel1,bevel2,bevang=30,\n    ibevel, ibevel1, ibevel2,\n    id1,id2, height, thickness, \n    length, l,\n    blunt_start, blunt_start1, blunt_start2,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    end_len, end_len1, end_len2,\n    lead_in_shape=\"default\",\n    anchor, spin, orient\n) {\n    \n    extra = 0.01;\n    id1 = first_defined([id1,id]);\n    id2 = first_defined([id2,id]);\n    h = one_defined([h,height,thickness,l,length],\"h,height,thickness,l,length\");\n    dummyA = assert(is_num(pitch) && pitch>=0, \"pitch must be a nonnegative number\")\n             assert(is_num(h) && h>0, \"height/thickness must be a positive number\")\n             assert(in_list(shape,[\"square\",\"hex\"]), \"shape must be \\\"hex\\\" or \\\"square\\\"\")\n             assert(all_positive([id1,id2]), \"Inner diameter(s) of nut must be positive number(s)\");\n    slope = (id2-id1)/h;\n    full_id1 = id1-slope*extra/2;\n    full_id2 = id2+slope*extra/2;\n    ibevel1 = first_defined([ibevel1,ibevel,true]);\n    ibevel2 = first_defined([ibevel2,ibevel,true]);\n    bevel1 = first_defined([bevel1,bevel,shape==\"hex\"?true:false]);\n    bevel2 = first_defined([bevel2,bevel,shape==\"hex\"?true:false]);\n    depth = -pitch*min(column(profile,1));\n    IBEV=0.05;\n    vnf = linear_sweep(hexagon(id=nutwidth), height=h, center=true);\n    attachable(anchor,spin,orient, size=shape==\"square\" ? [nutwidth,nutwidth,h] : undef, vnf=shape==\"hex\" ? vnf : undef) {\n        difference() {\n            _nutshape(nutwidth,h, shape,bevel1,bevel2);\n            if (pitch==0) \n               cyl(l=h+extra, d1=full_id1+4*get_slop(), d2=full_id2+4*get_slop(),\n                   chamfer1=ibevel1?-IBEV*full_id1:undef,\n                   chamfer2=ibevel2?-IBEV*full_id2:undef);\n            else\n               generic_threaded_rod(\n                     d1=full_id1,d2=full_id2,\n                     l=h+extra,\n                     pitch=pitch,\n                     profile=profile,\n                     left_handed=left_handed,\n                     starts=starts,\n                     internal=true,\n                     bevel1=ibevel1,bevel2=ibevel2,\n                     blunt_start=blunt_start, blunt_start1=blunt_start1, blunt_start2=blunt_start2,\n                     lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2, lead_in_shape=lead_in_shape,\n                     lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n                     end_len=end_len, end_len1=end_len1, end_len2=end_len2\n                );\n        }\n        children();\n    }\n}\n\n\nmodule _nutshape(nutwidth, h, shape, bevel1, bevel2)\n{\n   bevel_d=0.9;\n   intersection(){\n       if (shape==\"hex\")\n         cyl(d=nutwidth, circum=true, $fn=6, l=h, chamfer1=bevel1?0:nutwidth*.01, chamfer2=bevel2?0:nutwidth*.01);\n       else\n         cuboid([nutwidth,nutwidth,h],chamfer=nutwidth*.01, except=[if (bevel1) BOT, if(bevel2) TOP]);\n       fn = quantup(segs(r=nutwidth/2),shape==\"hex\"?6:4);\n       d = shape==\"hex\" ? 2*nutwidth/sqrt(3) : sqrt(2)*nutwidth;\n       chamfsize = (d-nutwidth)/2/bevel_d;\n       cyl(d=d*.99,h=h+.01,realign=true,circum=true,$fn=fn,chamfer1=bevel1?chamfsize:0,chamfer2=bevel2?chamfsize:0,chamfang=30);\n   }\n}\n\n\n// Module: thread_helix()\n// Synopsis: Creates a thread helix to add to a cylinder.\n// SynTags: Geom\n// Topics: Threading, Screws\n// See Also: generic_threaded_rod()\n// Usage:\n//     thread_helix(d, pitch, turns=, [thread_depth=], [thread_angle=|flank_angle=], [profile=], [starts=], [internal=], ...) {ATTACHMENTS};\n//     thread_helix(d1=,d2=, pitch=, turns=, [thread_depth=], [thread_angle=|flank_angle=], [profile=], [starts=], [internal=], ...) {ATTACHMENTS};\n// Description:\n//   Creates a right-handed helical thread with optional end tapering.  Unlike\n//   {{generic_threaded_rod()}, this module just generates the thread, and you specify the total\n//   angle of threading that you want, which makes it easy to put complete threads onto a longer\n//   shaft.  It also optionally makes a finely divided taper at the thread ends.  However, it takes\n//   2-3 times as long to render compared to {{generic_threaded_rod()}}.  This module was designed\n//   to handle threads found in plastic and glass bottles.\n//   .\n//   You can specify a thread_depth and flank_angle, in which case you get a symmetric trapezoidal\n//   thread, whose inner diameter (the base of the threads for external threading) is d (so the\n//   total diameter will be d + thread_depth).  This differs from the threaded_rod modules, where\n//   the specified diameter is the outer diameter.  Alternatively you can give a profile, following\n//   the same rules as for general_threaded_rod.  The Y=0 point will align with the specified\n//   diameter, and the profile should range in X from -1/2 to 1/2.  You cannot specify both the\n//   profile and the thread_depth or flank_angle.\n//   .\n//   Unlike {{generic_threaded_rod()}, when internal=true this module generates the threads, not a thread mask.\n//   The profile needs to be inverted to produce the proper thread form.  If you use the built-in trapezoidal\n//   thread you get the inverted thread, designed so that the inner diameter is d.  If you supply a custom profile\n//   you must invert it yourself to get internal threads.  With adequate clearance\n//   this thread will mate with the thread that uses the same parameters but has internal=false.  Note that\n//   unlike the threaded_rod modules, thread_helix does not adjust the diameter for faceting, nor does it\n//   subtract any $slop for clearance.  \n//   .\n//   The lead_in options specify a lead-in section where the ends of the threads scale down to avoid a sharp face at the thread ends.\n//   You can specify the length of this scaling directly with the lead_in parameters or as an angle using the lead_in_ang parameters.\n//   If you give a positive value, the extrusion is lengthenend by the specified distance or angle; if you give a negative\n//   value then the scaled end is included in the extrusion length specified by `turns`.  If the value is zero then no scaled ends\n//   are produced.  The shape of the scaled ends can be controlled with the lead_in_shape parameter.  Supported options are \"sqrt\", \"linear\"\n//   \"smooth\" and \"cut\".  Lead-in works on both internal and external threads.\n// Figure(2D,Med,NoAxes):\n//   pa_delta = tan(15)/4;\n//      rr1 = -1/2;\n//      z1 = 1/4-pa_delta;\n//      z2 = 1/4+pa_delta;\n//      profile = [\n//                  [-z2, rr1],\n//                  [-z1,  0],\n//                  [ z1,  0],\n//                  [ z2, rr1],\n//                ];\n//      fullprofile = 50*left(1/2,p=concat(profile, right(1, p=profile)));\n//      stroke(fullprofile,width=1);\n//      dir = fullprofile[2]-fullprofile[3];\n//      dir2 = fullprofile[5]-fullprofile[4];\n//      curve = arc(15,angle=[75,87],r=40 /*67.5*/);\n//      avgpt = mean([fullprofile[5]+.1*dir2, fullprofile[5]+.4*dir2]);\n//      color(\"red\"){\n//       stroke([fullprofile[4]+[0,1], fullprofile[4]+[0,37]], width=1);\n//       stroke([fullprofile[5]+.1*dir2, fullprofile[5]+.4*dir2], width=1);\n//       stroke(move(-curve[0]+avgpt,p=curve), width=0.71,endcaps=\"arrow2\");\n//       right(14)back(19)text(\"flank\",size=4,halign=\"center\");\n//       right(14)back(14)text(\"angle\",size=4,halign=\"center\");\n//      }\n// Figure(2D,Med,NoAxes):\n//   pa_delta = tan(15)/4;\n//   rr1 = -1/2;\n//   z1 = 1/4-pa_delta;\n//   z2 = 1/4+pa_delta;\n//   profile = [\n//               [-z2, rr1],\n//               [-z1,  0],\n//               [ z1,  0],\n//               [ z2, rr1],\n//             ];\n//   fullprofile = 50*left(1/2,p=concat(profile, right(1, p=profile)));\n//   stroke(fullprofile,width=1);\n//   dir = fullprofile[2]-fullprofile[3];\n//   dir2 = fullprofile[5]-fullprofile[4];\n//   curve = arc(32,angle=[75,105],r=67.5);\n//   avgpt = mean([fullprofile[5]+.1*dir2, fullprofile[5]+.4*dir2]);\n//   color(\"red\"){\n//    stroke([fullprofile[2]+.1*dir, fullprofile[2]+.4*dir], width=1);\n//    stroke([fullprofile[5]+.1*dir2, fullprofile[5]+.4*dir2], width=1);\n//    stroke(move(-curve[0]+avgpt,p=curve), width=1,endcaps=\"arrow2\");\n//    back(10)text(\"thread\",size=4,halign=\"center\");\n//    back(3)text(\"angle\",size=4,halign=\"center\");\n//   }\n// Arguments:\n//   d = Base diameter of threads.  Default: 10\n//   pitch = Distance between threads.  Default: 2\n//   ---\n//   turns = Number of revolutions to rotate thread around.\n//   thread_depth = Depth of threads from top to bottom.\n//   flank_angle = Angle of thread faces to plane perpendicular to screw.  Default: 15 degrees.\n//   thread_angle = Angle between two thread faces.  \n//   profile = If an asymmetrical thread profile is needed, it can be specified here.\n//   starts = The number of thread starts.  Default: 1\n//   left_handed = If true, thread has a left-handed winding.\n//   internal = if true make internal threads.  The only effect this has is to change how the thread lead_in is constructed. When true, the lead-in section tapers towards the outside; when false, it tapers towards the inside.  Default: false\n//   d1 = Bottom inside base diameter of threads.\n//   d2 = Top inside base diameter of threads.\n//   lead_in = Specify linear length of the lead in section of the threading with blunt start threads\n//   lead_in1 = Specify linear length of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in2 = Specify linear length of the lead in section of the threading at the top with blunt start threads\n//   lead_in_ang = Specify angular length in degrees of the lead in section of the threading with blunt start threads\n//   lead_in_ang1 = Specify angular length in degrees of the lead in section of the threading at the bottom with blunt start threads\n//   lead_in_ang2 = Specify angular length in degrees of the lead in section of the threading at the top with blunt start threads\n//   lead_in_shape = Specify the shape of the thread lead in by giving a text string or function.  Default: \"sqrt\"\n//   lead_in_sample = Factor to increase sample rate in the lead-in section.  Default: 10\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n// Example(2DMed): Typical Tooth Profile\n//   pitch = 2;\n//   depth = pitch * cos(30) * 5/8;\n//   profile = [\n//       [-6/16, 0           ],\n//       [-1/16, depth/pitch ],\n//       [ 1/16, depth/pitch ],\n//       [ 6/16, 0           ],\n//   ];\n//   stroke(profile, width=0.02);\n// Examples:\n//   thread_helix(d=10, pitch=2, thread_depth=0.75, flank_angle=15, turns=2.5, $fn=72);\n//   thread_helix(d=10, pitch=2, thread_depth=0.75, flank_angle=15, turns=2.5, lead_in=1, $fn=72);\n//   thread_helix(d=10, pitch=2, thread_depth=0.75, flank_angle=15, turns=2, lead_in=2, internal=true, $fn=72);\n//   thread_helix(d=10, pitch=2, thread_depth=0.75, flank_angle=15, turns=1, left_handed=true, lead_in=1, $fn=36);\nfunction thread_helix(\n    d, pitch, thread_depth, flank_angle, turns,\n    profile, starts=1, left_handed=false, internal=false,\n    d1, d2, thread_angle, \n    lead_in_shape,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    lead_in_sample=10,\n    anchor, spin, orient\n) = no_function(\"thread_helix\");\nmodule thread_helix(\n    d, pitch, thread_depth, flank_angle, turns,\n    profile, starts=1, left_handed=false, internal=false,\n    d1, d2, thread_angle, \n    lead_in_shape,\n    lead_in, lead_in1, lead_in2,\n    lead_in_ang, lead_in_ang1, lead_in_ang2,\n    lead_in_sample=10,\n    anchor, spin, orient\n) {\n    dummy1=assert(num_defined([thread_angle,flank_angle])<=1, \"Cannot define both flank angle and thread angle\")\n           assert(is_undef(profile) || !any_defined([thread_depth, flank_angle]),\n                  \"Cannot give thread_depth or flank_angle with a profile\")\n           assert(all_positive([turns]), \"The turns parameter must be a positive number\")\n           assert(all_positive(pitch), \"pitch must be a positive number\")\n           assert(num_defined([flank_angle,thread_angle])<=1, \"Cannot give both thread_angle and flank_angle\")\n           assert(is_def(profile) || is_def(thread_depth), \"If profile is not given, must give thread depth\");\n    flank_angle = first_defined([flank_angle,u_mul(0.5,thread_angle),15]);\n    h = pitch*starts*abs(turns);\n    r1 = get_radius(d1=d1, d=d, dflt=10);\n    r2 = get_radius(d1=d2, d=d, dflt=10);\n    profile = is_def(profile) ? profile :\n        let(\n            tdp = thread_depth / pitch,\n            dz = tdp * tan(flank_angle),\n            cap = (1 - 2*dz)/2\n        )\n        assert(cap/2+dz<=0.5, \"Invalid geometry: incompatible thread depth and thread_angle/flank_angle\")\n        internal?\n          [\n            [-cap/2-dz, tdp],\n            [-cap/2,    0  ],\n            [+cap/2,    0  ],\n            [+cap/2+dz, tdp],\n          ]\n        :\n          [\n            [+cap/2+dz, 0  ],\n            [+cap/2,    tdp],\n            [-cap/2,    tdp],\n            [-cap/2-dz, 0  ],\n          ];\n\n    pline = mirror([-1,1],  p = profile * pitch);\n    dir = left_handed? -1 : 1;\n    attachable(anchor,spin,orient, r1=r1, r2=r2, l=h) {\n        union(){\n        zrot_copies(n=starts)\n            spiral_sweep(pline, h=h, r1=r1, r2=r2, turns=turns*dir, internal=internal,\n                         lead_in_shape=lead_in_shape,\n                         lead_in=lead_in, lead_in1=lead_in1, lead_in2=lead_in2,\n                         lead_in_ang=lead_in_ang, lead_in_ang1=lead_in_ang1, lead_in_ang2=lead_in_ang2,\n                         lead_in_sample=lead_in_sample,anchor=CENTER);\n        }\n        children();\n    }\n}\n\n\n\n// Questions\n//   Should nut modules take d1/d2 for tapered nuts?\n//\n// Need explanation of what exactly the diff is between threaded_rod and helix_threads.\n//\n// What about blunt_start for ball screws?\n// Should default bevel be capped at 1mm or 2mm or something like that?  Including/especially inner bevel on nuts\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-44", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: transforms.scad\n//   Functions and modules that provide shortcuts for translation,\n//   rotation and mirror operations.  Also provided are skew and frame_map\n//   which remaps the coordinate axes.  The shortcuts can act on\n//   geometry, like the usual OpenSCAD rotate() and translate(). They\n//   also work as functions that operate on lists of points in various\n//   forms: paths, VNFS and bezier patches. Lastly, the function form\n//   of the shortcuts can return a matrix representing the operation\n//   the shortcut performs. The rotation and scaling shortcuts accept\n//   an optional centerpoint for the rotation or scaling operation.\n//   .\n//   Almost all of the transformation functions take a point, a point\n//   list, bezier patch, or VNF as a second positional argument to\n//   operate on.  The exceptions are rot(), frame_map() and skew().\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Basic Modeling\n// FileSummary: Shortcuts for translation, rotation, etc.  Can act on geometry, paths, or can return a matrix.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n// Section: Affine Transformations\n//   OpenSCAD provides various built-in modules to transform geometry by\n//   translation, scaling, rotation, and mirroring.  All of these operations\n//   are affine transformations.  A three-dimensional affine transformation\n//   can be represented by a 4x4 matrix.  The transformation shortcuts in this\n//   file generally have three modes of operation.  They can operate\n//   directly on geometry like their OpenSCAD built-in equivalents.  For example,\n//   `left(10) cube()`.  They can operate on a list of points (or various other\n//   types of geometric data).  For example, operating on a list of points: `points = left(10, [[1,2,3],[4,5,6]])`.\n//   The third option is that the shortcut can return the transformation matrix\n//   corresponding to its action.  For example, `M=left(10)`.\n//   .\n//   This capability allows you to store and manipulate transformations, and can\n//   be useful in more advanced modeling.  You can multiply these matrices\n//   together, analogously to applying a sequence of operations with the\n//   built-in transformations.  So you can write `zrot(37)left(5)cube()`\n//   to perform two operations on a cube.  You can also store\n//   that same transformation by multiplying the matrices together: `M = zrot(37) * left(5)`.\n//   Note that the order is exactly the same as the order used to apply the transformation.\n//   .\n//   Suppose you have constructed `M` as above.  What now?  You can use\n//   the OpensCAD built-in `multmatrix` to apply it to some geometry:  `multmatrix(M) cube()`.\n//   Alternative you can use the BOSL2 function `apply` to apply `M` to a point, a list\n//   of points, a bezier patch, or a VNF.  For example, `points = apply(M, [[3,4,5],[5,6,7]])`.\n//   Note that the `apply` function can work on both 2D and 3D data, but if you want to\n//   operate on 2D data, you must choose transformations that don't modify z\n//   .\n//   You can use matrices as described above without understanding the details, just\n//   treating a matrix as a box that stores a transformation.  The OpenSCAD manual section for multmatrix\n//   gives some details of how this works.  We'll elaborate a bit more below.  An affine transformation\n//   matrix for three dimensional data is a 4x4 matrix.  The top left 3x3 portion gives the linear\n//   transformation to apply to the data.  For example, it could be a rotation or scaling, or combination of both.\n//   The 3x1 column at the top right gives the translation to apply.  The bottom row should be `[0,0,0,1]`.  That\n//   bottom row is only present to enable\n//   the matrices to be multiplied together.  OpenSCAD ignores it and in fact `multmatrix` will\n//   accept a 3x4 matrix, where that row is missing.  In order for a matrix to act on a point you have to\n//   augment the point with an extra 1, making it a length 4 vector.  In OpenSCAD you can then compute the\n//   the affine transformed point as `tran_point = M * point`.  However, this syntax hides a complication that\n//   arises if you have a list of points.  A list of points like `[[1,2,3,1],[4,5,6,1],[7,8,9,1]]` has the augmented points\n//   as row vectors on the list.  In order to transform such a list, it needs to be muliplied on the right\n//   side, not the left side.\n\n\n\n_NO_ARG = [true,[123232345],false];\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Translations\n//////////////////////////////////////////////////////////////////////\n\n// Function&Module: move()\n// Aliases: translate()\n//\n// Synopsis: Translates children in an arbitrary direction.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Translation\n// See Also: left(), right(), fwd(), back(), down(), up(), spherical_to_xyz(), altaz_to_xyz(), cylindrical_to_xyz(), polar_to_xy()\n//\n// Usage: As Module\n//   move(v) CHILDREN;\n// Usage: As a function to translate points, VNF, or Bezier patches\n//   pts = move(v, p);\n//   pts = move(STRING, p);\n// Usage: Get Translation Matrix\n//   mat = move(v);\n//\n// Description:\n//   Translates position by the given amount.\n//   * Called as a module, moves/translates all children.\n//   * Called as a function with the `p` argument, returns the translated point or list of points.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the translated patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the translated VNF.\n//   * Called as a function with the `p` argument set to a VNF or a polygon and `v` set to \"centroid\", \"mean\" or \"box\", translates the argument to the centroid, mean, or bounding box center respectively.\n//   * Called as a function without a `p` argument, returns a 4x4 translation matrix for operating on 3D data.  \n//\n// Arguments:\n//   v = An [X,Y,Z] vector to translate by.  For function form with `p` a point list or VNF, can be \"centroid\", \"mean\" or \"box\".  \n//   p = Either a point, or a list of points to be translated when used as a function.\n//\n// Example:\n//   #sphere(d=10);\n//   move([0,20,30]) sphere(d=10);\n//\n// Example: You can move a 3D object with a 2D vector.  The Z component is treated as zero.  \n//   #sphere(d=10);\n//   move([-10,-5]) sphere(d=10);\n//\n// Example(2D): Move to centroid\n//   polygon(move(\"centroid\", right_triangle([10,4])));\n//\n// Example(FlatSpin): Using Altitude-Azimuth Coordinates\n//   #sphere(d=10);\n//   move(altaz_to_xyz(30,90,20)) sphere(d=10);\n//\n// Example(FlatSpin): Using Spherical Coordinates\n//   #sphere(d=10);\n//   move(spherical_to_xyz(20,45,30)) sphere(d=10);\n//\n// Example(2D):\n//   path = square([50,30], center=true);\n//   #stroke(path, closed=true);\n//   stroke(move([10,20],p=path), closed=true);\n//\n// Example(NORENDER):\n//   pt1 = move([0,20,30], p=[15,23,42]);       // Returns: [15, 43, 72]\n//   pt2 = move([0,3,1], p=[[1,2,3],[4,5,6]]);  // Returns: [[1,5,4], [4,8,7]]\n//   mat2d = move([2,3]);    // Returns: [[1,0,2],[0,1,3],[0,0,1]]\n//   mat3d = move([2,3,4]);  // Returns: [[1,0,0,2],[0,1,0,3],[0,0,1,4],[0,0,0,1]]\nmodule move(v=[0,0,0], p) {\n    req_children($children);  \n    assert(!is_string(v),\"Module form of `move()` does not accept string `v` arguments\");\n    assert(is_undef(p), \"Module form `move()` does not accept p= argument.\");\n    assert(is_vector(v) && (len(v)==3 || len(v)==2), \"Invalid value for `v`\")\n    translate(point3d(v)) children();\n}\n\nfunction move(v=[0,0,0], p=_NO_ARG) =\n    is_string(v) ? (\n        assert(is_vnf(p) || is_path(p),\"String movements only work with point lists and VNFs\")\n        let(\n             center = v==\"centroid\" ? centroid(p)\n                    : v==\"mean\" ? mean(p)\n                    : v==\"box\" ? mean(pointlist_bounds(p))\n                    : assert(false,str(\"Unknown string movement \",v))\n        )\n        move(-center,p=p)\n      )\n    :\n    assert(is_vector(v) && (len(v)==3 || len(v)==2), \"Invalid value for `v`\")\n    let(\n        m = affine3d_translate(point3d(v))\n    )\n    p==_NO_ARG ? m : apply(m, p);\n\nfunction translate(v=[0,0,0], p=_NO_ARG) = move(v=v, p=p);\n\n\n// Function&Module: left()\n//\n// Synopsis: Translates children leftwards (X-).\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Translation\n// See Also: move(), right(), fwd(), back(), down(), up()\n//\n// Usage: As Module\n//   left(x) CHILDREN;\n// Usage: Translate Points\n//   pts = left(x, p);\n// Usage: Get Translation Matrix\n//   mat = left(x);\n//\n// Description:\n//   If called as a module, moves/translates all children left (in the X- direction) by the given amount.\n//   If called as a function with the `p` argument, returns the translated VNF, point or list of points.\n//   If called as a function without the `p` argument, returns an affine3d translation matrix.\n//\n// Arguments:\n//   x = Scalar amount to move left.\n//   p = Either a point, or a list of points to be translated when used as a function.\n//\n// Example:\n//   #sphere(d=10);\n//   left(20) sphere(d=10);\n//\n// Example(NORENDER):\n//   pt1 = left(20, p=[23,42]);           // Returns: [3,42]\n//   pt2 = left(20, p=[15,23,42]);        // Returns: [-5,23,42]\n//   pt3 = left(3, p=[[1,2,3],[4,5,6]]);  // Returns: [[-2,2,3], [1,5,6]]\n//   mat3d = left(4);  // Returns: [[1,0,0,-4],[0,1,0,0],[0,0,1,0],[0,0,0,1]]\nmodule left(x=0, p) {\n    req_children($children);    \n    assert(is_undef(p), \"Module form `left()` does not accept p= argument.\");\n    assert(is_finite(x), \"Invalid number\")\n    translate([-x,0,0]) children();\n}\n\nfunction left(x=0, p=_NO_ARG) =\n    assert(is_finite(x), \"Invalid number\")\n    move([-x,0,0],p=p);\n\n\n// Function&Module: right()\n// Aliases: xmove()\n//\n// Synopsis: Translates children rightwards (X+).\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Translation\n// See Also: move(), left(), fwd(), back(), down(), up()\n//\n// Usage: As Module\n//   right(x) CHILDREN;\n// Usage: Translate Points\n//   pts = right(x, p);\n// Usage: Get Translation Matrix\n//   mat = right(x);\n//\n// Description:\n//   If called as a module, moves/translates all children right (in the X+ direction) by the given amount.\n//   If called as a function with the `p` argument, returns the translated VNF point or list of points.\n//   If called as a function without the `p` argument, returns an affine3d translation matrix.\n//\n// Arguments:\n//   x = Scalar amount to move right.\n//   p = Either a point, or a list of points to be translated when used as a function.\n//\n// Example:\n//   #sphere(d=10);\n//   right(20) sphere(d=10);\n//\n// Example(NORENDER):\n//   pt1 = right(20, p=[23,42]);           // Returns: [43,42]\n//   pt2 = right(20, p=[15,23,42]);        // Returns: [35,23,42]\n//   pt3 = right(3, p=[[1,2,3],[4,5,6]]);  // Returns: [[4,2,3], [7,5,6]]\n//   mat3d = right(4);  // Returns: [[1,0,0,4],[0,1,0,0],[0,0,1,0],[0,0,0,1]]\nmodule right(x=0, p) {\n    req_children($children);    \n    assert(is_undef(p), \"Module form `right()` does not accept p= argument.\");\n    assert(is_finite(x), \"Invalid number\")\n    translate([x,0,0]) children();\n}\n\nfunction right(x=0, p=_NO_ARG) =\n    assert(is_finite(x), \"Invalid number\")\n    move([x,0,0],p=p);\n\nmodule xmove(x=0, p) {\n    req_children($children);    \n    assert(is_undef(p), \"Module form `xmove()` does not accept p= argument.\");\n    assert(is_finite(x), \"Invalid number\")\n    translate([x,0,0]) children();\n}\n\nfunction xmove(x=0, p=_NO_ARG) =\n    assert(is_finite(x), \"Invalid number\")\n    move([x,0,0],p=p);\n\n\n// Function&Module: fwd()\n//\n// Synopsis: Translates children forwards (Y-).\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Translation\n// See Also: move(), left(), right(), back(), down(), up()\n//\n// Usage: As Module\n//   fwd(y) CHILDREN;\n// Usage: Translate Points\n//   pts = fwd(y, p);\n// Usage: Get Translation Matrix\n//   mat = fwd(y);\n//\n// Description:\n//   If called as a module, moves/translates all children forward (in the Y- direction) by the given amount.\n//   If called as a function with the `p` argument, returns the translated VNF, point or list of points.\n//   If called as a function without the `p` argument, returns an affine3d translation matrix.\n//\n// Arguments:\n//   y = Scalar amount to move forward.\n//   p = Either a point, or a list of points to be translated when used as a function.\n//\n// Example:\n//   #sphere(d=10);\n//   fwd(20) sphere(d=10);\n//\n// Example(NORENDER):\n//   pt1 = fwd(20, p=[23,42]);           // Returns: [23,22]\n//   pt2 = fwd(20, p=[15,23,42]);        // Returns: [15,3,42]\n//   pt3 = fwd(3, p=[[1,2,3],[4,5,6]]);  // Returns: [[1,-1,3], [4,2,6]]\n//   mat3d = fwd(4);  // Returns: [[1,0,0,0],[0,1,0,-4],[0,0,1,0],[0,0,0,1]]\nmodule fwd(y=0, p) {\n    req_children($children);    \n    assert(is_undef(p), \"Module form `fwd()` does not accept p= argument.\");\n    assert(is_finite(y), \"Invalid number\")\n    translate([0,-y,0]) children();\n}\n\nfunction fwd(y=0, p=_NO_ARG) =\n    assert(is_finite(y), \"Invalid number\")\n    move([0,-y,0],p=p);\n\n\n// Function&Module: back()\n// Aliases: ymove()\n//\n// Synopsis: Translates children backwards (Y+).\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Translation\n// See Also: move(), left(), right(), fwd(), down(), up()\n//\n// Usage: As Module\n//   back(y) CHILDREN;\n// Usage: Translate Points\n//   pts = back(y, p);\n// Usage: Get Translation Matrix\n//   mat = back(y);\n//\n// Description:\n//   If called as a module, moves/translates all children back (in the Y+ direction) by the given amount.\n//   If called as a function with the `p` argument, returns the translated VNF, point or list of points.\n//   If called as a function without the `p` argument, returns an affine3d translation matrix.\n//\n// Arguments:\n//   y = Scalar amount to move back.\n//   p = Either a point, or a list of points to be translated when used as a function.\n//\n// Example:\n//   #sphere(d=10);\n//   back(20) sphere(d=10);\n//\n// Example(NORENDER):\n//   pt1 = back(20, p=[23,42]);           // Returns: [23,62]\n//   pt2 = back(20, p=[15,23,42]);        // Returns: [15,43,42]\n//   pt3 = back(3, p=[[1,2,3],[4,5,6]]);  // Returns: [[1,5,3], [4,8,6]]\n//   mat3d = back(4);  // Returns: [[1,0,0,0],[0,1,0,4],[0,0,1,0],[0,0,0,1]]\nmodule back(y=0, p) {\n    req_children($children);    \n    assert(is_undef(p), \"Module form `back()` does not accept p= argument.\");\n    assert(is_finite(y), \"Invalid number\")\n    translate([0,y,0]) children();\n}\n\nfunction back(y=0,p=_NO_ARG) =\n    assert(is_finite(y), \"Invalid number\")\n    move([0,y,0],p=p);\n\nmodule ymove(y=0, p) {\n    req_children($children);    \n    assert(is_undef(p), \"Module form `ymove()` does not accept p= argument.\");\n    assert(is_finite(y), \"Invalid number\")\n    translate([0,y,0]) children();\n}\n\nfunction ymove(y=0,p=_NO_ARG) =\n    assert(is_finite(y), \"Invalid number\")\n    move([0,y,0],p=p);\n\n\n// Function&Module: down()\n//\n// Synopsis: Translates children downwards (Z-).\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Translation\n// See Also: move(), left(), right(), fwd(), back(), up()\n//\n// Usage: As Module\n//   down(z) CHILDREN;\n// Usage: Translate Points\n//   pts = down(z, p);\n// Usage: Get Translation Matrix\n//   mat = down(z);\n//\n// Description:\n//   If called as a module, moves/translates all children down (in the Z- direction) by the given amount.\n//   If called as a function with the `p` argument, returns the translated VNF, point or list of points.\n//   If called as a function without the `p` argument, returns an affine3d translation matrix.\n//\n// Arguments:\n//   z = Scalar amount to move down.\n//   p = Either a point, or a list of points to be translated when used as a function.\n//\n// Example:\n//   #sphere(d=10);\n//   down(20) sphere(d=10);\n//\n// Example(NORENDER):\n//   pt1 = down(20, p=[15,23,42]);        // Returns: [15,23,22]\n//   pt2 = down(3, p=[[1,2,3],[4,5,6]]);  // Returns: [[1,2,0], [4,5,3]]\n//   mat3d = down(4);  // Returns: [[1,0,0,0],[0,1,0,0],[0,0,1,-4],[0,0,0,1]]\nmodule down(z=0, p) {\n    req_children($children);    \n    assert(is_undef(p), \"Module form `down()` does not accept p= argument.\");\n    translate([0,0,-z]) children();\n}\n\nfunction down(z=0, p=_NO_ARG) =\n    assert(is_finite(z), \"Invalid number\")\n    move([0,0,-z],p=p);\n\n\n// Function&Module: up()\n// Aliases: zmove()\n//\n// Synopsis: Translates children upwards (Z+).\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Translation\n// See Also: move(), left(), right(), fwd(), back(), down()\n//\n// Usage: As Module\n//   up(z) CHILDREN;\n// Usage: Translate Points\n//   pts = up(z, p);\n// Usage: Get Translation Matrix\n//   mat = up(z);\n//\n// Description:\n//   If called as a module, moves/translates all children up (in the Z+ direction) by the given amount.\n//   If called as a function with the `p` argument, returns the translated VNF, point or list of points.\n//   If called as a function without the `p` argument, returns an affine3d translation matrix.\n//\n// Arguments:\n//   z = Scalar amount to move up.\n//   p = Either a point, or a list of points to be translated when used as a function.\n//\n// Example:\n//   #sphere(d=10);\n//   up(20) sphere(d=10);\n//\n// Example(NORENDER):\n//   pt1 = up(20, p=[15,23,42]);        // Returns: [15,23,62]\n//   pt2 = up(3, p=[[1,2,3],[4,5,6]]);  // Returns: [[1,2,6], [4,5,9]]\n//   mat3d = up(4);  // Returns: [[1,0,0,0],[0,1,0,0],[0,0,1,4],[0,0,0,1]]\nmodule up(z=0, p) {\n    req_children($children);      \n    assert(is_undef(p), \"Module form `up()` does not accept p= argument.\");\n    assert(is_finite(z), \"Invalid number\");\n    translate([0,0,z]) children();\n}\n\nfunction up(z=0, p=_NO_ARG) =\n    assert(is_finite(z), \"Invalid number\")\n    move([0,0,z],p=p);\n\nmodule zmove(z=0, p) {\n    req_children($children);      \n    assert(is_undef(p), \"Module form `zmove()` does not accept p= argument.\");\n    assert(is_finite(z), \"Invalid number\");\n    translate([0,0,z]) children();\n}\n\nfunction zmove(z=0, p=_NO_ARG) =\n    assert(is_finite(z), \"Invalid number\")\n    move([0,0,z],p=p);\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Rotations\n//////////////////////////////////////////////////////////////////////\n\n\n// Function&Module: rot()\n//\n// Synopsis: Rotates children in various ways.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Rotation\n// See Also: xrot(), yrot(), zrot(), tilt()\n//\n// Usage: As a Module\n//   rot(a, [cp=], [reverse=]) CHILDREN;\n//   rot([X,Y,Z], [cp=], [reverse=]) CHILDREN;\n//   rot(a, v, [cp=], [reverse=]) CHILDREN;\n//   rot(from=, to=, [a=], [reverse=]) CHILDREN;\n// Usage: As a Function to transform data in `p`\n//   pts = rot(a, p=, [cp=], [reverse=]);\n//   pts = rot([X,Y,Z], p=, [cp=], [reverse=]);\n//   pts = rot(a, v, p=, [cp=], [reverse=]);\n//   pts = rot([a], from=, to=, p=, [reverse=]);\n// Usage: As a Function to return a transform matrix\n//   M = rot(a, [cp=], [reverse=]);\n//   M = rot([X,Y,Z], [cp=], [reverse=]);\n//   M = rot(a, v, [cp=], [reverse=]);\n//   M = rot(from=, to=, [a=], [reverse=]);\n//\n// Description:\n//   This is a shorthand version of the built-in `rotate()`, and operates similarly, with a few additional capabilities.\n//   You can specify the rotation to perform in one of several ways:\n//   * `rot(30)` or `rot(a=30)` rotates 30 degrees around the Z axis.\n//   * `rot([20,30,40])` or `rot(a=[20,30,40])` rotates 20 degrees around the X axis, then 30 degrees around the Y axis, then 40 degrees around the Z axis.\n//   * `rot(30, [1,1,0])` or `rot(a=30, v=[1,1,0])` rotates 30 degrees around the axis vector `[1,1,0]`.\n//   * `rot(from=[0,0,1], to=[1,0,0])` rotates the `from` vector to line up with the `to` vector, in this case the top to the right and hence equivalent to `rot(a=90,v=[0,1,0]`.\n//   * `rot(from=[0,1,1], to=[1,1,0], a=45)` rotates 45 degrees around the `from` vector ([0,1,1]) and then rotates the `from` vector to align with the `to` vector.  Equivalent to `rot(from=[0,1,1],to=[1,1,0]) rot(a=45,v=[0,1,1])`.  You can also regard `a` as as post-rotation around the `to` vector.  For this form, `a` must be a scalar.\n//   * If the `cp` centerpoint argument is given, then rotations are performed around that centerpoint.  So `rot(args...,cp=[1,2,3])` is equivalent to `move(-[1,2,3])rot(args...)move([1,2,3])`.\n//   * If the `reverse` argument is true, then the rotations performed will be exactly reversed.\n//   .\n//   The behavior and return value varies depending on how `rot()` is called:\n//   * Called as a module, rotates all children.\n//   * Called as a function with a `p` argument containing a point, returns the rotated point.\n//   * Called as a function with a `p` argument containing a list of points, returns the list of rotated points.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the rotated patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the rotated VNF.\n//   * Called as a function without a `p` argument, returns the affine3d rotational matrix.\n//   Note that unlike almost all the other transformations, the `p` argument must be given as a named argument.\n//\n// Arguments:\n//   a = Scalar angle or vector of XYZ rotation angles to rotate by, in degrees.  If you use the `from` and `to` arguments then `a` must be a scalar.  Default: `0`\n//   v = vector for the axis of rotation.  Default: [0,0,1] or UP\n//   ---\n//   cp = centerpoint to rotate around. Default: [0,0,0]\n//   from = Starting vector for vector-based rotations.\n//   to = Target vector for vector-based rotations.\n//   reverse = If true, exactly reverses the rotation, including axis rotation ordering.  Default: false\n//   p = If called as a function, this contains data to rotate: a point, list of points, bezier patch or VNF.\n//\n// Example:\n//   #cube([2,4,9]);\n//   rot([30,60,0], cp=[0,0,9]) cube([2,4,9]);\n//\n// Example:\n//   #cube([2,4,9]);\n//   rot(30, v=[1,1,0], cp=[0,0,9]) cube([2,4,9]);\n//\n// Example:\n//   #cube([2,4,9]);\n//   rot(from=UP, to=LEFT+BACK) cube([2,4,9]);\n//\n// Example(2D):\n//   path = square([50,30], center=true);\n//   #stroke(path, closed=true);\n//   stroke(rot(30,p=path), closed=true);\nmodule rot(a=0, v, cp, from, to, reverse=false)\n{\n    req_children($children);        \n    m = rot(a=a, v=v, cp=cp, from=from, to=to, reverse=reverse);\n    multmatrix(m) children();\n}\n\nfunction rot(a=0, v, cp, from, to, reverse=false, p=_NO_ARG) =\n    assert(is_undef(from)==is_undef(to), \"from and to must be specified together.\")\n    assert(is_undef(from) || is_vector(from, zero=false), \"'from' must be a non-zero vector.\")\n    assert(is_undef(to) || is_vector(to, zero=false), \"'to' must be a non-zero vector.\")\n    assert(is_undef(v) || is_vector(v, zero=false), \"'v' must be a non-zero vector.\")\n    assert(is_undef(cp) || is_vector(cp), \"'cp' must be a vector.\")\n    assert(is_finite(a) || is_vector(a), \"'a' must be a finite scalar or a vector.\")\n    assert(is_bool(reverse))\n    let(\n        m = let(\n                from = is_undef(from)? undef : point3d(from),\n                to = is_undef(to)? undef : point3d(to),\n                cp = is_undef(cp)? undef : point3d(cp),\n                m1 = !is_undef(from) ?\n                        assert(is_num(a))\n                        affine3d_rot_from_to(from,to) * affine3d_rot_by_axis(from,a)\n                   : !is_undef(v)?\n                        assert(is_num(a))\n                        affine3d_rot_by_axis(v,a)\n                   : is_num(a) ? affine3d_zrot(a)\n                   : affine3d_zrot(a.z) * affine3d_yrot(a.y) * affine3d_xrot(a.x),\n                m2 = is_undef(cp)? m1 : (move(cp) * m1 * move(-cp)),\n                m3 = reverse? rot_inverse(m2) : m2\n            ) m3\n    )\n    p==_NO_ARG ? m : apply(m, p);\n\n\n\n\n// Function&Module: xrot()\n//\n// Synopsis: Rotates children around the X axis using the right-hand rule.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Rotation\n// See Also: rot(), yrot(), zrot(), tilt()\n//\n// Usage: As Module\n//   xrot(a, [cp=]) CHILDREN;\n// Usage: As a function to rotate points\n//   rotated = xrot(a, p, [cp=]);\n// Usage: As a function to return rotation matrix\n//   mat = xrot(a, [cp=]);\n//\n// Description:\n//   Rotates around the X axis by the given number of degrees.  If `cp` is given, rotations are performed around that centerpoint.\n//   * Called as a module, rotates all children.\n//   * Called as a function with a `p` argument containing a point, returns the rotated point.\n//   * Called as a function with a `p` argument containing a list of points, returns the list of rotated points.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the rotated patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the rotated VNF.\n//   * Called as a function without a `p` argument, returns the affine3d rotational matrix.\n//\n// Arguments:\n//   a = angle to rotate by in degrees.\n//   p = If called as a function, this contains data to rotate: a point, list of points, bezier patch or VNF.\n//   ---\n//   cp = centerpoint to rotate around. Default: [0,0,0]\n//\n// Example:\n//   #cylinder(h=50, r=10, center=true);\n//   xrot(90) cylinder(h=50, r=10, center=true);\nmodule xrot(a=0, p, cp)\n{\n    req_children($children);          \n    assert(is_undef(p), \"Module form `xrot()` does not accept p= argument.\");\n    if (a==0) {\n        children();  // May be slightly faster?\n    } else if (!is_undef(cp)) {\n        translate(cp) rotate([a, 0, 0]) translate(-cp) children();\n    } else {\n        rotate([a, 0, 0]) children();\n    }\n}\n\nfunction xrot(a=0, p=_NO_ARG, cp) = rot([a,0,0], cp=cp, p=p);\n\n\n// Function&Module: yrot()\n//\n// Synopsis: Rotates children around the Y axis using the right-hand rule.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Rotation\n// See Also: rot(), xrot(), zrot(), tilt()\n//\n// Usage: As Module\n//   yrot(a, [cp=]) CHILDREN;\n// Usage: Rotate Points\n//   rotated = yrot(a, p, [cp=]);\n// Usage: Get Rotation Matrix\n//   mat = yrot(a, [cp=]);\n//\n// Description:\n//   Rotates around the Y axis by the given number of degrees.  If `cp` is given, rotations are performed around that centerpoint.\n//   * Called as a module, rotates all children.\n//   * Called as a function with a `p` argument containing a point, returns the rotated point.\n//   * Called as a function with a `p` argument containing a list of points, returns the list of rotated points.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the rotated patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the rotated VNF.\n//   * Called as a function without a `p` argument, returns the affine3d rotational matrix.\n//\n// Arguments:\n//   a = angle to rotate by in degrees.\n//   p = If called as a function, this contains data to rotate: a point, list of points, bezier patch or VNF.\n//   ---\n//   cp = centerpoint to rotate around. Default: [0,0,0]\n//\n// Example:\n//   #cylinder(h=50, r=10, center=true);\n//   yrot(90) cylinder(h=50, r=10, center=true);\nmodule yrot(a=0, p, cp)\n{\n    req_children($children);  \n    assert(is_undef(p), \"Module form `yrot()` does not accept p= argument.\");\n    if (a==0) {\n        children();  // May be slightly faster?\n    } else if (!is_undef(cp)) {\n        translate(cp) rotate([0, a, 0]) translate(-cp) children();\n    } else {\n        rotate([0, a, 0]) children();\n    }\n}\n\nfunction yrot(a=0, p=_NO_ARG, cp) = rot([0,a,0], cp=cp, p=p);\n\n\n// Function&Module: zrot()\n//\n// Synopsis: Rotates children around the Z axis using the right-hand rule.\n// Topics: Affine, Matrices, Transforms, Rotation\n// SynTags: Trans, Path, VNF, Mat\n// See Also: rot(), xrot(), yrot(), tilt()\n//\n// Usage: As Module\n//   zrot(a, [cp=]) CHILDREN;\n// Usage: As Function to rotate points\n//   rotated = zrot(a, p, [cp=]);\n// Usage: As Function to return rotation matrix\n//   mat = zrot(a, [cp=]);\n//\n// Description:\n//   Rotates around the Z axis by the given number of degrees.  If `cp` is given, rotations are performed around that centerpoint.\n//   * Called as a module, rotates all children.\n//   * Called as a function with a `p` argument containing a point, returns the rotated point.\n//   * Called as a function with a `p` argument containing a list of points, returns the list of rotated points.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the rotated patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the rotated VNF.\n//   * Called as a function without a `p` argument, returns the affine3d rotational matrix.\n//\n// Arguments:\n//   a = angle to rotate by in degrees.\n//   p = If called as a function, this contains data to rotate: a point, list of points, bezier patch or VNF.\n//   ---\n//   cp = centerpoint to rotate around. Default: [0,0,0]\n//\n// Example:\n//   #cube(size=[60,20,40], center=true);\n//   zrot(90) cube(size=[60,20,40], center=true);\nmodule zrot(a=0, p, cp)\n{\n    req_children($children);    \n    assert(is_undef(p), \"Module form `zrot()` does not accept p= argument.\");\n    if (a==0) {\n        children();  // May be slightly faster?\n    } else if (!is_undef(cp)) {\n        translate(cp) rotate(a) translate(-cp) children();\n    } else {\n        rotate(a) children();\n    }\n}\n\nfunction zrot(a=0, p=_NO_ARG, cp) = rot(a, cp=cp, p=p);\n\n\n// Function&Module: tilt()\n//\n// Synopsis: Tilts children towards a direction\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Rotation\n// See Also: rot(), xrot(), yrot(), zrot()\n//\n// Usage: As a Module\n//   tilt(to=, [reverse=], [cp=]) CHILDREN;\n// Usage: As a Function to transform data in `p`\n//   pts = tilt(to=, p=, [reverse=], [cp=]);\n// Usage: As a Function to return a transform matrix\n//   M = tilt(to=, [reverse=], [cp=]);\n//\n// Description:\n//   This is shorthand for `rot(from=UP,to=x)` and operates similarly.  It tilts that which is pointing UP until it is pointing at the given direction vector.\n//   * If the `cp` centerpoint argument is given, then the tilt/rotation is performed around that centerpoint.  So `tilt(...,cp=[1,2,3])` is equivalent to `move([1,2,3]) tilt(...) move([-1,-2,-3])`.\n//   * If the `reverse` argument is true, then the tilt/rotation performed will be exactly reversed.\n//   .\n//   The behavior and return value varies depending on how `tilt()` is called:\n//   * Called as a module, tilts all children.\n//   * Called as a function with a `p` argument containing a point, returns the tilted/rotated point.\n//   * Called as a function with a `p` argument containing a list of points, returns the list of tilted/rotated points.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the tilted/rotated patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the tilted/rotated VNF.\n//   * Called as a function without a `p` argument, returns the affine3d rotational matrix.\n//   Note that unlike almost all the other transformations, the `p` argument must be given as a named argument.\n//\n// Arguments:\n//   to = Target vector for vector-based rotations.\n//   ---\n//   cp = centerpoint to tilt/rotate around. Default: [0,0,0]\n//   reverse = If true, exactly reverses the rotation.  Default: false\n//   p = If called as a function, this contains data to rotate: a point, list of points, bezier patch or a VNF.\n//\n// Example:\n//   #cube([2,4,9]);\n//   tilt(LEFT+BACK) cube([2,4,9]);\n//\n// Example(2D):\n//   path = square([50,30], center=true);\n//   #stroke(path, closed=true);\n//   stroke(tilt(RIGHT+FWD,p=path3d(path)), closed=true);\nmodule tilt(to, cp, reverse=false)\n{\n    req_children($children);\n    m = rot(from=UP, to=to, cp=cp, reverse=reverse);\n    multmatrix(m) children();\n}\n\n\nfunction tilt(to, cp, reverse=false, p=_NO_ARG) =\n    assert(is_vector(to, zero=false), \"'to' must be a non-zero vector.\")\n    assert(is_undef(cp) || is_vector(cp), \"'cp' must be a vector.\")\n    assert(is_bool(reverse))\n    let( m = rot(from=UP, to=to, cp=cp, reverse=reverse) )\n    p==_NO_ARG ? m : apply(m, p);\n\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Scaling\n//////////////////////////////////////////////////////////////////////\n\n\n// Function&Module: scale()\n//\n// Synopsis: Scales children arbitrarily.\n// SynTags: Trans, Path, VNF, Mat, Ext\n// Topics: Affine, Matrices, Transforms, Scaling\n// See Also: xscale(), yscale(), zscale()\n//\n// Usage: As Module\n//   scale(SCALAR) CHILDREN;\n//   scale([X,Y,Z]) CHILDREN;\n// Usage: Scale Points\n//   pts = scale(v, p, [cp=]);\n// Usage: Get Scaling Matrix\n//   mat = scale(v, [cp=]);\n//\n// Description:\n//   Scales by the [X,Y,Z] scaling factors given in `v`.  If `v` is given as a scalar number, all axes are scaled uniformly by that amount.\n//   * Called as the built-in module, scales all children.\n//   * Called as a function with a point in the `p` argument, returns the scaled point.\n//   * Called as a function with a list of points in the `p` argument, returns the list of scaled points.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the scaled patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the scaled VNF.\n//   * Called as a function without a `p` argument, and a 2D list of scaling factors in `v`, returns an affine2d scaling matrix.\n//   * Called as a function without a `p` argument, and a 3D list of scaling factors in `v`, returns an affine3d scaling matrix.\n//\n// Arguments:\n//   v = Either a numeric uniform scaling factor, or a list of [X,Y,Z] scaling factors.  Default: 1\n//   p = If called as a function, the point or list of points to scale.\n//   ---\n//   cp = If given, centers the scaling on the point `cp`.\n//\n// Example(NORENDER):\n//   pt1 = scale(3, p=[3,1,4]);        // Returns: [9,3,12]\n//   pt2 = scale([2,3,4], p=[3,1,4]);  // Returns: [6,3,16]\n//   pt3 = scale([2,3,4], p=[[1,2,3],[4,5,6]]);  // Returns: [[2,6,12], [8,15,24]]\n//   mat2d = scale([2,3]);    // Returns: [[2,0,0],[0,3,0],[0,0,1]]\n//   mat3d = scale([2,3,4]);  // Returns: [[2,0,0,0],[0,3,0,0],[0,0,4,0],[0,0,0,1]]\n//\n// Example(2D):\n//   path = circle(d=50,$fn=12);\n//   #stroke(path,closed=true);\n//   stroke(scale([1.5,3],p=path),closed=true);\nfunction scale(v=1, p=_NO_ARG, cp=[0,0,0]) =\n    assert(is_num(v) || is_vector(v),\"Invalid scale\")\n    assert(p==_NO_ARG || is_list(p),\"Invalid point list\")\n    assert(is_vector(cp))\n    let(\n        v = is_num(v)? [v,v,v] : v,\n        m = cp==[0,0,0]\n          ? affine3d_scale(v)\n          : affine3d_translate(point3d(cp))\n            * affine3d_scale(v)\n            * affine3d_translate(point3d(-cp))\n    )\n    p==_NO_ARG? m : apply(m, p) ;\n\n\n// Function&Module: xscale()\n//\n// Synopsis: Scales children along the X axis.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Scaling\n// See Also: scale(), yscale(), zscale()\n//\n// Usage: As Module\n//   xscale(x, [cp=]) CHILDREN;\n// Usage: Scale Points\n//   scaled = xscale(x, p, [cp=]);\n// Usage: Get Affine Matrix\n//   mat = xscale(x, [cp=]);\n//\n// Description:\n//   Scales along the X axis by the scaling factor `x`.\n//   * Called as the built-in module, scales all children.\n//   * Called as a function with a point in the `p` argument, returns the scaled point.\n//   * Called as a function with a list of points in the `p` argument, returns the list of scaled points.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the scaled patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the scaled VNF.\n//   * Called as a function without a `p` argument, and a 2D list of scaling factors in `v`, returns an affine2d scaling matrix.\n//   * Called as a function without a `p` argument, and a 3D list of scaling factors in `v`, returns an affine3d scaling matrix.\n//\n// Arguments:\n//   x = Factor to scale by, along the X axis.\n//   p = A point, path, bezier patch, or VNF to scale, when called as a function.\n//   ---\n//   cp = If given as a point, centers the scaling on the point `cp`.  If given as a scalar, centers scaling on the point `[cp,0,0]`\n//\n// Example: As Module\n//   xscale(3) sphere(r=10);\n//\n// Example(2D): Scaling Points\n//   path = circle(d=50,$fn=12);\n//   #stroke(path,closed=true);\n//   stroke(xscale(2,p=path),closed=true);\nmodule xscale(x=1, p, cp=0) {\n    req_children($children);      \n    assert(is_undef(p), \"Module form `xscale()` does not accept p= argument.\");\n    cp = is_num(cp)? [cp,0,0] : cp;\n    if (cp == [0,0,0]) {\n        scale([x,1,1]) children();\n    } else {\n        translate(cp) scale([x,1,1]) translate(-cp) children();\n    }\n}\n\nfunction xscale(x=1, p=_NO_ARG, cp=0) =\n    assert(is_finite(x))\n    assert(p==_NO_ARG || is_list(p))\n    assert(is_finite(cp) || is_vector(cp))\n    let( cp = is_num(cp)? [cp,0,0] : cp )\n    scale([x,1,1], cp=cp, p=p);\n\n\n// Function&Module: yscale()\n//\n// Synopsis: Scales children along the Y axis.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Scaling\n// See Also: scale(), xscale(), zscale()\n//\n// Usage: As Module\n//   yscale(y, [cp=]) CHILDREN;\n// Usage: Scale Points\n//   scaled = yscale(y, p, [cp=]);\n// Usage: Get Affine Matrix\n//   mat = yscale(y, [cp=]);\n//\n// Description:\n//   Scales along the Y axis by the scaling factor `y`.\n//   * Called as the built-in module, scales all children.\n//   * Called as a function with a point in the `p` argument, returns the scaled point.\n//   * Called as a function with a list of points in the `p` argument, returns the list of scaled points.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the scaled patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the scaled VNF.\n//   * Called as a function without a `p` argument, and a 2D list of scaling factors in `v`, returns an affine2d scaling matrix.\n//   * Called as a function without a `p` argument, and a 3D list of scaling factors in `v`, returns an affine3d scaling matrix.\n//\n// Arguments:\n//   y = Factor to scale by, along the Y axis.\n//   p = A point, path, bezier patch, or VNF to scale, when called as a function.\n//   ---\n//   cp = If given as a point, centers the scaling on the point `cp`.  If given as a scalar, centers scaling on the point `[0,cp,0]`\n//\n// Example: As Module\n//   yscale(3) sphere(r=10);\n//\n// Example(2D): Scaling Points\n//   path = circle(d=50,$fn=12);\n//   #stroke(path,closed=true);\n//   stroke(yscale(2,p=path),closed=true);\nmodule yscale(y=1, p, cp=0) {\n    req_children($children);      \n    assert(is_undef(p), \"Module form `yscale()` does not accept p= argument.\");\n    cp = is_num(cp)? [0,cp,0] : cp;\n    if (cp == [0,0,0]) {\n        scale([1,y,1]) children();\n    } else {\n        translate(cp) scale([1,y,1]) translate(-cp) children();\n    }\n}\n\nfunction yscale(y=1, p=_NO_ARG, cp=0) =\n    assert(is_finite(y))\n    assert(p==_NO_ARG || is_list(p))\n    assert(is_finite(cp) || is_vector(cp))\n    let( cp = is_num(cp)? [0,cp,0] : cp )\n    scale([1,y,1], cp=cp, p=p);\n\n\n// Function&Module: zscale()\n//\n// Synopsis: Scales children along the Z axis.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Scaling\n// See Also: scale(), xscale(), yscale()\n//\n// Usage: As Module\n//   zscale(z, [cp=]) CHILDREN;\n// Usage: Scale Points\n//   scaled = zscale(z, p, [cp=]);\n// Usage: Get Affine Matrix\n//   mat = zscale(z, [cp=]);\n//\n// Description:\n//   Scales along the Z axis by the scaling factor `z`.\n//   * Called as the built-in module, scales all children.\n//   * Called as a function with a point in the `p` argument, returns the scaled point.\n//   * Called as a function with a list of points in the `p` argument, returns the list of scaled points.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the scaled patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the scaled VNF.\n//   * Called as a function without a `p` argument, and a 2D list of scaling factors in `v`, returns an affine2d scaling matrix.\n//   * Called as a function without a `p` argument, and a 3D list of scaling factors in `v`, returns an affine3d scaling matrix.\n//\n// Arguments:\n//   z = Factor to scale by, along the Z axis.\n//   p = A point, path, bezier patch, or VNF to scale, when called as a function.\n//   ---\n//   cp = If given as a point, centers the scaling on the point `cp`.  If given as a scalar, centers scaling on the point `[0,0,cp]`\n//\n// Example: As Module\n//   zscale(3) sphere(r=10);\n//\n// Example: Scaling Points\n//   path = xrot(90,p=path3d(circle(d=50,$fn=12)));\n//   #stroke(path,closed=true);\n//   stroke(zscale(2,path),closed=true);\nmodule zscale(z=1, p, cp=0) {\n    req_children($children);      \n    assert(is_undef(p), \"Module form `zscale()` does not accept p= argument.\");\n    cp = is_num(cp)? [0,0,cp] : cp;\n    if (cp == [0,0,0]) {\n        scale([1,1,z]) children();\n    } else {\n        translate(cp) scale([1,1,z]) translate(-cp) children();\n    }\n}\n\nfunction zscale(z=1, p=_NO_ARG, cp=0) =\n    assert(is_finite(z))\n    assert(is_undef(p) || is_list(p))\n    assert(is_finite(cp) || is_vector(cp))\n    let( cp = is_num(cp)? [0,0,cp] : cp )\n    scale([1,1,z], cp=cp, p=p);\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Reflection (Mirroring)\n//////////////////////////////////////////////////////////////////////\n\n// Function&Module: mirror()\n//\n// Synopsis: Reflects children across an arbitrary plane.\n// SynTags: Trans, Path, VNF, Mat, Ext\n// Topics: Affine, Matrices, Transforms, Reflection, Mirroring\n// See Also: xflip(), yflip(), zflip()\n//\n// Usage: As Module\n//   mirror(v) CHILDREN;\n// Usage: As Function\n//   pt = mirror(v, p);\n// Usage: Get Reflection/Mirror Matrix\n//   mat = mirror(v);\n//\n// Description:\n//   Mirrors/reflects across the plane or line whose normal vector is given in `v`.\n//   * Called as the built-in module, mirrors all children across the line/plane.\n//   * Called as a function with a point in the `p` argument, returns the point mirrored across the line/plane.\n//   * Called as a function with a list of points in the `p` argument, returns the list of points, with each one mirrored across the line/plane.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the mirrored patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the mirrored VNF.\n//   * Called as a function without a `p` argument, and with a 2D normal vector `v`, returns the affine2d 3x3 mirror matrix.\n//   * Called as a function without a `p` argument, and with a 3D normal vector `v`, returns the affine3d 4x4 mirror matrix.\n//\n// Arguments:\n//   v = The normal vector of the line or plane to mirror across.\n//   p = If called as a function, the point or list of points to scale.\n//\n// Example:\n//   n = [1,0,0];\n//   module obj() right(20) rotate([0,15,-15]) cube([40,30,20]);\n//   obj();\n//   mirror(n) obj();\n//   rot(a=atan2(n.y,n.x),from=UP,to=n) {\n//       color(\"red\") anchor_arrow(s=20, flag=false);\n//       color(\"#7777\") cube([75,75,0.1], center=true);\n//   }\n//\n// Example:\n//   n = [1,1,0];\n//   module obj() right(20) rotate([0,15,-15]) cube([40,30,20]);\n//   obj();\n//   mirror(n) obj();\n//   rot(a=atan2(n.y,n.x),from=UP,to=n) {\n//       color(\"red\") anchor_arrow(s=20, flag=false);\n//       color(\"#7777\") cube([75,75,0.1], center=true);\n//   }\n//\n// Example:\n//   n = [1,1,1];\n//   module obj() right(20) rotate([0,15,-15]) cube([40,30,20]);\n//   obj();\n//   mirror(n) obj();\n//   rot(a=atan2(n.y,n.x),from=UP,to=n) {\n//       color(\"red\") anchor_arrow(s=20, flag=false);\n//       color(\"#7777\") cube([75,75,0.1], center=true);\n//   }\n//\n// Example(2D):\n//   n = [0,1];\n//   path = rot(30, p=square([50,30]));\n//   color(\"gray\") rot(from=[0,1],to=n) stroke([[-60,0],[60,0]]);\n//   color(\"red\") stroke([[0,0],10*n],endcap2=\"arrow2\");\n//   #stroke(path,closed=true);\n//   stroke(mirror(n, p=path),closed=true);\n//\n// Example(2D):\n//   n = [1,1];\n//   path = rot(30, p=square([50,30]));\n//   color(\"gray\") rot(from=[0,1],to=n) stroke([[-60,0],[60,0]]);\n//   color(\"red\") stroke([[0,0],10*n],endcap2=\"arrow2\");\n//   #stroke(path,closed=true);\n//   stroke(mirror(n, p=path),closed=true);\n//\nfunction mirror(v, p=_NO_ARG) =\n    assert(is_vector(v))\n    assert(p==_NO_ARG || is_list(p),\"Invalid pointlist\")\n    let(m = len(v)==2? affine2d_mirror(v) : affine3d_mirror(v))\n    p==_NO_ARG? m : apply(m,p);\n\n\n// Function&Module: xflip()\n//\n// Synopsis: Reflects children across the YZ plane.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Reflection, Mirroring\n// See Also: mirror(), yflip(), zflip()\n//\n// Usage: As Module\n//   xflip([x=]) CHILDREN;\n// Usage: As Function\n//   pt = xflip(p, [x]);\n// Usage: Get Affine Matrix\n//   mat = xflip([x=]);\n//\n// Description:\n//   Mirrors/reflects across the origin [0,0,0], along the X axis.  If `x` is given, reflects across [x,0,0] instead.\n//   * Called as the built-in module, mirrors all children across the line/plane.\n//   * Called as a function with a point in the `p` argument, returns the point mirrored across the line/plane.\n//   * Called as a function with a list of points in the `p` argument, returns the list of points, with each one mirrored across the line/plane.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the mirrored patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the mirrored VNF.\n//   * Called as a function without a `p` argument, returns the affine3d 4x4 mirror matrix.\n//\n// Arguments:\n//   p = If given, the point, path, patch, or VNF to mirror.  Function use only.\n//   x = The X coordinate of the plane of reflection.  Default: 0\n//\n// Example:\n//   xflip() yrot(90) cylinder(d1=10, d2=0, h=20);\n//   color(\"blue\", 0.25) cube([0.01,15,15], center=true);\n//   color(\"red\", 0.333) yrot(90) cylinder(d1=10, d2=0, h=20);\n//\n// Example:\n//   xflip(x=-5) yrot(90) cylinder(d1=10, d2=0, h=20);\n//   color(\"blue\", 0.25) left(5) cube([0.01,15,15], center=true);\n//   color(\"red\", 0.333) yrot(90) cylinder(d1=10, d2=0, h=20);\nmodule xflip(p, x=0) {\n    req_children($children);        \n    assert(is_undef(p), \"Module form `zflip()` does not accept p= argument.\");\n    translate([x,0,0])\n        mirror([1,0,0])\n            translate([-x,0,0]) children();\n}\n\nfunction xflip(p=_NO_ARG, x=0) =\n    assert(is_finite(x))\n    assert(p==_NO_ARG || is_list(p),\"Invalid point list\")\n    let( v = RIGHT )\n    x == 0 ? mirror(v,p=p) :\n    let(\n        cp = x * v,\n        m = move(cp) * mirror(v) * move(-cp)\n    )\n    p==_NO_ARG? m : apply(m, p);\n\n\n// Function&Module: yflip()\n//\n// Synopsis: Reflects children across the XZ plane.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Reflection, Mirroring\n// See Also: mirror(), xflip(), zflip()\n//\n// Usage: As Module\n//   yflip([y=]) CHILDREN;\n// Usage: As Function\n//   pt = yflip(p, [y]);\n// Usage: Get Affine Matrix\n//   mat = yflip([y=]);\n//\n// Description:\n//   Mirrors/reflects across the origin [0,0,0], along the Y axis.  If `y` is given, reflects across [0,y,0] instead.\n//   * Called as the built-in module, mirrors all children across the line/plane.\n//   * Called as a function with a point in the `p` argument, returns the point mirrored across the line/plane.\n//   * Called as a function with a list of points in the `p` argument, returns the list of points, with each one mirrored across the line/plane.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the mirrored patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the mirrored VNF.\n//   * Called as a function without a `p` argument, returns the affine3d 4x4 mirror matrix.\n//\n// Arguments:\n//   p = If given, the point, path, patch, or VNF to mirror.  Function use only.\n//   y = The Y coordinate of the plane of reflection.  Default: 0\n//\n// Example:\n//   yflip() xrot(90) cylinder(d1=10, d2=0, h=20);\n//   color(\"blue\", 0.25) cube([15,0.01,15], center=true);\n//   color(\"red\", 0.333) xrot(90) cylinder(d1=10, d2=0, h=20);\n//\n// Example:\n//   yflip(y=5) xrot(90) cylinder(d1=10, d2=0, h=20);\n//   color(\"blue\", 0.25) back(5) cube([15,0.01,15], center=true);\n//   color(\"red\", 0.333) xrot(90) cylinder(d1=10, d2=0, h=20);\nmodule yflip(p, y=0) {\n    req_children($children);          \n    assert(is_undef(p), \"Module form `yflip()` does not accept p= argument.\");\n    translate([0,y,0])\n        mirror([0,1,0])\n            translate([0,-y,0]) children();\n}\n\nfunction yflip(p=_NO_ARG, y=0) =\n    assert(is_finite(y))\n    assert(p==_NO_ARG || is_list(p),\"Invalid point list\")\n    let( v = BACK )\n    y == 0 ? mirror(v,p=p) :\n    let(\n        cp = y * v,\n        m = move(cp) * mirror(v) * move(-cp)\n    )\n    p==_NO_ARG? m : apply(m, p);\n\n\n// Function&Module: zflip()\n//\n// Synopsis: Reflects children across the XY plane.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Reflection, Mirroring\n// See Also: mirror(), xflip(), yflip()\n//\n// Usage: As Module\n//   zflip([z=]) CHILDREN;\n// Usage: As Function\n//   pt = zflip(p, [z]);\n// Usage: Get Affine Matrix\n//   mat = zflip([z=]);\n//\n// Description:\n//   Mirrors/reflects across the origin [0,0,0], along the Z axis.  If `z` is given, reflects across [0,0,z] instead.\n//   * Called as the built-in module, mirrors all children across the line/plane.\n//   * Called as a function with a point in the `p` argument, returns the point mirrored across the line/plane.\n//   * Called as a function with a list of points in the `p` argument, returns the list of points, with each one mirrored across the line/plane.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the mirrored patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the mirrored VNF.\n//   * Called as a function without a `p` argument, returns the affine3d 4x4 mirror matrix.\n//\n// Arguments:\n//   p = If given, the point, path, patch, or VNF to mirror.  Function use only.\n//   z = The Z coordinate of the plane of reflection.  Default: 0\n//\n// Example:\n//   zflip() cylinder(d1=10, d2=0, h=20);\n//   color(\"blue\", 0.25) cube([15,15,0.01], center=true);\n//   color(\"red\", 0.333) cylinder(d1=10, d2=0, h=20);\n//\n// Example:\n//   zflip(z=-5) cylinder(d1=10, d2=0, h=20);\n//   color(\"blue\", 0.25) down(5) cube([15,15,0.01], center=true);\n//   color(\"red\", 0.333) cylinder(d1=10, d2=0, h=20);\nmodule zflip(p, z=0) {\n    req_children($children);          \n    assert(is_undef(p), \"Module form `zflip()` does not accept p= argument.\");\n    translate([0,0,z])\n        mirror([0,0,1])\n            translate([0,0,-z]) children();\n}\n\nfunction zflip(p=_NO_ARG, z=0) =\n    assert(is_finite(z))\n    assert(p==_NO_ARG || is_list(p),\"Invalid point list\")\n    z==0? mirror([0,0,1],p=p) :\n    let(m = up(z) * mirror(UP) * down(z))\n    p==_NO_ARG? m : apply(m, p);\n\n\n//////////////////////////////////////////////////////////////////////\n// Section: Other Transformations\n//////////////////////////////////////////////////////////////////////\n\n// Function&Module: frame_map()\n//\n// Synopsis: Rotates and possibly skews children from one frame of reference to another.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Rotation\n// See Also: rot(), xrot(), yrot(), zrot()\n//\n// Usage: As module\n//   frame_map(v1, v2, v3, [reverse=]) CHILDREN;\n// Usage: As function to remap points\n//   transformed = frame_map(v1, v2, v3, p=points, [reverse=]);\n// Usage: As function to return a transformation matrix:\n//   map = frame_map(v1, v2, v3, [reverse=]);\n//   map = frame_map(x=VECTOR1, y=VECTOR2, [reverse=]);\n//   map = frame_map(x=VECTOR1, z=VECTOR2, [reverse=]);\n//   map = frame_map(y=VECTOR1, z=VECTOR2, [reverse=]);\n//\n// Description:\n//   Maps one coordinate frame to another.  You must specify two or\n//   three of `x`, `y`, and `z`.  The specified axes are mapped to the vectors you supplied, so if you\n//   specify x=[1,1] then the x axis will be mapped to the line y=x.  If you\n//   give two inputs, the third vector is mapped to the appropriate normal to maintain a right hand\n//   coordinate system.  If the vectors you give are orthogonal the result will be a rotation and the\n//   `reverse` parameter will supply the inverse map, which enables you to map two arbitrary\n//   coordinate systems to each other by using the canonical coordinate system as an intermediary.\n//   You cannot use the `reverse` option with non-orthogonal inputs.  Note that only the direction\n//   of the specified vectors matters: the transformation will not apply scaling, though it can\n//   skew if your provide non-orthogonal axes.\n//\n// Arguments:\n//   x = Destination 3D vector for x axis.\n//   y = Destination 3D vector for y axis.\n//   z = Destination 3D vector for z axis.\n//   p = If given, the point, path, patch, or VNF to operate on.  Function use only.\n//   reverse = reverse direction of the map for orthogonal inputs.  Default: false\n//\n// Example:  Remap axes after linear extrusion\n//   frame_map(x=[0,1,0], y=[0,0,1]) linear_extrude(height=10) square(3);\n//\n// Example: This map is just a rotation around the z axis\n//   mat = frame_map(x=[1,1,0], y=[-1,1,0]);\n//   multmatrix(mat) frame_ref();\n//\n// Example:  This map is not a rotation because x and y aren't orthogonal\n//   frame_map(x=[1,0,0], y=[1,1,0]) cube(10);\n//\n// Example:  This sends [1,1,0] to [0,1,1] and [-1,1,0] to [0,-1,1].  (Original directions shown in light shade, final directions shown dark.)\n//   mat = frame_map(x=[0,1,1], y=[0,-1,1]) * frame_map(x=[1,1,0], y=[-1,1,0],reverse=true);\n//   color(\"purple\",alpha=.2) stroke([[0,0,0],10*[1,1,0]]);\n//   color(\"green\",alpha=.2)  stroke([[0,0,0],10*[-1,1,0]]);\n//   multmatrix(mat) {\n//      color(\"purple\") stroke([[0,0,0],10*[1,1,0]]);\n//      color(\"green\") stroke([[0,0,0],10*[-1,1,0]]);\n//   }\n//\nfunction frame_map(x,y,z, p=_NO_ARG, reverse=false) =\n    p != _NO_ARG\n    ? apply(frame_map(x,y,z,reverse=reverse), p)\n    :\n    assert(num_defined([x,y,z])>=2, \"Must define at least two inputs\")\n    let(\n        xvalid = is_undef(x) || (is_vector(x) && len(x)==3),\n        yvalid = is_undef(y) || (is_vector(y) && len(y)==3),\n        zvalid = is_undef(z) || (is_vector(z) && len(z)==3)\n    )\n    assert(xvalid,\"Input x must be a length 3 vector\")\n    assert(yvalid,\"Input y must be a length 3 vector\")\n    assert(zvalid,\"Input z must be a length 3 vector\")\n    let(\n        x = is_undef(x)? undef : unit(x,RIGHT),\n        y = is_undef(y)? undef : unit(y,BACK),\n        z = is_undef(z)? undef : unit(z,UP),\n        map = is_undef(x)? [cross(y,z), y, z] :\n            is_undef(y)? [x, cross(z,x), z] :\n            is_undef(z)? [x, y, cross(x,y)] :\n            [x, y, z]\n    )\n    reverse? (\n        let(\n            ocheck = (\n                approx(map[0]*map[1],0) &&\n                approx(map[0]*map[2],0) &&\n                approx(map[1]*map[2],0)\n            )\n        )\n        assert(ocheck, \"Inputs must be orthogonal when reverse==true\")\n        [for (r=map) [for (c=r) c, 0], [0,0,0,1]]\n    ) : [for (r=transpose(map)) [for (c=r) c, 0], [0,0,0,1]];\n\n\nmodule frame_map(x,y,z,p,reverse=false)\n{\n   req_children($children);        \n   assert(is_undef(p), \"Module form `frame_map()` does not accept p= argument.\");\n   multmatrix(frame_map(x,y,z,reverse=reverse))\n       children();\n}\n\n\n// Function&Module: skew()\n//\n// Synopsis: Skews children along various axes.\n// SynTags: Trans, Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms, Skewing\n// See Also: move(), rot(), scale()\n//\n// Usage: As Module\n//   skew([sxy=]|[axy=], [sxz=]|[axz=], [syx=]|[ayx=], [syz=]|[ayz=], [szx=]|[azx=], [szy=]|[azy=]) CHILDREN;\n// Usage: As Function\n//   pts = skew(p, [sxy=]|[axy=], [sxz=]|[axz=], [syx=]|[ayx=], [syz=]|[ayz=], [szx=]|[azx=], [szy=]|[azy=]);\n// Usage: Get Affine Matrix\n//   mat = skew([sxy=]|[axy=], [sxz=]|[axz=], [syx=]|[ayx=], [syz=]|[ayz=], [szx=]|[azx=], [szy=]|[azy=]);\n//\n// Description:\n//   Skews geometry by the given skew factors.\n//   * Called as the built-in module, skews all children.\n//   * Called as a function with a point in the `p` argument, returns the skewed point.\n//   * Called as a function with a list of points in the `p` argument, returns the list of skewed points.\n//   * Called as a function with a [bezier patch](beziers.scad) in the `p` argument, returns the skewed patch.\n//   * Called as a function with a [VNF structure](vnf.scad) in the `p` argument, returns the skewed VNF.\n//   * Called as a function without a `p` argument, returns the affine3d 4x4 skew matrix.\n//   Each skew factor is a multiplier.  For example, if `sxy=2`, then it will skew along the X axis by 2x the value of the Y axis.\n// Arguments:\n//   p = If given, the point, path, patch, or VNF to skew.  Function use only.\n//   ---\n//   sxy = Skew factor multiplier for skewing along the X axis as you get farther from the Y axis.  Default: 0\n//   sxz = Skew factor multiplier for skewing along the X axis as you get farther from the Z axis.  Default: 0\n//   syx = Skew factor multiplier for skewing along the Y axis as you get farther from the X axis.  Default: 0\n//   syz = Skew factor multiplier for skewing along the Y axis as you get farther from the Z axis.  Default: 0\n//   szx = Skew factor multiplier for skewing along the Z axis as you get farther from the X axis.  Default: 0\n//   szy = Skew factor multiplier for skewing along the Z axis as you get farther from the Y axis.  Default: 0\n//   axy = Angle to skew along the X axis as you get farther from the Y axis.\n//   axz = Angle to skew along the X axis as you get farther from the Z axis.\n//   ayx = Angle to skew along the Y axis as you get farther from the X axis.\n//   ayz = Angle to skew along the Y axis as you get farther from the Z axis.\n//   azx = Angle to skew along the Z axis as you get farther from the X axis.\n//   azy = Angle to skew along the Z axis as you get farther from the Y axis.\n// Example(2D): Skew along the X axis in 2D.\n//   skew(sxy=0.5) square(40, center=true);\n// Example(2D): Skew along the X axis by 30\u00ba in 2D.\n//   skew(axy=30) square(40, center=true);\n// Example(2D): Skew along the Y axis in 2D.\n//   skew(syx=0.5) square(40, center=true);\n// Example: Skew along the X axis in 3D as a factor of Y coordinate.\n//   skew(sxy=0.5) cube(40, center=true);\n// Example: Skew along the X axis in 3D as a factor of Z coordinate.\n//   skew(sxz=0.5) cube(40, center=true);\n// Example: Skew along the Y axis in 3D as a factor of X coordinate.\n//   skew(syx=0.5) cube(40, center=true);\n// Example: Skew along the Y axis in 3D as a factor of Z coordinate.\n//   skew(syz=0.5) cube(40, center=true);\n// Example: Skew along the Z axis in 3D as a factor of X coordinate.\n//   skew(szx=0.5) cube(40, center=true);\n// Example: Skew along the Z axis in 3D as a factor of Y coordinate.\n//   skew(szy=0.75) cube(40, center=true);\n// Example(FlatSpin,VPD=275): Skew Along Multiple Axes.\n//   skew(sxy=0.5, syx=0.3, szy=0.75) cube(40, center=true);\n// Example(2D): Calling as a 2D Function\n//   pts = skew(p=square(40,center=true), sxy=0.5);\n//   color(\"yellow\") stroke(pts, closed=true);\n//   color(\"blue\") move_copies(pts) circle(d=3, $fn=8);\n// Example(FlatSpin,VPD=175): Calling as a 3D Function\n//   pts = skew(p=path3d(square(40,center=true)), szx=0.5, szy=0.3);\n//   stroke(pts,closed=true,dots=true,dots_color=\"blue\");\nmodule skew(p, sxy, sxz, syx, syz, szx, szy, axy, axz, ayx, ayz, azx, azy)\n{\n    req_children($children);          \n    assert(is_undef(p), \"Module form `skew()` does not accept p= argument.\");\n    mat = skew(\n        sxy=sxy, sxz=sxz, syx=syx, syz=syz, szx=szx, szy=szy,\n        axy=axy, axz=axz, ayx=ayx, ayz=ayz, azx=azx, azy=azy\n    );\n    multmatrix(mat) children();\n}\n\nfunction skew(p=_NO_ARG, sxy, sxz, syx, syz, szx, szy, axy, axz, ayx, ayz, azx, azy) =\n    assert(num_defined([sxy,axy]) < 2)\n    assert(num_defined([sxz,axz]) < 2)\n    assert(num_defined([syx,ayx]) < 2)\n    assert(num_defined([syz,ayz]) < 2)\n    assert(num_defined([szx,azx]) < 2)\n    assert(num_defined([szy,azy]) < 2)\n    assert(sxy==undef || is_finite(sxy))\n    assert(sxz==undef || is_finite(sxz))\n    assert(syx==undef || is_finite(syx))\n    assert(syz==undef || is_finite(syz))\n    assert(szx==undef || is_finite(szx))\n    assert(szy==undef || is_finite(szy))\n    assert(axy==undef || is_finite(axy))\n    assert(axz==undef || is_finite(axz))\n    assert(ayx==undef || is_finite(ayx))\n    assert(ayz==undef || is_finite(ayz))\n    assert(azx==undef || is_finite(azx))\n    assert(azy==undef || is_finite(azy))\n    let(\n        sxy = is_num(sxy)? sxy : is_num(axy)? tan(axy) : 0,\n        sxz = is_num(sxz)? sxz : is_num(axz)? tan(axz) : 0,\n        syx = is_num(syx)? syx : is_num(ayx)? tan(ayx) : 0,\n        syz = is_num(syz)? syz : is_num(ayz)? tan(ayz) : 0,\n        szx = is_num(szx)? szx : is_num(azx)? tan(azx) : 0,\n        szy = is_num(szy)? szy : is_num(azy)? tan(azy) : 0,\n        m = affine3d_skew(sxy=sxy, sxz=sxz, syx=syx, syz=syz, szx=szx, szy=szy)\n    )\n    p==_NO_ARG? m : apply(m, p);\n\n\n// Section: Applying transformation matrices to data\n\n/// Internal Function: is_2d_transform()\n/// Usage:\n///   bool = is_2d_transform(t);\n/// Topics: Affine, Matrices, Transforms, Type Checking\n/// See Also: is_affine(), is_matrix()\n/// Description:\n///   Checks if the input is a 3D transform that does not act on the z coordinate, except possibly\n///   for a simple scaling of z.  Note that an input which is only a zscale returns false.\n/// Arguments:\n///   t = The transformation matrix to check.\n/// Example:\n///   b = is_2d_transform(zrot(45));  // Returns: true\n///   b = is_2d_transform(yrot(45));  // Returns: false\n///   b = is_2d_transform(xrot(45));  // Returns: false\n///   b = is_2d_transform(move([10,20,0]));  // Returns: true\n///   b = is_2d_transform(move([10,20,30]));  // Returns: false\n///   b = is_2d_transform(scale([2,3,4]));  // Returns: true\nfunction is_2d_transform(t) =    // z-parameters are zero, except we allow t[2][2]!=1 so scale() works\n  t[2][0]==0 && t[2][1]==0 && t[2][3]==0 && t[0][2] == 0 && t[1][2]==0 &&\n  (t[2][2]==1 || !(t[0][0]==1 && t[0][1]==0 && t[1][0]==0 && t[1][1]==1));   // But rule out zscale()\n\n\n\n// Function: apply()\n//\n// Synopsis: Applies a transformation matrix to a point, list of points, array of points, or a VNF.\n// SynTags: Path, VNF, Mat\n// Topics: Affine, Matrices, Transforms\n// See Also: move(), rot(), scale(), skew()\n//\n// Usage:\n//   pts = apply(transform, points);\n//\n// Description:\n//   Applies the specified transformation matrix `transform` to a point, point list, bezier patch or VNF.\n//   When `points` contains 2D or 3D points the transform matrix may be a 4x4 affine matrix or a 3x4 \n//   matrix&mdash;the 4x4 matrix with its final row removed.  When the data is 2D the matrix must not operate on the Z axis,\n//   except possibly by scaling it.  When points contains 2D data you can also supply the transform as\n//   a 3x3 affine transformation matrix or the corresponding 2x3 matrix with the last row deleted.\n//   .\n//   Any other combination of matrices will produce an error, including acting with a 2D matrix (3x3) on 3D data.\n//   The output of apply is always the same dimension as the input&mdash;projections are not supported.\n//   .\n//   Note that a matrix with a negative determinant such as any mirror reflection flips the orientation of faces.\n//   If the transform matrix is square then apply() checks the determinant and if it is negative, apply() reverses the face order so that\n//   the transformed VNF has faces with the same winding direction as the original VNF.  This adjustment applies\n//   only to VNFs, not to beziers or point lists.  \n//\n// Arguments:\n//   transform = The 2D (3x3 or 2x3) or 3D (4x4 or 3x4) transformation matrix to apply.\n//   points = The point, point list, bezier patch, or VNF to apply the transformation to.\n//\n// Example(3D):\n//   path1 = path3d(circle(r=40));\n//   tmat = xrot(45);\n//   path2 = apply(tmat, path1);\n//   #stroke(path1,closed=true);\n//   stroke(path2,closed=true);\n//\n// Example(2D):\n//   path1 = circle(r=40);\n//   tmat = translate([10,5]);\n//   path2 = apply(tmat, path1);\n//   #stroke(path1,closed=true);\n//   stroke(path2,closed=true);\n//\n// Example(2D):\n//   path1 = circle(r=40);\n//   tmat = rot(30) * back(15) * scale([1.5,0.5,1]);\n//   path2 = apply(tmat, path1);\n//   #stroke(path1,closed=true);\n//   stroke(path2,closed=true);\n//\nfunction apply(transform,points) =\n    points==[] ? []\n  : is_vector(points) ? _apply(transform, [points])[0]    // point\n  : is_vnf(points) ?                                      // vnf\n        let(\n            newvnf = [_apply(transform, points[0]), points[1]],\n            reverse = (len(transform)==len(transform[0])) && determinant(transform)<0\n        )\n        reverse ? vnf_reverse_faces(newvnf) : newvnf\n  : is_list(points) && is_list(points[0]) && is_vector(points[0][0])    // bezier patch\n        ? [for (x=points) _apply(transform,x)]\n  : _apply(transform,points);\n\n\n\n\nfunction _apply(transform,points) =\n    assert(is_matrix(transform),\"Invalid transformation matrix\")\n    assert(is_matrix(points),\"Invalid points list\")\n    let(\n        tdim = len(transform[0])-1,\n        datadim = len(points[0])\n    )\n    assert(len(transform)==tdim || len(transform)-1==tdim, \"transform matrix height not compatible with width\")\n    assert(datadim==2 || datadim==3,\"Data must be 2D or 3D\")\n    let(\n        scale = len(transform)==tdim ? 1 : transform[tdim][tdim],\n        matrix = [for(i=[0:1:tdim]) [for(j=[0:1:datadim-1]) transform[j][i]]] / scale\n    )\n    tdim==datadim ? [for(p=points) concat(p,1)] * matrix\n  : tdim == 3 && datadim == 2 ?\n            assert(is_2d_transform(transform), str(\"Transforms is 3D and acts on Z, but points are 2D\"))\n            [for(p=points) concat(p,[0,1])]*matrix\n  : assert(false, str(\"Unsupported combination: \",len(transform),\"x\",len(transform[0]),\" transform (dimension \",tdim,\n                          \"), data of dimension \",datadim));\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-45", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: trigonometry.scad\n//   Trigonometry shortcuts for people who can't be bothered to remember\n//   all the function relations, or silly acronyms like SOHCAHTOA.\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Math\n// FileSummary: Trigonometry shortcuts for when you can't recall the mnemonic SOHCAHTOA.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n\n// Section: 2D General Triangle Functions\n\n\n// Function: law_of_cosines()\n// Synopsis: Applies the Law of Cosines for an arbitrary triangle.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: law_of_sines()\n// Usage:\n//   C = law_of_cosines(a, b, c);\n//   c = law_of_cosines(a, b, C=);\n// Description:\n//   Applies the Law of Cosines for an arbitrary triangle.  Given three side lengths, returns the\n//   angle in degrees for the corner opposite of the third side.  Given two side lengths, and the\n//   angle between them, returns the length of the third side.\n// Figure(2D):\n//   stroke([[-50,0], [10,60], [50,0]], closed=true);\n//   color(\"black\") {\n//       translate([ 33,35]) text(text=\"a\", size=8, halign=\"center\", valign=\"center\");\n//       translate([  0,-6]) text(text=\"b\", size=8, halign=\"center\", valign=\"center\");\n//       translate([-22,35]) text(text=\"c\", size=8, halign=\"center\", valign=\"center\");\n//   }\n//   color(\"blue\") {\n//       translate([-37, 6]) text(text=\"A\", size=8, halign=\"center\", valign=\"center\");\n//       translate([  9,51]) text(text=\"B\", size=8, halign=\"center\", valign=\"center\");\n//       translate([ 38, 6]) text(text=\"C\", size=8, halign=\"center\", valign=\"center\");\n//   }\n// Arguments:\n//   a = The length of the first side.\n//   b = The length of the second side.\n//   c = The length of the third side.\n//   ---\n//   C = The angle in degrees of the corner opposite of the third side.\nfunction law_of_cosines(a, b, c, C) =\n    // Triangle Law of Cosines:\n    //   c^2 = a^2 + b^2 - 2*a*b*cos(C)\n    assert(num_defined([c,C]) == 1, \"Must give exactly one of c= or C=.\")\n    is_undef(c) ? sqrt(a*a + b*b - 2*a*b*cos(C)) :\n    acos(constrain((a*a + b*b - c*c) / (2*a*b), -1, 1));\n\n\n// Function: law_of_sines()\n// Synopsis: Applies the Law of Sines for an arbitrary triangle.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: law_of_cosines()\n// Usage:\n//   B = law_of_sines(a, A, b);\n//   b = law_of_sines(a, A, B=);\n// Description:\n//   Applies the Law of Sines for an arbitrary triangle.  Given two triangle side lengths and the\n//   angle between them, returns the angle of the corner opposite of the second side.  Given a side\n//   length, the opposing angle, and a second angle, returns the length of the side opposite of the\n//   second angle.\n// Figure(2D):\n//   stroke([[-50,0], [10,60], [50,0]], closed=true);\n//   color(\"black\") {\n//       translate([ 33,35]) text(text=\"a\", size=8, halign=\"center\", valign=\"center\");\n//       translate([  0,-6]) text(text=\"b\", size=8, halign=\"center\", valign=\"center\");\n//       translate([-22,35]) text(text=\"c\", size=8, halign=\"center\", valign=\"center\");\n//   }\n//   color(\"blue\") {\n//       translate([-37, 6]) text(text=\"A\", size=8, halign=\"center\", valign=\"center\");\n//       translate([  9,51]) text(text=\"B\", size=8, halign=\"center\", valign=\"center\");\n//       translate([ 38, 6]) text(text=\"C\", size=8, halign=\"center\", valign=\"center\");\n//   }\n// Arguments:\n//   a = The length of the first side.\n//   A = The angle in degrees of the corner opposite of the first side.\n//   b = The length of the second side.\n//   ---\n//   B = The angle in degrees of the corner opposite of the second side.\nfunction law_of_sines(a, A, b, B) =\n    // Triangle Law of Sines:\n    //   a/sin(A) = b/sin(B) = c/sin(C)\n    assert(num_defined([b,B]) == 1, \"Must give exactly one of b= or B=.\")\n    let( r = a/sin(A) )\n    is_undef(b) ? r*sin(B) :\n    asin(constrain(b/r, -1, 1));\n\n\n\n// Section: 2D Right Triangle Functions\n//   This is a set of functions to make it easier to perform trig calculations on right triangles.\n//   In general, all these functions are named using these abbreviations:\n//   - **hyp**: The length of the Hypotenuse.\n//   - **adj**: The length of the side adjacent to the angle.\n//   - **opp**: The length of the side opposite to the angle.\n//   - **ang**: The angle size in degrees.\n//   .\n//   If you know two of those, and want to know the value of a third, you will need to call a\n//   function named like `AAA_BBB_to_CCC()`.  For example, if you know the length of the hypotenuse,\n//   and the length of the side adjacent to the angle, and want to learn the length of the side\n//   opposite to the angle, you will call `opp = hyp_adj_to_opp(hyp,adj);`.\n// Figure(2D):\n//   color(\"brown\") {\n//       stroke([[40,0], [40,10], [50,10]]);\n//       left(50) stroke(arc(r=37,angle=30));\n//   }\n//   color(\"lightgreen\") stroke([[-50,0], [50,60], [50,0]], closed=true);\n//   color(\"black\") {\n//       translate([ 62,25]) text(text=\"opp\", size=8, halign=\"center\", valign=\"center\");\n//       translate([  0,-6]) text(text=\"adj\", size=8, halign=\"center\", valign=\"center\");\n//       translate([  0,40]) text(text=\"hyp\", size=8, halign=\"center\", valign=\"center\");\n//       translate([-25, 5]) text(text=\"ang\", size=7, halign=\"center\", valign=\"center\");\n//   }\n\n\n// Function: hyp_opp_to_adj()\n// Alias: opp_hyp_to_adj()\n// Synopsis: Returns the adjacent side length from the lengths of the hypotenuse and the opposite side.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   adj = hyp_opp_to_adj(hyp,opp);\n//   adj = opp_hyp_to_adj(opp,hyp);\n// Description:\n//   Given the lengths of the hypotenuse and opposite side of a right triangle, returns the length\n//   of the adjacent side.\n// Arguments:\n//   hyp = The length of the hypotenuse of the right triangle.\n//   opp = The length of the side of the right triangle that is opposite from the primary angle.\n// Example:\n//   hyp = hyp_opp_to_adj(5,3);  // Returns: 4\nfunction hyp_opp_to_adj(hyp,opp) =\n    assert(is_finite(hyp+opp) && hyp>=0 && opp>=0,\n           \"Triangle side lengths should be a positive numbers.\" )\n    sqrt(hyp*hyp-opp*opp);\n\nfunction opp_hyp_to_adj(opp,hyp) = hyp_opp_to_adj(hyp,opp);\n\n\n// Function: hyp_ang_to_adj()\n// Alias: ang_hyp_to_adj()\n// Synopsis: Returns the adjacent side length from the length of the hypotenuse and the angle.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   adj = hyp_ang_to_adj(hyp,ang);\n//   adj = ang_hyp_to_adj(ang,hyp);\n// Description:\n//   Given the length of the hypotenuse and the angle of the primary corner of a right triangle,\n//   returns the length of the adjacent side.\n// Arguments:\n//   hyp = The length of the hypotenuse of the right triangle.\n//   ang = The angle in degrees of the primary corner of the right triangle.\n// Example:\n//   adj = hyp_ang_to_adj(8,60);  // Returns: 4\nfunction hyp_ang_to_adj(hyp,ang) =\n    assert(is_finite(hyp) && hyp>=0, \"Triangle side length should be a positive number.\" )\n    assert(is_finite(ang) && ang>-90 && ang<90, \"The angle should be an acute angle.\" )\n    hyp*cos(ang);\n\nfunction ang_hyp_to_adj(ang,hyp) = hyp_ang_to_adj(hyp, ang);\n\n\n// Function: opp_ang_to_adj()\n// Alias: ang_opp_to_adj()\n// Synopsis: Returns the adjacent side length from the length of the opposite side and the angle.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   adj = opp_ang_to_adj(opp,ang);\n//   adj = ang_opp_to_adj(ang,opp);\n// Description:\n//   Given the angle of the primary corner of a right triangle, and the length of the side opposite of it,\n//   returns the length of the adjacent side.\n// Arguments:\n//   opp = The length of the side of the right triangle that is opposite from the primary angle.\n//   ang = The angle in degrees of the primary corner of the right triangle.\n// Example:\n//   adj = opp_ang_to_adj(8,30);  // Returns: 4\nfunction opp_ang_to_adj(opp,ang) =\n    assert(is_finite(opp) && opp>=0, \"Triangle side length should be a positive number.\" )\n    assert(is_finite(ang) && ang>-90 && ang<90, \"The angle should be an acute angle.\" )\n    opp/tan(ang);\n\nfunction ang_opp_to_adj(ang,opp) = opp_ang_to_adj(opp,ang);\n\n\n// Function: hyp_adj_to_opp()\n// Alias: adj_hyp_to_opp()\n// Synopsis: Returns the opposite side length from the lengths of the hypotenuse and the adjacent side.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   opp = hyp_adj_to_opp(hyp,adj);\n//   opp = adj_hyp_to_opp(adj,hyp);\n// Description:\n//   Given the length of the hypotenuse and the adjacent side, returns the length of the opposite side.\n// Arguments:\n//   hyp = The length of the hypotenuse of the right triangle.\n//   adj = The length of the side of the right triangle that is adjacent to the primary angle.\n// Example:\n//   opp = hyp_adj_to_opp(5,4);  // Returns: 3\nfunction hyp_adj_to_opp(hyp,adj) =\n    assert(is_finite(hyp) && hyp>=0 && is_finite(adj) && adj>=0,\n           \"Triangle side lengths should be a positive numbers.\" )\n    sqrt(hyp*hyp-adj*adj);\n\nfunction adj_hyp_to_opp(adj,hyp) = hyp_adj_to_opp(hyp,adj);\n\n\n// Function: hyp_ang_to_opp()\n// Alias: ang_hyp_to_opp()\n// Synopsis: Returns the opposite side length from the length of the hypotenuse and the angle.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   opp = hyp_ang_to_opp(hyp,ang);\n//   opp = ang_hyp_to_opp(ang,hyp);\n// Description:\n//   Given the length of the hypotenuse of a right triangle, and the angle of the corner, returns the length of the opposite side.\n// Arguments:\n//   hyp = The length of the hypotenuse of the right triangle.\n//   ang = The angle in degrees of the primary corner of the right triangle.\n// Example:\n//   opp = hyp_ang_to_opp(8,30);  // Returns: 4\nfunction hyp_ang_to_opp(hyp,ang) =\n    assert(is_finite(hyp)&&hyp>=0, \"Triangle side length should be a positive number.\" )\n    assert(is_finite(ang) && ang>-90 && ang<90, \"The angle should be an acute angle.\" )\n    hyp*sin(ang);\n\nfunction ang_hyp_to_opp(ang,hyp) = hyp_ang_to_opp(hyp,ang);\n\n\n// Function: adj_ang_to_opp()\n// Alias: ang_adj_to_opp()\n// Synopsis: Returns the opposite side length from the length of the adjacent side and the angle.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   opp = adj_ang_to_opp(adj,ang);\n//   opp = ang_adj_to_opp(ang,adj);\n// Description:\n//   Given the length of the adjacent side of a right triangle, and the angle of the corner, returns the length of the opposite side.\n// Arguments:\n//   adj = The length of the side of the right triangle that is adjacent to the primary angle.\n//   ang = The angle in degrees of the primary corner of the right triangle.\n// Example:\n//   opp = adj_ang_to_opp(8,45);  // Returns: 8\nfunction adj_ang_to_opp(adj,ang) =\n    assert(is_finite(adj)&&adj>=0, \"Triangle side length should be a positive number.\" )\n    assert(is_finite(ang) && ang>-90 && ang<90, \"The angle should be an acute angle.\" )\n    adj*tan(ang);\n\nfunction ang_adj_to_opp(ang,adj) = adj_ang_to_opp(adj,ang);\n\n\n// Function: adj_opp_to_hyp()\n// Alias: opp_adj_to_hyp()\n// Synopsis: Returns the hypotenuse length from the lengths of the adjacent and opposite sides.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   hyp = adj_opp_to_hyp(adj,opp);\n//   hyp = opp_adj_to_hyp(opp,adj);\n// Description:\n//   Given the length of the adjacent and opposite sides of a right triangle, returns the length of the hypotenuse.\n// Arguments:\n//   adj = The length of the side of the right triangle that is adjacent to the primary angle.\n//   opp = The length of the side of the right triangle that is opposite from the primary angle.\n// Example:\n//   hyp = adj_opp_to_hyp(3,4);  // Returns: 5\nfunction adj_opp_to_hyp(adj,opp) =\n    assert(is_finite(opp) && opp>=0 && is_finite(adj) && adj>=0,\n           \"Triangle side lengths should be a positive numbers.\" )\n    norm([opp,adj]);\n\nfunction opp_adj_to_hyp(opp,adj) = adj_opp_to_hyp(adj,opp);\n\n\n// Function: adj_ang_to_hyp()\n// Alias: ang_adj_to_hyp()\n// Synopsis: Returns the hypotenuse length from the length of the adjacent and the angle.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   hyp = adj_ang_to_hyp(adj,ang);\n//   hyp = ang_adj_to_hyp(ang,adj);\n// Description:\n//   For a right triangle, given the length of the adjacent side, and the corner angle, returns the length of the hypotenuse.\n// Arguments:\n//   adj = The length of the side of the right triangle that is adjacent to the primary angle.\n//   ang = The angle in degrees of the primary corner of the right triangle.\n// Example:\n//   hyp = adj_ang_to_hyp(4,60);  // Returns: 8\nfunction adj_ang_to_hyp(adj,ang) =\n    assert(is_finite(adj) && adj>=0, \"Triangle side length should be a positive number.\" )\n    assert(is_finite(ang) && ang>-90 && ang<90, \"The angle should be an acute angle.\" )\n    adj/cos(ang);\n\nfunction ang_adj_to_hyp(ang,adj) = adj_ang_to_hyp(adj,ang);\n\n\n// Function: opp_ang_to_hyp()\n// Alias: ang_opp_to_hyp()\n// Synopsis: Returns the hypotenuse length from the length of the opposite side and the angle.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   hyp = opp_ang_to_hyp(opp,ang);\n//   hyp = ang_opp_to_hyp(ang,opp);\n// Description:\n//   For a right triangle, given the length of the opposite side, and the corner angle, returns the length of the hypotenuse.\n// Arguments:\n//   opp = The length of the side of the right triangle that is opposite from the primary angle.\n//   ang = The angle in degrees of the primary corner of the right triangle.\n// Example:\n//   hyp = opp_ang_to_hyp(4,30);  // Returns: 8\nfunction opp_ang_to_hyp(opp,ang) =\n    assert(is_finite(opp) && opp>=0, \"Triangle side length should be a positive number.\" )\n    assert(is_finite(ang) && ang>-90 && ang<90, \"The angle should be an acute angle.\" )\n    opp/sin(ang);\n\nfunction ang_opp_to_hyp(ang,opp) = opp_ang_to_hyp(opp,ang);\n\n\n// Function: hyp_adj_to_ang()\n// Alias: adj_hyp_to_ang()\n// Synopsis: Returns the angle from the lengths of the hypotenuse and the adjacent side.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   ang = hyp_adj_to_ang(hyp,adj);\n//   ang = adj_hyp_to_ang(adj,hyp);\n// Description:\n//   For a right triangle, given the lengths of the hypotenuse and the adjacent sides, returns the angle of the corner.\n// Arguments:\n//   hyp = The length of the hypotenuse of the right triangle.\n//   adj = The length of the side of the right triangle that is adjacent to the primary angle.\n// Example:\n//   ang = hyp_adj_to_ang(8,4);  // Returns: 60 degrees\nfunction hyp_adj_to_ang(hyp,adj) =\n    assert(is_finite(hyp) && hyp>0 && is_finite(adj) && adj>=0,\n            \"Triangle side lengths should be positive numbers.\" )\n    acos(adj/hyp);\n\nfunction adj_hyp_to_ang(adj,hyp) = hyp_adj_to_ang(hyp,adj);\n\n\n// Function: hyp_opp_to_ang()\n// Alias: opp_hyp_to_ang()\n// Synopsis: Returns the angle from the lengths of the hypotenuse and the opposite side.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   ang = hyp_opp_to_ang(hyp,opp);\n//   ang = opp_hyp_to_ang(opp,hyp);\n// Description:\n//   For a right triangle, given the lengths of the hypotenuse and the opposite sides, returns the angle of the corner.\n// Arguments:\n//   hyp = The length of the hypotenuse of the right triangle.\n//   opp = The length of the side of the right triangle that is opposite from the primary angle.\n// Example:\n//   ang = hyp_opp_to_ang(8,4);  // Returns: 30 degrees\nfunction hyp_opp_to_ang(hyp,opp) =\n    assert(is_finite(hyp+opp) && hyp>0 && opp>=0,\n            \"Triangle side lengths should be positive numbers.\" )\n    asin(opp/hyp);\n\nfunction opp_hyp_to_ang(opp,hyp) = hyp_opp_to_ang(hyp,opp);\n\n\n// Function: adj_opp_to_ang()\n// Alias: opp_adj_to_ang()\n// Synopsis: Returns the angle from the lengths of the adjacent and opposite sides.\n// Topics: Geometry, Trigonometry, Triangles\n// See Also: adj_ang_to_hyp(), adj_ang_to_opp(), adj_opp_to_ang(), adj_opp_to_hyp(), hyp_adj_to_ang(), hyp_adj_to_opp(), hyp_ang_to_adj(), hyp_ang_to_opp(), hyp_opp_to_adj(), hyp_opp_to_ang(), opp_ang_to_adj(), opp_ang_to_hyp()\n// Usage:\n//   ang = adj_opp_to_ang(adj,opp);\n//   ang = opp_adj_to_ang(opp,adj);\n// Description:\n//   For a right triangle, given the lengths of the adjacent and opposite sides, returns the angle of the corner.\n// Arguments:\n//   adj = The length of the side of the right triangle that is adjacent to the primary angle.\n//   opp = The length of the side of the right triangle that is opposite from the primary angle.\n// Example:\n//   ang = adj_opp_to_ang(sqrt(3)/2,0.5);  // Returns: 30 degrees\nfunction adj_opp_to_ang(adj,opp) =\n    assert(is_finite(adj+opp) && adj>0 && opp>=0,\n            \"Triangle side lengths should be positive numbers.\" )\n    atan2(opp,adj);\n\nfunction opp_adj_to_ang(opp,adj) = adj_opp_to_ang(adj,opp);\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-46", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////////////////////////////\n// LibFile: tripod_mounts.scad\n//   Mount plates for tripods.  Currently only the Manfrotto RC2 plate. \n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/tripod_mounts.scad>\n// FileGroup: Parts\n// FileSummary: Tripod mount plates: RC2\n//////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// Module: manfrotto_rc2_plate()\n// Synopsis: Creates a Manfrotto RC2 tripod quick release mount plate.\n// SynTags: Geom\n// Topics: Parts\n// See Also: threaded_rod()\n// Usage:\n//   manfrotto_rc2_plate([chamfer],[anchor],[orient],[spin]) [ATTACHMENTS];\n// Description:\n//   Creates a Manfrotto RC2 quick release mount plate to mount to a tripod.  The chamfer argument\n//   lets you control whether the model edges are chamfered.  By default all edges are chamfered,\n//   but you can set it to \"bot\" to chamfer only the bottom, so that connections to a model larger\n//   than the plate doin't have a V-groove at the junction.  The plate is 10.5 mm thick.\n// Arguments:\n//   chamfer = \"none\" for no chamfer, \"all\" for full chamfering, and \"bot\" or \"bottom\" for bottom chamfering.  Default: \"all\".\n// Examples:\n//   manfrotto_rc2_plate();\n//   manfrotto_rc2_plate(\"bot\");\nmodule manfrotto_rc2_plate(chamfer=\"all\",anchor,orient,spin)\n{\n  chsize=0.5;\n\n  dummy = assert(in_list(chamfer, [\"bot\",\"bottom\",\"all\",\"none\"]), \"chamfer must be \\\"all\\\", \\\"bottom\\\", \\\"bot\\\", or \\\"none\\\"\");\n  chamf_top = chamfer==\"all\";\n  chamf_bot = in_list(chamfer, [\"bot\",\"bottom\",\"all\"]);\n\n  length = 52.5;\n  innerlen=43;\n  \n  topwid = 37.4;\n  botwid = 42.4;\n  \n  thickness = 10.5;\n\n  flat_height=3;\n  angled_size=5;\n  angled_height = thickness - flat_height*2;\n  angled_width = sqrt(angled_size^2-angled_height^2);\n\n  corner_space = 25;\n  corner_space_ht = 4.5;\n\n  left_top=2;\n\n  pts = turtle([\n                \"move\",botwid,\n                \"left\",\n                \"move\", flat_height,\n                \"xymove\", [-angled_width, angled_height],\n                \"move\", flat_height,\n                \"left\",\n                \"move\", topwid,\n                \"left\",\n                \"move\", left_top,\n                \"jump\", [0,flat_height]\n               ]);\n\n\n  cutout_len=26;\n\n\n  facet = [\n            back(-left_top,select(pts,-3)),\n            each fwd(1.5,select(pts,-2,-1)),\n            [-10,-left_top+select(pts,-1).y],\n            left(10,back(-flat_height,select(pts,-3)))\n          ];\n\n  attachable(anchor,spin,orient,size=[botwid,length,thickness],size2=[topwid,length],shift=[.64115/2,0]){\n    tag_scope()\n    down(thickness/2)\n    diff()\n      linear_sweep(pts,h=length,convexity=4,orient=FWD,anchor=FWD){\n          tag(\"remove\"){\n            zflip_copy()\n              down(.01)fwd(.01)left(.01)position(LEFT+FRONT+BOT)\n                cuboid([corner_space,(length-innerlen)/2,thickness+.02], chamfer=-chsize,\n                       orient=FWD,anchor=TOP+LEFT+FWD,edges=chamf_top?\"ALL\":TOP);\n            fwd(left_top)position(LEFT+BACK)linear_sweep(h=cutout_len,facet,convexity=4,anchor=RIGHT+BACK);\n          }\n          if (chamf_bot){\n            edge_mask(FRONT+LEFT)chamfer_edge_mask(length,chsize);\n            edge_mask(FRONT+RIGHT)chamfer_edge_mask(length,chsize);\n            edge_mask(FRONT+TOP)chamfer_edge_mask(length,chsize);        \n            edge_mask(FRONT+BOT)chamfer_edge_mask(length,chsize);\n            edge_mask(TOP+RIGHT)chamfer_edge_mask(length,chsize);\n            edge_mask(BOT+RIGHT)chamfer_edge_mask(length,chsize);\n            zflip_copy(){\n               right(corner_space)edge_mask(TOP+LEFT) chamfer_edge_mask(length,chsize);\n               down((length-innerlen)/2)edge_mask(TOP+LEFT) chamfer_edge_mask(length,chsize);\n            }\n          }\n          if (chamf_top){\n            edge_mask(BACK+LEFT) chamfer_edge_mask(length,chsize);\n            edge_mask(BACK+RIGHT) chamfer_edge_mask(length,chsize);\n            edge_mask(BACK+TOP) chamfer_edge_mask(length,chsize);        \n            edge_mask(BACK+BOT) chamfer_edge_mask(length,chsize);\n          }\n        }\n    children();\n    }\n}\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-47", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: turtle3d.scad\n//   Three dimensional turtle graphics to generate 3d paths or sequences\n//   of 3d transformations. \n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/turtle3d.scad>\n// FileGroup: Advanced Modeling\n// FileSummary: 3D turtle graphics for making paths or lists of transformations.\n//////////////////////////////////////////////////////////////////////\ninclude<structs.scad>\n\n// Section: Functions\n\n// Translation vector from a matrix\nfunction _transpart(T) = [for(row=[0:2]) T[row][3]];\n\n// The non-translation part of a matrix\nfunction _rotpart(T) = [for(i=[0:3]) [for(j=[0:3]) j<3 || i==3 ? T[i][j] : 0]];\n\n\n// Function: turtle3d()\n// Synopsis: Extends [turtle graphics](https://en.wikipedia.org/wiki/Turtle_graphics) to 3d. Generates a 3D path or returns a list of transforms.\n// SynTags: MatList, Path\n// Topics: Shapes (3D), Path Generators (3D), Mini-Language\n// See Also: turtle()\n// Usage:\n//   path = turtle3d(commands, [state=], [repeat=]);\n//   mats = turtle3d(commands, transforms=true, [state=], [repeat=]);\n//   state = turtle3d(commands, full_state=true, [state=], [repeat=]);\n// Description:\n//   Like the classic two dimensional turtle, the 3d turtle flies through space following a sequence\n//   of turtle graphics commands to generate either a sequence of transformations (suitable for input\n//   to sweep) or a 3d path.  The turtle state keeps track of the position and orientation (including twist)\n//   and scale of the turtle.  By default the turtle begins pointing along the X axis with the \"right\" direction\n//   along the -Y axis and the \"up\" direction aligned with the Z axis.  You can give a direction vector\n//   for the state input to change the starting direction.  Because of the complexity of object positioning\n//   in three space, some types of movement require compound commands.  These compound commands are lists that specify several operations\n//   all applied to one turtle step.  For example:  [\"move\", 4, \"twist\", 25] executes a twist while moving, and\n//   the command [\"arc\", 4, \"grow\", 2, \"right\", 45, \"up\", 30] turns to the right and up while also growing the object.\n//   .\n//   You can turn the turtle using relative commands, \"right\", \"left\", \"up\" and \"down\", which operate relative\n//   to the turtle's current orientation.   This is sometimes confusing, so you can also use absolute\n//   commands which turn the turtle relative to the absolute coordinate system, the \"xrot\", \"yrot\" and \"zrot\"\n//   commands.  You can use \"setdir\" to point the turtle along a given vector.\n//   If you want a valid transformation list for use with sweep you will usually want to avoid abrupt changes\n//   in the orientation of the turtle.  To do this, use the \"arc\"\n//   forms for turns.  This form, with commands like \"arcright\" and \"arcup\" creates an arc with a gradual\n//   change in the turtle orientation, which usually produces a better result for sweep operations.\n//   .\n//   Another potential problem for sweep is a command that makes movements not relative to the turtle's current direction such as\n//   \"jump\" or \"untily\".  These commands are not a problem for tracing out a path, but if you want a swept shape to\n//   maintain a constant cross sectional shape then you need to avoid them.  operations and avoid the movement commands\n//   which do not move relative to the turtle direction such as the \"jump\" commands.\n//   .\n//   If you use sweep to convert a turtle path into a 3d shape the result depends both on the path the shape traces out but also\n//   the twist and size of the shape.  The \"twist\" parameter described below to the compound commands has no effect on\n//   the turtle orientation for the purpose of defining movement, but it will rotate the swept shape around the origin\n//   as it traces out the path.  Similarly the \"grow\" and \"shrink\" options allow you to change the size of the swept\n//   polygon without any effect on the turtle.  The \"roll\" command differs from \"twist\" in that it both rotates the swept\n//   polygon but also changes the turtle's orientation, so it will alter subsequent operations of the turtle.  Note that\n//   when making a path, \"twist\" will have no effect, but \"roll\" may have an effect because of how it changes the path.  \n//   .\n//   The compound \"move\" command accepts a \"reverse\" argument.  If you specify \"reverse\" it reflects the\n//   turtle direction to point backwards.  This enables you to back out to create a hollow shape.  But be\n//   aware that everything is reversed, so turns will be the opposite direction.  So for example if you\n//   used \"arcright\" on the outside you might expect arcleft when reversed on the inside, but it will\n//   be \"arcright\" again.  (Note that \"reverse\" is the only command that appears by itself with no argument\n//   .\n//   By default you get a simple path (like the 2d turtle) which ignores growing/shrinking or twisting in the\n//   transformation.  If you select transform=true then you will get a list of transformations returned.  Some of\n//   of the commands are likely to produce transformation lists that are invalid for sweep.  The \"jump\" commands\n//   can move in directions not perpendicular to the current direction of movement, which may produce bad results.\n//   The turning commands like \"left\" or \"up\" can rotate the frame so that a sweep operation is invalid.\n//   The `T` column in the list below marks commands that operate relative\n//   to the current frame that should generally produce valid sweep transformations.\n//   Be aware that it is possible to create a self intersection, and hence an invalid swept shape, if the radii of\n//   arcs in turtle are smaller than the width of the polygon you use with sweep.  \n//   .\n//   The turtle state is a list containing:\n//     - a list of path transformations, the transformations that move the turtle along the path\n//     - a list of object transformations, the transformations that twist or scale the cross section as the turtle moves\n//     - the current movement step size (scalar)\n//     - the current default angle\n//     - the current default arcsteps  \n//   .\n//   Commands   |T | Arguments          | What it does\n//   ---------- |--| ------------------ | -------------------------------\n//   \"move\"     |x | [dist]             | Move turtle scale*dist units in the turtle direction.  Default dist=1.  \n//   \"xmove\"    |  | [dist]             | Move turtle scale*dist units in the x direction. Default dist=1.  Does not change turtle direction.\n//   \"ymove\"    |  | [dist]             | Move turtle scale*dist units in the y direction. Default dist=1.  Does not change turtle direction.\n//   \"zmove\"    |  | [dist]             | Move turtle scale*dist units in the y direction. Default dist=1.  Does not change turtle direction.\n//   \"xyzmove\"  |  | vector             | Move turtle by the specified vector.  Does not change turtle direction. \n//   \"untilx\"   |x | xtarget            | Move turtle in turtle direction until x==xtarget.  Produces an error if xtarget is not reachable.\n//   \"untily\"   |x | ytarget            | Move turtle in turtle direction until y==ytarget.  Produces an error if ytarget is not reachable.\n//   \"untilz\"   |x | ytarget            | Move turtle in turtle direction until y==ytarget.  Produces an error if ztarget is not reachable.\n//   \"jump\"     |  | point              | Move the turtle to the specified point\n//   \"xjump\"    |  | x                  | Move the turtle's x position to the specified value\n//   \"yjump     |  | y                  | Move the turtle's y position to the specified value\n//   \"zjump     |  | y                  | Move the turtle's y position to the specified value\n//   \"left\"     |  | [angle]            | Turn turtle left by specified angle or default angle\n//   \"right\"    |  | [angle]            | Turn turtle to the right by specified angle or default angle\n//   \"up\"       |  | [angle]            | Turn turtle up by specified angle or default angle\n//   \"down\"     |  | [angle]            | Turn turtle down by specified angle or default angle\n//   \"xrot\"     |x | [angle]            | Turn turtle around x-axis by specified angle or default angle\n//   \"yrot\"     |x | [angle]            | Turn turtle around y-axis by specified angle or default angle\n//   \"zrot\"     |x | [angle]            | Turn turtle around z-axis by specified angle or default angle\n//   \"rot\"      |x | rotation           | Turn turtle by specified rotation relative to absolute coordinates\n//   \"angle\"    |x | angle              | Set the default turn angle.\n//   \"setdir\"   |  | vector             | Rotate the reference frame along the shortest path to specified direction\n//   \"length\"   |x | length             | Change the turtle move distance to `length`\n//   \"scale\"    |x | factor             | Multiply turtle move distances by `factor`.  Does not rescale the cross sectional shape in transformation lists.  \n//   \"addlength\"|x | length             | Add `length` to the turtle move distance\n//   \"repeat\"   |x | count, commands    | Repeats a list of commands `count` times.  (To repeat a compound command put it in a list: `[[\"move\",10,\"grow\",2]]`)\n//   \"arcleft\"  |x | radius, [angle]    | Draw an arc from the current position toward the left at the specified radius and angle.  The turtle turns by `angle`.\n//   \"arcright\" |x | radius, [angle]    | Draw an arc from the current position toward the right at the specified radius and angle.  The turtle turns by `angle`.\n//   \"arcup\"    |x | radius, [angle]    | Draw an arc from the current position upward at the specified radius and angle\n//   \"arcdown\"  |x | radius, [angle]    | Draw an arc from the current position downward at the specified radius and angle\n//   \"arcxrot\"  |x | radius, [angle]    | Draw an arc turning around x-axis by specified angle or default angle\n//   \"arcyrot\"  |x | radius, [angle]    | Draw an arc turning around y-axis by specified angle or default angle\n//   \"arczrot\"  |x | radius, [angle]    | Draw an arc turning around z-axis by specified angle or default angle\n//   \"arcrot\"   |x | radius, rotation   | Draw an arc turning by the specified absolute rotation with given radius\n//   \"arctodir\" |x | radius, vector     | Draw an arc turning to point in the (absolute) direction of given vector\n//   \"arcsteps\" |x | count              | Specifies the number of segments to use for drawing arcs.  If you set it to zero then the standard `$fn`, `$fa` and `$fs` variables define the number of segments.\n//   .\n//   Compound commands are lists that group multiple commands to be applied simultaneously during a\n//   turtle movement.  Example: `[\"move\", 5, \"shrink\", 2]`.  The subcommands that may appear are\n//   listed below.  Each compound command must begin with either \"move\" or \"arc\".  The order of\n//   subcommands is not important.  Left/right turning is applied before up/down.  You cannot combine\n//   \"rot\" or \"todir\" with any other turning commands.  \n//   .\n//   Subcommands  | Arguments          | What it does\n//   ------------ | ------------------ | -------------------------------\n//   \"move\"       | dist               | Compound command is a forward movement operation\n//   \"arc\"        | radius             | Compound command traces an arc\n//   \"grow\"       | factor             | Increase size by specified factor (e.g. 2 doubles the size); factor can be a 2-vector\n//   \"shrink\"     | factor             | Decrease size by specified factor (e.g. 2 halves the size); factor can be a 2-vector\n//   \"twist\"      | angle              | Twist by the specified angle over the arc or segment (does not change frame orientation)\n//   \"roll\"       | angle              | Roll by the specified angle over the arc or segment (changes the orientation of the frame)\n//   \"steps\"      | count              | Divide arc or segment into this many steps.  Default is 1 for segments, arcsteps for arcs\n//   \"reverse\"    |                    | For \"move\" only: If given then reverses the turtle after the move\n//   \"right\"      | angle              | For \"arc\" only: Turn to the right by specified angle\n//   \"left\"       | angle              | For \"arc\" only: Turn to the left by specified angle\n//   \"up\"         | angle              | For \"arc\" only: Turn up by specified angle\n//   \"down\"       | angle              | For \"arc\" only: Turn down by specified angle\n//   \"xrot\"       | angle              | For \"arc\" only: Absolute rotation around x axis. Cannot be combined with any other rotation.\n//   \"yrot\"       | angle              | For \"arc\" only: Absolute rotation around y axis. Cannot be combined with any other rotation.\n//   \"zrot\"       | angle              | For \"arc\" only: Absolute rotation around z axis. Cannot be combined with any other rotation.\n//   \"rot\"        | rotation           | For \"arc\" only: Turn by specified absolute rotation as a matrix, e.g. xrot(33)*zrot(47).  Cannot be combined with any other rotation.\n//   \"todir\"      | vector             | For \"arc\" only: Turn to point in the specified direction\n//   .\n//   The \"twist\", \"shrink\" and \"grow\" subcommands will only have an effect if you return a transformation list.  They do not\n//   change the path the turtle traces.  The \"roll\" subcommand, on the other hand, changes the turtle frame orientation, so it can alter the path.\n//   The \"xrot\", \"yrot\" and \"zrot\" subcommands can make turns larger than 180 degrees, and even larger than 360 degrees.  If you use \"up\",\n//   \"down\", \"left\" or \"right\" alone then you can give any angle, but if you combine \"up\"/\"down\" with \"left\"/\"right\" then the specified\n//   angles must be smaller than 180 degrees.  (This is because the algorithm decodes the rotation into an angle smaller than 180, so\n//   the results are very strange if larger angles are permitted.)\n// Arguments:\n//   commands = List of turtle3d commands\n//   state = Starting turtle direction or full turtle state (from a previous call).  Default: RIGHT\n//   transforms = If true teturn list of transformations instead of points.  Default: false\n//   full_state = If true return full turtle state for continuing the path in subsequent turtle calls.  Default: false\n//   repeat = Number of times to repeat the command list.  Default: 1\n// Example(3D): Angled rectangle\n//   path = turtle3d([\"up\",25,\"move\",\"left\",\"move\",3,\"left\",\"move\"]);\n//   stroke(path,closed=true, width=.2);\n// Example(3D): Path with rounded corners.  Note first and last point of the path are duplicates.  \n//   r = 0.25;\n//   path = turtle3d([\"up\",25,\"move\",\"arcleft\",r,\"move\",3,\"arcleft\",r,\"move\",\"arcleft\",r,\"move\",3,\"arcleft\",r]);\n//   stroke(path,closed=true, width=.2);\n// Example(3D): Non-coplanar figure\n//   path = turtle3d([\"up\",25,\"move\",\"left\",\"move\",3,\"up\",\"left\",0,\"move\"]);\n//   stroke(path,closed=true, width=.2);\n// Example(3D): Square spiral.  Note that the core twists because the \"up\" and \"left\" turns are relative to the previous turns.\n//   include<BOSL2/skin.scad>\n//   path = turtle3d([\"move\",10,\"left\",\"up\",15],repeat=50);\n//   path_sweep(circle(d=1, $fn=12), path);\n// Example(3D): Square spiral, second try.  Use roll to create the spiral instead of turning up.  It still twists because the left turns are inclined.\n//   include<BOSL2/skin.scad>\n//   path = turtle3d([\"move\",10,\"left\",\"roll\",10],repeat=50);\n//   path_sweep(circle(d=1, $fn=12), path);\n// Example(3D): Square spiral, third try.  One way to avoid the core twisting in the spiral is to use absolute turns.  Note that the vertical rise is controlled by the starting upward angle of the turtle, which is preserved as we rotate around the z axis.  \n//   include<BOSL2/skin.scad>\n//   path = turtle3d([\"up\", 5, \"repeat\", 12, [\"move\",10,\"zrot\"]]);\n//   path_sweep(circle(d=1, $fn=12), path);\n// Example(3D): Square spiral, rounded corners.  Careful use of rotations can work for sweep, but it may be better to round the corners.  Here we return a list of transforms and use sweep instead of path_sweep:\n//   include<BOSL2/skin.scad>\n//   path = turtle3d([\"up\", 5, \"repeat\", 12, [\"move\",10,\"arczrot\",4]],transforms=true);\n//   sweep(circle(d=1, $fn=12), path);\n// Example(3D): Mixing relative and absolute commands\n//   include<BOSL2/skin.scad>\n//   path = turtle3d([\"repeat\", 4, [\"move\",80,\"arczrot\",40],\n//                    \"arcyrot\",40,-90,\n//                    \"move\",40,\n//                    \"arcxrot\",40,90,\n//                    [\"arc\",14,\"rot\",xrot(90)*zrot(-33)],\n//                    \"move\",80,\n//                    \"arcyrot\",40,\n//                    \"arcup\",40,\n//                    \"arcleft\",40,\n//                    \"arcup\",30,\n//                    [\"move\",100,\"twist\",90,\"steps\",20],\n//                   ],\n//                   state=[1,0,.2],transforms=true);\n//   ushape = rot(90,p=[[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]]);\n//   sweep(ushape, path);\n// Example(3D): Generic helix, constructed by a sequence of movements and then rotations\n//   include<BOSL2/skin.scad>\n//   radius=14;       // Helix radius\n//   pitch=20;        // Distance from one turn to the next\n//   turns=3;         // Number of turns\n//   turn_steps=32;   // Number of steps on each turn\n//   axis = [1,4,1];  // Helix axis\n//   up_angle = atan2(pitch,2*PI*radius);\n//   helix = turtle3d([\n//                      \"up\", up_angle,\n//                      \"zrot\", 360/turn_steps/2,\n//                      \"rot\", rot(from=UP,to=axis), // to correct the turtle direction\n//                      \"repeat\", turn_steps*turns,\n//                      [\n//                       \"move\", norm([2*PI*radius, pitch])/turn_steps,\n//                       \"rot\",  rot(360/turn_steps,v=axis)\n//                      ],\n//                     ], transforms=true);\n//   sweep(subdivide_path(square([5,1]),20), helix);\n// Example(3D): Helix generated by a single command.  Note this only works for x, y, or z aligned helixes because the generic rot cannot handle multi-turn angles.  \n//   include<BOSL2/skin.scad>\n//   pitch=20;       // Distance from one turn to the next\n//   radius=14;      // Helix radius\n//   turns=3;        // Number of turns\n//   turn_steps=33;  // Steps on each turn\n//   up_angle = atan2(pitch,2*PI*radius);\n//   helix = turtle3d([\n//                     \"up\", up_angle,\n//                     [\n//                       \"arc\", radius,\n//                       \"zrot\", 360*turns,\n//                       \"steps\", turn_steps*turns,\n//                     ]\n//                    ], transforms=true);\n//   sweep(subdivide_path(square([5,1]),80), helix);\n// Example(3D): Expanding helix\n//   include<BOSL2/skin.scad>\n//   path = turtle3d([\"length\",.2,\"angle\",360/20,\"up\",5,\"repeat\",50,[\"move\",\"zrot\",\"addlength\",0.05]]);\n//   path_sweep(circle(d=1, $fn=12), path);\n// Example(3D): Adding some twist to the model\n//   include<BOSL2/skin.scad>\n//   r = 2.5;\n//   trans = turtle3d([\"move\",10,\n//                     \"arcleft\",r,\n//                     [\"move\",30,\"twist\",180,\"steps\",40],\n//                     \"arcleft\",r,\n//                     \"move\",10,\n//                     \"arcleft\",r,\n//                     [\"move\",30,\"twist\",360,\"steps\",40],\n//                     \"arcleft\",r],\n//                    state=yrot(25,p=RIGHT),transforms=true);\n//   sweep(supershape(m1=4,n1=4,n2=16,n3=1.5,a=.9,b=9,step=5),trans);\n// Example(3D): Twist does not change the turtle orientation, but roll does.  The only change from the previous example is twist was changed to roll.\n//   include<BOSL2/skin.scad>\n//   r = 2;\n//   trans = turtle3d([\"move\",10,\n//                     \"arcleft\",r,\n//                     [\"move\",30,\"roll\",180,\"steps\",40],\n//                     \"arcleft\",r,\n//                     \"move\",10,\n//                     \"arcleft\",r,\n//                     [\"move\",30,\"roll\",360,\"steps\",40],\n//                     \"arcleft\",r],\n//                    state=yrot(25,p=RIGHT),transforms=true);\n//   sweep(supershape(m1=4,n1=4,n2=16,n3=1.5,a=.9,b=9,step=5),trans);\n// Example(3D): Use of shrink and grow\n//   include<BOSL2/skin.scad>\n//   $fn=32;\n//   T = turtle3d([\n//                 \"move\",10,\n//                 [\"arc\",8,\"right\", 90, \"twist\", 90, \"grow\", 2],\n//                 [\"move\", 5,\"shrink\",4,\"steps\",4],\n//                 [\"arc\",8, \"right\", 45, \"up\", 90],\n//                 \"move\", 10,\n//                 \"arcright\", 5, 90,\n//                 \"arcleft\", 5, 90,\n//                 \"arcup\", 5, 90,\n//                 \"untily\", -1,\n//                ],state=RIGHT, transforms=true);   \n//   sweep(square(2,center=true),T);\n// Example(3D): After several moves you may not understand the turtle orientation. An absolute reorientation with \"arctodir\" is helpful to head in a known direction\n//   include<BOSL2/skin.scad>\n//   trans = turtle3d([\n//                  \"move\",5,\n//                  \"arcup\",1,\n//                  \"move\",8,\n//                  \"arcright\",1,\n//                  \"move\",6,\n//                  \"arcdown\",1,\n//                  \"move\",4,\n//                  [\"arc\",2,\"right\",45,\"up\",25,\"roll\",25],\n//                  \"untilz\",4,\n//                  \"move\",1,\n//                  \"arctodir\",1,DOWN,\n//                  \"untilz\",0\n//                  ],transforms=true);\n//   sweep(square(1,center=true),trans);\n// Example(3D): The \"grow\" and \"shrink\" commands can take a vector giving x and y scaling\n//   include<BOSL2/skin.scad>\n//   tr = turtle3d([\n//                   \"move\", 1.5, \n//                   [\"move\", 5, \"grow\", [1,2],  \"steps\", 10],\n//                   [\"move\", 5, \"grow\", [2,0.5],\"steps\", 10]\n//                  ], transforms=true);\n//   sweep(circle($fn=32,r=1), tr);\n// Example(3D): With \"twist\" added the anisotropic \"grow\" interacts with \"twist\", producing a complex form\n//   include<BOSL2/skin.scad>\n//   tr = turtle3d([\n//                   \"move\", 1.5, \n//                   [\"move\", 5, \"grow\", [1,2],  \"steps\", 20, \"twist\",90],\n//                   [\"move\", 5, \"grow\", [0.5,2],\"steps\", 20, \"twist\",90]\n//                  ], transforms=true);\n//   sweep(circle($fn=64,r=1), tr);\n// Example(3D): Making a tube with \"reverse\".  Note that the move direction is the same even though the direction is reversed.  \n//   include<BOSL2/skin.scad>\n//   tr = turtle3d([ \"move\", 4,\n//                   [\"move\",0, \"grow\", .8, \"reverse\"],\n//                   \"move\", 4\n//                 ],  transforms=true);\n//   back_half(s=10)\n//     sweep(circle(r=1,$fn=16), tr, closed=true);\n// Example(3D): To close the tube at one end we set closed to false in sweep.  \n//   include<BOSL2/skin.scad>\n//   tr = turtle3d([ \"move\", 4,\n//                   [\"move\",0, \"grow\", .8, \"reverse\"],\n//                   \"move\", 3.75\n//                 ],  transforms=true);\n//   back_half(s=10)\n//     sweep(circle(r=1,$fn=16), tr, closed=false);\n// Example(3D): Cookie cutter using \"reverse\" \n//   include<BOSL2/skin.scad>\n//   cutter = turtle3d( [ \n//                       [\"move\", 10, \"shrink\", 1.3, ],\n//                       [\"move\", 2, \"reverse\" ],\n//                       [\"move\", 8, \"shrink\", 1.3 ],\n//                      ], transforms=true,state=UP);\n//   cookie_shape = star(5, r=10, ir=5);\n//   sweep(cookie_shape, cutter, closed=true);\n// Example(3D): angled shopvac adapter.  Shopvac tubing wedges together because the tubes are slightly tapered.  We can make this part without using any difference() operations by using \"reverse\" to trace out the interior portion of the part.  Note that it's \"arcright\" even when reversed.  \n//   include<BOSL2/skin.scad>\n//   inch = 25.4;\n//   insert_ID = 2.3*inch;        // Size of shopvac tube at larger end of taper\n//   wall = 1.7;                  // Desired wall thickness\n//   seg1_bot_ID = insert_ID;     // Bottom section, to have tube inserted, specify ID\n//   seg2_bot_OD = insert_ID+.03; // Top section inserts into a tube, so specify tapered OD\n//   seg2_top_OD = 2.26*inch;     // The slightly oversized value gave me a better fit\n//   seg1_len = 3*inch;           // Length of bottom section\n//   seg2_len = 2*inch;           // Length of top section\n//   bend_angle=45;               // Angle to bend, 45 or less to print without supports!\n//   // Other diameters derived from the wall thickness\n//   seg1_bot_OD = seg1_bot_ID+2*wall;\n//   seg2_bot_ID = seg2_bot_OD-2*wall;\n//   seg2_top_ID = seg2_top_OD-2*wall;\n//   bend_r = 0.5*inch+seg1_bot_OD/2;   // Bend radius to get constant wall thickness\n//   trans = turtle3d([\n//                       [\"move\", seg1_len, \"grow\", seg2_bot_OD/seg1_bot_OD],  \n//                       \"arcright\", bend_r, bend_angle,\n//                       [\"move\", seg2_len, \"grow\", seg2_top_OD/seg2_bot_OD],\n//                       [\"move\", 0, \"reverse\", \"grow\", seg2_top_ID/seg2_top_OD],\n//                       [\"move\", seg2_len, \"grow\", seg2_bot_ID/seg2_top_ID],\n//                       \"arcright\", bend_r, bend_angle,\n//                       [\"move\", seg1_len, \"grow\", seg1_bot_ID/seg2_bot_ID]\n//                    ],\n//                    state=UP, transforms=true);\n//   back_half(s=300)    // Remove this to get a usable part\n//     sweep(circle(d=seg1_bot_OD, $fn=128), trans, closed=true);\n// Example(3D): Closed spiral\n//   include<BOSL2/skin.scad>\n//   steps = 500;\n//   spiral = turtle3d([\n//                      [\"arc\", 20,\n//                       \"twist\", 120,\n//                       \"zrot\", 360*4,\n//                       \"steps\",steps,\n//                       \"shrink\",1.5],\n//                      [\"arc\", 20,\n//                       \"twist\", 120,\n//                       \"zrot\", 360*4,\n//                       \"steps\",steps/5 ],\n//                      [\"arc\", 20,\n//                       \"twist\", 120,\n//                       \"zrot\", 360*4,\n//                       \"steps\",steps,\n//                       \"grow\",1.5],\n//                      ], transforms=true);\n//   sweep(fwd(25,p=circle(r=2,$fn=24)), spiral, caps=false);\n// Example(3D): Mobius strip (square)\n//   include<BOSL2/skin.scad>\n//   mobius = turtle3d([[\"arc\", 20, \"zrot\", 360,\"steps\",100,\"twist\",180]], transforms=true);\n//   sweep(subdivide_path(square(8,center=true),16), mobius, closed=false);\n// Example(3D): Torus knot\n//   include<BOSL2/skin.scad>\n//   p = 3;      // (number of turns)*gcd(p,q)\n//   q = 10;     // (number of dives)*gcd(p,q)\n//   steps = 60; // steps per turn\n//   cordR  = 2; // knot cord radius\n//   torusR = 20;// torus major radius\n//   torusr = 4; // torus minor radius\n//   knot_radius = torusr + 0.75*cordR; // inner radius of knot, set to torusr to put knot\n//   wind_angle = atan(p / q *torusR / torusr);            // center on torus surface\n//   m = gcd(p,q);\n//   torus_knot0 =\n//       turtle3d([ \"arcsteps\", 1,\n//                  \"repeat\", p*steps/m-1 ,\n//                     [ [ \"arc\", torusR, \"left\", 360/steps, \"twist\", 360*q/p/steps ] ]\n//                ], transforms=true);\n//   torus_knot = [for(tr=torus_knot0) tr*xrot(wind_angle+90)];\n//   torus = turtle3d( [\"arcsteps\", steps, \"arcleft\", torusR, 360], transforms=true);\n//   fwd(torusR){ // to center the torus and knot at the origin\n//       color([.8,.7,1])\n//         sweep(right(knot_radius,p=circle(cordR,$fn=16)), torus_knot,closed=true);\n//       color(\"blue\")\n//         sweep(circle(torusr,$fn=24), torus);\n//   }\n\n/*\nturtle state: sequence of transformations (\"path\") so far\n              sequence of pre-transforms that apply to the polygon (scaling and twist)\n              default move\n              default angle\n              default arc steps\n*/\n\nfunction _turtle3d_state_valid(state) =\n    is_list(state)\n        && is_consistent(state[0],ident(4))\n        && is_consistent(state[1],ident(4))\n        && is_num(state[2])\n        && is_num(state[3])\n        && is_num(state[4]);\n\nmodule turtle3d(commands, state=RIGHT, transforms=false, full_state=false, repeat=1) {no_module();}\nfunction turtle3d(commands, state=RIGHT, transforms=false, full_state=false, repeat=1) =\n  assert(is_bool(transforms))\n  let(\n       state = is_matrix(state,4,4) ? [[state],[yrot(90)],1,90,0] :\n               is_vector(state,3) ?\n                  let( updir = UP - (UP * state) * state / (state*state) )\n                  [[frame_map(x=state, z=approx(norm(updir),0) ? FWD : updir)], [yrot(90)],1, 90, 0]\n                : assert(_turtle3d_state_valid(state), \"Supplied state is not valid\")\n                  state,\n       finalstate = _turtle3d_repeat(commands, state, repeat)\n  )\n    assert(is_integer(repeat) && repeat>=0, \"turtle3d repeat argument must be a nonnegative integer\")\n    full_state  ? finalstate \n  : !transforms ? deduplicate([for(T=finalstate[0]) apply(T,[0,0,0])])\n  : [for(i=idx(finalstate[0])) finalstate[0][i]*finalstate[1][i]];\n\nfunction _turtle3d_repeat(commands, state, repeat) =\n   repeat<=0 ? state : _turtle3d_repeat(commands, _turtle3d(commands, state), repeat-1);\n\nfunction _turtle3d_command_len(commands, index) =\n    let( one_or_two_arg = [\"arcleft\",\"arcright\", \"arcup\", \"arcdown\", \"arczrot\", \"arcyrot\", \"arcxrot\"] )\n    in_list(commands[index],[\"repeat\",\"arctodir\",\"arcrot\"]) ? 3 :   // Repeat, arctodir and arcrot commands require 2 args\n    // For these, the first arg is required, second arg is present if it is not a string or list\n    in_list(commands[index], one_or_two_arg) && len(commands)>index+2 && !is_string(commands[index+2]) && !is_list(commands[index+2])  ? 3 :  \n    is_string(commands[index+1]) || is_list(commands[index])? 1 :  // If 2nd item is a string it's must be a new command; \n                                                                   // If first item is a list it's a compound command\n    2;                                 // Otherwise we have command and arg\n       \nfunction _turtle3d(commands, state, index=0) =\n    index >= len(commands) ? state :\n    _turtle3d(commands,\n            _turtle3d_command(commands[index],commands[index+1],commands[index+2],state,index),\n            index+_turtle3d_command_len(commands,index)\n        );\n\nfunction _turtle3d_rotation(command,angle,center) =\n  let(\n      myangle = (ends_with(command,\"right\") || ends_with(command,\"up\") ? -1 : 1 ) * angle\n  )\n  ends_with(command,\"xrot\") ? xrot(myangle,cp=center) :\n  ends_with(command,\"yrot\") ? yrot(myangle,cp=center) :\n  ends_with(command,\"zrot\") ? zrot(myangle,cp=center) :\n  ends_with(command,\"right\") || ends_with(command,\"left\") ? zrot(myangle,cp=center) :\n                                                            yrot(myangle,cp=center);\n\n// The turtle3d state maintains two lists of transformations that must be updated together. \n// This function updates the state by appending a list of transforms and list of pre-transforms\n// to the state.\nfunction _tupdate(state, tran, pretran) =\n    [\n     concat(state[0],tran),\n     concat(state[1],pretran),\n     each list_tail(state,2)\n    ];\n\nfunction _turtle3d_command(command, parm, parm2, state, index) =\n    command == \"repeat\"?\n        assert(is_int(parm) && parm>=0,str(\"\\\"repeat\\\" command requires an integer repeat count at index \",index))\n        assert(is_list(parm2),str(\"\\\"repeat\\\" command requires a command list parameter at index \",index))\n        _turtle3d_repeat(parm2, state, parm) :\n    let(\n        trlist = 0,\n        prelist = 1,\n        movestep=2,\n        angle=3,\n        arcsteps=4,\n        parm = !is_string(parm) ? parm : undef,\n        parm2 = command==\"arctodir\" || command==\"arcrot\" ? parm2 \n              : !is_string(parm2) && !is_list(parm2) ? parm2 : undef,\n        needvec = [\"jump\", \"xyzmove\",\"setdir\"],\n        neednum = [\"untilx\",\"untily\",\"untilz\",\"xjump\",\"yjump\",\"zjump\",\"angle\",\"length\",\"scale\",\"addlength\"],\n        numornothing = [\"right\",\"left\",\"up\",\"down\",\"xrot\",\"yrot\",\"zrot\", \"roll\", \"move\"],\n        needtran = [\"rot\"],\n        chvec = !in_list(command,needvec) || is_vector(parm,3),\n        chnum = (!in_list(command,neednum) || is_num(parm))\n                && (!in_list(command,numornothing) || (is_undef(parm) || is_num(parm))),\n        chtran = !in_list(command,needtran) || is_matrix(parm,4,4),\n        lastT = last(state[trlist]),\n        lastPre = last(state[prelist]),\n        lastpt = apply(lastT,[0,0,0])\n    )\n    assert(chvec,str(\"\\\"\",command,\"\\\" requires a 3d vector parameter at index \",index))\n    assert(chnum,str(\"\\\"\",command,\"\\\" requires a numeric parameter at index \",index))\n    assert(chtran,str(\"\\\"\",command,\"\\\" requires a 4x4 transformation matrix at index \",index))\n    command==\"move\" ? _tupdate(state, [lastT*right(default(parm,1)*state[movestep])], [lastPre]):\n    in_list(command,[\"untilx\",\"untily\",\"untilz\"]) ? (\n        let(\n            dirlist=[RIGHT, BACK, UP],\n            plane = [each dirlist[search([command],[\"untilx\",\"untily\",\"untilz\"])[0]], parm],\n            step = [lastpt,apply(lastT,RIGHT)],\n            int = plane_line_intersection(plane, step, bounded=[true,false])\n        )\n        assert(is_def(int), str(\"\\\"\",command,\"\\\" never reaches desired goal at index \",index))\n        let(\n            size = is_vector(int,3) ? norm(int-lastpt) / norm(step[1]-step[0]) : 0\n        )\n        _tupdate(state, [lastT*right(size)], [lastPre])\n    ) :\n    command==\"xmove\" ? _tupdate(state,[right(default(parm,1)*state[movestep])*lastT],[lastPre]):\n    command==\"ymove\" ? _tupdate(state,[back(default(parm,1)*state[movestep])*lastT],[lastPre]):\n    command==\"zmove\" ? _tupdate(state,[up(default(parm,1)*state[movestep])*lastT],[lastPre]):\n    command==\"xyzmove\" ? _tupdate(state,[move(parm)*lastT],[lastPre]):\n    command==\"jump\" ? _tupdate(state,[move(parm-lastpt)*lastT],[lastPre]):\n    command==\"xjump\" ? _tupdate(state,[move([parm,lastpt.y,lastpt.z]-lastpt)*lastT],[lastPre]):\n    command==\"yjump\" ? _tupdate(state,[move([lastpt.x,parm,lastpt.z]-lastpt)*lastT],[lastPre]):\n    command==\"yjump\" ? _tupdate(state,[move([lastpt.x,lastpt.y,parm]-lastpt)*lastT],[lastPre]):\n    command==\"angle\" ? assert(parm!=0,str(\"\\\"\",command,\"\\\" requires nonnegative argument at index \",index))\n                       list_set(state, angle, parm) :\n    command==\"length\" ? list_set(state, movestep, parm) :\n    command==\"scale\" ?  list_set(state, movestep, parm*state[movestep]) :\n    command==\"addlength\" ?  list_set(state, movestep, state[movestep]+parm) :\n    command==\"arcsteps\" ?  assert(is_int(parm) && parm>0, str(\"\\\"\",command,\"\\\" requires a postive integer argument at index \",index))\n                           list_set(state, arcsteps, parm) :\n    command==\"roll\" ? list_set(state, trlist, concat(list_head(state[trlist]), [lastT*xrot(parm)])):\n    in_list(command,[\"right\",\"left\",\"up\",\"down\"]) ? \n        list_set(state, trlist, concat(list_head(state[trlist]), [lastT*_turtle3d_rotation(command,default(parm,state[angle]))])):\n    in_list(command,[\"xrot\",\"yrot\",\"zrot\"]) ?\n        let(\n             Trot = _rotpart(lastT),      // Extract rotational part of lastT\n             shift = _transpart(lastT)    // Translation part of lastT\n        )\n        list_set(state, trlist, concat(list_head(state[trlist]),\n                                       [move(shift)*_turtle3d_rotation(command,default(parm,state[angle])) * Trot])):\n    command==\"rot\" ?\n        let(\n             Trot = _rotpart(lastT),      // Extract rotational part of lastT\n             shift = _transpart(lastT)    // Translation part of lastT\n        )\n        list_set(state, trlist, concat(list_head(state[trlist]),[move(shift) * parm * Trot])):\n    command==\"setdir\" ?\n        let(\n             Trot = _rotpart(lastT),\n             shift = _transpart(lastT)\n        )\n        list_set(state, trlist, concat(list_head(state[trlist]),\n                                       [move(shift)*rot(from=apply(Trot,RIGHT),to=parm) * Trot ])):\n    in_list(command,[\"arcleft\",\"arcright\",\"arcup\",\"arcdown\"]) ?\n        assert(is_num(parm),str(\"\\\"\",command,\"\\\" command requires a numeric radius value at index \",index))\n        let(\n            radius = state[movestep]*parm,\n            myangle = default(parm2,state[angle])\n        )\n        assert(myangle!=0, str(\"\\\"\",command,\"\\\" command requires a nonzero angle at index \",index))\n        let(\n            length = 2*PI*radius * abs(myangle)/360, \n            center = [0,\n                      command==\"arcleft\"?radius:command==\"arcright\"?-radius:0,\n                      command==\"arcdown\"?-radius:command==\"arcup\"?radius:0],\n            steps = state[arcsteps]==0 ? segs(abs(radius)) : state[arcsteps]\n        )    \n        _tupdate(state,\n                 [for(n=[1:1:steps]) lastT*_turtle3d_rotation(command,myangle*n/steps,center)],\n                 repeat(lastPre,steps)):\n    in_list(command,[\"arcxrot\",\"arcyrot\",\"arczrot\"]) ?\n        assert(is_num(parm),str(\"\\\"\",command,\"\\\" command requires a numeric radius value at index \",index))  \n        let(\n            radius = state[movestep]*parm,\n            myangle = default(parm2,state[angle])\n        )\n        assert(myangle!=0, str(\"\\\"\",command,\"\\\" command requires a nonzero angle at index \",index))\n        let(\n            length = 2*PI*radius * abs(myangle)/360, \n            steps = state[arcsteps]==0 ? segs(abs(radius)) : state[arcsteps],\n            Trot = _rotpart(lastT),\n            shift = _transpart(lastT),\n            v = apply(Trot,RIGHT),\n            dir = command==\"arcxrot\" ? RIGHT\n                : command==\"arcyrot\" ? BACK\n                : UP,\n            projv = v - (dir*v)*dir,\n            center = sign(myangle) * radius * cross(dir,projv),\n            slope = dir*v / norm(projv),\n            vshift = dir*slope*length\n        )\n        assert(!all_zero(projv), str(\"Rotation acts as twist, which does not produce a valid arc, at index \",index))\n        _tupdate(state,\n                 [for(n=[1:1:steps]) move(shift+vshift*n/steps)*_turtle3d_rotation(command,myangle*n/steps,center)*Trot],\n                 repeat(lastPre,steps)):\n    command==\"arctodir\" || command==\"arcrot\"?\n        assert(command!=\"arctodir\" || is_vector(parm2,3),str(\"\\\"\",command,\"\\\" command requires a direction vector at index \",index))\n        assert(command!=\"arcrot\" || is_matrix(parm2,4,4),str(\"\\\"\",command,\"\\\" command requires a transformation matrix at index \",index))  \n        let(\n            Trot = _rotpart(lastT),\n            shift = _transpart(lastT),\n            v = apply(Trot,RIGHT),\n            rotparms = command==\"arctodir\"\n                              ? rot_decode(rot(from=v,to=parm2))\n                              : rot_decode(parm2),\n            dir = rotparms[1],\n            myangle = rotparms[0],\n            projv = v - (dir*v)*dir,\n            slope = dir*v / norm(projv),\n            radius = state[movestep]*parm,\n            length = 2*PI*radius * myangle/360, \n            vshift = dir*slope*length,\n            steps = state[arcsteps]==0 ? segs(abs(radius)) : state[arcsteps],\n            center = radius * cross(dir,projv)\n        )\n        assert(!all_zero(projv), str(\"Rotation acts as twist, which does not produce a valid arc, at index \",index))\n        _tupdate(state,\n                 [for(n=[1:1:steps]) move(shift+vshift*n/steps)*rot(n/steps*myangle,v=rotparms[1],cp=center)*Trot],\n                 repeat(lastPre,steps)):\n    is_list(command) ?\n        let(list_update = _turtle3d_list_command(command, state[arcsteps], state[movestep], lastT, lastPre, index))\n        _tupdate(state, list_update[0], list_update[1]):\n    assert(false,str(\"Unknown turtle command \\\"\",command,\"\\\" at index\",index))\n    [];\n       \n\nfunction _turtle3d_list_command(command,arcsteps,movescale, lastT,lastPre,index) =\n   let(\n       reverse_index = search([\"reverse\"], command, 0)[0],\n       reverse = len(reverse_index)==1,\n       arcind = search([\"arc\"], command, 0)[0],\n       moveind = search([\"move\"], command, 0)[0],\n       movearcok = (arcind==[] || max(arcind)==0) && (moveind==[] || max(moveind)==0)\n   )\n   assert(len(reverse_index)<=1, str(\"Only one \\\"reverse\\\" is allowed at index \",index))\n   assert(!reverse || reverse_index[0]%2==0, str(\"Error processing compound command at index \",index))\n   assert(movearcok, str(\"\\\"move\\\" or \\\"arc\\\" must appear at the beginning of the compound command at index \",index))\n   assert(!reverse || len(command)%2==1,str(\"Odd number of entries in [keyword,value] list (after removing \\\"reverse\\\") at index \",index))\n   assert(reverse || len(command)%2==0,str(\"Odd number of entries in [keyword,value] list at index \",index))\n   let(\n       \n       command = list_remove(command, reverse_index),\n       keys=command[0]==\"move\" ?\n               struct_set([\n                           [\"move\", 0],\n                           [\"twist\",0],\n                           [\"grow\",1],\n                           [\"shrink\",1],\n                           [\"steps\",1],\n                           [\"roll\",0],\n                          ],\n                          command, grow=false)\n          :command[0]==\"arc\" ?\n               struct_set([\n                           [\"arc\", 0],\n                           [\"up\", 0],\n                           [\"down\", 0],\n                           [\"left\", 0],\n                           [\"right\", 0],\n                           [\"twist\",0],\n                           [\"grow\",1],\n                           [\"shrink\",1],\n                           [\"steps\",0],\n                           [\"roll\",0],\n                           [\"rot\", 0],\n                           [\"todir\", 0],\n                           [\"xrot\", 0],\n                           [\"yrot\", 0],\n                           [\"zrot\", 0],\n                          ],\n                          command, grow=false)\n          :assert(false,str(\"Unknown compound turtle3d command \\\"\",command,\"\\\" at index \",index)),\n       move = command[0]==\"move\" ? movescale*struct_val(keys,\"move\") : 0,\n       flip = reverse ? xflip() : ident(4),            // If reverse is given we set flip \n       radius = movescale*first_defined([struct_val(keys,\"arc\"),0]),  // arc radius if given\n       twist = struct_val(keys,\"twist\"),\n       grow = force_list(struct_val(keys,\"grow\"),2),\n       shrink = force_list(struct_val(keys, \"shrink\"),2)\n   )\n   assert(is_num(radius), str(\"Radius parameter to \\\"arc\\\" must be a number in command at index \",index))\n   assert(is_vector(grow,2), str(\"Parameter to \\\"grow\\\" must be a scalar or 2d vector at index \",index))\n   assert(is_vector(shrink,2), str(\"Parameter to \\\"shrink\\\" must be a scalar or 2d vector at index \",index))\n   let(\n       scaling = point3d(v_div(grow,shrink),1),\n       usersteps = struct_val(keys,\"steps\"),\n       roll = struct_val(keys,\"roll\"),\n       ////////////////////////////////////////////////////////////////////////////////////////\n       ////  Next section is computations for relative rotations: \"left\", \"right\", \"up\" or \"down\"\n       right = default(struct_val(keys,\"right\"),0),\n       left = default(struct_val(keys,\"left\"),0),\n       up = default(struct_val(keys,\"up\"),0),\n       down = default(struct_val(keys,\"down\"),0),\n       angleok = assert(command[0]==\"move\" || (is_num(right) && is_num(left) && is_num(up) && is_num(down)),\n                        str(\"Must give numeric argument to \\\"left\\\", \\\"right\\\", \\\"up\\\" and \\\"down\\\" in command at index \",index))\n                 command[0]==\"move\" || ((up-down==0 || abs(left-right)<180) && (left-right==0 || abs(up-down)<180))\n   )\n   assert(command[0]==\"move\" || right==0 || left==0, str(\"Cannot specify both \\\"left\\\" and \\\"right\\\" in command at index \",index))\n   assert(command[0]==\"move\" || up==0 || down==0, str(\"Cannot specify both \\\"up\\\" and \\\"down\\\" in command at index \",index))\n   assert(angleok, str(\"Mixed angles must all be below 180 at index \",index))\n   let(\n        newdir = apply(zrot(left-right)*yrot(down-up),RIGHT),     // This is the new direction turtle points relative to RIGHT\n        relaxis = left-right == 0 ? BACK\n                : down-up == 0 ? UP\n                : cross(RIGHT,newdir),         // This is the axis of rotation for \"right\", \"left\", \"up\" or \"down\"\n        angle = command[0]==\"move\" ? 0 :\n                  left-right==0 || down-up==0 ? down-up+left-right :\n                  vector_angle(RIGHT,newdir),    // And this is the angle for that case.\n        center = -radius * (                     // Center of rotation for this case\n                      left-right == 0 ? [0,0,sign(down-up)]\n                    : down-up == 0 ? [0,sign(right-left),0]\n                    :       unit(cross(RIGHT,cross(RIGHT,newdir)),[0,0,0])\n                 ),    \n        ///////////////////////////////////////////////\n        // Next we compute values for absolute rotations: \"xrot\", \"xrot\", \"yrot\", \"zrot\", and \"todir\"\n        //\n        xrotangle = struct_val(keys,\"xrot\"),\n        yrotangle = struct_val(keys,\"yrot\"),\n        zrotangle = struct_val(keys,\"zrot\"),\n        rot = struct_val(keys,\"rot\"),\n        todir = struct_val(keys,\"todir\"),\n        // Compute rotation angle and axis for the absolute rotation (or undef if no absolute rotation is given)\n        abs_angle_axis =\n            command[0]==\"move\" ? [undef,CENTER] :\n            let(nzcount=len([for(entry=[xrotangle,yrotangle,zrotangle,rot,todir]) if (entry!=0) 1]))\n            assert(nzcount<=1, str(\"You can only define one of \\\"xrot\\\", \\\"yrot\\\", \\\"zrot\\\", \\\"rot\\\", and \\\"todir\\\" at index \",index))\n            rot!=0 ?   assert(is_matrix(rot,4,4),str(\"Argument to \\\"rot\\\" is not a 3d transformation matrix at index \",index))\n                       rot_decode(rot)\n          : todir!=0 ? assert(is_vector(todir,3),str(\"Argument to \\\"todir\\\" is not a length 3 vector at index \",index))\n                       rot_decode(rot(from=v, to=todir))\n          : xrotangle!=0 ? [xrotangle, RIGHT]\n          : yrotangle!=0 ? [yrotangle, BACK]\n          : zrotangle!=0 ? [zrotangle, UP]\n          : [undef,CENTER],\n        absangle = abs_angle_axis[0],\n        absaxis = abs_angle_axis[1],\n        // Computes the extra shift and center with absolute rotation\n        Trot = _rotpart(lastT),  \n        shift = _transpart(lastT), \n        v = apply(Trot,RIGHT),           // Current direction\n        projv = v - (absaxis*v)*absaxis, // Component of rotation axis orthogonal to v\n        abscenter = is_undef(absangle) ? undef : sign(absangle) * radius * cross(absaxis,projv),    // absangle might be undef if command is \"move\"\n        slope = absaxis*v / norm(projv),       // This computes the shift in the direction along the rotational axis\n        vshift = is_undef(absangle) ? undef : absaxis*slope* 2*PI*radius*absangle/360\n    )\n    // At this point angle is nonzero if and only if a relative angle command (left, right, up down) was given,\n    //               absangle is defined if and only if an absolute angle command was given\n    assert(is_undef(absangle) || absangle!=0, str(\"Arc rotation with zero angle at index \",index))\n    assert(angle==0 || is_undef(absangle), str(\"Mixed relative and absolute rotations at index \",index))\n    assert(is_int(usersteps) && usersteps>=0 && (command[0]==\"arc\" || usersteps>=1),\n           str(\"Steps value \",usersteps,\" invalid at index \",index))\n    assert(is_undef(absangle) || !all_zero(projv), str(\"Rotation acts as twist, which does not produce a valid arc at index \",index))\n    let( \n        steps = usersteps != 0 ? usersteps\n              : arcsteps != 0 ? arcsteps\n              : ceil(segs(abs(radius)) * abs(first_defined([absangle,angle]))/360),\n        // The next line computes a list of pairs [trans,pretrans] for the segment or arc\n        result =  is_undef(absangle)\n                  ? [for(n=[1:1:steps]) let(frac=n/steps)\n                              [lastT * flip * right(frac*move) * (angle==0?ident(4):rot(frac*angle,v=relaxis,cp=center)) * xrot(frac*roll),\n                               lastPre * zrot(frac*twist) * scale(lerp([1,1,1],scaling,frac))]\n                    ]\n                  : [for(n=[1:1:steps]) let(frac=n/steps) \n                              [move(shift+vshift*frac) * rot(frac*absangle,v=absaxis,cp=abscenter)*Trot * xrot(frac*roll),\n                               lastPre * zrot(frac*twist) * scale(lerp([1,1,1],scaling,frac))]\n                    ]\n    )                     // Transpose converts the result into a list of the form [[trans1,trans2,...],[pretran1,pretran2,...]],\n    transpose(result);    // which is required by _tupdate\n\n\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-48", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: utility.scad\n//   Functions for type checking, handling undefs, processing function arguments,\n//   and testing. \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Data Management\n// FileSummary: Type checking, dealing with undefs, processing function args\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n\n// Section: Type Checking\n\n\n// Function: typeof()\n// Synopsis: Returns a string representing the type of the value.\n// Topics: Type Checking\n// See Also: is_type()\n// Usage:\n//   typ = typeof(x);\n// Description:\n//   Returns a string representing the type of the value.  One of \"undef\", \"boolean\", \"number\", \"nan\", \"string\", \"list\", \"range\", \"function\" or \"invalid\".\n//   Some malformed \"ranges\", like '[0:NAN:INF]' and '[0:\"a\":INF]', may be classified as \"undef\" or \"invalid\".\n// Arguments:\n//   x = value whose type to check\n// Example:\n//   typ = typeof(undef);  // Returns: \"undef\"\n//   typ = typeof(true);  // Returns: \"boolean\"\n//   typ = typeof(42);  // Returns: \"number\"\n//   typ = typeof(NAN);  // Returns: \"nan\"\n//   typ = typeof(\"foo\");  // Returns: \"string\"\n//   typ = typeof([3,4,5]);  // Returns: \"list\"\n//   typ = typeof([3:1:8]);  // Returns: \"range\"\n//   typ = typeof(function (x,y) x+y);  // Returns: \"function\"\nfunction typeof(x) =\n    is_undef(x)? \"undef\" :\n    is_bool(x)? \"boolean\" :\n    is_num(x)? \"number\" :\n    is_nan(x)? \"nan\" :\n    is_string(x)? \"string\" :\n    is_list(x)? \"list\" :\n    is_range(x) ? \"range\" :\n    version_num()>20210000 && is_function(x) ? \"function\" :\n    \"invalid\";\n\n\n// Function: is_type()\n// Synopsis: Returns true if the type of 'x' is one of those in the list `types`.\n// Topics: Type Checking\n// See Also: typeof()\n// Usage:\n//   bool = is_type(x, types);\n// Description:\n//   Returns true if the type of the value `x` is one of those given as strings in the list `types`. \n//   Valid types are \"undef\", \"boolean\", \"number\", \"nan\", \"string\", \"list\", \"range\", or \"function\".\n// Arguments:\n//   x = The value to check the type of.\n//   types = A list of types to check \n// Example:\n//   is_str_or_list = is_type(\"foo\", [\"string\",\"list\"]);   // Returns: true\n//   is_str_or_list2 = is_type([1,2,3], [\"string\",\"list\"]);  // Returns: true\n//   is_str_or_list3 = is_type(2, [\"string\",\"list\"]);  // Returns: false\n//   is_str = is_type(\"foo\", \"string\");  // Returns: true\n//   is_str2 = is_type([3,4], \"string\");  // Returns: false\n//   is_str3 = is_type([\"foo\"], \"string\");  // Returns: false\n//   is_str4 = is_type(3, \"string\");  // Returns: false\nfunction is_type(x,types) =\n    is_list(types)? in_list(typeof(x),types) :\n    is_string(types)? typeof(x) == types :\n    assert(is_list(types)||is_string(types));\n\n\n// Function: is_def()\n// Synopsis: Returns true if `x` is not `undef`.\n// Topics: Type Checking\n// See Also: typeof(), is_type(), is_str()\n// Usage:\n//   bool = is_def(x);\n// Description:\n//   Returns true if `x` is not `undef`.  False if `x==undef`.\n// Arguments:\n//   x = value to check\n// Example:\n//   bool = is_def(undef);  // Returns: false\n//   bool = is_def(false);  // Returns: true\n//   bool = is_def(42);     // Returns: true\n//   bool = is_def(\"foo\");  // Returns: true\nfunction is_def(x) = !is_undef(x);\n\n\n// Function: is_str()\n// Synopsis: Returns true if the argument is a string.\n// Topics: Type Checking\n// See Also: typeof(), is_type(), is_int(), is_def(), is_int()\n// Usage:\n//   bool = is_str(x);\n// Description:\n//   Returns true if `x` is a string.  A shortcut for `is_string()`.\n// Arguments:\n//   x = value to check\n// Example:\n//   bool = is_str(undef);  // Returns: false\n//   bool = is_str(false);  // Returns: false\n//   bool = is_str(42);     // Returns: false\n//   bool = is_str(\"foo\");  // Returns: true\nfunction is_str(x) = is_string(x);\n\n\n// Function: is_int()\n// Alias: is_integer()\n// Synopsis: Returns true if the argument is an integer.\n// Topics: Type Checking\n// See Also: typeof(), is_type(), is_str(), is_def()\n// Usage:\n//   bool = is_int(n);\n//   bool = is_integer(n);\n// Description:\n//   Returns true if the given value is an integer (it is a number and it rounds to itself).  \n// Arguments:\n//   n = value to check\n// Example:\n//   bool = is_int(undef);  // Returns: false\n//   bool = is_int(false);  // Returns: false\n//   bool = is_int(42);     // Returns: true\n//   bool = is_int(\"foo\");  // Returns: false\nfunction is_int(n) = is_finite(n) && n == round(n);\nfunction is_integer(n) = is_finite(n) && n == round(n);\n\n\n// Function: all_integer()\n// Synopsis: Returns true if all of the numbers in the argument are integers.\n// Topics: Type Checking\n// See also: is_int(), typeof(), is_type()\n// Usage:\n//   bool = all_integer(x);\n// Description:\n//   If given a number, returns true if the number is a finite integer.\n//   If given an empty list, returns false.  If given a non-empty list, returns\n//   true if every item of the list is an integer.  Otherwise, returns false.\n// Arguments:\n//   x = The value to check.\n// Example:\n//   b = all_integer(true);  // Returns: false\n//   b = all_integer(\"foo\"); // Returns: false\n//   b = all_integer(4);     // Returns: true\n//   b = all_integer(4.5);   // Returns: false\n//   b = all_integer([]);    // Returns: false\n//   b = all_integer([3,4,5]);   // Returns: true\n//   b = all_integer([3,4.2,5]); // Returns: false\n//   b = all_integer([3,[4,7],5]); // Returns: false\nfunction all_integer(x) =\n    is_num(x)? is_int(x) :\n    is_list(x)? (x != [] && [for (xx=x) if(!is_int(xx)) 1] == []) :\n    false;\n\n\n// Function: is_nan()\n// Synopsis: Return true if the argument is \"not a number\".\n// Topics: Type Checking\n// See Also: typeof(), is_type(), is_str(), is_def(), is_int(), is_finite()\n// Usage:\n//   bool = is_nan(x);\n// Description:\n//   Returns true if a given value `x` is nan, a floating point value representing \"not a number\".\n// Arguments:\n//   x = value to check\n// Example:\n//   bool = is_nan(undef);  // Returns: false\n//   bool = is_nan(false);  // Returns: false\n//   bool = is_nan(42);     // Returns: false\n//   bool = is_nan(\"foo\");  // Returns: false\n//   bool = is_nan(NAN);    // Returns: true\nfunction is_nan(x) = (x!=x);\n\n\n// Function: is_finite()\n// Synopsis: Returns true if the argument is a finite number.\n// Topics: Type Checking\n// See Also: typeof(), is_type(), is_str(), is_def(), is_int(), is_nan()\n// Usage:\n//   bool = is_finite(x);\n// Description:\n//   Returns true if a given value `x` is a finite number.\n// Arguments:\n//   x = value to check\n// Example:\n//   bool = is_finite(undef);  // Returns: false\n//   bool = is_finite(false);  // Returns: false\n//   bool = is_finite(42);     // Returns: true\n//   bool = is_finite(\"foo\");  // Returns: false\n//   bool = is_finite(NAN);    // Returns: false\n//   bool = is_finite(INF);    // Returns: false\n//   bool = is_finite(-INF);   // Returns: false\nfunction is_finite(x) = is_num(x) && !is_nan(0*x);\n\n\n// Function: is_range()\n// Synopsis: Returns true if the argument is a range.\n// Topics: Type Checking\n// See Also: typeof(), is_type(), is_str(), is_def(), is_int()\n// Usage:\n//   bool = is_range(x);\n// Description:\n//   Returns true if its argument is a range\n// Arguments:\n//   x = value to check\n// Example:\n//   bool = is_range(undef);   // Returns: false\n//   bool = is_range(false);   // Returns: false\n//   bool = is_range(42);      // Returns: false\n//   bool = is_range([3,4,5]); // Returns: false\n//   bool = is_range(\"foo\");   // Returns: false\n//   bool = is_range([3:5]);   // Returns: true\nfunction is_range(x) = !is_list(x) && is_finite(x[0]) && is_finite(x[1]) && is_finite(x[2]) ;\n\n\n// Function: valid_range()\n// Synopsis: Returns true if the argument is a valid range.\n// Topics: Type Checking\n// See Also: typeof(), is_type(), is_str(), is_def(), is_int(), is_range()\n// Usage:\n//   bool = valid_range(x);\n// Description:\n//   Returns true if its argument is a valid range (deprecated ranges excluded).\n// Arguments:\n//   x = value to check\n// Example:\n//   bool = is_range(undef);   // Returns: false\n//   bool = is_range(false);   // Returns: false\n//   bool = is_range(42);      // Returns: false\n//   bool = is_range([3,4,5]); // Returns: false\n//   bool = is_range(\"foo\");   // Returns: false\n//   bool = is_range([3:5]);   // Returns: true\n//   bool = is_range([3:1]);   // Returns: false\nfunction valid_range(x) = \n    is_range(x) \n    && ( x[1]>0 \n         ? x[0]<=x[2]\n         : ( x[1]<0 && x[0]>=x[2] ) );\n\n\n// Function: is_func()\n// Synopsis: Returns true if the argument is a function literal.\n// Topics: Type Checking, Function Literals\n// See also: is_type(), typeof()\n// Usage:\n//   bool = is_func(x);\n// Description:\n//   Returns true if OpenSCAD supports function literals, and the given item is one.\n// Arguments:\n//   x = The value to check\n// Example:\n//   f = function (a) a==2;\n//   bool = is_func(f);  // Returns: true\nfunction is_func(x) = version_num()>20210000 && is_function(x);\n\n\n// Function: is_consistent()\n// Synopsis: Returns true if the argument is a list with consistent structure and finite numerical data.\n// Topics: Type Checking, Testing\n// See Also: typeof(), is_type(), is_str(), is_def(), is_int(), is_range(), is_homogeneous()\n// Usage:\n//   bool = is_consistent(list, [pattern]);\n// Description:\n//   Tests whether input is a list of entries which all have the same list structure\n//   and are filled with finite numerical data.  You can optionally specify a required \n//   list structure with the pattern argument.  \n//   It returns `true` for the empty list regardless the value of the `pattern`.\n// Arguments:\n//   list = list to check\n//   pattern = optional pattern required to match\n// Example:\n//   is_consistent([3,4,5]);              // Returns true\n//   is_consistent([[3,4],[4,5],[6,7]]);  // Returns true\n//   is_consistent([[3,4,5],[3,4]]);      // Returns false\n//   is_consistent([[3,[3,4,[5]]], [5,[2,9,[9]]]]); // Returns true\n//   is_consistent([[3,[3,4,[5]]], [5,[2,9,9]]]);   // Returns false\n//   is_consistent([3,4,5], 0);            // Returns true\n//   is_consistent([3,4,undef], 0);        // Returns false\n//   is_consistent([[3,4],[4,5]], [1,1]);  // Returns true\n//   is_consistent([[3,\"a\"],[4,true]], [1,undef]);  // Returns true\n//   is_consistent([[3,4], 6, [4,5]], [1,1]);  // Returns false\n//   is_consistent([[1,[3,4]], [4,[5,6]]], [1,[2,3]]);    // Returns true\n//   is_consistent([[1,[3,INF]], [4,[5,6]]], [1,[2,3]]);  // Returns false\n//   is_consistent([], [1,[2,3]]);                        // Returns true\nfunction is_consistent(list, pattern) =\n    is_list(list) \n    && (len(list)==0 \n       || (let(pattern = is_undef(pattern) ? _list_pattern(list[0]): _list_pattern(pattern) )\n          []==[for(entry=0*list) if (entry != pattern) entry]));\n\n//Internal function\n//Creates a list with the same structure of `list` with each of its elements replaced by 0.\nfunction _list_pattern(list) =\n  is_list(list) \n  ? [for(entry=list) is_list(entry) ? _list_pattern(entry) : 0]\n  : 0;\n\n\n// Function: same_shape()\n// Synopsis: Returns true if the argument lists are numeric and of the same shape.\n// Topics: Type Checking, Testing\n// See Also: is_homogeneous(), is_consistent()\n// Usage:\n//   bool = same_shape(a,b);\n// Description:\n//   Tests whether the inputs `a` and `b` are both numeric and are the same shaped list.\n// Example:\n//   same_shape([3,[4,5]],[7,[3,4]]);   // Returns true\n//   same_shape([3,4,5], [7,[3,4]]);    // Returns false\nfunction same_shape(a,b) = is_def(b) && _list_pattern(a) == b*0;\n\n\n// Function: is_bool_list()\n// Synopsis: Returns true if the argument list contains only booleans.\n// Topics: Boolean Testing\n// See Also: is_homogeneous(), is_consistent()\n// Usage:\n//   check = is_bool_list(list,[length])\n// Description:\n//   Tests whether input is a list containing only booleans, and optionally checks its length.\n// Arguments:\n//   list = list to test\n//   length = if given, list must be this length\nfunction is_bool_list(list, length) =\n     is_list(list) && (is_undef(length) || len(list)==length) && []==[for(entry=list) if (!is_bool(entry)) 1];\n\n\n// Section: Boolean list testing\n\n// Function: any()\n// Synopsis: Returns true if any item in the argument list is true.\n// Topics: Type Checking\n// See Also: all(), num_true()\n// Usage:\n//   bool = any(l);\n//   bool = any(l, func);   // Requires OpenSCAD 2021.01 or later.\n// Requirements:\n//   Requires OpenSCAD 2021.01 or later to use the `func` argument.\n// Description:\n//   Returns true if any item in list `l` evaluates as true.\n//   If `func` is given then returns true if the function evaluates as true on any list entry. \n//   Items that evaluate as true include nonempty lists, nonempty strings, and nonzero numbers.\n// Arguments:\n//   l = The list to test for true items.\n//   func = An optional function literal of signature (x), returning bool, to test each list item with.\n// Example:\n//   any([0,false,undef]);  // Returns false.\n//   any([1,false,undef]);  // Returns true.\n//   any([1,5,true]);       // Returns true.\n//   any([[0,0], [0,0]]);   // Returns true.\n//   any([[0,0], [1,0]]);   // Returns true.\nfunction any(l, func) =\n    assert(is_list(l), \"The input is not a list.\" )\n    assert(func==undef || is_func(func))\n    is_func(func)\n      ? _any_func(l, func)\n      : _any_bool(l);\n\nfunction _any_func(l, func, i=0, out=false) =\n    i >= len(l) || out? out :\n    _any_func(l, func, i=i+1, out=out || func(l[i]));\n\nfunction _any_bool(l, i=0, out=false) =\n    i >= len(l) || out? out :\n    _any_bool(l, i=i+1, out=out || l[i]);\n\n\n// Function: all()\n// Synopsis: Returns true if all items in the argument list are true.\n// Topics: Type Checking\n// See Also: any(), num_true()\n// Usage:\n//   bool = all(l);\n//   bool = all(l, func);   // Requires OpenSCAD 2021.01 or later.\n// Requirements:\n//   Requires OpenSCAD 2021.01 or later to use the `func` argument.\n// Description:\n//   Returns true if all items in list `l` evaluate as true.\n//   If `func` is given then returns true if the function evaluates as true on all list etnries. \n//   Items that evaluate as true include nonempty lists, nonempty strings, and nonzero numbers.\n// Arguments:\n//   l = The list to test for true items.\n//   func = An optional function literal of signature (x), returning bool, to test each list item with.\n// Example:\n//   test1 = all([0,false,undef]);  // Returns false.\n//   test2 = all([1,false,undef]);  // Returns false.\n//   test3 = all([1,5,true]);       // Returns true.\n//   test4 = all([[0,0], [0,0]]);   // Returns true.\n//   test5 = all([[0,0], [1,0]]);   // Returns true.\n//   test6 = all([[1,1], [1,1]]);   // Returns true.\nfunction all(l, func) =\n    assert(is_list(l), \"The input is not a list.\")\n    assert(func==undef || is_func(func))\n    is_func(func)\n      ? _all_func(l, func)\n      : _all_bool(l);\n\nfunction _all_func(l, func, i=0, out=true) =\n    i >= len(l) || !out? out :\n    _all_func(l, func, i=i+1, out=out && func(l[i]));\n\nfunction _all_bool(l, i=0, out=true) =\n    i >= len(l) || !out? out :\n    _all_bool(l, i=i+1, out=out && l[i]);\n\n\n// Function: num_true()\n// Synopsis: Returns the number of true entries in the arguemnt list.\n// Topics: Boolean Testing\n// See Also: any(), all()\n// Usage:\n//   seq = num_true(l);\n//   seq = num_true(l, func);  // Requires OpenSCAD 2021.01 or later.\n// Requirements:\n//   Requires OpenSCAD 2021.01 or later to use the `func=` argument.\n// Description:\n//   Returns the number of items in `l` that evaluate as true.  If `func` is given then counts\n//   list entries where the function evaluates as true.  \n//   Items that evaluate as true include nonempty lists, nonempty strings, and nonzero numbers.\n// Arguments:\n//   l = The list to test for true items.\n//   func = An optional function literal of signature (x), returning bool, to test each list item with.\n// Example:\n//   num1 = num_true([0,false,undef]);  // Returns 0.\n//   num2 = num_true([1,false,undef]);  // Returns 1.\n//   num3 = num_true([1,5,false]);      // Returns 2.\n//   num4 = num_true([1,5,true]);       // Returns 3.\n//   num5 = num_true([[0,0], [0,0]]);   // Returns 2.\n//   num6 = num_true([[], [1,0]]);      // Returns 1.\nfunction num_true(l, func) = \n    assert(is_list(l))\n    assert(func==undef || is_func(func))\n    let(\n        true_list = is_def(func)? [for(entry=l) if (func(entry)) 1]\n                                : [for(entry=l) if (entry) 1]\n    )\n    len(true_list);\n\n\n\n// Section: Handling `undef`s.\n\n\n// Function: default()\n// Synopsis: Returns a default value if the argument is 'undef', else returns the argument.\n// Topics: Undef Handling\n// See Also: first_defined(), one_defined(), num_defined()\n// Usage:\n//   val = default(val, dflt);\n// Description:\n//   Returns the value given as `v` if it is not `undef`.\n//   Otherwise, returns the value of `dflt`.\n// Arguments:\n//   v = Value to pass through if not `undef`.\n//   dflt = Value to return if `v` *is* `undef`.  Default: undef\nfunction default(v,dflt=undef) = is_undef(v)? dflt : v;\n\n\n// Function: first_defined()\n// Synopsis: Returns the first value in the argument list that is not 'undef'.\n// Topics: Undef Handling\n// See Also: default(), one_defined(), num_defined(), any_defined(), all_defined()\n// Usage:\n//   val = first_defined(v, [recursive]);\n// Description:\n//   Returns the first item in the list that is not `undef`.\n//   If all items are `undef`, or list is empty, returns `undef`.\n// Arguments:\n//   v = The list whose items are being checked.\n//   recursive = If true, sublists are checked recursively for defined values.  The first sublist that has a defined item is returned.  Default: false\n// Example:\n//   val = first_defined([undef,7,undef,true]);  // Returns: 7\nfunction first_defined(v,recursive=false,_i=0) =\n    _i<len(v) && (\n        is_undef(v[_i]) || (\n            recursive &&\n            is_list(v[_i]) &&\n            is_undef(first_defined(v[_i],recursive=recursive))\n        )\n    )? first_defined(v,recursive=recursive,_i=_i+1) : v[_i];\n    \n\n// Function: one_defined()\n// Synopsis: Returns the defined value in the argument list if only a single value is defined.\n// Topics: Undef Handling\n// See Also: default(), first_defined(), num_defined(), any_defined(), all_defined()\n// Usage:\n//   val = one_defined(vals, names, [dflt])\n// Description:\n//   Examines the input list `vals` and returns the entry which is not `undef`.\n//   If more than one entry is not `undef` then an error is asserted, specifying\n//   \"Must define exactly one of\" followed by the names in the `names` parameter.\n//   If `dflt` is given, and all `vals` are `undef`, then the value in `dflt` is returned.\n//   If `dflt` is *not* given, and all `vals` are `undef`, then an error is asserted.\n// Arguments:\n//   vals = The values to return the first one which is not `undef`.\n//   names = A string with comma-separated names for the arguments whose values are passed in `vals`.\n//   dflt = If given, the value returned if all `vals` are `undef`.\n// Example:\n//   length1 = one_defined([length,L,l], [\"length\",\"L\",\"l\"]);\n//   length2 = one_defined([length,L,l], \"length,L,l\", dflt=1);\n\nfunction one_defined(vals, names, dflt=_UNDEF) = \n    let(\n        checkargs = is_list(names)? assert(len(vals) == len(names)) :\n            is_string(names)? let(\n                name_cnt = len([for (c=names) if (c==\",\") 1]) + 1\n            ) assert(len(vals) == name_cnt) :\n            assert(is_list(names) || is_string(names)) 0,\n        ok = num_defined(vals)==1 || (dflt!=_UNDEF && num_defined(vals)==0)\n    ) ok? default(first_defined(vals), dflt) :\n    let(\n        names = is_string(names) ? str_split(names,\",\") : names,\n        defd = [for (i=idx(vals)) if (is_def(vals[i])) names[i]],\n        msg = str(\n            \"Must define \",\n            dflt==_UNDEF? \"exactly\" : \"at most\",\n            \" one of \",\n            num_defined(vals) == 0 ? names : defd\n        )\n    ) assert(ok,msg);\n\n\n// Function: num_defined()\n// Synopsis: Returns the number of defined values in the the argument list.\n// Topics: Undef Handling\n// See Also: default(), first_defined(), one_defined(), any_defined(), all_defined()\n// Usage:\n//   cnt = num_defined(v);\n// Description:\n//   Counts how many items in list `v` are not `undef`.\n// Example:\n//   cnt = num_defined([3,7,undef,2,undef,undef,1]);  // Returns: 4\nfunction num_defined(v) =\n    len([for(vi=v) if(!is_undef(vi)) 1]);\n\n\n// Function: any_defined()\n// Synopsis: Returns true if any item in the argument list is not `undef`.\n// Topics: Undef Handling\n// See Also: default(), first_defined(), one_defined(), num_defined(), all_defined()\n// Usage:\n//   bool = any_defined(v, [recursive]);\n// Description:\n//   Returns true if any item in the given array is not `undef`.\n// Arguments:\n//   v = The list whose items are being checked.\n//   recursive = If true, any sublists are evaluated recursively.  Default: false\n// Example:\n//   bool = any_defined([undef,undef,undef]);    // Returns: false\n//   bool = any_defined([undef,42,undef]);       // Returns: true\n//   bool = any_defined([34,42,87]);             // Returns: true\n//   bool = any_defined([undef,undef,[undef]]);  // Returns: true\n//   bool = any_defined([undef,undef,[undef]],recursive=true);  // Returns: false\n//   bool = any_defined([undef,undef,[42]],recursive=true);     // Returns: true\nfunction any_defined(v,recursive=false) =\n    first_defined(v,recursive=recursive) != undef;\n\n\n// Function: all_defined()\n// Synopsis: Returns true if all items in the given array are defined.\n// Topics: Undef Handling\n// See Also: default(), first_defined(), one_defined(), num_defined(), all_defined()\n// Usage:\n//   bool = all_defined(v, [recursive]);\n// Description:\n//   Returns true if all items in the given array are not `undef`.\n// Arguments:\n//   v = The list whose items are being checked.\n//   recursive = If true, any sublists are evaluated recursively.  Default: false\n// Example:\n//   bool = all_defined([undef,undef,undef]);    // Returns: false\n//   bool = all_defined([undef,42,undef]);       // Returns: false\n//   bool = all_defined([34,42,87]);             // Returns: true\n//   bool = all_defined([23,34,[undef]]);        // Returns: true\n//   bool = all_defined([23,34,[undef]],recursive=true);  // Returns: false\n//   bool = all_defined([23,34,[42]],recursive=true);     // Returns: true\nfunction all_defined(v,recursive=false) = \n    []==[for (x=v) if(is_undef(x)||(recursive && is_list(x) && !all_defined(x,recursive))) 0 ];\n\n\n\n// Section: Undef Safe Arithmetic\n\n// Function: u_add()\n// Synopsis: Returns the sum of 2 numbers if both are defined, otherwise returns undef.\n// Topics: Undef Handling\n// See Also: u_sub(), u_mul(), u_div()\n// Usage:\n//   x = u_add(a, b);\n// Description:\n//   Adds `a` to `b`, returning the result, or undef if either value is `undef`.\n//   This emulates the way undefs used to be handled in versions of OpenSCAD before 2020.\n// Arguments:\n//   a = First value.\n//   b = Second value.\nfunction u_add(a,b) = is_undef(a) || is_undef(b)? undef : a + b;\n\n\n// Function: u_sub()\n// Synopsis: Returns the difference of 2 numbers if both are defined, otherwise returns undef.\n// Topics: Undef Handling\n// See Also: u_add(), u_mul(), u_div()\n// Usage:\n//   x = u_sub(a, b);\n// Description:\n//   Subtracts `b` from `a`, returning the result, or undef if either value is `undef`.\n//   This emulates the way undefs used to be handled in versions of OpenSCAD before 2020.\n// Arguments:\n//   a = First value.\n//   b = Second value.\nfunction u_sub(a,b) = is_undef(a) || is_undef(b)? undef : a - b;\n\n\n// Function: u_mul()\n// Synopsis: Returns the product of 2 numbers if both are defined, otherwise returns undef.\n// Topics: Undef Handling\n// See Also: u_add(), u_sub(), u_div()\n// Usage:\n//   x = u_mul(a, b);\n// Description:\n//   Multiplies `a` by `b`, returning the result, or undef if either value is `undef`.\n//   This emulates the way undefs used to be handled in versions of OpenSCAD before 2020.\n// Arguments:\n//   a = First value.\n//   b = Second value.\nfunction u_mul(a,b) =\n    is_undef(a) || is_undef(b)? undef :\n    is_vector(a) && is_vector(b)? v_mul(a,b) :\n    a * b;\n\n\n// Function: u_div()\n// Synopsis: Returns the quotient of 2 numbers if both are defined, otherwise returns undef.\n// Topics: Undef Handling\n// See Also: u_add(), u_sub(), u_mul()\n// Usage:\n//   x = u_div(a, b);\n// Description:\n//   Divides `a` by `b`, returning the result, or undef if either value is `undef`.\n//   This emulates the way undefs used to be handled in versions of OpenSCAD before 2020.\n// Arguments:\n//   a = First value.\n//   b = Second value.\nfunction u_div(a,b) =\n    is_undef(a) || is_undef(b)? undef :\n    is_vector(a) && is_vector(b)? v_div(a,b) :\n    a / b;\n\n\n\n\n// Section: Processing Arguments to Functions and Modules\n\n\n// Function: get_anchor()\n// Synopsis: Returns the correct anchor from `anchor` and `center`.\n// Topics: Argument Handling\n// See Also: get_radius()\n// Usage:\n//   anchr = get_anchor(anchor,center,[uncentered],[dflt]);\n// Description:\n//   Calculated the correct anchor from `anchor` and `center`.  In order:\n//   - If `center` is not `undef` and `center` evaluates as true, then `CENTER` (`[0,0,0]`) is returned.\n//   - Otherwise, if `center` is not `undef` and `center` evaluates as false, then the value of `uncentered` is returned.\n//   - Otherwise, if `anchor` is not `undef`, then the value of `anchor` is returned.\n//   - Otherwise, the value of `dflt` is returned.\n//   .\n//   This ordering ensures that `center` will override `anchor`.\n// Arguments:\n//   anchor = The anchor name or vector.\n//   center = If not `undef`, this overrides the value of `anchor`.\n//   uncentered = The value to return if `center` is not `undef` and evaluates as false.  Default: BOTTOM\n//   dflt = The default value to return if both `anchor` and `center` are `undef`.  Default: `CENTER`\n// Example:\n//   anchr1 = get_anchor(undef, undef, BOTTOM, TOP);  // Returns: [0, 0, 1] (TOP)\n//   anchr2 = get_anchor(RIGHT, undef, BOTTOM, TOP);  // Returns: [1, 0, 0] (RIGHT)\n//   anchr3 = get_anchor(undef, false, BOTTOM, TOP);  // Returns: [0, 0,-1] (BOTTOM)\n//   anchr4 = get_anchor(RIGHT, false, BOTTOM, TOP);  // Returns: [0, 0,-1] (BOTTOM)\n//   anchr5 = get_anchor(undef, true,  BOTTOM, TOP);  // Returns: [0, 0, 0] (CENTER)\n//   anchr6 = get_anchor(RIGHT, true,  BOTTOM, TOP);  // Returns: [0, 0, 0] (CENTER)\nfunction get_anchor(anchor,center,uncentered=BOT,dflt=CENTER) =\n    !is_undef(center)? (center? CENTER : uncentered) :\n    !is_undef(anchor)? anchor :\n    dflt;\n\n\n// Function: get_radius()\n// Synopsis: Given various radii and diameters, returns the most specific radius.\n// Topics: Argument Handling\n// See Also: get_anchor()\n// Usage:\n//   r = get_radius([r1=], [r2=], [r=], [d1=], [d2=], [d=], [dflt=]);\n// Description:\n//   Given various radii and diameters, returns the most specific radius.  If a diameter is most\n//   specific, returns half its value, giving the radius.  If no radii or diameters are defined,\n//   returns the value of `dflt`.  Value specificity order is `r1`, `r2`, `d1`, `d2`, `r`, `d`,\n//   then `dflt`.  Only one of `r1`, `r2`, `d1`, or `d2` can be defined at once, or else it errors\n//   out, complaining about conflicting radius/diameter values.  \n// Arguments:\n//   ---\n//   r1 = Most specific radius.\n//   r2 = Second most specific radius.\n//   r = Most general radius.\n//   d1 = Most specific diameter.\n//   d2 = Second most specific diameter.\n//   d = Most general diameter.\n//   dflt = Value to return if all other values given are `undef`.\n// Example:\n//   r = get_radius(r1=undef, r=undef, dflt=undef);  // Returns: undef\n//   r = get_radius(r1=undef, r=undef, dflt=1);      // Returns: 1\n//   r = get_radius(r1=undef, r=6, dflt=1);          // Returns: 6\n//   r = get_radius(r1=7, r=6, dflt=1);              // Returns: 7\n//   r = get_radius(r1=undef, r2=8, r=6, dflt=1);    // Returns: 8\n//   r = get_radius(r1=undef, r2=8, d=6, dflt=1);    // Returns: 8\n//   r = get_radius(r1=undef, d=6, dflt=1);          // Returns: 3\n//   r = get_radius(d1=7, d=6, dflt=1);              // Returns: 3.5\n//   r = get_radius(d1=7, d2=8, d=6, dflt=1);        // Returns: 3.5\n//   r = get_radius(d1=undef, d2=8, d=6, dflt=1);    // Returns: 4\n//   r = get_radius(r1=8, d=6, dflt=1);              // Returns: 8\nfunction get_radius(r1, r2, r, d1, d2, d, dflt) = \n    assert(num_defined([r1,d1,r2,d2])<2, \"Conflicting or redundant radius/diameter arguments given.\")\n    assert(num_defined([r,d])<2, \"Conflicting or redundant radius/diameter arguments given.\")\n    let(\n        rad = !is_undef(r1) ?  r1 \n            : !is_undef(d1) ?  d1/2\n            : !is_undef(r2) ?  r2\n            : !is_undef(d2) ?  d2/2\n            : !is_undef(r)  ?  r\n            : !is_undef(d)  ?  d/2\n            : dflt\n    )\n    assert(is_undef(dflt) || is_finite(rad) || is_vector(rad), \"Invalid radius.\" )\n    rad;\n\n\n// Function: scalar_vec3()\n// Synopsis: Expands a scalar or a list with length less than 3 to a length 3 vector. \n// Topics: Argument Handling\n// See Also: get_anchor(), get_radius(), force_list()\n// Usage:\n//   vec = scalar_vec3(v, [dflt]);\n// Description:\n//   This is expands a scalar or a list with length less than 3 to a length 3 vector in the\n//   same way that OpenSCAD expands short vectors in some contexts, e.g. cube(10) or rotate([45,90]).  \n//   If `v` is a scalar, and `dflt==undef`, returns `[v, v, v]`.\n//   If `v` is a scalar, and `dflt!=undef`, returns `[v, dflt, dflt]`.\n//   If `v` is a vector and dflt is defined, returns the first 3 items, with any missing values replaced by `dflt`.\n//   If `v` is a vector and dflt is undef, returns the first 3 items, with any missing values replaced by 0.\n//   If `v` is `undef`, returns `undef`.\n// Arguments:\n//   v = Value to return vector from.\n//   dflt = Default value to set empty vector parts from.\n// Example:\n//   vec = scalar_vec3(undef);      // Returns: undef\n//   vec = scalar_vec3(10);         // Returns: [10,10,10]\n//   vec = scalar_vec3(10,1);       // Returns: [10,1,1]\n//   vec = scalar_vec3([10,10],1);  // Returns: [10,10,1]\n//   vec = scalar_vec3([10,10]);    // Returns: [10,10,0]\n//   vec = scalar_vec3([10]);       // Returns: [10,0,0]\nfunction scalar_vec3(v, dflt) =\n    is_undef(v)? undef :\n    is_list(v)? [for (i=[0:2]) default(v[i], default(dflt, 0))] :\n    !is_undef(dflt)? [v,dflt,dflt] : [v,v,v];\n\n// Function: segs()\n// Synopsis: Returns the number of sides for a circle given `$fn`, `$fa`, and `$fs`.\n// Topics: Geometry\n// See Also: circle(), cyl()\n// Usage:\n//   sides = segs(r);\n// Description:\n//   Calculate the standard number of sides OpenSCAD would give a circle based on `$fn`, `$fa`, and `$fs`.\n// Arguments:\n//   r = Radius of circle to get the number of segments for.\n// Example:\n//   $fn=12; sides=segs(10);  // Returns: 12\n//   $fa=2; $fs=3; sides=segs(10);  // Returns: 21\nfunction segs(r) = \n    $fn>0? ($fn>3? $fn : 3) :\n    let( r = is_finite(r)? r : 0 )\n    ceil(max(5, min(360/$fa, abs(r)*2*PI/$fs)));\n\n\n// Module: no_children()\n// Synopsis: Assert that the calling module does not support children.\n// Topics: Error Checking\n// See Also: no_function(), no_module(), req_children()\n// Usage:\n//   no_children($children);\n// Description:\n//   Assert that the calling module does not support children.  Prints an error message to this effect and fails if children are present,\n//   as indicated by its argument.\n// Arguments:\n//   $children = number of children the module has.  \n// Example:\n//   module foo() {\n//       no_children($children);\n//   }\nmodule no_children(count) {\n  assert($children==0, \"Module no_children() does not support child modules\");\n  if ($parent_modules>0) {\n      assert(count==0, str(\"Module \",parent_module(1),\"() does not support child modules\"));\n  }\n}\n\n\n// Module: req_children()\n// Synopsis: Assert that the calling module requires children.\n// Topics: Error Checking\n// See Also: no_function(), no_module()\n// Usage:\n//   req_children($children);\n// Description:\n//   Assert that the calling module requires children.  Prints an error message and fails if no\n//   children are present as indicated by its argument.\n// Arguments:\n//   $children = number of children the module has.  \n// Example:\n//   module foo() {\n//       req_children($children);\n//   }\nmodule req_children(count) {\n  assert($children==0, \"Module no_children() does not support child modules\");\n  if ($parent_modules>0) {\n      assert(count>0, str(\"Module \",parent_module(1),\"() requires children\"));\n  }\n}\n\n\n// Function: no_function()\n// Synopsis: Assert that the argument exists only as a module and not as a function.\n// Topics: Error Checking\n// See Also: no_children(), no_module()\n// Usage:\n//   dummy = no_function(name)\n// Description:\n//   Asserts that the function, \"name\", only exists as a module.\n// Example:\n//   x = no_function(\"foo\");\nfunction no_function(name) =\n   assert(false,str(\"You called \",name,\"() as a function, but it is available only as a module\"));\n\n\n// Module: no_module()\n// Synopsis: Assert that the argument exists only as a function and not as a module.\n// Topics: Error Checking\n// See Also: no_children(), no_function()\n// Usage:\n//   no_module();\n// Description:\n//   Asserts that the called module exists only as a function.\n// Example:\n//   module foo() { no_module(); }\nmodule no_module() {\n    assert(false, str(\"You called \",parent_module(1),\"() as a module but it is available only as a function\"));\n}    \n  \n\n// Module: deprecate()\n// Synopsis: Display a console note that a module is deprecated and suggest a replacement.\n// Topics: Error Checking\n// See Also: no_function(), no_module()\n// Usage:\n//   deprecate(new_name);\n// Description:\n//   Display info that the current module is deprecated and you should switch to a new name\n// Arguments:\n//   new_name = name of the new module that replaces the old one\nmodule deprecate(new_name)\n{\n   echo(str(\"***** Module \",parent_module(1),\"() has been replaced by \",new_name,\"() and will be removed in a future version *****\"));\n}   \n\n\n// Section: Testing Helpers\n\n\nfunction _valstr(x) =\n    is_string(x)? str(\"\\\"\",str_replace_char(x, \"\\\"\", \"\\\\\\\"\"),\"\\\"\") :\n    is_list(x)? str(\"[\",str_join([for (xx=x) _valstr(xx)],\",\"),\"]\") :\n    is_num(x) && x==floor(x)? format_int(x) :\n    is_finite(x)? format_float(x,12) : x;\n\n\n// Module: assert_approx()\n// Synopsis: Assert that a value is approximately what was expected.\n// Topics: Error Checking, Debugging\n// See Also: no_children(), no_function(), no_module(), assert_equal()\n// Usage:\n//   assert_approx(got, expected, [info]);\n// Description:\n//   Tests if the value gotten is what was expected, plus or minus 1e-9.  If not, then\n//   the expected and received values are printed to the console and\n//   an assertion is thrown to stop execution.\n//   Returns false if both 'got' and 'expected' are 'nan'.\n// Arguments:\n//   got = The value actually received.\n//   expected = The value that was expected.\n//   info = Extra info to print out to make the error clearer.\n// Example:\n//   assert_approx(1/3, 0.333333333333333, str(\"number=\",1,\", denom=\",3));\nmodule assert_approx(got, expected, info) {\n    no_children($children);\n    if (!approx(got, expected)) {\n        echo();\n        echo(str(\"EXPECT: \", _valstr(expected)));\n        echo(str(\"GOT   : \", _valstr(got)));\n        if (same_shape(got, expected)) {\n            echo(str(\"DELTA : \", _valstr(got - expected)));\n        }\n        if (is_def(info)) {\n            echo(str(\"INFO  : \", _valstr(info)));\n        }\n        assert(approx(got, expected));\n    }\n}\n\n\n// Module: assert_equal()\n// Synopsis: Assert that a value is expected.\n// See Also: no_children(), no_function(), no_module(), assert_approx()\n// Topics: Error Checking, Debugging\n// Usage:\n//   assert_equal(got, expected, [info]);\n// Description:\n//   Tests if the value gotten is what was expected.  If not, then the expected and received values\n//   are printed to the console and an assertion is thrown to stop execution.\n//   Returns true if both 'got' and 'expected' are 'nan'.\n// Arguments:\n//   got = The value actually received.\n//   expected = The value that was expected.\n//   info = Extra info to print out to make the error clearer.\n// Example:\n//   assert_approx(3*9, 27, str(\"a=\",3,\", b=\",9));\nmodule assert_equal(got, expected, info) {\n    no_children($children);\n    if (got != expected || (is_nan(got) && is_nan(expected))) {\n        echo();\n        echo(str(\"EXPECT: \", _valstr(expected)));\n        echo(str(\"GOT   : \", _valstr(got)));\n        if (same_shape(got, expected)) {\n            echo(str(\"DELTA : \", _valstr(got - expected)));\n        }\n        if (is_def(info)) {\n            echo(str(\"INFO  : \", _valstr(info)));\n        }\n        assert(got == expected);\n    }\n}\n\n\n// Module: shape_compare()\n// Synopsis: Compares two child shapes.\n// SynTags: Geom\n// Topics: Error Checking, Debugging, Testing\n// See Also: assert_approx(), assert_equal()\n// Usage:\n//   shape_compare([eps]) {TEST_SHAPE; EXPECTED_SHAPE;}\n// Description:\n//   Compares two child shapes, returning empty geometry if they are very nearly the same shape and size.\n//   Returns the differential geometry if they are not quite the same shape and size.\n// Arguments:\n//   eps = The surface of the two shapes must be within this size of each other.  Default: 1/1024\n// Example:\n//   $fn=36;\n//   shape_compare() {\n//       sphere(d=100);\n//       rotate_extrude() right_half(planar=true) circle(d=100);\n//   }\nmodule shape_compare(eps=1/1024) {\n    assert($children==2,\"Must give exactly two children\");\n    union() {\n        difference() {\n            children(0);\n            if (eps==0) {\n                children(1);\n            } else {\n                minkowski() {\n                    children(1);\n                    spheroid(r=eps, style=\"octa\");\n                }\n            }\n        }\n        difference() {\n            children(1);\n            if (eps==0) {\n                children(0);\n            } else {\n                minkowski() {\n                    children(0);\n                    spheroid(r=eps, style=\"octa\");\n                }\n            }\n        }\n    }\n}\n\n\n// Section: C-Style For Loop Helpers\n//   You can use a list comprehension with a C-style for loop to iteratively make a calculation.\n//   .\n//   The syntax is: `[for (INIT; CONDITION; NEXT) RETVAL]` where:\n//   - INIT is zero or more `let()` style assignments that are evaluated exactly one time, before the first loop.\n//   - CONDITION is an expression evaluated at the start of each loop.  If true, continues with the loop.\n//   - RETVAL is an expression that returns a list item for each loop.\n//   - NEXT is one or more `let()` style assignments that is evaluated at the end of each loop.\n//   .\n//   Since the INIT phase is only run once, and the CONDITION and RETVAL expressions cannot update\n//   variables, that means that only the NEXT phase can be used for iterative calculations.\n//   Unfortunately, the NEXT phase runs *after* the RETVAL expression, which means that you need\n//   to run the loop one extra time to return the final value.  This tends to make the loop code\n//   look rather ugly.  The `looping()`, `loop_while()` and `loop_done()` functions\n//   can make this somewhat more legible.\n//   .\n//   ```openscad\n//   function flat_sum(l) = [\n//       for (\n//           i = 0,\n//           total = 0,\n//           state = 0;\n//           \n//           looping(state);\n//           \n//           state = loop_while(state, i < len(l)),\n//           total = total +\n//               loop_done(state) ? 0 :\n//               let( x = l[i] )\n//               is_list(x) ? flat_sum(x) : x,\n//           i = i + 1\n//       ) if (loop_done(state)) total;\n//   ].x;\n//   ```\n\n\n// Function: looping()\n// Synopsis: Returns true if the argument indicates the current C-style loop should continue.\n// Topics: Iteration\n// See Also: loop_while(), loop_done()\n// Usage:\n//   bool = looping(state);\n// Description:\n//   Returns true if the `state` value indicates the current loop should continue.  This is useful\n//   when using C-style for loops to iteratively calculate a value.  Used with `loop_while()` and\n//   `loop_done()`.  See [Looping Helpers](section-looping-helpers) for an example.\n// Arguments:\n//   state = The loop state value.\nfunction looping(state) = state < 2;\n\n\n// Function: loop_while()\n// Synopsis: Returns true if both arguments indicate the current C-style loop should continue.\n// Topics: Iteration\n// See Also: looping(), loop_done()\n// Usage:\n//   state = loop_while(state, continue);\n// Description:\n//   Given the current `state`, and a boolean `continue` that indicates if the loop should still be\n//   continuing, returns the updated state value for the the next loop.  This is useful when using\n//   C-style for loops to iteratively calculate a value.  Used with `looping()` and `loop_done()`.\n//   See [Looping Helpers](section-looping-helpers) for an example.\n// Arguments:\n//   state = The loop state value.\n//   continue = A boolean value indicating whether the current loop should progress.\nfunction loop_while(state, continue) =\n    state > 0 ? 2 :\n    continue ? 0 : 1;\n\n\n// Function: loop_done()\n// Synopsis: Returns true if the argument indicates the current C-style loop is finishing.\n// Topics: Iteration\n// See Also: looping(), loop_while()\n// Usage:\n//   bool = loop_done(state);\n// Description:\n//   Returns true if the `state` value indicates the loop is finishing.  This is useful when using\n//   C-style for loops to iteratively calculate a value.  Used with `looping()` and `loop_while()`.\n//   See [Looping Helpers](#5-looping-helpers) for an example.\n// Arguments:\n//   state = The loop state value.\nfunction loop_done(state) = state > 0;\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-49", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: vectors.scad\n//   This file provides some mathematical operations that apply to each\n//   entry in a vector.  It provides normalization and angle computation, and\n//   it provides functions for searching lists of vectors for matches to\n//   a given vector.  \n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Math\n// FileSummary: Vector arithmetic, angle, and searching.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Vector Testing\n\n\n// Function: is_vector()\n// Synopsis: Returns true if the given value is a vector.\n// Topics: Vectors, Math\n// See Also: is_matrix(), is_path(), is_region()\n// Usage:\n//   bool = is_vector(v, [length], [zero=], [all_nonzero=], [eps=]);\n// Description:\n//   Returns true if v is a list of finite numbers.\n// Arguments:\n//   v = The value to test to see if it is a vector.\n//   length = If given, make sure the vector is `length` items long.\n//   ---\n//   zero = If false, require that the `norm()` of the vector is not approximately zero.  If true, require the `norm()` of the vector to be approximately zero.  Default: `undef` (don't check vector `norm()`.)\n//   all_nonzero = If true, requires all elements of the vector to be more than `eps` different from zero.  Default: `false`\n//   eps = The minimum vector length that is considered non-zero.  Default: `EPSILON` (`1e-9`)\n// Example:\n//   is_vector(4);                          // Returns false\n//   is_vector([4,true,false]);             // Returns false\n//   is_vector([3,4,INF,5]);                // Returns false\n//   is_vector([3,4,5,6]);                  // Returns true\n//   is_vector([3,4,undef,5]);              // Returns false\n//   is_vector([3,4,5],3);                  // Returns true\n//   is_vector([3,4,5],4);                  // Returns true\n//   is_vector([]);                         // Returns false\n//   is_vector([0,4,0],3,zero=false);       // Returns true\n//   is_vector([0,0,0],zero=false);         // Returns false\n//   is_vector([0,0,1e-12],zero=false);     // Returns false\n//   is_vector([0,1,0],all_nonzero=false);  // Returns false\n//   is_vector([1,1,1],all_nonzero=false);  // Returns true\n//   is_vector([],zero=false);              // Returns false\nfunction is_vector(v, length, zero, all_nonzero=false, eps=EPSILON) =\n    is_list(v) && len(v)>0 && []==[for(vi=v) if(!is_finite(vi)) 0] \n    && (is_undef(length) || len(v)==length)\n    && (is_undef(zero) || ((norm(v) >= eps) == !zero))\n    && (!all_nonzero || all_nonzero(v)) ;\n\n\n\n// Section: Scalar operations on vectors\n\n// Function: add_scalar()\n// Synopsis: Adds a scalar value to every item in a vector.\n// Topics: Vectors, Math\n// See Also: add_scalar(), v_mul(), v_div()\n// Usage:  \n//   v_new = add_scalar(v, s);\n// Description:\n//   Given a vector and a scalar, returns the vector with the scalar added to each item in it.\n// Arguments:\n//   v = The initial array.\n//   s = A scalar value to add to every item in the array.\n// Example:\n//   a = add_scalar([1,2,3],3);            // Returns: [4,5,6]\nfunction add_scalar(v,s) =\n    assert(is_vector(v), \"Input v must be a vector\")\n    assert(is_finite(s), \"Input s must be a finite scalar\")\n    [for(entry=v) entry+s];\n\n\n// Function: v_mul()\n// Synopsis: Returns the element-wise multiplication of two equal-length vectors.\n// Topics: Vectors, Math\n// See Also: add_scalar(), v_mul(), v_div()\n// Usage:\n//   v3 = v_mul(v1, v2);\n// Description:\n//   Element-wise multiplication.  Multiplies each element of `v1` by the corresponding element of `v2`.\n//   Both `v1` and `v2` must be the same length.  Returns a vector of the products.  Note that\n//   the items in `v1` and `v2` can be anything that OpenSCAD will multiply.  \n// Arguments:\n//   v1 = The first vector.\n//   v2 = The second vector.\n// Example:\n//   v_mul([3,4,5], [8,7,6]);  // Returns [24, 28, 30]\nfunction v_mul(v1, v2) = \n    assert( is_list(v1) && is_list(v2) && len(v1)==len(v2), \"Incompatible input\")\n    [for (i = [0:1:len(v1)-1]) v1[i]*v2[i]];\n    \n\n// Function: v_div()\n// Synopsis: Returns the element-wise division of two equal-length vectors.\n// Topics: Vectors, Math\n// See Also: add_scalar(), v_mul(), v_div()\n// Usage:\n//   v3 = v_div(v1, v2);\n// Description:\n//   Element-wise vector division.  Divides each element of vector `v1` by\n//   the corresponding element of vector `v2`.  Returns a vector of the quotients.\n// Arguments:\n//   v1 = The first vector.\n//   v2 = The second vector.\n// Example:\n//   v_div([24,28,30], [8,7,6]);  // Returns [3, 4, 5]\nfunction v_div(v1, v2) = \n    assert( is_vector(v1) && is_vector(v2,len(v1)), \"Incompatible vectors\")\n    [for (i = [0:1:len(v1)-1]) v1[i]/v2[i]];\n\n\n// Function: v_abs()\n// Synopsis: Returns the absolute values of the given vector.\n// Topics: Vectors, Math\n// See Also: v_abs(), v_floor(), v_ceil()\n// Usage:\n//   v2 = v_abs(v);\n// Description: Returns a vector of the absolute value of each element of vector `v`.\n// Arguments:\n//   v = The vector to get the absolute values of.\n// Example:\n//   v_abs([-1,3,-9]);  // Returns: [1,3,9]\nfunction v_abs(v) =\n    assert( is_vector(v), \"Invalid vector\" ) \n    [for (x=v) abs(x)];\n\n\n// Function: v_floor()\n// Synopsis: Returns the values of the given vector, rounded down.\n// Topics: Vectors, Math\n// See Also: v_abs(), v_floor(), v_ceil()\n// Usage:\n//   v2 = v_floor(v);\n// Description:\n//   Returns the given vector after performing a `floor()` on all items.\nfunction v_floor(v) =\n    assert( is_vector(v), \"Invalid vector\" ) \n    [for (x=v) floor(x)];\n\n\n// Function: v_ceil()\n// Synopsis: Returns the values of the given vector, rounded up.\n// Topics: Vectors, Math\n// See Also: v_abs(), v_floor(), v_ceil()\n// Usage:\n//   v2 = v_ceil(v);\n// Description:\n//   Returns the given vector after performing a `ceil()` on all items.\nfunction v_ceil(v) =\n    assert( is_vector(v), \"Invalid vector\" ) \n    [for (x=v) ceil(x)];\n\n\n// Function: v_lookup()\n// Synopsis: Like `lookup()`, but it can interpolate between vector results.\n// Topics: Vectors, Math\n// See Also: v_abs(), v_floor(), v_ceil()\n// Usage:\n//   v2 = v_lookup(x, v);\n// Description:\n//   Works just like the built-in function [`lookup()`](https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Functions#lookup), except that it can also interpolate between vector result values of the same length.\n// Arguments:\n//   x = The scalar value to look up.\n//   v = A list of [KEY,VAL] pairs. KEYs are scalars.  VALs should either all be scalar, or all be vectors of the same length.\n// Example:\n//   x = v_lookup(4.5, [[4, [3,4,5]], [5, [5,6,7]]]);  // Returns: [4,5,6]\nfunction v_lookup(x, v) =\n    is_num(v[0][1])? lookup(x,v) :\n    let(\n        i = lookup(x, [for (i=idx(v)) [v[i].x,i]]),\n        vlo = v[floor(i)],\n        vhi = v[ceil(i)],\n        lo = vlo[1],\n        hi = vhi[1]\n    )\n    assert(is_vector(lo) && is_vector(hi),\n        \"Result values must all be numbers, or all be vectors.\")\n    assert(len(lo) == len(hi), \"Vector result values must be the same length\")\n    vlo.x == vhi.x? vlo[1] :\n    let( u = (x - vlo.x) / (vhi.x - vlo.x) )\n    lerp(lo,hi,u);\n\n\n// Section: Vector Properties\n\n\n// Function: unit()\n// Synopsis: Returns the unit length of a given vector.\n// Topics: Vectors, Math\n// See Also: v_abs(), v_floor(), v_ceil()\n// Usage:\n//   v = unit(v, [error]);\n// Description:\n//   Returns the unit length normalized version of vector v.  If passed a zero-length vector,\n//   asserts an error unless `error` is given, in which case the value of `error` is returned.\n// Arguments:\n//   v = The vector to normalize.\n//   error = If given, and input is a zero-length vector, this value is returned.  Default: Assert error on zero-length vector.\n// Example:\n//   v1 = unit([10,0,0]);   // Returns: [1,0,0]\n//   v2 = unit([0,10,0]);   // Returns: [0,1,0]\n//   v3 = unit([0,0,10]);   // Returns: [0,0,1]\n//   v4 = unit([0,-10,0]);  // Returns: [0,-1,0]\n//   v5 = unit([0,0,0],[1,2,3]);    // Returns: [1,2,3]\n//   v6 = unit([0,0,0]);    // Asserts an error.\nfunction unit(v, error=[[[\"ASSERT\"]]]) =\n    assert(is_vector(v), \"Invalid vector\")\n    norm(v)<EPSILON? (error==[[[\"ASSERT\"]]]? assert(norm(v)>=EPSILON,\"Cannot normalize a zero vector\") : error) :\n    v/norm(v);\n\n\n// Function: v_theta()\n// Synopsis: Returns the angle counter-clockwise from X+ on the XY plane.\n// Topics: Vectors, Math\n// See Also: unit()\n// Usage:\n//   theta = v_theta([X,Y]);\n// Description:\n//   Given a vector, returns the angle in degrees counter-clockwise from X+ on the XY plane.\nfunction v_theta(v) =\n    assert( is_vector(v,2) || is_vector(v,3) , \"Invalid vector\")\n    atan2(v.y,v.x);\n\n\n\n// Function: vector_angle()\n// Synopsis: Returns the minor angle between two vectors.\n// Topics: Vectors, Math\n// See Also: unit(), v_theta()\n// Usage:\n//   ang = vector_angle(v1,v2);\n//   ang = vector_angle([v1,v2]);\n//   ang = vector_angle(PT1,PT2,PT3);\n//   ang = vector_angle([PT1,PT2,PT3]);\n// Description:\n//   If given a single list of two vectors, like `vector_angle([V1,V2])`, returns the angle between the two vectors V1 and V2.\n//   If given a single list of three points, like `vector_angle([A,B,C])`, returns the angle between the line segments AB and BC.\n//   If given two vectors, like `vector_angle(V1,V2)`, returns the angle between the two vectors V1 and V2.\n//   If given three points, like `vector_angle(A,B,C)`, returns the angle between the line segments AB and BC.\n// Arguments:\n//   v1 = First vector or point.\n//   v2 = Second vector or point.\n//   v3 = Third point in three point mode.\n// Example:\n//   ang1 = vector_angle(UP,LEFT);     // Returns: 90\n//   ang2 = vector_angle(RIGHT,LEFT);  // Returns: 180\n//   ang3 = vector_angle(UP+RIGHT,RIGHT);  // Returns: 45\n//   ang4 = vector_angle([10,10], [0,0], [10,-10]);  // Returns: 90\n//   ang5 = vector_angle([10,0,10], [0,0,0], [-10,10,0]);  // Returns: 120\n//   ang6 = vector_angle([[10,0,10], [0,0,0], [-10,10,0]]);  // Returns: 120\nfunction vector_angle(v1,v2,v3) =\n    assert( ( is_undef(v3) && ( is_undef(v2) || same_shape(v1,v2) ) )\n            || is_consistent([v1,v2,v3]) ,\n            \"Bad arguments.\")\n    assert( is_vector(v1) || is_consistent(v1), \"Bad arguments.\") \n    let( vecs = ! is_undef(v3) ? [v1-v2,v3-v2] :\n                ! is_undef(v2) ? [v1,v2] :\n                len(v1) == 3   ? [v1[0]-v1[1], v1[2]-v1[1]] \n                               : v1\n    )\n    assert(is_vector(vecs[0],2) || is_vector(vecs[0],3), \"Bad arguments.\")\n    let(\n        norm0 = norm(vecs[0]),\n        norm1 = norm(vecs[1])\n    )\n    assert(norm0>0 && norm1>0, \"Zero length vector.\")\n    // NOTE: constrain() corrects crazy FP rounding errors that exceed acos()'s domain.\n    acos(constrain((vecs[0]*vecs[1])/(norm0*norm1), -1, 1));\n    \n\n// Function: vector_axis()\n// Synopsis: Returns the perpendicular axis between two vectors.\n// Topics: Vectors, Math\n// See Also: unit(), v_theta(), vector_angle()\n// Usage:\n//   axis = vector_axis(v1,v2);\n//   axis = vector_axis([v1,v2]);\n//   axis = vector_axis(PT1,PT2,PT3);\n//   axis = vector_axis([PT1,PT2,PT3]);\n// Description:\n//   If given a single list of two vectors, like `vector_axis([V1,V2])`, returns the vector perpendicular the two vectors V1 and V2.\n//   If given a single list of three points, like `vector_axis([A,B,C])`, returns the vector perpendicular to the plane through a, B and C.\n//   If given two vectors, like `vector_axis(V1,V2)`, returns the vector perpendicular to the two vectors V1 and V2.\n//   If given three points, like `vector_axis(A,B,C)`, returns the vector perpendicular to the plane through a, B and C.\n// Arguments:\n//   v1 = First vector or point.\n//   v2 = Second vector or point.\n//   v3 = Third point in three point mode.\n// Example:\n//   axis1 = vector_axis(UP,LEFT);     // Returns: [0,-1,0] (FWD)\n//   axis2 = vector_axis(RIGHT,LEFT);  // Returns: [0,-1,0] (FWD)\n//   axis3 = vector_axis(UP+RIGHT,RIGHT);  // Returns: [0,1,0] (BACK)\n//   axis4 = vector_axis([10,10], [0,0], [10,-10]);  // Returns: [0,0,-1] (DOWN)\n//   axis5 = vector_axis([10,0,10], [0,0,0], [-10,10,0]);  // Returns: [-0.57735, -0.57735, 0.57735]\n//   axis6 = vector_axis([[10,0,10], [0,0,0], [-10,10,0]]);  // Returns: [-0.57735, -0.57735, 0.57735]\nfunction vector_axis(v1,v2=undef,v3=undef) =\n    is_vector(v3)\n    ?   assert(is_consistent([v3,v2,v1]), \"Bad arguments.\")\n        vector_axis(v1-v2, v3-v2)\n    :   assert( is_undef(v3), \"Bad arguments.\")\n        is_undef(v2)\n        ?   assert( is_list(v1), \"Bad arguments.\")\n            len(v1) == 2 \n            ?   vector_axis(v1[0],v1[1]) \n            :   vector_axis(v1[0],v1[1],v1[2])\n        :   assert( is_vector(v1,zero=false) && is_vector(v2,zero=false) && is_consistent([v1,v2])\n                    , \"Bad arguments.\")  \n            let(\n              eps = 1e-6,\n              w1 = point3d(v1/norm(v1)),\n              w2 = point3d(v2/norm(v2)),\n              w3 = (norm(w1-w2) > eps && norm(w1+w2) > eps) ? w2 \n                   : (norm(v_abs(w2)-UP) > eps)? UP \n                   : RIGHT\n            ) unit(cross(w1,w3));\n\n\n// Function: vector_bisect()\n// Synopsis: Returns the vector that bisects two vectors.\n// Topics: Vectors, Math\n// See Also: unit(), v_theta(), vector_angle(), vector_axis()\n// Usage:\n//   newv = vector_bisect(v1,v2);\n// Description:\n//   Returns a unit vector that exactly bisects the minor angle between two given vectors.\n//   If given two vectors that are directly opposed, returns `undef`.\nfunction vector_bisect(v1,v2) =\n    assert(is_vector(v1))\n    assert(is_vector(v2))\n    assert(!approx(norm(v1),0), \"Zero length vector.\")\n    assert(!approx(norm(v2),0), \"Zero length vector.\")\n    assert(len(v1)==len(v2), \"Vectors are of different sizes.\")\n    let( v1 = unit(v1), v2 = unit(v2) )\n    approx(v1,-v2)? undef :\n    let(\n        axis = vector_axis(v1,v2),\n        ang = vector_angle(v1,v2),\n        v3 = unit(rot(ang/2, v=axis, p=v1))\n    ) v3;\n\n\n\n// Section: Vector Searching\n\n\n// Function: pointlist_bounds()\n// Synopsis: Returns the min and max bounding coordinates for the given list of points.\n// Topics: Geometry, Bounding Boxes, Bounds\n// See Also: closest_point()\n// Usage:\n//   pt_pair = pointlist_bounds(pts);\n// Description:\n//   Finds the bounds containing all the points in `pts` which can be a list of points in any dimension.\n//   Returns a list of two items: a list of the minimums and a list of the maximums.  For example, with\n//   3d points `[[MINX, MINY, MINZ], [MAXX, MAXY, MAXZ]]`\n// Arguments:\n//   pts = List of points.\nfunction pointlist_bounds(pts) =\n    assert(is_path(pts,dim=undef,fast=true) , \"Invalid pointlist.\" )\n    let(\n        select = ident(len(pts[0])),\n        spread = [\n            for(i=[0:len(pts[0])-1])\n            let( spreadi = pts*select[i] )\n            [ min(spreadi), max(spreadi) ]\n        ]\n    ) transpose(spread);\n\n\n\n// Function: closest_point()\n// Synopsis: Finds the closest point in a list of points.\n// Topics: Geometry, Points, Distance\n// See Also: pointlist_bounds(), furthest_point(), closest_point()\n// Usage:\n//   index = closest_point(pt, points);\n// Description:\n//   Given a list of `points`, finds the index of the closest point to `pt`.\n// Arguments:\n//   pt = The point to find the closest point to.\n//   points = The list of points to search.\nfunction closest_point(pt, points) =\n    assert( is_vector(pt), \"Invalid point.\" )\n    assert(is_path(points,dim=len(pt)), \"Invalid pointlist or incompatible dimensions.\" )\n    min_index([for (p=points) norm(p-pt)]);\n\n\n// Function: furthest_point()\n// Synopsis: Finds the furthest point in a list of points.\n// Topics: Geometry, Points, Distance\n// See Also: pointlist_bounds(), furthest_point(), closest_point()\n// Usage:\n//   index = furthest_point(pt, points);\n// Description:\n//   Given a list of `points`, finds the index of the furthest point from `pt`.\n// Arguments:\n//   pt = The point to find the farthest point from.\n//   points = The list of points to search.\nfunction furthest_point(pt, points) =\n    assert( is_vector(pt), \"Invalid point.\" )\n    assert(is_path(points,dim=len(pt)), \"Invalid pointlist or incompatible dimensions.\" )\n    max_index([for (p=points) norm(p-pt)]);\n\n\n// Function: vector_search()\n// Synopsis: Finds points in a list that are close to a given point.\n// Topics: Search, Points, Closest\n// See Also: vector_search_tree(), vector_nearest()\n// Usage:\n//   indices = vector_search(query, r, target);\n// Description:\n//   Given a list of query points `query` and a `target` to search, \n//   finds the points in `target` that match each query point. A match holds when the \n//   distance between a point in `target` and a query point is less than or equal to `r`. \n//   The returned list will have a list for each query point containing, in arbitrary \n//   order, the indices of all points that match that query point. \n//   The `target` may be a simple list of points or a search tree.\n//   When `target` is a large list of points, a search tree is constructed to \n//   speed up the search with an order around O(log n) per query point. \n//   For small point lists, a direct search is done dispensing a tree construction. \n//   Alternatively, `target` may be a search tree built with `vector_search_tree()`.\n//   In that case, that tree is parsed looking for matches.\n//   An empty list of query points will return a empty output list.\n//   An empty list of target points will return a output list with an empty list for each query point.\n// Arguments:\n//   query = list of points to find matches for.\n//   r = the search radius.\n//   target = list of the points to search for matches or a search tree.\n// Example: A set of four queries to find points within 1 unit of the query.  The circles show the search region and all have radius 1.  \n//   $fn=32;\n//   k = 2000;\n//   points = list_to_matrix(rands(0,10,k*2,seed=13333),2);\n//   queries = [for(i=[3,7],j=[3,7]) [i,j]];\n//   search_ind = vector_search(queries, points, 1);\n//   move_copies(points) circle(r=.08);\n//   for(i=idx(queries)){\n//       color(\"blue\")stroke(move(queries[i],circle(r=1)), closed=true, width=.08);\n//       color(\"red\") move_copies(select(points, search_ind[i])) circle(r=.08);\n//   }\n// Example: when a series of searches with different radius are needed, its is faster to pre-compute the tree\n//   $fn=32;\n//   k = 2000;\n//   points = list_to_matrix(rands(0,10,k*2),2,seed=13333);\n//   queries1 = [for(i=[3,7]) [i,i]];\n//   queries2 = [for(i=[3,7]) [10-i,i]];\n//   r1 = 1;\n//   r2 = .7;\n//   search_tree = vector_search_tree(points);\n//   search_1 = vector_search(queries1, r1, search_tree);\n//   search_2 = vector_search(queries2, r2, search_tree);\n//   move_copies(points) circle(r=.08);\n//   for(i=idx(queries1)){\n//       color(\"blue\")stroke(move(queries1[i],circle(r=r1)), closed=true, width=.08);\n//       color(\"red\") move_copies(select(points, search_1[i])) circle(r=.08);\n//   }\n//   for(i=idx(queries2)){\n//       color(\"green\")stroke(move(queries2[i],circle(r=r2)), closed=true, width=.08);\n//       color(\"red\") move_copies(select(points, search_2[i])) circle(r=.08);\n//   }\nfunction vector_search(query, r, target) =\n    query==[] ? [] :\n    is_list(query) && target==[] ? is_vector(query) ? [] : [for(q=query) [] ] :\n    assert( is_finite(r) && r>=0, \n            \"The query radius should be a positive number.\" )\n    let(\n        tgpts  = is_matrix(target),   // target is a point list\n        tgtree = is_list(target)      // target is a tree\n                 && (len(target)==2)\n                 && is_matrix(target[0])\n                 && is_list(target[1])\n                 && (len(target[1])==4 || (len(target[1])==1 && is_list(target[1][0])) )\n    )\n    assert( tgpts || tgtree, \n            \"The target should be a list of points or a search tree compatible with the query.\" )\n    let( \n        dim    = tgpts ? len(target[0]) : len(target[0][0]),\n        simple = is_vector(query, dim)\n        )\n    assert( simple || is_matrix(query,undef,dim), \n            \"The query points should be a list of points compatible with the target point list.\")\n    tgpts \n    ?   len(target)<=400\n        ?   simple ? [for(i=idx(target)) if(norm(target[i]-query)<=r) i ] :\n            [for(q=query) [for(i=idx(target)) if(norm(target[i]-q)<=r) i ] ]\n        :   let( tree = _bt_tree(target, count(len(target)), leafsize=25) )\n            simple ? _bt_search(query, r, target, tree) :\n            [for(q=query) _bt_search(q, r, target, tree)]\n    :   simple ?  _bt_search(query, r, target[0], target[1]) :\n        [for(q=query) _bt_search(q, r, target[0], target[1])];\n\n\n//Ball tree search\nfunction _bt_search(query, r, points, tree) = \n    assert( is_list(tree) \n            && (   ( len(tree)==1 && is_list(tree[0]) )\n                || ( len(tree)==4 && is_num(tree[0]) && is_num(tree[1]) ) ), \n            \"The tree is invalid.\")\n    len(tree)==1 \n    ?   assert( tree[0]==[] || is_vector(tree[0]), \"The tree is invalid.\" )\n        [for(i=tree[0]) if(norm(points[i]-query)<=r) i ]\n    :   norm(query-points[tree[0]]) > r+tree[1] ? [] :\n        concat( \n            [ if(norm(query-points[tree[0]])<=r) tree[0] ],\n            _bt_search(query, r, points, tree[2]),\n            _bt_search(query, r, points, tree[3]) ) ;\n     \n\n// Function: vector_search_tree()\n// Synopsis: Makes a distance search tree for a list of points.\n// Topics: Search, Points, Closest\n// See Also: vector_nearest(), vector_search()\n// Usage:\n//    tree = vector_search_tree(points,leafsize);\n// Description:\n//    Construct a search tree for the given list of points to be used as input\n//    to the function `vector_search()`. The use of a tree speeds up the\n//    search process. The tree construction stops branching when \n//    a tree node represents a number of points less or equal to `leafsize`.\n//    Search trees are ball trees. Constructing the\n//    tree should be O(n log n) and searches should be O(log n), though real life\n//    performance depends on how the data is distributed, and it will deteriorate\n//    for high data dimensions.  This data structure is useful when you will be\n//    performing many searches of the same data, so that the cost of constructing \n//    the tree is justified. (See https://en.wikipedia.org/wiki/Ball_tree)\n//    For a small lists of points, the search with a tree may be more expensive\n//    than direct comparisons. The argument `treemin` sets the minimum length of \n//    point set for which a tree search will be done by `vector_search`.\n//    For an empty list of points it returns an empty list.\n// Arguments:\n//    points = list of points to store in the search tree.\n//    leafsize = the size of the tree leaves. Default: 25\n//    treemin = the minimum size of the point list for which a tree search is done. Default: 400\n// Example: A set of four queries to find points within 1 unit of the query.  The circles show the search region and all have radius 1.  \n//   $fn=32;\n//   k = 2000;\n//   points = random_points(k, scale=10, dim=2,seed=13333);\n//   queries = [for(i=[3,7],j=[3,7]) [i,j]];\n//   search_tree = vector_search_tree(points);\n//   search_ind = vector_search(queries,1,search_tree);\n//   move_copies(points) circle(r=.08);\n//   for(i=idx(queries)){\n//       color(\"blue\") stroke(move(queries[i],circle(r=1)), closed=true, width=.08);\n//       color(\"red\")  move_copies(select(points, search_ind[i])) circle(r=.08);\n//   }\nfunction vector_search_tree(points, leafsize=25, treemin=400) =\n    points==[] ? [] :\n    assert( is_matrix(points), \"The input list entries should be points.\" )\n    assert( is_int(leafsize) && leafsize>=1,\n            \"The tree leaf size should be an integer greater than zero.\")\n    len(points)<treemin ? points :\n    [ points, _bt_tree(points, count(len(points)), leafsize) ];\n\n\n//Ball tree construction\nfunction _bt_tree(points, ind, leafsize=25) =\n    len(ind)<=leafsize ? [ind] :\n    let( \n        bounds = pointlist_bounds(select(points,ind)),\n        coord  = max_index(bounds[1]-bounds[0]), \n        projc  = [for(i=ind) points[i][coord] ],\n        meanpr = mean(projc), \n        pivot  = min_index([for(p=projc) abs(p-meanpr)]),\n        radius = max([for(i=ind) norm(points[ind[pivot]]-points[i]) ]),\n        Lind   = [for(i=idx(ind)) if(projc[i]<=meanpr && i!=pivot) ind[i] ],\n        Rind   = [for(i=idx(ind)) if(projc[i] >meanpr && i!=pivot) ind[i] ]\n      )\n    [ ind[pivot], radius, _bt_tree(points, Lind, leafsize), _bt_tree(points, Rind, leafsize) ];\n\n\n// Function: vector_nearest()\n// Synopsis: Finds the `k` nearest points in a list to a given point.\n// Topics: Search, Points, Closest\n// See Also: vector_search(), vector_search_tree()\n// Usage:\n//    indices = vector_nearest(query, k, target);\n// Description:\n//    Search `target` for the `k` points closest to point `query`.\n//    The input `target` is either a list of points to search or a search tree\n//    pre-computed by `vector_search_tree(). A list is returned containing the indices\n//    of the points found in sorted order, closest point first.  \n// Arguments:\n//    query = point to search for\n//    k = number of neighbors to return\n//    target = a list of points or a search tree to search in\n// Example:  Four queries to find the 15 nearest points.  The circles show the radius defined by the most distant query result.  Note they are different for each query.  \n//    $fn=32;\n//    k = 1000;\n//    points = list_to_matrix(rands(0,10,k*2,seed=13333),2);\n//    tree = vector_search_tree(points);\n//    queries = [for(i=[3,7],j=[3,7]) [i,j]];\n//    search_ind = [for(q=queries) vector_nearest(q, 15, tree)];\n//    move_copies(points) circle(r=.08);\n//    for(i=idx(queries)){\n//        circle = circle(r=norm(points[last(search_ind[i])]-queries[i]));\n//        color(\"red\")  move_copies(select(points, search_ind[i])) circle(r=.08);\n//        color(\"blue\") stroke(move(queries[i], circle), closed=true, width=.08);  \n//    }\nfunction vector_nearest(query, k, target) =\n    assert(is_int(k) && k>0)\n    assert(is_vector(query), \"Query must be a vector.\")\n    let(\n        tgpts  = is_matrix(target,undef,len(query)), // target is a point list\n        tgtree = is_list(target)      // target is a tree\n                 && (len(target)==2)\n                 && is_matrix(target[0],undef,len(query))\n                 && (len(target[1])==4 || (len(target[1])==1 && is_list(target[1][0])) )\n    )\n    assert( tgpts || tgtree, \n            \"The target should be a list of points or a search tree compatible with the query.\" )\n    assert((tgpts && (k<=len(target))) || (tgtree && (k<=len(target[0]))), \n            \"More results are requested than the number of points.\")\n    tgpts\n    ?   let( tree = _bt_tree(target, count(len(target))) )\n        column(_bt_nearest( query, k, target,  tree),0)\n    :   column(_bt_nearest( query, k, target[0], target[1]),0);\n\n\n//Ball tree nearest\nfunction _bt_nearest(p, k, points, tree, answers=[]) =\n    assert( is_list(tree) \n            && (   ( len(tree)==1 && is_list(tree[0]) )\n                || ( len(tree)==4 && is_num(tree[0]) && is_num(tree[1]) ) ), \n            \"The tree is invalid.\")\n    len(tree)==1\n    ?   _insert_many(answers, k, [for(entry=tree[0]) [entry, norm(points[entry]-p)]])\n    :   let( d = norm(p-points[tree[0]]) )\n        len(answers)==k && ( d > last(answers)[1]+tree[1] ) ? answers :\n        let(\n            answers1 = _insert_sorted(answers, k, [tree[0],d]),\n            answers2 = _bt_nearest(p, k, points, tree[2], answers1),\n            answers3 = _bt_nearest(p, k, points, tree[3], answers2)\n         )\n         answers3;\n\n\nfunction _insert_sorted(list, k, new) =\n    (len(list)==k && new[1]>= last(list)[1]) ? list\n    : [\n        for(entry=list) if (entry[1]<=new[1]) entry,\n        new,\n        for(i=[0:1:min(k-1,len(list))-1]) if (list[i][1]>new[1]) list[i]\n      ];\n\n\nfunction _insert_many(list, k, newlist,i=0) =\n  i==len(newlist) \n    ? list\n    : assert(is_vector(newlist[i],2), \"The tree is invalid.\")\n      _insert_many(_insert_sorted(list,k,newlist[i]),k,newlist,i+1);\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-50", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: version.scad\n//   File that provides functions to manage versioning.\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Data Management\n// FileSummary: Parse and compare semantic versions.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\nBOSL_VERSION = [2,0,716];\n\n\n// Section: BOSL Library Version Functions\n\n\n// Function: bosl_version()\n// Synopsis: Returns the BOSL2 version as a list.\n// Topics: Versioning\n// See Also: bosl_version_num(), bosl_version_str(), bosl_required()\n// Usage:\n//   ver = bosl_version();\n// Description:\n//   Returns a list with three integer elements, [MAJOR,MINOR,REV],\n//   representing the Major, Minor, and Build Revision numbers.\n//   For example, version 2.1.43 will be returned as `[2,1,43]`.\nfunction bosl_version() = BOSL_VERSION;\n\n\n// Function: bosl_version_num()\n// Synopsis: Returns the BOSL2 version as a float.\n// Topics: Versioning\n// See Also: bosl_version(), bosl_version_str(), bosl_required()\n// Usage:\n//   ver = bosl_version_num();\n// Description:\n//   Returns a floating point number of the version, formatted like M.mmrrrr where M is the major version number,\n//   each m is a zero-padded digit of the minor version number, and each r is a zero-padded digit of the build\n//   revision number.  For example, version 2.1.43 will be returned as `2.010043`.\nfunction bosl_version_num() = version_to_num(BOSL_VERSION);\n\n\n// Function: bosl_version_str()\n// Synopsis: Returns the BOSL2 version as a string.\n// Topics: Versioning\n// See Also: bosl_version(), bosl_version_num(), bosl_required()\n// Usage:\n//   ver = bosl_version_str();\n// Description:\n//   Returns a string of the version, formatted like \"MAJOR.MINOR.REV\".\n//   For example, version 2.1.43 will be returned as `\"2.1.43\"`.\nfunction bosl_version_str() = version_to_str(BOSL_VERSION);\n\n\n// Module: bosl_required()\n// Synopsis: Asserts that the current version of the library is at least the given version.\n// Topics: Versioning\n// See Also: version_to_num(), version_to_str(), version_to_list(), version_cmp()\n// Usage:\n//   bosl_required(version);\n// Description:\n//   Given a version as a list, number, or string, asserts that the currently installed BOSL library is at least the given version.\n// Arguments:\n//   version = version required\nmodule bosl_required(version) {\n    no_children($children);\n    assert(\n        version_cmp(bosl_version(), version) >= 0,\n        str(\n            \"BOSL \", bosl_version_str(), \" is installed, but BOSL \",\n            version_to_str(version), \" or better is required.\"  \n        )\n    );\n}\n\n\n// Section: Generic Version Functions\n\nfunction _version_split_str(x, _i=0, _out=[], _num=0) =\n    _i>=len(x)? concat(_out,[_num]) :\n    let(\n        cval = ord(x[_i]) - ord(\"0\"),\n        numend = cval<0 || cval>9,\n        _out = numend? concat(_out, [_num]) : _out,\n        _num = numend? 0 : (10*_num + cval)\n    )\n    _version_split_str(x, _i=_i+1, _out=_out, _num=_num);\n\n\n// Function: version_to_list()\n// Synopsis: Splits a version into a list of integer version parts.\n// Topics: Versioning\n// See Also: version_to_num(), version_to_str(), version_cmp(), bosl_required()\n// Usage:\n//   ver = version_to_list(x);\n// Description:\n//   Given a version string, number, or list, returns the list of version integers [MAJOR,MINOR,REVISION].\n// Arguments:\n//   x = version to convert\n// Example:\n//   v1 = version_to_list(\"2.1.43\");  // Returns: [2,1,43]\n//   v2 = version_to_list(2.120234);  // Returns: [2,12,234]\n//   v3 = version_to_list([2,3,4]);   // Returns: [2,3,4]\n//   v4 = version_to_list([2,3,4,5]); // Returns: [2,3,4]\nfunction version_to_list(version) =\n    is_list(version)? [default(version[0],0), default(version[1],0), default(version[2],0)] :\n    is_string(version)? _version_split_str(version) :\n    is_num(version)? [floor(version), floor(version*100%100), floor(version*1000000%10000+0.5)] :\n    assert(is_num(version) || is_vector(version) || is_string(version)) 0;\n\n\n// Function: version_to_str()\n// Synopsis: Coerces a version into a standard version string.\n// Topics: Versioning\n// See Also: version_to_num(), version_to_list(), version_cmp(), bosl_required()\n// Usage:\n//   str = version_to_str(version);\n// Description:\n//   Takes a version string, number, or list, and returns the properly formatter version string for it.\n// Arguments:\n//   version = version to convert\n// Example:\n//   v1 = version_to_str([2,1,43]);  // Returns: \"2.1.43\"\n//   v2 = version_to_str(2.010043);  // Returns: \"2.1.43\"\n//   v3 = version_to_str(2.340789);  // Returns: \"2.34.789\"\n//   v4 = version_to_str(\"2.3.89\");  // Returns: \"2.3.89\"\nfunction version_to_str(version) =\n    let(version = version_to_list(version))\n    str(version[0],\".\",version[1],\".\",version[2]);\n\n\n// Function: version_to_num()\n// Synopsis: Coerces a version into a standard version float.\n// Topics: Versioning\n// See Also: version_cmp(), version_to_str(), version_to_list(), bosl_required()\n// Usage:\n//   str = version_to_num(version);\n// Description:\n//   Takes a version string, number, or list, and returns the properly formatter version number for it.\n// Arguments:\n//   version = version to convert\n// Example:\n//   v1 = version_to_num([2,1,43]);   // Returns: 2.010043\n//   v2 = version_to_num([2,34,567]); // Returns: 2.340567\n//   v3 = version_to_num(2.120567);   // Returns: 2.120567\n//   v4 = version_to_num(\"2.6.79\");   // Returns: 2.060079\nfunction version_to_num(version) =\n    let(version = version_to_list(version))\n    (version[0]*1000000 + version[1]*10000 + version[2])/1000000;\n\n\n// Function: version_cmp()\n// Synopsis: Compares two versions.\n// Topics: Versioning\n// See Also: version_to_num(), version_to_str(), version_to_list(), bosl_required()\n// Usage:\n//   cmp = version_cmp(a,b);\n// Description:\n//   Given a pair of versions, in any combination of string, integer, or list, compares them, and returns the relative value of them.\n//   Returns an integer <0 if a<b.  Returns 0 if a==b.  Returns an integer >0 if a>b.\n// Example:\n//   cmp1 = version_cmp(2.010034, \"2.1.33\");  // Returns: >0\n//   cmp2 = version_cmp(2.010034, \"2.1.34\");  // Returns: 0\n//   cmp3 = version_cmp(2.010034, \"2.1.35\");  // Returns: <0\nfunction version_cmp(a,b) =\n    let(\n        a = version_to_list(a),\n        b = version_to_list(b),\n        cmps = [for (i=[0:1:2]) if(a[i]!=b[i]) a[i]-b[i]]\n    ) cmps==[]? 0 : cmps[0];\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-51", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: vnf.scad\n//   The Vertices'N'Faces structure (VNF) holds the data used by polyhedron() to construct objects: a vertex\n//   list and a list of faces.  This library makes it easier to construct polyhedra by providing\n//   functions to construct, merge, and modify VNF data, while avoiding common pitfalls such as\n//   reversed faces.  It can find faults in your polyhedrons.  Note that this file is for low level manipulation\n//   of lists of vertices and faces: it can perform some simple transformations on VNF structures\n//   but cannot perform boolean operations on the polyhedrons represented by VNFs.\n// Includes:\n//   include <BOSL2/std.scad>\n// FileGroup: Advanced Modeling\n// FileSummary: Vertices 'n' Faces structure.  Makes polyhedron() easier to use.\n// FileFootnotes: STD=Included in std.scad\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Creating Polyhedrons with VNF Structures\n//   VNF stands for \"Vertices'N'Faces\".  VNF structures are 2-item lists, `[VERTICES,FACES]` where the\n//   first item is a list of vertex points, and the second is a list of face indices into the vertex\n//   list.  Each VNF is self contained, with face indices referring only to its own vertex list.\n//   You can construct a `polyhedron()` in parts by describing each part in a self-contained VNF, then\n//   merge the various VNFs to get the completed polyhedron vertex list and faces.\n\n/// Constant: EMPTY_VNF\n/// Description:\n///   The empty VNF data structure.  Equal to `[[],[]]`.\nEMPTY_VNF = [[],[]];  // The standard empty VNF with no vertices or faces.\n\n\n// Function: vnf_vertex_array()\n// Synopsis: Returns a VNF structure from a rectangular vertex list.\n// SynTags: VNF\n// Topics: VNF Generators, Lists\n// See Also: vnf_tri_array(), vnf_join(), vnf_from_polygons(), vnf_from_region()\n// Usage:\n//   vnf = vnf_vertex_array(points, [caps=], [cap1=], [cap2=], [style=], [reverse=], [col_wrap=], [row_wrap=], [triangulate=]);\n// Description:\n//   Creates a VNF structure from a rectangular vertex list, by dividing the vertices into columns and rows,\n//   adding faces to tile the surface.  You can optionally have faces added to wrap the last column\n//   back to the first column, or wrap the last row to the first.  Endcaps can be added to either\n//   the first and/or last rows.  The style parameter determines how the quadrilaterals are divided into\n//   triangles.  The default style is an arbitrary, systematic subdivision in the same direction.  The \"alt\" style\n//   is the uniform subdivision in the other (alternate) direction.  The \"min_edge\" style picks the shorter edge to\n//   subdivide for each quadrilateral, so the division may not be uniform across the shape.  The \"quincunx\" style\n//   adds a vertex in the center of each quadrilateral and creates four triangles, and the \"convex\" and \"concave\" styles\n//   chooses the locally convex/concave subdivision.  Degenerate faces\n//   are not included in the output, but if this results in unused vertices they will still appear in the output.\n// Arguments:\n//   points = A list of vertices to divide into columns and rows.\n//   ---\n//   caps = If true, add endcap faces to the first AND last rows.\n//   cap1 = If true, add an endcap face to the first row.\n//   cap2 = If true, add an endcap face to the last row.\n//   col_wrap = If true, add faces to connect the last column to the first.\n//   row_wrap = If true, add faces to connect the last row to the first.\n//   reverse = If true, reverse all face normals.\n//   style = The style of subdividing the quads into faces.  Valid options are \"default\", \"alt\", \"min_edge\", \"min_area\", \"quincunx\", \"convex\" and \"concave\".\n//   triangulate = If true, triangulates endcaps to resolve possible CGAL issues.  This can be an expensive operation if the endcaps are complex.  Default: false\n// Example(3D):\n//   vnf = vnf_vertex_array(\n//       points=[\n//           for (h = [0:5:180-EPSILON]) [\n//               for (t = [0:5:360-EPSILON])\n//                   cylindrical_to_xyz(100 + 12 * cos((h/2 + t)*6), t, h)\n//           ]\n//       ],\n//       col_wrap=true, caps=true, reverse=true, style=\"alt\"\n//   );\n//   vnf_polyhedron(vnf);\n// Example(3D): Both `col_wrap` and `row_wrap` are true to make a torus.\n//   vnf = vnf_vertex_array(\n//       points=[\n//           for (a=[0:5:360-EPSILON])\n//               apply(\n//                   zrot(a) * right(30) * xrot(90),\n//                   path3d(circle(d=20))\n//               )\n//       ],\n//       col_wrap=true, row_wrap=true, reverse=true\n//   );\n//   vnf_polyhedron(vnf);\n// Example(3D): M\u00f6bius Strip.  Note that `row_wrap` is not used, and the first and last profile copies are the same.\n//   vnf = vnf_vertex_array(\n//       points=[\n//           for (a=[0:5:360]) apply(\n//               zrot(a) * right(30) * xrot(90) * zrot(a/2+60),\n//               path3d(square([1,10], center=true))\n//           )\n//       ],\n//       col_wrap=true, reverse=true\n//   );\n//   vnf_polyhedron(vnf);\n// Example(3D): Assembling a Polyhedron from Multiple Parts\n//   wall_points = [\n//       for (a = [-90:2:90]) apply(\n//           up(a) * scale([1-0.1*cos(a*6),1-0.1*cos((a+90)*6),1]),\n//           path3d(circle(d=100))\n//       )\n//   ];\n//   cap = [\n//       for (a = [0:0.01:1+EPSILON]) apply(\n//           up(90-5*sin(a*360*2)) * scale([a,a,1]),\n//           wall_points[0]\n//       )\n//   ];\n//   cap1 = [for (p=cap) down(90, p=zscale(-1, p=p))];\n//   cap2 = [for (p=cap) up(90, p=p)];\n//   vnf1 = vnf_vertex_array(points=wall_points, col_wrap=true);\n//   vnf2 = vnf_vertex_array(points=cap1, col_wrap=true);\n//   vnf3 = vnf_vertex_array(points=cap2, col_wrap=true, reverse=true);\n//   vnf_polyhedron([vnf1, vnf2, vnf3]);\n// Example(3D): Building a Multi-Stage Cylindrical Ramp\n//   include <BOSL2/rounding.scad>\n//   major_r = 50;\n//   groove_profile = [\n//       [-10,0], each arc(points=[[-7,0],[0,-3],[7,0]]), [10,0]\n//   ];\n//   ramp_profile = [ [-10,25], [90,25], [180,5], [190,5] ];\n//   rgroove = apply(right(major_r) * xrot(90), path3d(groove_profile));\n//   rprofile = round_corners(ramp_profile, radius=20, closed=false, $fn=72);\n//   vnf = vnf_vertex_array([\n//       for (a = [ramp_profile[0].x : 1 : last(ramp_profile).x]) let(\n//           z = lookup(a,rprofile),\n//           m = zrot(a) * up(z)\n//       )\n//       apply(m, [ [rgroove[0].x,0,-z], each rgroove, [last(rgroove).x,0,-z] ])\n//   ], caps=true, col_wrap=true, reverse=true);\n//   vnf_polyhedron(vnf, convexity=8);\nfunction vnf_vertex_array(\n    points,\n    caps, cap1, cap2,\n    col_wrap=false,\n    row_wrap=false,\n    reverse=false,\n    style=\"default\",\n    triangulate = false\n) =\n    assert(!(any([caps,cap1,cap2]) && !col_wrap), \"col_wrap must be true if caps are requested\")\n    assert(!(any([caps,cap1,cap2]) && row_wrap), \"Cannot combine caps with row_wrap\")\n    assert(in_list(style,[\"default\",\"alt\",\"quincunx\", \"convex\",\"concave\", \"min_edge\",\"min_area\"]))\n    assert(is_matrix(points[0], n=3),\"Point array has the wrong shape or points are not 3d\")\n    assert(is_consistent(points), \"Non-rectangular or invalid point array\")\n    assert(is_bool(triangulate))\n    let(\n        pts = flatten(points),\n        pcnt = len(pts),\n        rows = len(points),\n        cols = len(points[0])\n    )\n    rows<=1 || cols<=1 ? EMPTY_VNF :\n    let(\n        cap1 = first_defined([cap1,caps,false]),\n        cap2 = first_defined([cap2,caps,false]),\n        colcnt = cols - (col_wrap?0:1),\n        rowcnt = rows - (row_wrap?0:1),\n        verts = [\n            each pts,\n            if (style==\"quincunx\")\n                for (r = [0:1:rowcnt-1], c = [0:1:colcnt-1])\n                   let(\n                       i1 = ((r+0)%rows)*cols + ((c+0)%cols),\n                       i2 = ((r+1)%rows)*cols + ((c+0)%cols),\n                       i3 = ((r+1)%rows)*cols + ((c+1)%cols),\n                       i4 = ((r+0)%rows)*cols + ((c+1)%cols)\n                   )\n                   mean([pts[i1], pts[i2], pts[i3], pts[i4]])\n        ],\n        allfaces = [\n            if (cap1) count(cols,reverse=!reverse),\n            if (cap2) count(cols,(rows-1)*cols, reverse=reverse),\n            for (r = [0:1:rowcnt-1], c=[0:1:colcnt-1])\n               each\n               let(\n                   i1 = ((r+0)%rows)*cols + ((c+0)%cols),\n                   i2 = ((r+1)%rows)*cols + ((c+0)%cols),\n                   i3 = ((r+1)%rows)*cols + ((c+1)%cols),\n                   i4 = ((r+0)%rows)*cols + ((c+1)%cols),\n                   faces =\n                        style==\"quincunx\"?\n                          let(i5 = pcnt + r*colcnt + c)\n                          [[i1,i5,i2],[i2,i5,i3],[i3,i5,i4],[i4,i5,i1]]\n                      : style==\"alt\"?\n                          [[i1,i4,i2],[i2,i4,i3]]\n                      : style==\"min_area\"?\n                          let(\n                               area42 = norm(cross(pts[i2]-pts[i1], pts[i4]-pts[i1]))+norm(cross(pts[i4]-pts[i3], pts[i2]-pts[i3])),\n                               area13 = norm(cross(pts[i1]-pts[i4], pts[i3]-pts[i4]))+norm(cross(pts[i3]-pts[i2], pts[i1]-pts[i2])),\n                               minarea_edge = area42 < area13 + EPSILON\n                                 ? [[i1,i4,i2],[i2,i4,i3]]\n                                 : [[i1,i3,i2],[i1,i4,i3]]\n                          )\n                          minarea_edge\n                      : style==\"min_edge\"?\n                          let(\n                               d42=norm(pts[i4]-pts[i2]),\n                               d13=norm(pts[i1]-pts[i3]),\n                               shortedge = d42<d13+EPSILON\n                                 ? [[i1,i4,i2],[i2,i4,i3]]\n                                 : [[i1,i3,i2],[i1,i4,i3]]\n                          )\n                          shortedge\n                      : style==\"convex\"?\n                          let(   // Find normal for 3 of the points.  Is the other point above or below?\n                              n = (reverse?-1:1)*cross(pts[i2]-pts[i1],pts[i3]-pts[i1]),\n                              convexfaces = n==0\n                                ? [[i1,i4,i3]]\n                                : n*pts[i4] > n*pts[i1]\n                                    ? [[i1,i4,i2],[i2,i4,i3]]\n                                    : [[i1,i3,i2],[i1,i4,i3]]\n                          )\n                          convexfaces\n                      : style==\"concave\"?\n                          let(   // Find normal for 3 of the points.  Is the other point above or below?\n                              n = (reverse?-1:1)*cross(pts[i2]-pts[i1],pts[i3]-pts[i1]),\n                              concavefaces = n==0\n                                ? [[i1,i4,i3]]\n                                : n*pts[i4] <= n*pts[i1]\n                                    ? [[i1,i4,i2],[i2,i4,i3]]\n                                    : [[i1,i3,i2],[i1,i4,i3]]\n                          )\n                          concavefaces\n                      : [[i1,i3,i2],[i1,i4,i3]],\n                   // remove degenerate faces\n                   culled_faces= [for(face=faces)\n                       if (norm(cross(verts[face[1]]-verts[face[0]],\n                                      verts[face[2]]-verts[face[0]]))>EPSILON)\n                           face\n                   ],\n                   rfaces = reverse? [for (face=culled_faces) reverse(face)] : culled_faces\n               )\n               rfaces,\n        ],\n        vnf = [verts, allfaces]\n    ) triangulate? vnf_triangulate(vnf) : vnf;\n\n\n// Function: vnf_tri_array()\n// Synopsis: Returns a VNF from an array of points.\n// SynTags: VNF\n// Topics: VNF Generators, Lists\n// See Also: vnf_vertex_array(), vnf_join(), vnf_from_polygons(), vnf_from_region()\n// Usage:\n//   vnf = vnf_tri_array(points, [row_wrap], [reverse])\n// Description:\n//   Produces a VNF from an array of points where each row length can differ from the adjacent rows by up to 2 in length.  This enables\n//   the construction of triangular VNF patches.  The resulting VNF can be wrapped along the rows by setting `row_wrap` to true.\n//   You cannot wrap columns: if you need to do that you'll need to merge two VNF arrays that share edges.  Degenerate faces\n//   are not included in the output, but if this results in unused vertices they will still appear in the output.\n// Arguments:\n//   points = List of point lists for each row\n//   row_wrap = If true then add faces connecting the first row and last row.  These rows must differ by at most 2 in length.\n//   reverse = Set this to reverse the direction of the faces\n// Example(3D,NoAxes): Each row has one more point than the preceeding one.\n//   pts = [for(y=[1:1:10]) [for(x=[0:y-1]) [x,y,y]]];\n//   vnf = vnf_tri_array(pts);\n//   vnf_wireframe(vnf,width=0.1);\n//   color(\"red\")move_copies(flatten(pts)) sphere(r=.15,$fn=9);\n// Example(3D,NoAxes): Each row has two more points than the preceeding one.\n//   pts = [for(y=[0:2:10]) [for(x=[-y/2:y/2]) [x,y,y]]];\n//   vnf = vnf_tri_array(pts);\n//   vnf_wireframe(vnf,width=0.1);\n//   color(\"red\")move_copies(flatten(pts)) sphere(r=.15,$fn=9);\n// Example(3D): Merging two VNFs to construct a cone with one point length change between rows.\n//   pts1 = [for(z=[0:10]) path3d(arc(3+z,r=z/2+1, angle=[0,180]),10-z)];\n//   pts2 = [for(z=[0:10]) path3d(arc(3+z,r=z/2+1, angle=[180,360]),10-z)];\n//   vnf = vnf_join([vnf_tri_array(pts1),\n//                     vnf_tri_array(pts2)]);\n//   color(\"green\")vnf_wireframe(vnf,width=0.1);\n//   vnf_polyhedron(vnf);\n// Example(3D): Cone with length change two between rows\n//   pts1 = [for(z=[0:1:10]) path3d(arc(3+2*z,r=z/2+1, angle=[0,180]),10-z)];\n//   pts2 = [for(z=[0:1:10]) path3d(arc(3+2*z,r=z/2+1, angle=[180,360]),10-z)];\n//   vnf = vnf_join([vnf_tri_array(pts1),\n//                    vnf_tri_array(pts2)]);\n//   color(\"green\")vnf_wireframe(vnf,width=0.1);\n//   vnf_polyhedron(vnf);\n// Example(3D,NoAxes): Point count can change irregularly\n//   lens = [10,9,7,5,6,8,8,10];\n//   pts = [for(y=idx(lens)) lerpn([-lens[y],y,y],[lens[y],y,y],lens[y])];\n//   vnf = vnf_tri_array(pts);\n//   vnf_wireframe(vnf,width=0.1);\n//   color(\"red\")move_copies(flatten(pts)) sphere(r=.15,$fn=9);\nfunction vnf_tri_array(points, row_wrap=false, reverse=false) =\n    let(\n       lens = [for(row=points) len(row)],\n       rowstarts = [0,each cumsum(lens)],\n       faces =\n          [for(i=[0:1:len(points) - 1 - (row_wrap ? 0 : 1)]) each\n            let(\n                rowstart = rowstarts[i],\n                nextrow = select(rowstarts,i+1),\n                delta = select(lens,i+1)-lens[i]\n            )\n            delta == 0 ?\n              [for(j=[0:1:lens[i]-2]) reverse ? [j+rowstart+1, j+rowstart, j+nextrow] : [j+rowstart, j+rowstart+1, j+nextrow],\n               for(j=[0:1:lens[i]-2]) reverse ? [j+rowstart+1, j+nextrow, j+nextrow+1] : [j+rowstart+1, j+nextrow+1, j+nextrow]] :\n            delta == 1 ?\n              [for(j=[0:1:lens[i]-2]) reverse ? [j+rowstart+1, j+rowstart, j+nextrow+1] : [j+rowstart, j+rowstart+1, j+nextrow+1],\n               for(j=[0:1:lens[i]-1]) reverse ? [j+rowstart, j+nextrow, j+nextrow+1] : [j+rowstart, j+nextrow+1, j+nextrow]] :\n            delta == -1 ?\n              [for(j=[0:1:lens[i]-3]) reverse ? [j+rowstart+1, j+nextrow, j+nextrow+1]: [j+rowstart+1, j+nextrow+1, j+nextrow],\n               for(j=[0:1:lens[i]-2]) reverse ? [j+rowstart+1, j+rowstart, j+nextrow] : [j+rowstart, j+rowstart+1, j+nextrow]] :\n            let(count = floor((lens[i]-1)/2))\n            delta == 2 ?\n              [\n               for(j=[0:1:count-1]) reverse ? [j+rowstart+1, j+rowstart, j+nextrow+1] : [j+rowstart, j+rowstart+1, j+nextrow+1],       // top triangles left\n               for(j=[count:1:lens[i]-2]) reverse ? [j+rowstart+1, j+rowstart, j+nextrow+2] : [j+rowstart, j+rowstart+1, j+nextrow+2], // top triangles right\n               for(j=[0:1:count]) reverse ? [j+rowstart, j+nextrow, j+nextrow+1] : [j+rowstart, j+nextrow+1, j+nextrow],                        // bot triangles left\n               for(j=[count+1:1:select(lens,i+1)-2]) reverse ? [j+rowstart-1, j+nextrow, j+nextrow+1] : [j+rowstart-1, j+nextrow+1, j+nextrow], // bot triangles right\n              ] :\n            delta == -2 ?\n              [\n               for(j=[0:1:count-2]) reverse ? [j+nextrow, j+nextrow+1, j+rowstart+1] : [j+nextrow, j+rowstart+1, j+nextrow+1],\n               for(j=[count-1:1:lens[i]-4]) reverse ? [j+nextrow,j+nextrow+1,j+rowstart+2] : [j+nextrow,j+rowstart+2, j+nextrow+1],\n               for(j=[0:1:count-1]) reverse ? [j+nextrow, j+rowstart+1, j+rowstart] : [j+nextrow, j+rowstart, j+rowstart+1],\n               for(j=[count:1:select(lens,i+1)]) reverse ? [ j+nextrow-1, j+rowstart+1, j+rowstart]: [ j+nextrow-1, j+rowstart, j+rowstart+1],\n              ] :\n            assert(false,str(\"Unsupported row length difference of \",delta, \" between row \",i,\" and \",(i+1)%len(points)))\n          ],\n       verts = flatten(points),\n       culled_faces=\n           [for(face=faces)\n               if (norm(verts[face[0]]-verts[face[1]])>EPSILON &&\n                   norm(verts[face[1]]-verts[face[2]])>EPSILON &&\n                   norm(verts[face[2]]-verts[face[0]])>EPSILON)\n                   face\n           ]\n    )\n    [flatten(points), culled_faces];\n\n\n\n// Function: vnf_join()\n// Synopsis: Returns a single VNF structure from a list of VNF structures.\n// SynTags: VNF\n// Topics: VNF Generators, Lists\n// See Also: vnf_tri_array(), vnf_vertex_array(), vnf_from_polygons(), vnf_from_region()\n// Usage:\n//   vnf = vnf_join([VNF, VNF, VNF, ...]);\n// Description:\n//   Given a list of VNF structures, merges them all into a single VNF structure.\n//   Combines all the points of the input VNFs and labels the faces appropriately.\n//   All the points in the input VNFs will appear in the output, even if they are\n//   duplicates of each other.  It is valid to repeat points in a VNF, but if you\n//   with to remove the duplicates that will occur along joined edges, use {{vnf_merge_points()}}.\n//   .\n//   Note that this is a tool for manipulating polyhedron data.  It is for\n//   building up a full polyhedron from partial polyhedra.\n//   It is *not* a union operator for VNFs.  The VNFs to be joined must not intersect each other,\n//   except at edges, or the result will be an invalid polyhedron.  Similarly the\n//   result must not have any other illegal polyhedron characteristics, such as creating\n//   more than two faces sharing the same edge.\n//   If you want a valid result it is your responsibility to ensure that the polyhedron\n//   has no holes, no intersecting faces or edges, and obeys all the requirements\n//   that CGAL expects.\n//   .\n//   For example, if you combine two pyramids to try to make an octahedron, the result will\n//   be invalid because of the two internal faces created by the pyramid bases.  A valid\n//   use would be to build a cube missing one face and a pyramid missing its base and\n//   then join them into a cube with a point.\n// Arguments:\n//   vnfs = a list of the VNFs to joint into one VNF.\n// Example(3D,VPR=[60,0,26],VPD=55,VPT=[5.6,-5.3,9.8]): Here is a VNF where the top face is missing.  It is not a valid polyhedron like this, but we can use it as a building block to make a polyhedron.\n//   bottom = vnf_vertex_array([path3d(rect(8)), path3d(rect(5),4)],col_wrap=true,cap1=true);\n//   vnf_polyhedron(bottom);\n// Example(3D,VPR=[60,0,26],VPD=55,VPT=[5.6,-5.3,9.8]): Here is a VNF that also has a missing face.\n//   triangle = yrot(-90,path3d(regular_ngon(n=3,side=5,anchor=LEFT)));\n//   top = up(4,vnf_vertex_array([list_set(right(2.5,triangle),0,[0,0,7]),\n//                               right(6,triangle)\n//                               ], col_wrap=true, cap2=true));\n//   vnf_polyhedron(zrot(90,top));\n// Example(3D,VPR=[60,0,26],VPD=55,VPT=[5.6,-5.3,9.8]): Using vnf_join combines the two VNFs into a single VNF.  Note that they share an edge.  But the result still isn't closed, so it is not yet a valid polyhedron.\n//   bottom = vnf_vertex_array([path3d(rect(8)), path3d(rect(5),4)],col_wrap=true,cap1=true);\n//   triangle = yrot(-90,path3d(regular_ngon(n=3,side=5,anchor=LEFT)));\n//   top = up(4,vnf_vertex_array([list_set(right(2.5,triangle),0,[0,0,7]),\n//                                right(6,triangle)\n//                               ], col_wrap=true, cap2=true));\n//   full = vnf_join([bottom,zrot(90,top)]);\n//   vnf_polyhedron(full);\n// Example(3D,VPR=[60,0,26],VPD=55,VPT=[5.6,-5.3,9.8]): If we add enough pieces, and the pieces are all consistent with each other, then we can arrive at a valid polyhedron like this one.  To be valid you need to meet all the CGAL requirements: every edge has exactly two faces, all faces are in clockwise order, no intersections of edges.\n//   bottom = vnf_vertex_array([path3d(rect(8)), path3d(rect(5),4)],col_wrap=true,cap1=true);\n//   triangle = yrot(-90,path3d(regular_ngon(n=3,side=5,anchor=LEFT)));\n//   top = up(4,vnf_vertex_array([list_set(right(2.5,triangle),0,[0,0,7]),\n//                                right(6,triangle)\n//                               ], col_wrap=true, cap2=true));\n//   full = vnf_join([bottom,\n//                     for(theta=[0:90:359]) zrot(theta,top)\n//                    ]);\n//   vnf_polyhedron(full);\n// Example(3D): The vnf_join function is not a union operator for polyhedra.  If any faces intersect, like they do in this example where we combine the faces of two cubes, the result is invalid and will give rise to CGAL errors when you add more objects into the model.\n//   cube1 = cube(5);\n//   cube2 = move([2,2,2],cube1);\n//   badvnf = vnf_join([cube1,cube2]);\n//   vnf_polyhedron(badvnf);\n//   right(2.5)up(3)color(\"red\")\n//         text3d(\"Invalid\",size=1,anchor=CENTER,\n//         orient=FRONT,h=.1);\nfunction vnf_join(vnfs) =\n    assert(is_vnf_list(vnfs) , \"Input must be a list of VNFs\")\n    len(vnfs)==1 ? vnfs[0]\n    :\n    let (\n        offs  = cumsum([ 0, for (vnf = vnfs) len(vnf[0]) ]),\n        verts = [for (vnf=vnfs) each vnf[0]],\n        faces =\n            [ for (i = idx(vnfs))\n                let( faces = vnfs[i][1] )\n                for (face = faces)\n                    if ( len(face) >= 3 )\n                        [ for (j = face)\n                            assert( j>=0 && j<len(vnfs[i][0]),\n                                    str(\"VNF number \", i, \" has a face indexing an nonexistent vertex\") )\n                            offs[i] + j ]\n            ]\n    )\n    [verts,faces];\n\n\n\n// Function: vnf_from_polygons()\n// Synopsis: Returns a VNF from a list of 3D polygons.\n// SynTags: VNF\n// Topics: VNF Generators, Lists\n// See Also: vnf_tri_array(), vnf_join(), vnf_vertex_array(), vnf_from_region()\n// Usage:\n//   vnf = vnf_from_polygons(polygons, [eps]);\n// Description:\n//   Given a list of 3D polygons, produces a VNF containing those polygons.\n//   It is up to the caller to make sure that the points are in the correct order to make the face\n//   normals point outwards.  No checking for duplicate vertices is done.  If you want to\n//   remove duplicate vertices use {{vnf_merge_points()}}.  Polygons with zero area are discarded from the face list by default.\n//   If you give non-coplanar faces an error is displayed.  These checks increase run time by about 2x for triangular polygons, but\n//   about 10x for pentagons; the checks can be disabled by setting fast=true.  \n// Arguments:\n//   polygons = The list of 3D polygons to turn into a VNF\n//   fast = Set to true to skip area and coplanarity checks for increased speed.  Default: false\n//   eps = Polygons with area small than this are discarded.  Default: EPSILON\nfunction vnf_from_polygons(polygons,fast=false,eps=EPSILON) =\n   assert(is_list(polygons) && is_path(polygons[0]),\"Input should be a list of polygons\")\n   let(\n       offs = cumsum([0, for(p=polygons) len(p)]),\n       faces = [for(i=idx(polygons))\n                  let(\n                      area=fast ? 1 : polygon_area(polygons[i]),\n                      dummy=assert(is_def(area) || is_collinear(polygons[i],eps=eps),str(\"Polygon \", i, \" is not coplanar\"))\n                  )\n                  if (is_def(area) && area > eps)\n                    [for (j=idx(polygons[i])) offs[i]+j]\n               ]\n   )\n   [flatten(polygons), faces];\n\n\n\n\nfunction _path_path_closest_vertices(path1,path2) =\n    let(\n        dists = [for (i=idx(path1)) let(j=closest_point(path1[i],path2)) [j,norm(path2[j]-path1[i])]],\n        i1 = min_index(column(dists,1)),\n        i2 = dists[i1][0]\n    ) [dists[i1][1], i1, i2];\n\n\nfunction _join_paths_at_vertices(path1,path2,v1,v2) =\n    let(\n        repeat_start = !approx(path1[v1],path2[v2]),\n        path1 = clockwise_polygon(list_rotate(path1,v1)),\n        path2 = ccw_polygon(list_rotate(path2,v2))\n    )\n    [\n        each path1,\n        if (repeat_start) path1[0],\n        each path2,\n        if (repeat_start) path2[0],\n    ];\n\n\n/// Internal Function: _cleave_connected_region(region, eps)\n/// Description:\n///   Given a region that is connected and has its outer border in region[0],\n///   produces a overlapping connected path to join internal holes to\n///   the outer border without adding points. Output is a single non-simple polygon.\n/// Requirements:\n///   It expects that all region paths be simple closed paths, with region[0] CW and\n///   the other paths CCW and encircled by region[0]. The input region paths are also\n///   supposed to be disjoint except for common vertices and common edges but with\n///   no crossings. It may return `undef` if these conditions are not met.\n///   This function implements an extension of the algorithm discussed in:\n///   https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\nfunction _cleave_connected_region(region, eps=EPSILON) =\n    len(region)==1 ? region[0] :\n    let(\n        outer   = deduplicate(region[0]),             //\n        holes   = [for(i=[1:1:len(region)-1])         // deduplication possibly unneeded\n                      deduplicate( region[i] ) ],     //\n        extridx = [for(li=holes) max_index(column(li,0)) ],\n        // the right extreme vertex for each hole sorted by decreasing x values\n        extremes = sort( [for(i=idx(holes)) [ i, extridx[i], -holes[i][extridx[i]].x] ], idx=2 )\n    )\n    _polyHoles(outer, holes, extremes, eps, 0);\n\n\n// connect the hole paths one at a time to the outer path.\n// 'extremes' is the list of the right extreme vertex of each hole sorted by decreasing abscissas\n// see: _cleave_connected_region(region, eps)\nfunction _polyHoles(outer, holes, extremes, eps=EPSILON, n=0) =\n    let(\n        extr = extremes[n],    //\n        hole = holes[extr[0]], // hole path to bridge to the outer path\n        ipt  = extr[1],        // index of the hole point with maximum abscissa\n        brdg = _bridge(hole[ipt], outer, eps)  // the index of a point in outer to bridge hole[ipt] to\n    )\n    brdg == undef ? undef :\n    let(\n        l  = len(outer),\n        lh = len(hole),\n        // the new outer polygon bridging the hole to the old outer\n        npoly =\n            approx(outer[brdg], hole[ipt], eps)\n            ?   [ for(i=[brdg:  1: brdg+l])   outer[i%l] ,\n                  for(i=[ipt+1: 1: ipt+lh-1]) hole[i%lh] ]\n            :   [ for(i=[brdg:  1: brdg+l])   outer[i%l] ,\n                  for(i=[ipt:   1: ipt+lh])   hole[i%lh] ]\n    )\n    n==len(holes)-1 ?  npoly :\n    _polyHoles(npoly, holes, extremes, eps, n+1);\n\n// find a point in outer to be connected to pt in the interior of outer\n// by a segment that not cross or touch any non adjacente edge of outer.\n// return the index of a vertex in the outer path where the bridge should end\n// see _polyHoles(outer, holes, extremes, eps)\nfunction _bridge(pt, outer,eps) =\n    // find the intersection of a ray from pt to the right\n    // with the boundary of the outer cycle\n    let(\n        l    = len(outer),\n        crxs =\n            let( edges = pair(outer,wrap=true) )\n            [for( i = idx(edges) )\n                let( edge = edges[i] )\n                // consider just descending outer edges at right of pt crossing ordinate pt.y\n                if(    (edge[0].y >  pt.y) //+eps)\n                    && (edge[1].y <= pt.y)\n                    && _is_at_left(pt, [edge[1], edge[0]], eps) )\n                    [ i,\n                      // the point of edge with ordinate pt.y\n                      abs(pt.y-edge[1].y)<eps ? edge[1] :\n                      let( u = (pt-edge[1]).y / (edge[0]-edge[1]).y )\n                      (1-u)*edge[1] + u*edge[0]\n                    ]\n             ]\n    )\n    crxs == [] ? undef :\n    let(\n        // the intersection point of the nearest edge to pt with minimum slope\n        minX    = min([for(p=crxs) p[1].x]),\n        crxcand = [for(crx=crxs) if(crx[1].x < minX+eps) crx ], // nearest edges\n        nearest = min_index([for(crx=crxcand)\n                                (outer[crx[0]].x - pt.x) / (outer[crx[0]].y - pt.y) ]), // minimum slope\n        proj    = crxcand[nearest],\n        vert0   = outer[proj[0]],    // the two vertices of the nearest crossing edge\n        vert1   = outer[(proj[0]+1)%l],\n        isect   = proj[1]            // the intersection point\n    )\n    norm(pt-vert1) < eps ? (proj[0]+1)%l : // if pt touches an outer vertex, return its index\n    // as vert0.y > pt.y then pt!=vert0\n    norm(pt-isect) < eps ? undef :         // if pt touches the middle of an outer edge -> error\n    let(\n        // the edge [vert0, vert1] necessarily satisfies vert0.y > vert1.y\n        // indices of candidates to an outer bridge point\n        cand  =\n            (vert0.x > pt.x)\n            ?   [ proj[0],\n                  // select reflex vertices inside of the triangle [pt, vert0, isect]\n                  for(i=idx(outer))\n                      if( _tri_class(select(outer,i-1,i+1),eps) <= 0\n                          && _pt_in_tri(outer[i], [pt, vert0, isect], eps)>=0 )\n                        i\n                ]\n            :   [ (proj[0]+1)%l,\n                  // select reflex vertices inside of the triangle [pt, isect, vert1]\n                  for(i=idx(outer))\n                      if( _tri_class(select(outer,i-1,i+1),eps) <= 0\n                          &&  _pt_in_tri(outer[i], [pt, isect, vert1], eps)>=0 )\n                        i\n                ],\n        // choose the candidate outer[i] such that the line [pt, outer[i]] has minimum slope\n        // among those with minimum slope choose the nearest to pt\n        slopes  = [for(i=cand) 1-abs(outer[i].x-pt.x)/norm(outer[i]-pt) ],\n        min_slp = min(slopes),\n        cand2   = [for(i=idx(cand)) if(slopes[i]<=min_slp+eps) cand[i] ],\n        nearest = min_index([for(i=cand2) norm(pt-outer[i]) ])\n    )\n    cand2[nearest];\n\n\n// Function: vnf_from_region()\n// Synopsis: Returns a 3D VNF given a 2D region.\n// SynTags: VNF\n// Topics: VNF Generators, Lists\n// See Also: vnf_vertex_array(), vnf_tri_array(), vnf_join(), vnf_from_polygons()\n// Usage:\n//   vnf = vnf_from_region(region, [transform], [reverse]);\n// Description:\n//   Given a (two-dimensional) region, applies the given transformation matrix to it and makes a (three-dimensional) triangulated VNF of\n//   faces for that region, reversed if desired.\n// Arguments:\n//   region = The region to convert to a vnf.\n//   transform = If given, a transformation matrix to apply to the faces generated from the region.  Default: No transformation applied.\n//   reverse = If true, reverse the normals of the faces generated from the region.  An untransformed region will have face normals pointing `UP`.  Default: false\n// Example(3D):\n//   region = [square([20,10],center=true),\n//             right(5,square(4,center=true)),\n//             left(5,square(6,center=true))];\n//   vnf = vnf_from_region(region);\n//   color(\"gray\")down(.125)\n//        linear_extrude(height=.125)region(region);\n//   vnf_wireframe(vnf,width=.25);\nfunction vnf_from_region(region, transform, reverse=false) =\n    let (\n        region = [for (path = region) deduplicate(path, closed=true)],\n        regions = region_parts(force_region(region)),\n        vnfs =\n            [\n                for (rgn = regions)\n                let(\n                    cleaved = path3d(_cleave_connected_region(rgn))\n                )\n                assert( cleaved, \"The region is invalid\")\n                let(\n                    face = is_undef(transform)? cleaved : apply(transform,cleaved),\n                    faceidxs = reverse? [for (i=[len(face)-1:-1:0]) i] : [for (i=[0:1:len(face)-1]) i]\n                ) [face, [faceidxs]]\n            ],\n        outvnf = vnf_join(vnfs)\n    )\n    vnf_triangulate(outvnf);\n\n\n\n// Section: VNF Testing and Access\n\n\n// Function: is_vnf()\n// Synopsis: Returns true given a VNF-like structure.\n// Topics: VNF Manipulation\n// See Also: is_vnf_list(), vnf_vertices(), vnf_faces()\n// Usage:\n//   bool = is_vnf(x);\n// Description:\n//   Returns true if the given value looks like a VNF structure.\nfunction is_vnf(x) =\n    is_list(x) &&\n    len(x)==2 &&\n    is_list(x[0]) &&\n    is_list(x[1]) &&\n    (x[0]==[] || (len(x[0])>=3 && is_vector(x[0][0],3))) &&\n    (x[1]==[] || is_vector(x[1][0]));\n\n\n// Function: is_vnf_list()\n// Synopsis: Returns true given a list of VNF-like structures.\n// Topics: VNF Manipulation\n// See Also: is_vnf(), vnf_vertices(), vnf_faces()\n//\n// Description: Returns true if the given value looks passingly like a list of VNF structures.\nfunction is_vnf_list(x) = is_list(x) && all([for (v=x) is_vnf(v)]);\n\n\n// Function: vnf_vertices()\n// Synopsis: Returns the list of vertex points from a VNF.\n// Topics: VNF Manipulation\n// See Also: is_vnf(), is_vnf_list(), vnf_faces()\n// Description: Given a VNF structure, returns the list of vertex points.\nfunction vnf_vertices(vnf) = vnf[0];\n\n\n// Function: vnf_faces()\n// Synopsis: Returns the list of faces from a VNF.\n// Topics: VNF Manipulation\n// See Also: is_vnf(), is_vnf_list(), vnf_vertices()\n// Description: Given a VNF structure, returns the list of faces, where each face is a list of indices into the VNF vertex list.\nfunction vnf_faces(vnf) = vnf[1];\n\n\n\n// Section: Altering the VNF Internals\n\n\n// Function: vnf_reverse_faces()\n// Synopsis: Reverses the faces of a VNF.\n// SynTags: VNF\n// Topics: VNF Manipulation\n// See Also: vnf_quantize(), vnf_merge_points(), vnf_drop_unused_points(), vnf_triangulate(), vnf_slice(), vnf_unify_faces() \n// Usage:\n//   rvnf = vnf_reverse_faces(vnf);\n// Description:\n//   Reverses the orientation of all the faces in the given VNF.\nfunction vnf_reverse_faces(vnf) =\n    [vnf[0], [for (face=vnf[1]) reverse(face)]];\n\n\n// Function: vnf_quantize()\n// Synopsis: Quantizes the vertex coordinates of a VNF.\n// SynTags: VNF\n// Topics: VNF Manipulation\n// See Also: vnf_reverse_faces(), vnf_merge_points(), vnf_drop_unused_points(), vnf_triangulate(), vnf_slice() \n// Usage:\n//   vnf2 = vnf_quantize(vnf,[q]);\n// Description:\n//   Quantizes the vertex coordinates of the VNF to the given quanta `q`.\n// Arguments:\n//   vnf = The VNF to quantize.\n//   q = The quanta to quantize the VNF coordinates to.\nfunction vnf_quantize(vnf,q=pow(2,-12)) =\n    [[for (pt = vnf[0]) quant(pt,q)], vnf[1]];\n\n\n\n// Function: vnf_merge_points()\n// Synopsis: Consolidates duplicate vertices of a VNF.\n// SynTags: VNF\n// Topics: VNF Manipulation\n// See Also: vnf_reverse_faces(), vnf_quantize(), vnf_drop_unused_points(), vnf_triangulate(), vnf_slice(), vnf_unify_faces() \n// Usage:\n//   new_vnf = vnf_merge_points(vnf, [eps]);\n// Description:\n//   Given a VNF, consolidates all duplicate vertices with a tolerance `eps`, relabeling the faces as necessary,\n//   and eliminating any face with fewer than 3 vertices.  Unreferenced vertices of the input VNF are not dropped.\n//   To remove such vertices uses {{vnf_drop_unused_points()}}.\n// Arguments:\n//   vnf = a VNF to consolidate\n//   eps = the tolerance in finding duplicates. Default: EPSILON\nfunction vnf_merge_points(vnf,eps=EPSILON) =\n    let(\n        verts = vnf[0],\n        dedup  = vector_search(verts,eps,verts),                 // collect vertex duplicates\n        map    = [for(i=idx(verts)) min(dedup[i]) ],             // remap duplic vertices\n        offset = cumsum([for(i=idx(verts)) map[i]==i ? 0 : 1 ]), // remaping face vertex offsets\n        map2   = list(idx(verts))-offset,                        // map old vertex indices to new indices\n        nverts = [for(i=idx(verts)) if(map[i]==i) verts[i] ],    // this doesn't eliminate unreferenced vertices\n        nfaces =\n            [ for(face=vnf[1])\n                let(\n                    nface = [ for(vi=face) map2[map[vi]] ],\n                    dface = [for (i=idx(nface))\n                                if( nface[i]!=nface[(i+1)%len(nface)])\n                                    nface[i] ]\n                )\n                if(len(dface) >= 3) dface\n            ]\n    )\n    [nverts, nfaces];\n\n\n// Function: vnf_drop_unused_points()\n// Synopsis: Removes unreferenced vertices from a VNF.\n// SynTags: VNF\n// Topics: VNF Manipulation\n// See Also: vnf_reverse_faces(), vnf_quantize(), vnf_merge_points(), vnf_triangulate(), vnf_slice(), vnf_unify_faces() \n// Usage:\n//   clean_vnf = vnf_drop_unused_points(vnf);\n// Description:\n//   Remove all unreferenced vertices from a VNF.  Note that in most\n//   cases unreferenced vertices cause no harm, and this function may\n//   be slow on large VNFs.\nfunction vnf_drop_unused_points(vnf) =\n    let(\n        flat = flatten(vnf[1]),\n        ind  = _link_indicator(flat,0,len(vnf[0])-1),\n        verts = [for(i=idx(vnf[0])) if(ind[i]==1) vnf[0][i] ],\n        map   = cumsum(ind)\n    )\n    [ verts, [for(face=vnf[1]) [for(v=face) map[v]-1 ] ] ];\n\nfunction _link_indicator(l,imin,imax) =\n    len(l) == 0  ? repeat(imax-imin+1,0) :\n    imax-imin<100 || len(l)<400 ? [for(si=search(list([imin:1:imax]),l,1)) si!=[] ? 1: 0 ] :\n    let(\n        pivot   = floor((imax+imin)/2),\n        lesser  = [ for(li=l) if( li< pivot) li ],\n        greater = [ for(li=l) if( li> pivot) li ]\n    )\n    concat( _link_indicator(lesser ,imin,pivot-1),\n            search(pivot,l,1) ? 1 : 0 ,\n            _link_indicator(greater,pivot+1,imax) ) ;\n\n// Function: vnf_triangulate()\n// Synopsis: Triangulates the faces of a VNF.\n// SynTags: VNF\n// Topics: VNF Manipulation\n// See Also: vnf_reverse_faces(), vnf_quantize(), vnf_merge_points(), vnf_drop_unused_points(), vnf_slice(), vnf_unify_faces() \n// Usage:\n//   vnf2 = vnf_triangulate(vnf);\n// Description:\n//   Triangulates faces in the VNF that have more than 3 vertices.\n// Arguments:\n//   vnf = VNF to triangulate\n// Example(3D):\n//   include <BOSL2/polyhedra.scad>\n//   vnf = zrot(33,regular_polyhedron_info(\"vnf\", \"dodecahedron\", side=12));\n//   vnf_polyhedron(vnf);\n//   triangulated = vnf_triangulate(vnf);\n//   color(\"red\")vnf_wireframe(triangulated,width=.3);\nfunction vnf_triangulate(vnf) =\n    let(\n        verts = vnf[0],\n        faces = [for (face=vnf[1])\n                    each (len(face)==3 ? [face] :\n                    let( tris = polygon_triangulate(verts, face) )\n                    assert( tris!=undef, \"Some `vnf` face cannot be triangulated.\")\n                    tris ) ]\n    )\n    [verts, faces];\n\n\n\n// Function: vnf_unify_faces()\n// Synopsis: Remove triangulation from VNF, returning a copy with full faces\n// SynTags: VNF\n// Topics: VNF Manipulation\n// See Also: vnf_reverse_faces(), vnf_quantize(), vnf_merge_points(), vnf_triangulate(), vnf_slice() \n// Usage:\n//   newvnf = vnf_unify_faces(vnf);\n// Description:\n//   When a VNF has been triangulated, the polygons that form the true faces have been chopped up into\n//   triangles.  This can create problems for algorithms that operate on the VNF itself, where you might\n//   want to be able to identify the true faces.  This function merges together the triangles that\n//   form those true faces, turning a VNF where each true face is represented by a single entry\n//   in the faces list of the VNF.  This function requires that the true faces have no internal vertices.\n//   This will always be true for a triangulated VNF, but might fail for a VNF with some other\n//   face partition.  If internal vertices are present, the output will include backtracking paths from\n//   the boundary to all of those vertices.\n// Arguments:\n//   vnf = vnf whose faces you want to unify\n// Example(3D,Med,NoAxes): Original prism on the left is triangulated.  On the right, the result of unifying the faces.\n//   $fn=16;\n//   poly = linear_sweep(hexagon(side=10),h=35);\n//   vnf = vnf_unify_faces(poly);\n//   vnf_wireframe(poly);\n//   color([0,1,1,.70])vnf_polyhedron(poly);\n//   right(25){\n//     vnf_wireframe(vnf);\n//     color([0,1,1,.70])vnf_polyhedron(vnf);\n//   }\n\nfunction vnf_unify_faces(vnf) =\n   let(\n       faces = vnf[1],\n       edges =  [for(i=idx(faces), edge=pair(faces[i],wrap=true))\n                   [[min(edge),max(edge)],i]],\n       normals = [for(face=faces) polygon_normal(select(vnf[0],face))],\n       facelist = count(faces), //[for(i=[1:1:len(faces)-1]) i],\n       newfaces = _detri_combine_faces(edges,faces,normals,facelist,0)\n   )\n   [vnf[0],newfaces];\n\n\nfunction _detri_combine_faces(edgelist,faces,normals,facelist,curface) =\n    curface==len(faces)? select(faces,facelist)\n  : !in_list(curface,facelist) ? _detri_combine_faces(edgelist,faces,normals,facelist,curface+1)\n  :\n    let(\n        thisface=faces[curface],\n        neighbors = [for(i=idx(thisface))\n                       let(\n                           edgepair = search([sort(select(thisface,i,i+1))],edgelist,0)[0],\n                           choices = select(edgelist,edgepair),\n                           good_choice=[for(choice=choices)\n                              if (choice[1]!=curface && in_list(choice[1],facelist) && normals[choice[1]]*normals[curface]>1-EPSILON)\n                                choice],\n                           d=assert(len(good_choice)<=1)\n                       )\n                       len(good_choice)==1 ? good_choice[0][1] : -1\n                    ],\n        // Check for duplicates in the neighbor list so we don't add them twice\n        dups = search([for(n=neighbors) if (n>=0) n], neighbors,0),\n        goodind = column(dups,0),\n        newface = [for(i=idx(thisface))\n                    each\n                     !in_list(i,goodind) ? [thisface[i]]\n                    :\n                     let(\n                         ind = search(select(thisface,i,i+1), faces[neighbors[i]])\n                     )\n                     select(faces[neighbors[i]],ind[0],ind[1]-1)\n                   ],\n        usedfaces = [for(n=neighbors) if (n>=0) n],\n        faces = list_set(faces,curface,newface),\n        facelist = list_remove_values(facelist,usedfaces)\n     )\n     _detri_combine_faces(edgelist,faces,normals,facelist,len(usedfaces)==0?curface+1:curface);\n\n\n\nfunction _vnf_sort_vertices(vnf, idx=[2,1,0]) =\n    let(\n        verts = vnf[0],\n        faces = vnf[1],\n        vidx = sortidx(verts, idx=idx),\n        rvidx = sortidx(vidx),\n        sorted_vnf = [\n            [ for (i = vidx) verts[i] ],\n            [ for (face = faces) [ for (i = face) rvidx[i] ] ],\n        ]\n    ) sorted_vnf;\n\n\n\n\n// Function: vnf_slice()\n// Synopsis: Slice the faces of a VNF along an axis.\n// SynTags: VNF\n// Topics: VNF Manipulation\n// See Also: vnf_reverse_faces(), vnf_quantize(), vnf_merge_points(), vnf_drop_unused_points(), vnf_triangulate()\n// Usage:\n//   sliced = vnf_slice(vnf, dir, cuts);\n// Description:\n//   Slice the faces of a VNF along a specified axis direction at a given list of cut points.\n//   The cut points can appear in any order.  You can use this to refine the faces of a VNF before\n//   applying a nonlinear transformation to its vertex set.\n// Arguments:\n//   vnf = VNF to slice\n//   dir = normal direction to the slices, either \"X\", \"Y\" or \"Z\"\n//   cuts = X, Y or Z values where cuts occur\n// Example(3D):\n//   include <BOSL2/polyhedra.scad>\n//   vnf = regular_polyhedron_info(\"vnf\", \"dodecahedron\", side=12);\n//   vnf_polyhedron(vnf);\n//   sliced = vnf_slice(vnf, \"X\", [-6,-1,10]);\n//   color(\"red\")vnf_wireframe(sliced,width=.3);\nfunction vnf_slice(vnf,dir,cuts) =\n    let(\n        //  Code below seems to be unnecessary\n        //cuts = [for (cut=cuts) _shift_cut_plane(vnf,dir,cut)],\n        vert = vnf[0],\n        faces = [for(face=vnf[1]) select(vert,face)],\n        poly_list = _slice_3dpolygons(faces, dir, cuts)\n    )\n    vnf_merge_points(vnf_from_polygons(poly_list));\n\n\nfunction _shift_cut_plane(vnf,dir,cut,off=0.001) =\n    let(\n        I = ident(3),\n        dir_ind = ord(dir)-ord(\"X\"),\n        verts = vnf[0],\n        on_cut = [for (x = verts * I[dir_ind]) if(approx(x,cut,eps=1e-4)) 1] != []\n    ) !on_cut? cut :\n    _shift_cut_plane(vnf,dir,cut+off);\n\n\nfunction _split_polygon_at_x(poly, x) =\n    let(\n        xs = column(poly,0)\n    ) (min(xs) >= x || max(xs) <= x)? [poly] :\n    let(\n        poly2 = [\n            for (p = pair(poly,true)) each [\n                p[0],\n                if(\n                    (p[0].x < x && p[1].x > x) ||\n                    (p[1].x < x && p[0].x > x)\n                ) let(\n                    u = (x - p[0].x) / (p[1].x - p[0].x)\n                ) [\n                    x,  // Important for later exact match tests\n                    u*(p[1].y-p[0].y)+p[0].y\n                ]\n            ]\n        ],\n        out1 = [for (p = poly2) if(p.x <= x) p],\n        out2 = [for (p = poly2) if(p.x >= x) p],\n        out3 = [\n            if (len(out1)>=3) each split_path_at_self_crossings(out1),\n            if (len(out2)>=3) each split_path_at_self_crossings(out2),\n        ],\n        out = [for (p=out3) if (len(p) > 2) list_unwrap(p)]\n    ) out;\n\n\nfunction _split_2dpolygons_at_each_x(polys, xs, _i=0) =\n    _i>=len(xs)? polys :\n    _split_2dpolygons_at_each_x(\n        [\n            for (poly = polys)\n            each _split_polygon_at_x(poly, xs[_i])\n        ], xs, _i=_i+1\n    );\n\n/// Internal Function: _slice_3dpolygons()\n/// Usage:\n///   splitpolys = _slice_3dpolygons(polys, dir, cuts);\n/// Topics: Geometry, Polygons, Intersections\n/// Description:\n///   Given a list of 3D polygons, a choice of X, Y, or Z, and a cut list, `cuts`, splits all of the polygons where they cross\n///   X/Y/Z at any value given in cuts.\n/// Arguments:\n///   polys = A list of 3D polygons to split.\n///   dir_ind = slice direction, 0=X, 1=Y, or 2=Z\n///   cuts = A list of scalar values for locating the cuts\nfunction _slice_3dpolygons(polys, dir, cuts) =\n    assert( [for (poly=polys) if (!is_path(poly,3)) 1] == [], \"Expects list of 3D paths.\")\n    assert( is_vector(cuts), \"The split list must be a vector.\")\n    assert( in_list(dir, [\"X\", \"Y\", \"Z\"]))\n    let(\n        I = ident(3),\n        dir_ind = ord(dir)-ord(\"X\")\n    )\n    flatten([\n        for (poly = polys)\n            if (polygon_area(poly)>EPSILON)   // Discard zero area polygons\n            let( \n                 plane = plane_from_polygon(poly,1e-4))\n            assert(plane,\"Found non-coplanar face.\")\n            let(\n                normal = point3d(plane),\n                pnormal = normal - (normal*I[dir_ind])*I[dir_ind]\n            )\n            approx(pnormal,[0,0,0]) ? [poly]     // Polygons parallel to cut plane just pass through\n          : let(\n                pind = max_index(v_abs(pnormal)),  // project along this direction\n                otherind = 3-pind-dir_ind,         // keep dir_ind and this direction\n                keep = [I[dir_ind], I[otherind]],  // dir ind becomes the x dir\n                poly2d = poly*transpose(keep),     // project to 2d, putting selected direction in the X position\n                poly_list = [for(p=_split_2dpolygons_at_each_x([poly2d], cuts))\n                                let(\n                                    a = p*keep,    // unproject, but pind dimension data is missing\n                                    ofs = outer_product((repeat(plane[3], len(a))-a*normal)/plane[pind],I[pind])\n                                 )\n                                 a+ofs]    // ofs computes the missing pind dimension data and adds it back in\n            )\n            poly_list\n    ]);\n\n\n\n\n\n// Section: Turning a VNF into geometry\n\n\n// Module: vnf_polyhedron()\n// Synopsis: Returns a polyhedron from a VNF or list of VNFs.\n// SynTags: Geom\n// Topics: VNF Manipulation\n// See Also: vnf_wireframe()\n// Usage:\n//   vnf_polyhedron(vnf) [ATTACHMENTS];\n//   vnf_polyhedron([VNF, VNF, VNF, ...]) [ATTACHMENTS];\n// Description:\n//   Given a VNF structure, or a list of VNF structures, creates a polyhedron from them.\n// Arguments:\n//   vnf = A VNF structure, or list of VNF structures.\n//   convexity = Max number of times a line could intersect a wall of the shape.\n//   cp = Centerpoint for determining intersection anchors or centering the shape.  Determintes the base of the anchor vector.  Can be \"centroid\", \"mean\", \"box\" or a 3D point.  Default: \"centroid\"\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `\"origin\"`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//   atype = Select \"hull\" or \"intersect\" anchor type.  Default: \"hull\"\n// Anchor Types:\n//   \"hull\" = Anchors to the virtual convex hull of the shape.\n//   \"intersect\" = Anchors to the surface of the shape.\n// Extra Anchors:\n//   \"origin\" = Anchor at the origin, oriented UP.\nmodule vnf_polyhedron(vnf, convexity=2, cp=\"centroid\", anchor=\"origin\", spin=0, orient=UP, atype=\"hull\") {\n    vnf = is_vnf_list(vnf)? vnf_join(vnf) : vnf;\n    assert(in_list(atype, _ANCHOR_TYPES), \"Anchor type must be \\\"hull\\\" or \\\"intersect\\\"\");\n    attachable(anchor,spin,orient, vnf=vnf, extent=atype==\"hull\", cp=cp) {\n        polyhedron(vnf[0], vnf[1], convexity=convexity);\n        children();\n    }\n}\n\n\n// Module: vnf_wireframe()\n// Synopsis: Creates a wireframe model from a VNF.\n// SynTags: VNF\n// Topics: VNF Manipulation\n// See Also: vnf_polyhedron()\n// Usage:\n//   vnf_wireframe(vnf, [width]);\n// Description:\n//   Given a VNF, creates a wire frame ball-and-stick model of the polyhedron with a cylinder for\n//   each edge and a sphere at each vertex.  The width parameter specifies the width of the sticks\n//   that form the wire frame and the diameter of the balls.\n// Arguments:\n//   vnf = A vnf structure\n//   width = width of the cylinders forming the wire frame.  Default: 1\n// Example:\n//   $fn=32;\n//   ball = sphere(r=20, $fn=6);\n//   vnf_wireframe(ball,width=1);\n// Example:\n//   include <BOSL2/polyhedra.scad>\n//   $fn=32;\n//   cube_oct = regular_polyhedron_info(\"vnf\",\n//                      name=\"cuboctahedron\", or=20);\n//   vnf_wireframe(cube_oct);\n// Example: The spheres at the vertex are imperfect at aligning with the cylinders, so especially at low $fn things look prety ugly.  This is normal.\n//   include <BOSL2/polyhedra.scad>\n//   $fn=8;\n//   octahedron = regular_polyhedron_info(\"vnf\",\n//                         name=\"octahedron\", or=20);\n//   vnf_wireframe(octahedron,width=5);\nmodule vnf_wireframe(vnf, width=1)\n{\n  no_children($children);\n  vertex = vnf[0];\n  edges = unique([for (face=vnf[1], i=idx(face))\n                    sort([face[i], select(face,i+1)])\n                 ]);\n  attachable()\n  {\n    union(){\n      for (e=edges) extrude_from_to(vertex[e[0]],vertex[e[1]]) circle(d=width);\n      // Identify vertices actually used and draw them\n      vertused = search(count(len(vertex)), flatten(edges), 1);\n      for(i=idx(vertex)) if(vertused[i]!=[]) move(vertex[i]) sphere(d=width);\n    }\n    union();\n  }\n}\n\n\n// Section: Operations on VNFs\n\n// Function: vnf_volume()\n// Synopsis: Returns the volume of a VNF.\n// Topics: VNF Manipulation\n// See Also: vnf_area(), vnf_halfspace(), vnf_bend() \n// Usage:\n//   vol = vnf_volume(vnf);\n// Description:\n//   Returns the volume enclosed by the given manifold VNF.   The VNF must describe a valid polyhedron with consistent face direction and\n//   no holes; otherwise the results are undefined.  Returns a positive volume if face direction is clockwise and a negative volume\n//   if face direction is counter-clockwise.\n\n// Divide the polyhedron into tetrahedra with the origin as one vertex and sum up the signed volume.\nfunction vnf_volume(vnf) =\n    let(verts = vnf[0])\n    sum([\n         for(face=vnf[1], j=[1:1:len(face)-2])\n             cross(verts[face[j+1]], verts[face[j]]) * verts[face[0]]\n    ])/6;\n\n\n// Function: vnf_area()\n// Synopsis: Returns the surface area of a VNF.\n// Topics: VNF Manipulation\n// See Also: vnf_volume(), vnf_halfspace(), vnf_bend() \n// Usage:\n//   area = vnf_area(vnf);\n// Description:\n//   Returns the surface area in any VNF by adding up the area of all its faces.  The VNF need not be a manifold.\nfunction vnf_area(vnf) =\n    let(verts=vnf[0])\n    sum([for(face=vnf[1]) polygon_area(select(verts,face))]);\n\n\n/// Internal Function: _vnf_centroid()\n/// Usage:\n///   vol = _vnf_centroid(vnf);\n/// Description:\n///   Returns the centroid of the given manifold VNF.  The VNF must describe a valid polyhedron with consistent face direction and\n///   no holes; otherwise the results are undefined.\n\n/// Divide the solid up into tetrahedra with the origin as one vertex.\n/// The centroid of a tetrahedron is the average of its vertices.\n/// The centroid of the total is the volume weighted average.\nfunction _vnf_centroid(vnf,eps=EPSILON) =\n    assert(is_vnf(vnf) && len(vnf[0])!=0 && len(vnf[1])!=0,\"Invalid or empty VNF given to centroid\")\n    let(\n        verts = vnf[0],\n        pos = sum([\n            for(face=vnf[1], j=[1:1:len(face)-2]) let(\n                v0  = verts[face[0]],\n                v1  = verts[face[j]],\n                v2  = verts[face[j+1]],\n                vol = cross(v2,v1)*v0\n            )\n            [ vol, (v0+v1+v2)*vol ]\n        ])\n    )\n    assert(!approx(pos[0],0, eps), \"The vnf has self-intersections.\")\n    pos[1]/pos[0]/4;\n\n\n// Function: vnf_halfspace()\n// Synopsis: Returns the intersection of the vnf with a half space.\n// SynTags: VNF\n// Topics: VNF Manipulation\n// See Also: vnf_volume(), vnf_area(), vnf_bend() \n// Usage:\n//   newvnf = vnf_halfspace(plane, vnf, [closed], [boundary]);\n// Description:\n//   Returns the intersection of the vnf with a half space.  The half space is defined by\n//   plane = [A,B,C,D], taking the side where the normal [A,B,C] points: Ax+By+Cz\u2265D.\n//   If closed is set to false then the cut face is not included in the vnf.  This could\n//   allow further extension of the vnf by join with other vnfs using {{vnf_join()}}.\n//   Note that if your given VNF has holes (missing faces) or is not a complete polyhedron\n//   then closed=true is may produce invalid results when it tries to construct closing faces\n//   on the cut plane.  Set closed=false for such inputs.\n//   .\n//   If you set boundary to true then the return will be the pair [vnf,boundary] where vnf is the\n//   vnf as usual (with closed=false) and boundary is a list giving each connected component of the cut\n//   boundary surface.  Each entry in boundary is a list of index values that index into the vnf vertex list (vnf[0]).\n//   This makes it possible to construct mating shapes, e.g. with {{skin()}} or {{vnf_vertex_array()}} that\n//   can be combined using {{vnf_join()}} to make a valid polyhedron.\n//   .\n//   Note that the input to vnf_halfspace() does not need to be a closed, manifold polyhedron.\n//   Because it adds the faces on the cut surface, you can use vnf_halfspace() to cap off an open shape if you\n//   slice through a region that excludes all of the gaps in the input VNF.  \n// Arguments:\n//   plane = plane defining the boundary of the half space\n//   vnf = VNF to cut\n//   closed = if false do not return the cut face(s) in the returned VNF.  Default: true\n//   boundary = if true return a pair [vnf,boundary] where boundary is a list of paths on the cut boundary indexed into the VNF vertex list.  If boundary is true, then closed is set to false.  Default: false\n// Example(3D):\n//   vnf = cube(10,center=true);\n//   cutvnf = vnf_halfspace([-1,1,-1,0], vnf);\n//   vnf_polyhedron(cutvnf);\n// Example(3D):  Cut face has 2 components\n//   vnf = path_sweep(circle(r=4, $fn=16),\n//                    circle(r=20, $fn=64),closed=true);\n//   cutvnf = vnf_halfspace([-1,1,-4,0], vnf);\n//   vnf_polyhedron(cutvnf);\n// Example(3D): Cut face is not simply connected\n//   vnf = path_sweep(circle(r=4, $fn=16),\n//                    circle(r=20, $fn=64),closed=true);\n//   cutvnf = vnf_halfspace([0,0.7,-4,0], vnf);\n//   vnf_polyhedron(cutvnf);\n// Example(3D): Cut object has multiple components\n//   function knot(a,b,t) =   // rolling knot\n//        [ a * cos (3 * t) / (1 - b* sin (2 *t)),\n//          a * sin( 3 * t) / (1 - b* sin (2 *t)),\n//        1.8 * b * cos (2 * t) /(1 - b* sin (2 *t))];\n//   a = 0.8; b = sqrt (1 - a * a);\n//   ksteps = 400;\n//   knot_path = [for (i=[0:ksteps-1]) 50 * knot(a,b,(i/ksteps)*360)];\n//   ushape = [[-10, 0],[-10, 10],[ -7, 10],[ -7, 2],[  7, 2],[  7, 7],[ 10, 7],[ 10, 0]];\n//   knot=path_sweep(ushape, knot_path, closed=true, method=\"incremental\");\n//   cut_knot = vnf_halfspace([1,0,0,0], knot);\n//   vnf_polyhedron(cut_knot);\n// Example(VPR=[80,0,15]): Cut a sphere with an arbitrary plane\n//   vnf1=sphere(r=50, style=\"icosa\", $fn=16);\n//   vnf2=vnf_halfspace([.8,1,-1.5,0], vnf1);\n//   vnf_polyhedron(vnf2);\n// Example(VPR=[80,0,15]): Cut it again, but with closed=false to leave an open boundary. \n//   vnf1=sphere(r=50, style=\"icosa\", $fn=16);\n//   vnf2=vnf_halfspace([.8,1,-1.5,0], vnf1);\n//   vnf3=vnf_halfspace([0,0,-1,0], vnf2, closed=false);\n//   vnf_polyhedron(vnf3);\n// Example(VPR=[80,0,15]): Use {vnf_join()} to combine with a mating vnf, in this case a reflection of the part we made. \n//   vnf1=sphere(r=50, style=\"icosa\", $fn=16);\n//   vnf2=vnf_halfspace([.8,1,-1.5,0], vnf1);\n//   vnf3=vnf_halfspace([0,0,-1,0], vnf2, closed=false);\n//   vnf4=vnf_join([vnf3, zflip(vnf3,1)]);\n//   vnf_polyhedron(vnf4);\n// Example: When the input VNF is a surface with a boundary, if you use the default setting closed=true, then vnf_halfspace() tries to construct closing faces from the edges created by the cut.  These faces may be invalid, for example if the cut points are collinear.  In this example the constructed face is a valid face.\n//   include <BOSL2/beziers.scad>\n//   patch=[\n//          [[10,-10,0],[1,-1,0],[-1,-1,0],[-10,-10,0]],\n//          [[10,-10,20],[1,-1,20],[-1,-1,20],[-10,-10,20]]\n//         ];\n//   vnf=bezier_vnf(patch);\n//   vnfcut = vnf_halfspace([-.8,0,-1,-14],vnf);\n//   vnf_polyhedron(vnfcut);\n// Example: Setting closed to false eliminates this (possibly invalid) face:\n//   include <BOSL2/beziers.scad>\n//   patch=[\n//          [[10,-10,0],[1,-1,0],[-1,-1,0],[-10,-10,0]],\n//          [[10,-10,20],[1,-1,20],[-1,-1,20],[-10,-10,20]]\n//         ];\n//   vnf=bezier_vnf(patch);\n//   vnfcut = vnf_halfspace([-.8,0,-1,-14],vnf,closed=false);\n//   vnf_polyhedron(vnfcut);\n// Example: Here is a VNF that has holes, so it is not a valid manifold. \n//   outside = linear_sweep(circle(r=30), h=100, caps=false);\n//   inside = yrot(7,linear_sweep(circle(r=10), h=120, caps=false));\n//   open_vnf=vnf_join([outside, vnf_reverse_faces(inside)]);\n//   vnf_polyhedron(open_vnf);\n// Example: By cutting it at each end we can create closing faces, resulting in a valid manifold without holes.\n//   outside = linear_sweep(circle(r=30), h=100, caps=false);\n//   inside = yrot(11,linear_sweep(circle(r=10), h=120, caps=false));\n//   open_vnf=vnf_join([outside, vnf_reverse_faces(inside)]);\n//   vnf = vnf_halfspace([0,0,1,5], vnf_halfspace([0,.7,-1,-75], open_vnf));\n//   vnf_polyhedron(vnf);\n// Example: If boundary=true then the return is a list with the VNF and boundary data.  \n//   vnf = path_sweep(circle(r=4, $fn=16),\n//                    circle(r=20, $fn=64),closed=true);\n//   cut_bnd = vnf_halfspace([-1,1,-4,0], vnf, boundary=true);*/\n//   cutvnf = cut_bnd[0];\n//   boundary = [for(b=cut_bnd[1]) select(cutvnf[0],b)];\n//   vnf_polyhedron(cutvnf);\n//   stroke(boundary,color=\"red\");\nfunction vnf_halfspace(plane, vnf, closed=true, boundary=false) =\n    assert(_valid_plane(plane), \"Invalid plane\")\n    assert(is_vnf(vnf), \"Invalid vnf\")\n    let(\n         inside = [for(x=vnf[0]) plane*[each x,-1] >= -EPSILON ? 1 : 0],\n         vertexmap = [0,each cumsum(inside)],\n         faces_edges_vertices = _vnfcut(plane, vnf[0],vertexmap,inside, vnf[1], last(vertexmap)),\n         newvert = concat(bselect(vnf[0],inside), faces_edges_vertices[2])\n    )\n    closed==false && !boundary ? [newvert, faces_edges_vertices[0]]\n  : let(\n        allpaths = _assemble_paths(newvert, faces_edges_vertices[1]),\n        newpaths = [for(p=allpaths) if (len(p)>=3) p\n                                    else assert(approx(p[0],p[1]),\"Orphan edge found when assembling cut edges.\")\n           ]\n    )\n    boundary ? [[newvert, faces_edges_vertices[0]], newpaths]\n  : len(newpaths)<=1 ? [newvert, concat(faces_edges_vertices[0], newpaths)]\n  : let(\n           M = project_plane(plane),\n           faceregion = [for(path=newpaths) path2d(apply(M,select(newvert,path)))],\n           facevnf = vnf_from_region(faceregion,transform=rot_inverse(M),reverse=true)\n      )\n      vnf_join([[newvert, faces_edges_vertices[0]], facevnf]);\n\nfunction _assemble_paths(vertices, edges, paths=[],i=0) =\n     i==len(edges) ? paths :\n     norm(vertices[edges[i][0]]-vertices[edges[i][1]])<EPSILON ? _assemble_paths(vertices,edges,paths,i+1) :\n     let(    // Find paths that connects on left side and right side of the edges (if one exists)\n         left = [for(j=idx(paths)) if (approx(vertices[last(paths[j])],vertices[edges[i][0]])) j],\n         right = [for(j=idx(paths)) if (approx(vertices[edges[i][1]],vertices[paths[j][0]])) j]\n     )\n     assert(len(left)<=1 && len(right)<=1)\n     let(\n          keep_path = list_remove(paths,concat(left,right)),\n          update_path = left==[] && right==[] ? edges[i]\n                      : left==[] ? concat([edges[i][0]],paths[right[0]])\n                      : right==[] ?  concat(paths[left[0]],[edges[i][1]])\n                      : left != right ? concat(paths[left[0]], paths[right[0]])\n                      : paths[left[0]]\n     )\n     _assemble_paths(vertices, edges, concat(keep_path, [update_path]), i+1);\n\n\nfunction _vnfcut(plane, vertices, vertexmap, inside, faces, vertcount, newfaces=[], newedges=[], newvertices=[], i=0) =\n   i==len(faces) ? [newfaces, newedges, newvertices] :\n   let(\n        pts_inside = select(inside,faces[i])\n   )\n   all(pts_inside) ? _vnfcut(plane, vertices, vertexmap, inside, faces, vertcount,\n                             concat(newfaces, [select(vertexmap,faces[i])]), newedges, newvertices, i+1):\n   !any(pts_inside) ? _vnfcut(plane, vertices, vertexmap,inside, faces, vertcount, newfaces, newedges, newvertices, i+1):\n   let(\n        first = search([[1,0]],pair(pts_inside,wrap=true),0)[0],\n        second = search([[0,1]],pair(pts_inside,wrap=true),0)[0]\n   )\n   assert(len(first)==1 && len(second)==1, \"Found concave face in VNF.  Run vnf_triangulate first to ensure convex faces.\")\n   let(\n        newface = [each select(vertexmap,select(faces[i],second[0]+1,first[0])),vertcount, vertcount+1],\n        newvert = [plane_line_intersection(plane, select(vertices,select(faces[i],first[0],first[0]+1)),eps=0),\n                   plane_line_intersection(plane, select(vertices,select(faces[i],second[0],second[0]+1)),eps=0)]\n   )\n   true //!approx(newvert[0],newvert[1])\n       ? _vnfcut(plane, vertices, vertexmap, inside, faces, vertcount+2,\n                 concat(newfaces, [newface]), concat(newedges,[[vertcount+1,vertcount]]),concat(newvertices,newvert),i+1)\n   :len(newface)>3\n       ? _vnfcut(plane, vertices, vertexmap, inside, faces, vertcount+1,\n                 concat(newfaces, [list_head(newface)]), newedges,concat(newvertices,[newvert[0]]),i+1)\n   :\n   _vnfcut(plane, vertices, vertexmap, inside, faces, vertcount,newfaces, newedges, newvert, i+1);\n\n\n\n\nfunction _triangulate_planar_convex_polygons(polys) =\n    polys==[]? [] :\n    let(\n        tris = [for (poly=polys) if (len(poly)==3) poly],\n        bigs = [for (poly=polys) if (len(poly)>3) poly],\n        newtris = [for (poly=bigs) select(poly,-2,0)],\n        newbigs = [for (poly=bigs) select(poly,0,-2)],\n        newtris2 = _triangulate_planar_convex_polygons(newbigs),\n        outtris = concat(tris, newtris, newtris2)\n    ) outtris;\n\n//**\n// this function may produce degenerate triangles:\n//    _triangulate_planar_convex_polygons([ [for(i=[0:1]) [i,i],\n//                                           [1,-1], [-1,-1],\n//                                           for(i=[-1:0]) [i,i] ] ] )\n//    == [[[-1, -1], [ 0,  0], [0,  0]]\n//        [[-1, -1], [-1, -1], [0,  0]]\n//        [[ 1, -1], [-1, -1], [0,  0]]\n//        [[ 0,  0], [ 1,  1], [1, -1]] ]\n//\n\n// Function: vnf_bend()\n// Synopsis: Bends a VNF around an axis.\n// SynTags: VNF\n// Topics: VNF Manipulation\n// See Also: vnf_volume(), vnf_area(), vnf_halfspace() \n// Usage:\n//   bentvnf = vnf_bend(vnf,r|d=,[axis=]);\n// Description:\n//   Bend a VNF around the X, Y or Z axis, splitting up faces as necessary.  Returns the bent\n//   VNF.  For bending around the Z axis the input VNF must not cross the Y=0 plane.  For bending\n//   around the X or Y axes the VNF must not cross the Z=0 plane.  Note that if you wrap a VNF all the way around\n//   it may intersect itself, which produces an invalid polyhedron.  It is your responsibility to\n//   avoid this situation.  The 1:1\n//   radius is where the curved length of the bent VNF matches the length of the original VNF.  If the\n//   `r` or `d` arguments are given, then they will specify the 1:1 radius or diameter.  If they are\n//   not given, then the 1:1 radius will be defined by the distance of the furthest vertex in the\n//   original VNF from the Z=0 plane.  You can adjust the granularity of the bend using the standard\n//   `$fa`, `$fs`, and `$fn` variables.\n// Arguments:\n//   vnf = The original VNF to bend.\n//   r = If given, the radius where the size of the original shape is the same as in the original.\n//   ---\n//   d = If given, the diameter where the size of the original shape is the same as in the original.\n//   axis = The axis to wrap around.  \"X\", \"Y\", or \"Z\".  Default: \"Z\"\n// Example(3D):\n//   vnf0 = cube([100,40,10], center=true);\n//   vnf1 = up(50, p=vnf0);\n//   vnf2 = down(50, p=vnf0);\n//   bent1 = vnf_bend(vnf1, axis=\"Y\");\n//   bent2 = vnf_bend(vnf2, axis=\"Y\");\n//   vnf_polyhedron([bent1,bent2]);\n// Example(3D):\n//   vnf0 = linear_sweep(star(n=5,step=2,d=100), height=10);\n//   vnf1 = up(50, p=vnf0);\n//   vnf2 = down(50, p=vnf0);\n//   bent1 = vnf_bend(vnf1, axis=\"Y\");\n//   bent2 = vnf_bend(vnf2, axis=\"Y\");\n//   vnf_polyhedron([bent1,bent2]);\n// Example(3D):\n//   rgn = union(rect([100,20]),\n//               rect([20,100]));\n//   vnf0 = linear_sweep(zrot(45,p=rgn), height=10);\n//   vnf1 = up(50, p=vnf0);\n//   vnf2 = down(50, p=vnf0);\n//   bent1 = vnf_bend(vnf1, axis=\"Y\");\n//   bent2 = vnf_bend(vnf2, axis=\"Y\");\n//   vnf_polyhedron([bent1,bent2]);\n// Example(3D): Bending Around X Axis.\n//   rgnr = union(\n//       rect([20,100]),\n//       back(50, p=trapezoid(w1=40, w2=0, h=20, anchor=FRONT))\n//   );\n//   vnf0 = xrot(00,p=linear_sweep(rgnr, height=10));\n//   vnf1 = up(50, p=vnf0);\n//   #vnf_polyhedron(vnf1);\n//   bent1 = vnf_bend(vnf1, axis=\"X\");\n//   vnf_polyhedron([bent1]);\n// Example(3D): Bending Around Y Axis.\n//   rgn = union(\n//       rect([20,100]),\n//       back(50, p=trapezoid(w1=40, w2=0, h=20, anchor=FRONT))\n//   );\n//   rgnr = zrot(-90, p=rgn);\n//   vnf0 = xrot(00,p=linear_sweep(rgnr, height=10));\n//   vnf1 = up(50, p=vnf0);\n//   #vnf_polyhedron(vnf1);\n//   bent1 = vnf_bend(vnf1, axis=\"Y\");\n//   vnf_polyhedron([bent1]);\n// Example(3D): Bending Around Z Axis.\n//   rgn = union(\n//       rect([20,100]),\n//       back(50, p=trapezoid(w1=40, w2=0, h=20, anchor=FRONT))\n//   );\n//   rgnr = zrot(90, p=rgn);\n//   vnf0 = xrot(90,p=linear_sweep(rgnr, height=10));\n//   vnf1 = fwd(50, p=vnf0);\n//   #vnf_polyhedron(vnf1);\n//   bent1 = vnf_bend(vnf1, axis=\"Z\");\n//   vnf_polyhedron([bent1]);\n// Example(3D): Bending more than once around the cylinder\n//   $fn=32;\n//   vnf = apply(fwd(5)*yrot(30),cube([100,2,5],center=true));\n//   bent = vnf_bend(vnf, axis=\"Z\");\n//   vnf_polyhedron(bent);\nfunction vnf_bend(vnf,r,d,axis=\"Z\") =\n    let(\n        chk_axis = assert(in_list(axis,[\"X\",\"Y\",\"Z\"])),\n        verts = vnf[0],\n        bounds = pointlist_bounds(verts),\n        bmin = bounds[0],\n        bmax = bounds[1],\n        dflt = axis==\"Z\"?\n            max(abs(bmax.y), abs(bmin.y)) :\n            max(abs(bmax.z), abs(bmin.z)),\n        r = get_radius(r=r,d=d,dflt=dflt),\n        extent = axis==\"X\" ? [bmin.y, bmax.y] : [bmin.x, bmax.x]\n    )\n    let(\n        span_chk = axis==\"Z\"?\n            assert(bmin.y > 0 || bmax.y < 0, \"Entire shape MUST be completely in front of or behind y=0.\") :\n            assert(bmin.z > 0 || bmax.z < 0, \"Entire shape MUST be completely above or below z=0.\"),\n        steps = 1+ceil(segs(r) * (extent[1]-extent[0])/(2*PI*r)),\n        step = (extent[1]-extent[0]) / steps,\n        bend_at = [for(i = [1:1:steps-1]) i*step+extent[0]],\n        slicedir = axis==\"X\"? \"Y\" : \"X\",   // slice in y dir for X axis case, and x dir otherwise\n        sliced = vnf_slice(vnf, slicedir, bend_at),\n        coord = axis==\"X\" ? [0,sign(bmax.z),0] : axis==\"Y\" ? [sign(bmax.z),0,0] : [sign(bmax.y),0,0],\n        new_vert = [for(p=sliced[0])\n                       let(a=coord*p*180/(PI*r))\n                       axis==\"X\"? [p.x, p.z*sin(a), p.z*cos(a)] :\n                       axis==\"Y\"? [p.z*sin(a), p.y, p.z*cos(a)] :\n                       [p.y*sin(a), p.y*cos(a), p.z]]\n   ) [new_vert,sliced[1]];\n\n\n\n// Function&Module: vnf_hull()\n// Synopsis: Compute convex hull of VNF or 3d path\n// Usage:\n//    vnf_hull = hull_vnf(vnf);\n//    hull_vnf(vnf,[fast]);\n// Description:\n//   Given a VNF or a list of 3d points, compute the convex hull\n//   and return it as a VNF.  This differs from {{hull()}} and {{hull3d_faces()}} which\n//   return just the face list referenced to the input point list.  Note that the point\n//   list that is returned will contain all the points that are actually used in the input\n//   VNF, which may be many more points than are needed to represent the convex hull.\n//   This is not usually a problem, but you can run the somewhat slow {{vnf_drop_unused_points()}}\n//   function to fix this if necessary.  \n// Arguments:\n//   region = region or path listing points to compute the hull from.\n//   fast = (module only) if input is a point list (not a VNF) use a fasterer cheat that may handle more points, but could emit warnings.  Ignored if input is a VNF.  Default: false.  \n// Example(3D,Big,NoAxes,VPR=[55,0,25],VPT=[9.47096,-4.50217,8.45727],VPD=60.2654): Input is a VNF\n//   ellipse = xscale(2, p=circle($fn=48, r=3));\n//   pentagon = subdivide_path(pentagon(r=1), 20);\n//   vnf=path_sweep(pentagon, path3d(ellipse),\n//                  closed=true, twist=360*2);\n//   vnfhull = vnf_hull(vnf);\n//   vnf_polyhedron(vnf);\n//   move([10,10])\n//     vnf_polyhedron(vnfhull);\n// Example(3D,Med,NoAxes,VPR=[70.4,0,110.4],VPT=[5.97456,1.26459,18.0317],VPD=126): Input is a point list\n//   h=helix(l=40, turns=1, r=8);\n//   color(\"red\")move_copies(h)\n//     sphere(r=0.5,$fn=12);\n//   vnf_polyhedron(vnf_hull(h));\nfunction vnf_hull(vnf) =\n  assert(is_vnf(vnf) || is_path(vnf,3),\"Input must be a VNF or a 3d path\")\n  let(\n      pts = is_vnf(vnf) ? select(vnf[0],unique(flatten(vnf[1])))\n                        : vnf,\n      faces = hull3d_faces(pts)\n  )\n  [pts, faces];\n\nmodule vnf_hull(vnf, fast=false)\n{\n  if (is_vnf(vnf)) hull()vnf_polyhedron(vnf);\n  else hull_points(vnf, fast);\n}  \n    \n\n// Section: Debugging Polyhedrons\n\n/// Internal Module: _show_vertices()\n/// Usage:\n///   _show_vertices(vertices, [size], [filter=])\n/// Description:\n///   Draws all the vertices in an array, at their 3D position, numbered by their\n///   position in the vertex array.  Also draws any children of this module with\n///   transparency.\n/// Arguments:\n///   vertices = Array of point vertices.\n///   size = The size of the text used to label the vertices.  Default: 1\n/// Example:\n///   verts = [for (z=[-10,10], y=[-10,10], x=[-10,10]) [x,y,z]];\n///   faces = [[0,1,2], [1,3,2], [0,4,5], [0,5,1], [1,5,7], [1,7,3], [3,7,6], [3,6,2], [2,6,4], [2,4,0], [4,6,7], [4,7,5]];\n///   _show_vertices(vertices=verts, size=2) {\n///       polyhedron(points=verts, faces=faces);\n///   }\nmodule _show_vertices(vertices, size=1, filter) {\n    color(\"blue\") {\n        dups = vector_search(vertices, EPSILON, vertices);\n        for (ind = dups) {\n            if (is_undef(filter) || any(ind, filter)) {\n                numstr = str_join([for(i=ind) str(i)],\",\");\n                v = vertices[ind[0]];\n                translate(v) {\n                    rot($vpr) back(size/8){\n                       linear_extrude(height=size/10, center=true, convexity=10) {\n                          text(text=numstr, size=size, halign=\"center\");\n                       }\n                    }\n                    sphere(size/10);\n                }\n            }\n        }\n    }\n}\n\n\n/// Internal Module: _show_faces()\n/// Usage:\n///   _show_faces(vertices, faces, [size=], [filter=]);\n/// Description:\n///   Draws all the vertices at their 3D position, numbered in blue by their\n///   position in the vertex array.  Each face will have their face number drawn\n///   in red, aligned with the center of face.  All children of this module are drawn\n///   with transparency.\n/// Arguments:\n///   vertices = Array of point vertices.\n///   faces = Array of faces by vertex numbers.\n///   size = The size of the text used to label the faces and vertices.  Default: 1\n/// Example(EdgesMed):\n///   verts = [for (z=[-10,10], y=[-10,10], x=[-10,10]) [x,y,z]];\n///   faces = [[0,1,2], [1,3,2], [0,4,5], [0,5,1], [1,5,7], [1,7,3], [3,7,6], [3,6,2], [2,6,4], [2,4,0], [4,6,7], [4,7,5]];\n///   _show_faces(vertices=verts, faces=faces, size=2) {\n///       polyhedron(points=verts, faces=faces);\n///   }\nmodule _show_faces(vertices, faces, size=1, filter) {\n    vlen = len(vertices);\n    color(\"red\") {\n        for (i = [0:1:len(faces)-1]) {\n            face = faces[i];\n            if (face[0] < 0 || face[1] < 0 || face[2] < 0 || face[0] >= vlen || face[1] >= vlen || face[2] >= vlen) {\n                echo(str(\"INVALID FACE: indices of face \",i,\" are out of bounds [0,\",vlen-1,\"]: face=\",face));\n            }\n            else if (is_undef(filter) || any(face,filter)) {\n                verts = select(vertices,face);\n                normal = polygon_normal(verts);\n                if (is_undef(normal))\n                    echo(str(\"DEGENERATE FACE: face \",i,\" has no normal vector, face=\", face));\n                else {\n                    axis = vector_axis(normal, DOWN);\n                    ang = vector_angle(normal, DOWN);\n                    theta = atan2(normal[1], normal[0]);\n                    translate(mean(verts)) \n                      rotate(a=(180-ang), v=axis)\n                      zrot(theta+90)\n                      linear_extrude(height=size/10, center=true, convexity=10) {\n                                text(text=str(i), size=size, halign=\"center\");\n                                text(text=str(\"_\"), size=size, halign=\"center\");\n                      }\n                }\n            }\n        }\n    }        \n}\n\n\n\n// Module: debug_vnf()\n// Synopsis: A replacement for `vnf_polyhedron()` to help with debugging.\n// SynTags: VNF\n// Topics: VNF Manipulation, Debugging\n// See Also: vnf_validate()\n// Usage:\n//   debug_vnf(vnfs, [faces=], [vertices=], [opacity=], [size=], [convexity=], [filter=]);\n// Description:\n//   A drop-in module to replace `vnf_polyhedron()` to help debug vertices and faces.\n//   Draws all the vertices at their 3D position, numbered in blue by their\n//   position in the vertex array.  Each face will have its face number drawn\n//   in red, aligned with the center of face.  All given faces are drawn with\n//   transparency. All children of this module are drawn with transparency.\n//   Works best with Thrown-Together preview mode, to see reversed faces.\n//   You can set opacity to 0 if you want to supress the display of the polyhedron faces.\n//   .\n//   The vertex numbers are shown rotated to face you.  As you rotate your polyhedron you\n//   can rerun the preview to display them oriented for viewing from a different viewpoint.\n// Topics: Polyhedra, Debugging\n// Arguments:\n//   vnf = VNF to display\n//   ---\n//   faces = if true display face numbers.  Default: true\n//   vertices = if true display vertex numbers.  Default: true\n//   opacity = Opacity of the polyhedron faces.  Default: 0.5\n//   convexity = The max number of walls a ray can pass through the given polygon paths.\n//   size = The size of the text used to label the faces and vertices.  Default: 1\n//   filter = If given a function literal of signature `function(i)`, will only show labels for vertices and faces that have a vertex index that gets a true result from that function.  Default: no filter.\n// Example(EdgesMed):\n//   verts = [for (z=[-10,10], a=[0:120:359.9]) [10*cos(a),10*sin(a),z]];\n//   faces = [[0,1,2], [5,4,3], [0,3,4], [0,4,1], [1,4,5], [1,5,2], [2,5,3], [2,3,0]];\n//   debug_vnf([verts,faces], size=2);\nmodule debug_vnf(vnf, faces=true, vertices=true, opacity=0.5, size=1, convexity=6, filter ) {\n    no_children($children);\n    if (faces)\n      _show_faces(vertices=vnf[0], faces=vnf[1], size=size, filter=filter);\n    if (vertices)\n      _show_vertices(vertices=vnf[0], size=size, filter=filter);\n    if (opacity > 0)\n      color([0.2, 1.0, 0, opacity])\n        vnf_polyhedron(vnf,convexity=convexity);\n}\n\n\n// Module: vnf_validate()\n// Synopsis: Echos non-manifold VNF errors to the console.\n// SynTags: VNF\n// Topics: VNF Manipulation, Debugging\n// See Also: debug_vnf()\n// \n// Usage: \n//   vnf_validate(vnf, [size], [show_warns=], [check_isects=], [opacity=], [adjacent=], [label_verts=], [label_faces=], [wireframe=]);\n// Description:\n//   When called as a module, echoes the non-manifold errors to the console, and color hilites the\n//   bad edges and vertices, overlaid on a transparent gray polyhedron of the VNF.\n//   .\n//   Currently checks for these problems:\n//   .\n//   Type    | Color    | Code         | Message\n//   ------- | -------- | ------------ | ---------------------------------\n//   WARNING | Yellow   | BIG_FACE     | Face has more than 3 vertices, and may confuse CGAL.\n//   WARNING | Blue     | NULL_FACE    | Face has zero area.\n//   ERROR   | Cyan     | NONPLANAR    | Face vertices are not coplanar.\n//   ERROR   | Brown    | DUP_FACE     | Multiple instances of the same face.\n//   ERROR   | Orange   | MULTCONN     | Multiply Connected Geometry. Too many faces attached at Edge.\n//   ERROR   | Violet   | REVERSAL     | Faces reverse across edge.\n//   ERROR   | Red      | T_JUNCTION   | Vertex is mid-edge on another Face.\n//   ERROR   | Brown    | FACE_ISECT   | Faces intersect.\n//   ERROR   | Magenta  | HOLE_EDGE    | Edge bounds Hole.\n//   .\n//   Still to implement:\n//   - Overlapping coplanar faces.\n// Arguments:\n//   vnf = The VNF to validate.\n//   size = The width of the lines and diameter of points used to highlight edges and vertices.  Module only.  Default: 1\n//   ---\n//   show_warns = If true show warnings for non-triangular faces.  Default: true\n//   check_isects = If true, performs slow checks for intersecting faces.  Default: false\n//   opacity = The opacity level to show the polyhedron itself with.    Default: 0.67\n//   label_verts = If true, shows labels at each vertex that show the vertex number.    Default: false\n//   label_faces = If true, shows labels at the center of each face that show the face number.    Default: false\n//   wireframe = If true, shows edges more clearly so you can see them in Thrown Together mode.    Default: false\n//   adjacent = If true, only display faces adjacent to a vertex listed in the errors.    Default: false\n// Example(3D,Edges): BIG_FACE Warnings; Faces with More Than 3 Vertices.  CGAL often will fail to accept that a face is planar after a rotation, if it has more than 3 vertices.\n//   vnf = skin([\n//       path3d(regular_ngon(n=3, d=100),0),\n//       path3d(regular_ngon(n=5, d=100),100)\n//   ], slices=0, caps=true, method=\"tangent\");\n//   vnf_validate(vnf);\n// Example(3D,Edges): NONPLANAR Errors; Face Vertices are Not Coplanar\n//   a = [  0,  0,-50];\n//   b = [-50,-50, 50];\n//   c = [-50, 50, 50];\n//   d = [ 50, 50, 60];\n//   e = [ 50,-50, 50];\n//   vnf = vnf_from_polygons([\n//       [a, b, e], [a, c, b], [a, d, c], [a, e, d], [b, c, d, e]\n//   ],fast=true);\n//   vnf_validate(vnf);\n// Example(3D,Edges): MULTCONN Errors; More Than Two Faces Attached to the Same Edge.  This confuses CGAL, and can lead to failed renders.\n//   vnf = vnf_triangulate(linear_sweep(union(square(50), square(50,anchor=BACK+RIGHT)), height=50));\n//   vnf_validate(vnf);\n// Example(3D,Edges): REVERSAL Errors; Faces Reversed Across Edge\n//   vnf1 = skin([\n//       path3d(square(100,center=true),0),\n//       path3d(square(100,center=true),100),\n//   ], slices=0, caps=false);\n//   vnf = vnf_join([vnf1, vnf_from_polygons([\n//       [[-50,-50,  0], [ 50, 50,  0], [-50, 50,  0]],\n//       [[-50,-50,  0], [ 50,-50,  0], [ 50, 50,  0]],\n//       [[-50,-50,100], [-50, 50,100], [ 50, 50,100]],\n//       [[-50,-50,100], [ 50,-50,100], [ 50, 50,100]],\n//   ])]);\n//   vnf_validate(vnf);\n// Example(3D,Edges): T_JUNCTION Errors; Vertex is Mid-Edge on Another Face.\n//   vnf = [\n//       [\n//           each path3d(square(100,center=true),0),\n//           each path3d(square(100,center=true),100),\n//           [0,-50,100],\n//       ], [\n//          [0,2,1], [0,3,2], [0,8,4], [0,1,8], [1,5,8],\n//          [0,4,3], [4,7,3], [1,2,5], [2,6,5], [3,7,6],\n//          [3,6,2], [4,5,6], [4,6,7],\n//       ]\n//   ];\n//   vnf_validate(vnf);\n// Example(3D,Edges): FACE_ISECT Errors; Faces Intersect\n//   vnf = vnf_join([\n//       vnf_triangulate(linear_sweep(square(100,center=true), height=100)),\n//       move([75,35,30],p=vnf_triangulate(linear_sweep(square(100,center=true), height=100)))\n//   ]);\n//   vnf_validate(vnf,size=2,check_isects=true);\n// Example(3D,Edges): HOLE_EDGE Errors; Edges Adjacent to Holes.\n//   vnf = skin([\n//       path3d(regular_ngon(n=4, d=100),0),\n//       path3d(regular_ngon(n=5, d=100),100)\n//   ], slices=0, caps=false);\n//   vnf_validate(vnf,size=2);\n\n\n//   Returns a list of non-manifold errors with the given VNF.\n//   Each error has the format `[ERR_OR_WARN,CODE,MESG,POINTS,COLOR]`.\nfunction _vnf_validate(vnf, show_warns=true, check_isects=false) =\n    assert(is_vnf(vnf), \"Invalid VNF\")\n    let(\n        varr = vnf[0],\n        faces = vnf[1],\n        lvarr = len(varr),\n        edges = sort([\n            for (face=faces, edge=pair(face,true))\n            edge[0]<edge[1]? edge : [edge[1],edge[0]]\n        ]),\n        dfaces = [\n            for (face=faces) let(\n                face=deduplicate_indexed(varr,face,closed=true)\n            ) if(len(face)>=3)\n            face\n        ],\n        face_areas = [\n            for (face = faces)\n            len(face) < 3? 0 :\n            polygon_area([for (k=face) varr[k]])\n        ],\n        edgecnts = unique_count(edges),\n        uniq_edges = edgecnts[0],\n        issues = []\n    )\n    let(\n        big_faces = !show_warns? [] : [\n            for (face = faces)\n            if (len(face) > 3)\n            _vnf_validate_err(\"BIG_FACE\", face)\n        ],\n        null_faces = !show_warns? [] : [\n            for (i = idx(faces)) let(\n                face = faces[i],\n                area = face_areas[i]\n            )\n            if (is_num(area) && abs(area) < EPSILON)\n            _vnf_validate_err(\"NULL_FACE\", face)\n        ],\n        issues = concat(big_faces, null_faces)\n    )\n    let(\n        bad_indices = [\n            for (face = faces, idx = face)\n            if (idx < 0 || idx >= lvarr)\n            _vnf_validate_err(\"BAD_INDEX\", [idx])\n        ],\n        issues = concat(issues, bad_indices)\n    ) bad_indices? issues :\n    let(\n        repeated_faces = [\n            for (i=idx(dfaces), j=idx(dfaces))\n            if (i!=j) let(\n                face1 = dfaces[i],\n                face2 = dfaces[j]\n            ) if (min(face1) == min(face2)) let(\n                min1 = min_index(face1),\n                min2 = min_index(face2)\n            ) if (min1 == min2) let(\n                sface1 = list_rotate(face1,min1),\n                sface2 = list_rotate(face2,min2)\n            ) if (sface1 == sface2)\n            _vnf_validate_err(\"DUP_FACE\", sface1)\n        ],\n        issues = concat(issues, repeated_faces)\n    ) repeated_faces? issues :\n    let(\n        multconn_edges = unique([\n            for (i = idx(uniq_edges))\n            if (edgecnts[1][i]>2)\n            _vnf_validate_err(\"MULTCONN\", uniq_edges[i])\n        ]),\n        issues = concat(issues, multconn_edges)\n    ) multconn_edges? issues :\n    let(\n        reversals = unique([\n            for(i = idx(dfaces), j = idx(dfaces)) if(i != j)\n            for(edge1 = pair(faces[i],true))\n            for(edge2 = pair(faces[j],true))\n            if(edge1 == edge2)  // Valid adjacent faces will never have the same vertex ordering.\n            if(_edge_not_reported(edge1, varr, multconn_edges))\n            _vnf_validate_err(\"REVERSAL\", edge1)\n        ]),\n        issues = concat(issues, reversals)\n    ) reversals? issues :\n    let(\n        t_juncts = unique([\n            for (v=idx(varr), edge=uniq_edges) let(\n                ia = edge[0],\n                ib = v,\n                ic = edge[1]\n            )\n            if (ia!=ib && ib!=ic && ia!=ic) let(\n                a = varr[ia],\n                b = varr[ib],\n                c = varr[ic]\n            )\n            if (!approx(a,b) && !approx(b,c) && !approx(a,c)) let(\n                pt = line_closest_point([a,c],b,SEGMENT)\n            )\n            if (approx(pt,b))\n            _vnf_validate_err(\"T_JUNCTION\", [ib])\n        ]),\n        issues = concat(issues, t_juncts)\n    ) t_juncts? issues :\n    let(\n        isect_faces = !check_isects? [] : unique([\n            for (i = [0:1:len(faces)-2]) let(\n                f1 = faces[i],\n                poly1   = select(varr, faces[i]),\n                plane1  = plane3pt(poly1[0], poly1[1], poly1[2]),\n                normal1 = [plane1[0], plane1[1], plane1[2]]\n            )\n            for (j = [i+1:1:len(faces)-1]) let(\n                f2 = faces[j],\n                poly2 = select(varr, f2),\n                val = poly2 * normal1\n            )\n            if( min(val)<=plane1[3] && max(val)>=plane1[3] ) let(\n                plane2  = plane_from_polygon(poly2),\n                normal2 = [plane2[0], plane2[1], plane2[2]],\n                val = poly1 * normal2\n            )\n            if( min(val)<=plane2[3] && max(val)>=plane2[3] ) let(\n                shared_edges = [\n                    for (edge1 = pair(f1, true), edge2 = pair(f2, true))\n                    if (edge1 == [edge2[1], edge2[0]]) 1\n                ]\n            )\n            if (!shared_edges) let(\n                line = plane_intersection(plane1, plane2)\n            )\n            if (!is_undef(line)) let(\n                isects = polygon_line_intersection(poly1, line)\n            )\n            if (!is_undef(isects))\n            for (isect = isects)\n            if (len(isect) > 1) let(\n                isects2 = polygon_line_intersection(poly2, isect, bounded=true)\n            )\n            if (!is_undef(isects2))\n            for (seg = isects2)\n            if (seg[0] != seg[1])\n            _vnf_validate_err(\"FACE_ISECT\", seg)\n        ]),\n        issues = concat(issues, isect_faces)\n    ) isect_faces? issues :\n    let(\n        hole_edges = unique([\n            for (i=idx(uniq_edges))\n            if (edgecnts[1][i]<2)\n            if (_pts_not_reported(uniq_edges[i], varr, t_juncts))\n            if (_pts_not_reported(uniq_edges[i], varr, isect_faces))\n            _vnf_validate_err(\"HOLE_EDGE\", uniq_edges[i])\n        ]),\n        issues = concat(issues, hole_edges)\n    ) hole_edges? issues :\n    let(\n        nonplanars = unique([\n            for (i = idx(faces))\n               if (is_undef(face_areas[i])) \n                  _vnf_validate_err(\"NONPLANAR\", faces[i])\n        ]),\n        issues = concat(issues, nonplanars)\n    ) issues;\n\n\n_vnf_validate_errs = [\n    [\"BIG_FACE\",    \"WARNING\", \"cyan\",    \"Face has more than 3 vertices, and may confuse CGAL\"],\n    [\"NULL_FACE\",   \"WARNING\", \"blue\",    \"Face has zero area.\"],\n    [\"BAD_INDEX\",   \"ERROR\",   \"cyan\",    \"Invalid face vertex index.\"],\n    [\"NONPLANAR\",   \"ERROR\",   \"yellow\",  \"Face vertices are not coplanar\"],\n    [\"DUP_FACE\",    \"ERROR\",   \"brown\",   \"Multiple instances of the same face.\"],\n    [\"MULTCONN\",    \"ERROR\",   \"orange\",  \"Multiply Connected Geometry. Too many faces attached at Edge\"],\n    [\"REVERSAL\",    \"ERROR\",   \"violet\",  \"Faces Reverse Across Edge\"],\n    [\"T_JUNCTION\",  \"ERROR\",   \"magenta\", \"Vertex is mid-edge on another Face\"],\n    [\"FACE_ISECT\",  \"ERROR\",   \"brown\",   \"Faces intersect\"],\n    [\"HOLE_EDGE\",   \"ERROR\",   \"red\",     \"Edge bounds Hole\"]\n];\n\n\nfunction _vnf_validate_err(name, extra) =\n    let(\n        info = [for (x = _vnf_validate_errs) if (x[0] == name) x][0]\n    ) concat(info, [extra]);\n\n\nfunction _pts_not_reported(pts, varr, reports) =\n    [\n        for (i = pts, report = reports, pt = report[3])\n        if (varr[i] == pt) 1\n    ] == [];\n\n\nfunction _edge_not_reported(edge, varr, reports) =\n    let(\n        edge = sort([for (i=edge) varr[i]])\n    ) [\n        for (report = reports) let(\n            pts = sort(report[3])\n        ) if (len(pts)==2 && edge == pts) 1\n    ] == [];\n\n\nmodule vnf_validate(vnf, size=1, show_warns=true, check_isects=false, opacity=0.67, adjacent=false, label_verts=false, label_faces=false, wireframe=false) {\n    no_children($children);\n    vcount = len(vnf[0]);\n    fcount = len(vnf[1]);\n    vnf = vnf_merge_points(vnf);\n    faults = _vnf_validate(\n        vnf, show_warns=show_warns,\n        check_isects=check_isects\n    );\n    verts = vnf[0];\n    vnf_changed = len(verts)!=vcount || len(vnf[1])!=fcount;\n    if (!faults) {\n        echo(\"VNF appears valid.\");\n    }\n    if (vnf_changed) echo(\"VNF changed when merging points; unable to display indices\");\n    for (fault = faults) {\n        err = fault[0];\n        typ = fault[1];\n        clr = fault[2];\n        msg = fault[3];\n        idxs = fault[4];\n        pts = err==\"FACE_ISECT\" ? idxs : [for (i=idxs) if(is_finite(i) && i>=0 && i<len(verts)) verts[i]];\n        if (vnf_changed || err==\"FACE_ISECT\")\n          echo(str(typ, \" \", err, \" (\", clr ,\"): \", msg, \" at \", pts));\n        else\n          echo(str(typ, \" \", err, \" (\", clr ,\"): \", msg, \" at \", pts, \" indices: \", idxs));\n        color(clr) {\n            if (is_vector(pts[0])) {\n                if (len(pts)==2) {\n                    stroke(pts, width=size, endcaps=\"butt\", $fn=8);\n                } else if (len(pts)>2) {\n                    stroke(pts, width=size, closed=true, $fn=8);\n                    polyhedron(pts,[[for (i=idx(pts)) i]]);\n                } else {\n                    move_copies(pts) sphere(d=size*3, $fn=18);\n                }\n            }\n        }\n    }\n    badverts = unique([for (fault=faults) each fault[4]]);\n    badverts2 = unique([for (j=idx(verts), i=badverts) if (i!=j && verts[i]==verts[j]) j]);\n    all_badverts = unique(concat(badverts, badverts2));\n    adjacent = !faults? false : adjacent;\n    filter_fn = !adjacent? undef : function(i) in_list(i,all_badverts);\n    adj_vnf = !adjacent? vnf : [\n        verts, [for (face=vnf[1]) if (any(face,filter_fn)) face]\n    ];\n    if (wireframe) {\n        vnf_wireframe(adj_vnf, width=size*0.25);\n    }\n    if (label_verts) {\n        debug_vnf(adj_vnf, size=size*3, opacity=0, faces=false, vertices=true, filter=filter_fn);\n    }\n    if (label_faces) {\n        debug_vnf(vnf, size=size*3, opacity=0, faces=true, vertices=false, filter=filter_fn);\n    }\n    if (opacity > 0) {\n        color([0.5,1,0.5,opacity]) vnf_polyhedron(adj_vnf);\n    }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-52", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: walls.scad\n//   Walls and structural elements that 3D print without support.\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/walls.scad>\n// FileGroup: Parts\n// FileSummary: Walls and structural elements that 3D print without support.\n//////////////////////////////////////////////////////////////////////\n\n\n// Section: Walls\n\n\n// Module: sparse_wall()\n// Synopsis: Makes an open cross-braced rectangular wall.\n// SynTags: Geom\n// Topics: FDM Optimized, Walls\n// See Also: sparse_wall(), corrugated_wall(), thinning_wall(), thinning_triangle(), narrowing_strut()\n//\n// Usage:\n//   sparse_wall(h, l, thick, [maxang=], [strut=], [max_bridge=]) [ATTACHMENTS];\n//\n// Description:\n//   Makes an open rectangular strut with X-shaped cross-bracing, designed to reduce\n//   the need for support material in 3D printing.\n//\n// Arguments:\n//   h = height of strut wall.\n//   l = length of strut wall.\n//   thick = thickness of strut wall.\n//   ---\n//   maxang = maximum overhang angle of cross-braces.\n//   strut = the width of the cross-braces.\n//   max_bridge = maximum bridging distance between cross-braces.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// See Also: corrugated_wall(), thinning_wall()\n//\n// Example: Typical Shape\n//   sparse_wall(h=40, l=100, thick=3);\n// Example: Thinner Strut\n//   sparse_wall(h=40, l=100, thick=3, strut=2);\n// Example: Larger maxang\n//   sparse_wall(h=40, l=100, thick=3, strut=2, maxang=45);\n// Example: Longer max_bridge\n//   sparse_wall(h=40, l=100, thick=3, strut=2, maxang=45, max_bridge=30);\nmodule sparse_wall(h=50, l=100, thick=4, maxang=30, strut=5, max_bridge=20, anchor=CENTER, spin=0, orient=UP)\n{\n    zoff = h/2 - strut/2;\n    yoff = l/2 - strut/2;\n\n    maxhyp = 1.5 * (max_bridge+strut)/2 / sin(maxang);\n    maxz = 2 * maxhyp * cos(maxang);\n\n    zreps = ceil(2*zoff/maxz);\n    zstep = 2*zoff / zreps;\n\n    hyp = zstep/2 / cos(maxang);\n    maxy = min(2 * hyp * sin(maxang), max_bridge+strut);\n\n    yreps = ceil(2*yoff/maxy);\n    ystep = 2*yoff / yreps;\n\n    ang = atan(ystep/zstep);\n    len = zstep / cos(ang);\n\n    size = [thick, l, h];\n    attachable(anchor,spin,orient, size=size) {\n        yrot(90)\n        linear_extrude(height=thick, convexity=4*yreps, center=true) {\n            difference() {\n                square([h, l], center=true);\n                square([h-2*strut, l-2*strut], center=true);\n            }\n            ycopies(ystep, n=yreps) {\n                xcopies(zstep, n=zreps) {\n                    skew(syx=tan(-ang)) square([(h-strut)/zreps, strut], center=true);\n                    skew(syx=tan( ang)) square([(h-strut)/zreps, strut], center=true);\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: corrugated_wall()\n// Synopsis: Makes a corrugated rectangular wall.\n// SynTags: Geom\n// Topics: FDM Optimized, Walls\n// See Also: sparse_wall(), corrugated_wall(), thinning_wall(), thinning_triangle(), narrowing_strut()\n//\n// Usage:\n//   corrugated_wall(h, l, thick, [strut=], [wall=]) [ATTACHMENTS];\n//\n// Description:\n//   Makes a corrugated wall which relieves contraction stress while still\n//   providing support strength.  Designed with 3D printing in mind.\n//\n// Arguments:\n//   h = height of strut wall.\n//   l = length of strut wall.\n//   thick = thickness of strut wall.\n//   ---\n//   strut = the width of the cross-braces.\n//   wall = thickness of corrugations.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// See Also: sparse_wall(), thinning_wall()\n//\n// Example: Typical Shape\n//   corrugated_wall(h=50, l=100);\n// Example: Wider Strut\n//   corrugated_wall(h=50, l=100, strut=8);\n// Example: Thicker Wall\n//   corrugated_wall(h=50, l=100, strut=8, wall=3);\nmodule corrugated_wall(h=50, l=100, thick=5, strut=5, wall=2, anchor=CENTER, spin=0, orient=UP)\n{\n    amplitude = (thick - wall) / 2;\n    period = min(15, thick * 2);\n    steps = quantup(segs(thick/2),4);\n    step = period/steps;\n    il = l - 2*strut + 2*step;\n    size = [thick, l, h];\n    attachable(anchor,spin,orient, size=size) {\n        union() {\n            linear_extrude(height=h-2*strut+0.1, slices=2, convexity=ceil(2*il/period), center=true) {\n                polygon(\n                    points=concat(\n                        [for (y=[-il/2:step:il/2]) [amplitude*sin(y/period*360)-wall/2, y] ],\n                        [for (y=[il/2:-step:-il/2]) [amplitude*sin(y/period*360)+wall/2, y] ]\n                    )\n                );\n            }\n            difference() {\n                cube([thick, l, h], center=true);\n                cube([thick+0.5, l-2*strut, h-2*strut], center=true);\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: thinning_wall()\n// Synopsis: Makes a rectangular wall with a thin middle.\n// SynTags: Geom\n// Topics: FDM Optimized, Walls\n// See Also: sparse_wall(), corrugated_wall(), thinning_wall(), thinning_triangle(), narrowing_strut()\n//\n// Usage:\n//   thinning_wall(h, l, thick, [ang=], [braces=], [strut=], [wall=]) [ATTACHMENTS];\n//\n// Description:\n//   Makes a rectangular wall which thins to a smaller width in the center,\n//   with angled supports to prevent critical overhangs.\n//\n// Arguments:\n//   h = Height of wall.\n//   l = Length of wall.  If given as a vector of two numbers, specifies bottom and top lengths, respectively.\n//   thick = Thickness of wall.\n//   ---\n//   ang = Maximum overhang angle of diagonal brace.\n//   braces = If true, adds diagonal crossbraces for strength.\n//   strut = The width of the borders and diagonal braces.  Default: `thick/2`\n//   wall = The thickness of the thinned portion of the wall.  Default: `thick/2`\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// See Also: sparse_wall(), corrugated_wall(), thinning_triangle()\n//\n// Example: Typical Shape\n//   thinning_wall(h=50, l=80, thick=4);\n// Example: Trapezoidal\n//   thinning_wall(h=50, l=[80,50], thick=4);\n// Example: Trapezoidal with Braces\n//   thinning_wall(h=50, l=[80,50], thick=4, strut=4, wall=2, braces=true);\nmodule thinning_wall(h=50, l=100, thick=5, ang=30, braces=false, strut, wall, anchor=CENTER, spin=0, orient=UP)\n{\n    l1 = (l[0] == undef)? l : l[0];\n    l2 = (l[1] == undef)? l : l[1];\n    strut = is_num(strut)? strut : min(h,l1,l2,thick)/2;\n    wall = is_num(wall)? wall : thick/2;\n\n    bevel_h = strut + (thick-wall)/2/tan(ang);\n    cp1 = circle_2tangents(strut, [0,0,+h/2], [l2/2,0,+h/2], [l1/2,0,-h/2])[0];\n    cp2 = circle_2tangents(bevel_h, [0,0,+h/2], [l2/2,0,+h/2], [l1/2,0,-h/2])[0];\n    cp3 = circle_2tangents(bevel_h, [0,0,-h/2], [l1/2,0,-h/2], [l2/2,0,+h/2])[0];\n    cp4 = circle_2tangents(strut, [0,0,-h/2], [l1/2,0,-h/2], [l2/2,0,+h/2])[0];\n\n    z1 = h/2;\n    z2 = cp1.z;\n    z3 = cp2.z;\n\n    x1 = l2/2;\n    x2 = cp1.x;\n    x3 = cp2.x;\n    x4 = l1/2;\n    x5 = cp4.x;\n    x6 = cp3.x;\n\n    y1 = thick/2;\n    y2 = wall/2;\n\n    corner1 = [ x2, 0,  z2];\n    corner2 = [-x5, 0, -z2];\n    brace_len = norm(corner1-corner2);\n\n    size = [l1, thick, h];\n    attachable(anchor,spin,orient, size=size, size2=[l2,thick]) {\n        zrot(90) {\n            polyhedron(\n                points=[\n                    [-x4, -y1, -z1],\n                    [ x4, -y1, -z1],\n                    [ x1, -y1,  z1],\n                    [-x1, -y1,  z1],\n\n                    [-x5, -y1, -z2],\n                    [ x5, -y1, -z2],\n                    [ x2, -y1,  z2],\n                    [-x2, -y1,  z2],\n\n                    [-x6, -y2, -z3],\n                    [ x6, -y2, -z3],\n                    [ x3, -y2,  z3],\n                    [-x3, -y2,  z3],\n\n                    [-x4,  y1, -z1],\n                    [ x4,  y1, -z1],\n                    [ x1,  y1,  z1],\n                    [-x1,  y1,  z1],\n\n                    [-x5,  y1, -z2],\n                    [ x5,  y1, -z2],\n                    [ x2,  y1,  z2],\n                    [-x2,  y1,  z2],\n\n                    [-x6,  y2, -z3],\n                    [ x6,  y2, -z3],\n                    [ x3,  y2,  z3],\n                    [-x3,  y2,  z3],\n                ],\n                faces=[\n                    [ 4,  5,  1],\n                    [ 5,  6,  2],\n                    [ 6,  7,  3],\n                    [ 7,  4,  0],\n\n                    [ 4,  1,  0],\n                    [ 5,  2,  1],\n                    [ 6,  3,  2],\n                    [ 7,  0,  3],\n\n                    [ 8,  9,  5],\n                    [ 9, 10,  6],\n                    [10, 11,  7],\n                    [11,  8,  4],\n\n                    [ 8,  5,  4],\n                    [ 9,  6,  5],\n                    [10,  7,  6],\n                    [11,  4,  7],\n\n                    [11, 10,  9],\n                    [20, 21, 22],\n\n                    [11,  9,  8],\n                    [20, 22, 23],\n\n                    [16, 17, 21],\n                    [17, 18, 22],\n                    [18, 19, 23],\n                    [19, 16, 20],\n\n                    [16, 21, 20],\n                    [17, 22, 21],\n                    [18, 23, 22],\n                    [19, 20, 23],\n\n                    [12, 13, 17],\n                    [13, 14, 18],\n                    [14, 15, 19],\n                    [15, 12, 16],\n\n                    [12, 17, 16],\n                    [13, 18, 17],\n                    [14, 19, 18],\n                    [15, 16, 19],\n\n                    [ 0,  1, 13],\n                    [ 1,  2, 14],\n                    [ 2,  3, 15],\n                    [ 3,  0, 12],\n\n                    [ 0, 13, 12],\n                    [ 1, 14, 13],\n                    [ 2, 15, 14],\n                    [ 3, 12, 15],\n                ],\n                convexity=6\n            );\n            if(braces) {\n                bracepath = [\n                    [-strut*0.33,thick/2],\n                    [ strut*0.33,thick/2],\n                    [ strut*0.33+(thick-wall)/2/tan(ang), wall/2],\n                    [ strut*0.33+(thick-wall)/2/tan(ang),-wall/2],\n                    [ strut*0.33,-thick/2],\n                    [-strut*0.33,-thick/2],\n                    [-strut*0.33-(thick-wall)/2/tan(ang),-wall/2],\n                    [-strut*0.33-(thick-wall)/2/tan(ang), wall/2]\n                ];\n                xflip_copy() {\n                    intersection() {\n                        extrude_from_to(corner1,corner2) {\n                            polygon(bracepath);\n                        }\n                        prismoid([l1,thick],[l2,thick],h=h,anchor=CENTER);\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: thinning_triangle()\n// Synopsis: Makes a triangular wall with a thin middle.\n// SynTags: Geom\n// Topics: FDM Optimized, Walls\n// See Also: sparse_wall(), corrugated_wall(), thinning_wall(), thinning_triangle(), narrowing_strut()\n//\n// Usage:\n//   thinning_triangle(h, l, thick, [ang=], [strut=], [wall=], [diagonly=], [center=]) [ATTACHMENTS];\n//\n// Description:\n//   Makes a triangular wall with thick edges, which thins to a smaller width in\n//   the center, with angled supports to prevent critical overhangs.\n//\n// Arguments:\n//   h = height of wall.\n//   l = length of wall.\n//   thick = thickness of wall.\n//   ---\n//   ang = maximum overhang angle of diagonal brace.\n//   strut = the width of the diagonal brace.\n//   wall = the thickness of the thinned portion of the wall.\n//   diagonly = boolean, which denotes only the diagonal side (hypotenuse) should be thick.\n//   center = If true, centers shape.  If false, overrides `anchor` with `UP+BACK`.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// See Also: thinning_wall()\n//\n// Example: Centered\n//   thinning_triangle(h=50, l=80, thick=4, ang=30, strut=5, wall=2, center=true);\n// Example: All Braces\n//   thinning_triangle(h=50, l=80, thick=4, ang=30, strut=5, wall=2, center=false);\n// Example: Diagonal Brace Only\n//   thinning_triangle(h=50, l=80, thick=4, ang=30, strut=5, wall=2, diagonly=true, center=false);\nmodule thinning_triangle(h=50, l=100, thick=5, ang=30, strut=5, wall=3, diagonly=false, center, anchor, spin=0, orient=UP)\n{\n    dang = atan(h/l);\n    dlen = h/sin(dang);\n    size = [thick, l, h];\n    anchor = get_anchor(anchor, center, BOT+FRONT, CENTER);\n    attachable(anchor,spin,orient, size=size) {\n        difference() {\n            union() {\n                if (!diagonly) {\n                    translate([0, 0, -h/2])\n                        narrowing_strut(w=thick, l=l, wall=strut, ang=ang);\n                    translate([0, -l/2, 0])\n                        xrot(-90) narrowing_strut(w=thick, l=h-0.1, wall=strut, ang=ang);\n                }\n                intersection() {\n                    cube(size=[thick, l, h], center=true);\n                    xrot(-dang) yrot(180) {\n                        narrowing_strut(w=thick, l=dlen*1.2, wall=strut, ang=ang);\n                    }\n                }\n                cube(size=[wall, l-0.1, h-0.1], center=true);\n            }\n            xrot(-dang) {\n                translate([0, 0, h/2]) {\n                    cube(size=[thick+0.1, l*2, h], center=true);\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n// Module: narrowing_strut()\n// Synopsis: Makes a strut like an extruded baseball home plate.\n// SynTags: Geom\n// Topics: FDM Optimized\n// See Also: sparse_wall(), corrugated_wall(), thinning_wall(), thinning_triangle(), narrowing_strut()\n//\n// Usage:\n//   narrowing_strut(w, l, wall, [ang=]) [ATTACHMENTS];\n//\n// Description:\n//   Makes a rectangular strut with the top side narrowing in a triangle.\n//   The shape created may be likened to an extruded home plate from baseball.\n//   This is useful for constructing parts that minimize the need to support\n//   overhangs.\n//\n// Arguments:\n//   w = Width (thickness) of the strut.\n//   l = Length of the strut.\n//   wall = height of rectangular portion of the strut.\n//   ---\n//   ang = angle that the trianglar side will converge at.\n//   anchor = Translate so anchor point is at origin (0,0,0).  See [anchor](attachments.scad#subsection-anchor).  Default: `CENTER`\n//   spin = Rotate this many degrees around the Z axis after anchor.  See [spin](attachments.scad#subsection-spin).  Default: `0`\n//   orient = Vector to rotate top towards, after spin.  See [orient](attachments.scad#subsection-orient).  Default: `UP`\n//\n// Example:\n//   narrowing_strut(w=10, l=100, wall=5, ang=30);\nmodule narrowing_strut(w=10, l=100, wall=5, ang=30, anchor=BOTTOM, spin=0, orient=UP)\n{\n    h = wall + w/2/tan(ang);\n    size = [w, l, h];\n    attachable(anchor,spin,orient, size=size) {\n        xrot(90)\n        fwd(h/2) {\n            linear_extrude(height=l, center=true, slices=2) {\n                back(wall/2) square([w, wall], center=true);\n                back(wall-0.001) {\n                    yscale(1/tan(ang)) {\n                        difference() {\n                            zrot(45) square(w/sqrt(2), center=true);\n                            fwd(w/2) square(w, center=true);\n                        }\n                    }\n                }\n            }\n        }\n        children();\n    }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
{"custom_id": "task-53", "method": "POST", "url": "/v1/chat/completions", "body": {"model": "gpt-4-turbo-preview", "messages": [{"role": "system", "content": "Provide a concise summary of critical technical details..."}, {"role": "user", "content": "```\n//////////////////////////////////////////////////////////////////////\n// LibFile: wiring.scad\n//   Rendering for routed wire bundles\n// Includes:\n//   include <BOSL2/std.scad>\n//   include <BOSL2/wiring.scad>\n// FileGroup: Parts\n// FileSummary: Routed bundles of wires.\n//////////////////////////////////////////////////////////////////////\n\ninclude <rounding.scad>\n\n\n/// Function: _hex_offset_ring()\n/// Usage:\n///   _hex_offset_ring(d, lev)\n/// Description:\n///   Returns a hexagonal ring of points, with a spacing of `d`.\n///   If `lev=0`, returns a single point at `[0,0]`.  All greater\n///   levels return `6 * lev` points.\n/// Arguments:\n///   d = Base unit diameter to build rings upon.\n///   lev = How many rings to produce.\n/// Example:\n///   _hex_offset_ring(d=1, lev=3); // Returns a hex ring of 18 points.\nfunction _hex_offset_ring(d, lev=0) =\n    (lev == 0)? [[0,0]] :\n    reverse(subdivide_path(hexagon(r=lev*d), refine=lev));\n\n\n/// Function: _hex_offsets()\n/// Usage:\n///   _hex_offsets(n, d)\n/// Description:\n///   Returns the centerpoints for the optimal hexagonal packing\n///   of at least `n` circular items, of diameter `d`.  Will return\n///   enough points to fill out the last ring, even if that is more\n///   than `n` points.\n/// Arguments:\n///   n = Number of items to bundle.\n///   d = How far to space each point away from others.\nfunction _hex_offsets(n, d, lev=0, arr=[]) =\n    (len(arr) >= n)? arr :\n        _hex_offsets(\n            n=n,\n            d=d,\n            lev=lev+1,\n            arr=concat(arr, _hex_offset_ring(d, lev=lev))\n        );\n\n\n\n// Section: Modules\n\n\n// Module: wire_bundle()\n// Synopsis: Creates a wire bundle for a given number of wires.\n// SynTags: Geom\n// Topics: Wiring\n// See Also: path_sweep(), path_sweep2d()\n// Usage:\n//   wire_bundle(path, wires, [wirediam], [rounding], [wirenum=], [corner_steps=]);\n// Description:\n//   Returns a 3D object representing a bundle of wires that follow a given path,\n//   with the corners rounded to a given radius.  There are 17 base wire colors.\n//   If you have more than 17 wires, colors will get re-used.\n// Arguments:\n//   path = The 3D path that the wire bundle should follow.\n//   wires = The number of wires in the wire bundle.\n//   wirediam = The diameter of each wire in the bundle.\n//   rounding = The radius that the path corners will be rounded to.\n//   ---\n//   wirenum = The first wire's offset into the color table.\n//   corner_steps = The corner roundings in the path will be converted into this number of segments.\n// Example:\n//   wire_bundle([[50,0,-50], [50,50,-50], [0,50,-50], [0,0,-50], [0,0,0]], rounding=10, wires=13);\nmodule wire_bundle(path, wires, wirediam=2, rounding=10, wirenum=0, corner_steps=15) {\n    no_children($children);\n    colors = [\n        [0.2, 0.2, 0.2], [1.0, 0.2, 0.2], [0.0, 0.8, 0.0], [1.0, 1.0, 0.2],\n        [0.3, 0.3, 1.0], [1.0, 1.0, 1.0], [0.7, 0.5, 0.0], [0.5, 0.5, 0.5],\n        [0.2, 0.9, 0.9], [0.8, 0.0, 0.8], [0.0, 0.6, 0.6], [1.0, 0.7, 0.7],\n        [1.0, 0.5, 1.0], [0.5, 0.6, 0.0], [1.0, 0.7, 0.0], [0.7, 1.0, 0.5],\n        [0.6, 0.6, 1.0],\n    ];\n    sides = max(segs(wirediam/2), 8);\n    offsets = _hex_offsets(wires, wirediam);\n    rounded_path = round_corners(path, radius=rounding, $fn=(corner_steps+1)*4, closed=false);\n    attachable(){\n      for (i = [0:1:wires-1]) {\n          extpath = move(offsets[i], p=circle(d=wirediam, $fn=sides));\n          color(colors[(i+wirenum)%len(colors)]) {\n              path_sweep(extpath, rounded_path);\n          }\n      }\n      union();\n    }\n}\n\n\n\n// vim: expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap\n\n```"}], "max_tokens": 4096}}
